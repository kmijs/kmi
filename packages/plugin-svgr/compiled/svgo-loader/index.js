(() => {
  var __webpack_modules__ = {
    6049: (__unused_webpack_module, exports) => {
      (function (sax) {
        sax.parser = function (strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script",
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace",
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase =
            parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase
            ? "toLowerCase"
            : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities
            ? Object.create(sax.XML_ENTITIES)
            : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function (o) {
            function F() {}
            F.prototype = o;
            var newf = new F();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function (o) {
            var a = [];
            for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
            return a;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
              switch (buffers[i]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }
        function clearBuffers(parser) {
          for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function () {
            end(this);
          },
          write,
          resume: function () {
            this.error = null;
            return this;
          },
          close: function () {
            return this.write(null);
          },
          flush: function () {
            flushBuffers(this);
          },
        };
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        var nameStart =
          /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody =
          /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        var entityStart =
          /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody =
          /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "\t";
        }
        function isQuote(c) {
          return c === '"' || c === "'";
        }
        function isAttribEnd(c) {
          return c === ">" || isWhitespace(c);
        }
        function isMatch(regex, c) {
          return regex.test(c);
        }
        function notMatch(regex, c) {
          return !isMatch(regex, c);
        }
        var S = 0;
        sax.STATE = {
          BEGIN: S++,
          BEGIN_WHITESPACE: S++,
          TEXT: S++,
          TEXT_ENTITY: S++,
          OPEN_WAKA: S++,
          SGML_DECL: S++,
          SGML_DECL_QUOTED: S++,
          DOCTYPE: S++,
          DOCTYPE_QUOTED: S++,
          DOCTYPE_DTD: S++,
          DOCTYPE_DTD_QUOTED: S++,
          COMMENT_STARTING: S++,
          COMMENT: S++,
          COMMENT_ENDING: S++,
          COMMENT_ENDED: S++,
          CDATA: S++,
          CDATA_ENDING: S++,
          CDATA_ENDING_2: S++,
          PROC_INST: S++,
          PROC_INST_BODY: S++,
          PROC_INST_ENDING: S++,
          OPEN_TAG: S++,
          OPEN_TAG_SLASH: S++,
          ATTRIB: S++,
          ATTRIB_NAME: S++,
          ATTRIB_NAME_SAW_WHITE: S++,
          ATTRIB_VALUE: S++,
          ATTRIB_VALUE_QUOTED: S++,
          ATTRIB_VALUE_CLOSED: S++,
          ATTRIB_VALUE_UNQUOTED: S++,
          ATTRIB_VALUE_ENTITY_Q: S++,
          ATTRIB_VALUE_ENTITY_U: S++,
          CLOSE_TAG: S++,
          CLOSE_TAG_SAW_WHITE: S++,
          SCRIPT: S++,
          SCRIPT_ENDING: S++,
        };
        sax.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" };
        sax.ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'",
          AElig: 198,
          Aacute: 193,
          Acirc: 194,
          Agrave: 192,
          Aring: 197,
          Atilde: 195,
          Auml: 196,
          Ccedil: 199,
          ETH: 208,
          Eacute: 201,
          Ecirc: 202,
          Egrave: 200,
          Euml: 203,
          Iacute: 205,
          Icirc: 206,
          Igrave: 204,
          Iuml: 207,
          Ntilde: 209,
          Oacute: 211,
          Ocirc: 212,
          Ograve: 210,
          Oslash: 216,
          Otilde: 213,
          Ouml: 214,
          THORN: 222,
          Uacute: 218,
          Ucirc: 219,
          Ugrave: 217,
          Uuml: 220,
          Yacute: 221,
          aacute: 225,
          acirc: 226,
          aelig: 230,
          agrave: 224,
          aring: 229,
          atilde: 227,
          auml: 228,
          ccedil: 231,
          eacute: 233,
          ecirc: 234,
          egrave: 232,
          eth: 240,
          euml: 235,
          iacute: 237,
          icirc: 238,
          igrave: 236,
          iuml: 239,
          ntilde: 241,
          oacute: 243,
          ocirc: 244,
          ograve: 242,
          oslash: 248,
          otilde: 245,
          ouml: 246,
          szlig: 223,
          thorn: 254,
          uacute: 250,
          ucirc: 251,
          ugrave: 249,
          uuml: 252,
          yacute: 253,
          yuml: 255,
          copy: 169,
          reg: 174,
          nbsp: 160,
          iexcl: 161,
          cent: 162,
          pound: 163,
          curren: 164,
          yen: 165,
          brvbar: 166,
          sect: 167,
          uml: 168,
          ordf: 170,
          laquo: 171,
          not: 172,
          shy: 173,
          macr: 175,
          deg: 176,
          plusmn: 177,
          sup1: 185,
          sup2: 178,
          sup3: 179,
          acute: 180,
          micro: 181,
          para: 182,
          middot: 183,
          cedil: 184,
          ordm: 186,
          raquo: 187,
          frac14: 188,
          frac12: 189,
          frac34: 190,
          iquest: 191,
          times: 215,
          divide: 247,
          OElig: 338,
          oelig: 339,
          Scaron: 352,
          scaron: 353,
          Yuml: 376,
          fnof: 402,
          circ: 710,
          tilde: 732,
          Alpha: 913,
          Beta: 914,
          Gamma: 915,
          Delta: 916,
          Epsilon: 917,
          Zeta: 918,
          Eta: 919,
          Theta: 920,
          Iota: 921,
          Kappa: 922,
          Lambda: 923,
          Mu: 924,
          Nu: 925,
          Xi: 926,
          Omicron: 927,
          Pi: 928,
          Rho: 929,
          Sigma: 931,
          Tau: 932,
          Upsilon: 933,
          Phi: 934,
          Chi: 935,
          Psi: 936,
          Omega: 937,
          alpha: 945,
          beta: 946,
          gamma: 947,
          delta: 948,
          epsilon: 949,
          zeta: 950,
          eta: 951,
          theta: 952,
          iota: 953,
          kappa: 954,
          lambda: 955,
          mu: 956,
          nu: 957,
          xi: 958,
          omicron: 959,
          pi: 960,
          rho: 961,
          sigmaf: 962,
          sigma: 963,
          tau: 964,
          upsilon: 965,
          phi: 966,
          chi: 967,
          psi: 968,
          omega: 969,
          thetasym: 977,
          upsih: 978,
          piv: 982,
          ensp: 8194,
          emsp: 8195,
          thinsp: 8201,
          zwnj: 8204,
          zwj: 8205,
          lrm: 8206,
          rlm: 8207,
          ndash: 8211,
          mdash: 8212,
          lsquo: 8216,
          rsquo: 8217,
          sbquo: 8218,
          ldquo: 8220,
          rdquo: 8221,
          bdquo: 8222,
          dagger: 8224,
          Dagger: 8225,
          bull: 8226,
          hellip: 8230,
          permil: 8240,
          prime: 8242,
          Prime: 8243,
          lsaquo: 8249,
          rsaquo: 8250,
          oline: 8254,
          frasl: 8260,
          euro: 8364,
          image: 8465,
          weierp: 8472,
          real: 8476,
          trade: 8482,
          alefsym: 8501,
          larr: 8592,
          uarr: 8593,
          rarr: 8594,
          darr: 8595,
          harr: 8596,
          crarr: 8629,
          lArr: 8656,
          uArr: 8657,
          rArr: 8658,
          dArr: 8659,
          hArr: 8660,
          forall: 8704,
          part: 8706,
          exist: 8707,
          empty: 8709,
          nabla: 8711,
          isin: 8712,
          notin: 8713,
          ni: 8715,
          prod: 8719,
          sum: 8721,
          minus: 8722,
          lowast: 8727,
          radic: 8730,
          prop: 8733,
          infin: 8734,
          ang: 8736,
          and: 8743,
          or: 8744,
          cap: 8745,
          cup: 8746,
          int: 8747,
          there4: 8756,
          sim: 8764,
          cong: 8773,
          asymp: 8776,
          ne: 8800,
          equiv: 8801,
          le: 8804,
          ge: 8805,
          sub: 8834,
          sup: 8835,
          nsub: 8836,
          sube: 8838,
          supe: 8839,
          oplus: 8853,
          otimes: 8855,
          perp: 8869,
          sdot: 8901,
          lceil: 8968,
          rceil: 8969,
          lfloor: 8970,
          rfloor: 8971,
          lang: 9001,
          rang: 9002,
          loz: 9674,
          spades: 9824,
          clubs: 9827,
          hearts: 9829,
          diams: 9830,
        };
        Object.keys(sax.ENTITIES).forEach(function (key) {
          var e = sax.ENTITIES[key];
          var s = typeof e === "number" ? String.fromCharCode(e) : e;
          sax.ENTITIES[key] = s;
        });
        for (var s in sax.STATE) {
          sax.STATE[sax.STATE[s]] = s;
        }
        S = sax.STATE;
        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode) closeText(parser);
          emit(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode) emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text) {
          if (opt.trim) text = text.trim();
          if (opt.normalize) text = text.replace(/\s+/g, " ");
          return text;
        }
        function error(parser, reason) {
          closeText(parser);
          const message =
            reason +
            "\nLine: " +
            parser.line +
            "\nColumn: " +
            parser.column +
            "\nChar: " +
            parser.c;
          const error = new Error(message);
          error.reason = reason;
          error.line = parser.line;
          error.column = parser.column;
          parser.error = error;
          emit(parser, "onerror", error);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, "Unclosed root tag");
          if (
            parser.state !== S.BEGIN &&
            parser.state !== S.BEGIN_WHITESPACE &&
            parser.state !== S.TEXT
          ) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict)
            parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = (parser.tag = { name: parser.tagName, attributes: {} });
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }
        function qname(name, attribute) {
          var i = name.indexOf(":");
          var qualName = i < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (
            parser.attribList.indexOf(parser.attribName) !== -1 ||
            parser.tag.attributes.hasOwnProperty(parser.attribName)
          ) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(
                  parser,
                  "xml: prefix must be bound to " +
                    XML_NAMESPACE +
                    "\n" +
                    "Actual: " +
                    parser.attribValue,
                );
              } else if (
                local === "xmlns" &&
                parser.attribValue !== XMLNS_NAMESPACE
              ) {
                strictFail(
                  parser,
                  "xmlns: prefix must be bound to " +
                    XMLNS_NAMESPACE +
                    "\n" +
                    "Actual: " +
                    parser.attribValue,
                );
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue,
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(
                parser,
                "Unbound namespace prefix: " + JSON.stringify(parser.tagName),
              );
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function (p) {
                emitNode(parser, "onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p],
                });
              });
            }
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
              var nv = parser.attribList[i];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a = { name, value, prefix, local, uri };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(
                  parser,
                  "Unbound namespace prefix: " + JSON.stringify(prefix),
                );
                a.uri = prefix;
              }
              parser.tag.attributes[name] = a;
              emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S.SCRIPT;
            } else {
              parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s = parser.tags.length;
          while (s-- > t) {
            var tag = (parser.tag = parser.tags.pop());
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i in tag.ns) {
              x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function (p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0) parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
          }
        }
        function charAt(chunk, i) {
          var result = "";
          if (i < chunk.length) {
            result = chunk.charAt(i);
          }
          return result;
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(
              parser,
              "Cannot write after close. Assign an onready handler.",
            );
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i = 0;
          var c = "";
          while (true) {
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === "\ufeff") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;
              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
              case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = charAt(chunk, i++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i - 1);
                }
                if (
                  c === "<" &&
                  !(parser.sawRoot && parser.closedRoot && !parser.strict)
                ) {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (
                    !isWhitespace(c) &&
                    (!parser.sawRoot || parser.closedRoot)
                  ) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;
              case S.SCRIPT:
                if (c === "<") {
                  parser.state = S.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;
              case S.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S.SCRIPT;
                }
                continue;
              case S.OPEN_WAKA:
                if (c === "!") {
                  parser.state = S.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c)) {
                } else if (isMatch(nameStart, c)) {
                  parser.state = S.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S.TEXT;
                }
                continue;
              case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if (parser.sgmlDecl + c === "--") {
                  parser.state = S.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(
                      parser,
                      "Inappropriately located doctype declaration",
                    );
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S.TEXT;
                } else if (isQuote(c)) {
                  parser.state = S.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;
              case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;
              case S.DOCTYPE:
                if (c === ">") {
                  parser.state = S.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S.DOCTYPE_DTD;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;
              case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S.DOCTYPE;
                }
                continue;
              case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === "]") {
                  parser.state = S.DOCTYPE;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                }
                continue;
              case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S.COMMENT:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;
              case S.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S.COMMENT;
                }
                continue;
              case S.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c;
                  parser.state = S.COMMENT;
                } else {
                  parser.state = S.TEXT;
                }
                continue;
              case S.CDATA:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;
              case S.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.PROC_INST:
                if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else if (isWhitespace(c)) {
                  parser.state = S.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;
              case S.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;
              case S.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody,
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S.PROC_INST_BODY;
                }
                continue;
              case S.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(
                    parser,
                    "Forward-slash in opening tag not followed by >",
                  );
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.ATTRIB:
                if (isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c)) {
                  parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (isWhitespace(c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: "",
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.ATTRIB_VALUE:
                if (isWhitespace(c)) {
                  continue;
                } else if (isQuote(c)) {
                  parser.q = c;
                  parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                  strictFail(parser, "Unquoted attribute value");
                  parser.state = S.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;
              case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;
              case S.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c)) {
                  parser.state = S.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c)) {
                    continue;
                  } else if (notMatch(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = "textNode";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }
                if (c === ";") {
                  var parsedEntity = parseEntity(parser);
                  if (
                    parser.state === S.TEXT_ENTITY &&
                    !sax.ENTITIES[parser.entity] &&
                    parsedEntity !== "&" + parser.entity + ";"
                  ) {
                    chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
                  } else {
                    parser[buffer] += parsedEntity;
                  }
                  parser.entity = "";
                  parser.state = returnState;
                } else if (
                  isMatch(parser.entity.length ? entityBody : entityStart, c)
                ) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default:
                throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
      })(false ? 0 : exports);
    },
    2882: (module) => {
      module.exports = {
        trueFunc: function trueFunc() {
          return true;
        },
        falseFunc: function falseFunc() {
          return false;
        },
      };
    },
    3447: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.attributeRules = void 0;
      var boolbase_1 = __nccwpck_require__(2882);
      var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
      function escapeRegex(value) {
        return value.replace(reChars, "\\$&");
      }
      var caseInsensitiveAttributes = new Set([
        "accept",
        "accept-charset",
        "align",
        "alink",
        "axis",
        "bgcolor",
        "charset",
        "checked",
        "clear",
        "codetype",
        "color",
        "compact",
        "declare",
        "defer",
        "dir",
        "direction",
        "disabled",
        "enctype",
        "face",
        "frame",
        "hreflang",
        "http-equiv",
        "lang",
        "language",
        "link",
        "media",
        "method",
        "multiple",
        "nohref",
        "noresize",
        "noshade",
        "nowrap",
        "readonly",
        "rel",
        "rev",
        "rules",
        "scope",
        "scrolling",
        "selected",
        "shape",
        "target",
        "text",
        "type",
        "valign",
        "valuetype",
        "vlink",
      ]);
      function shouldIgnoreCase(selector, options) {
        return typeof selector.ignoreCase === "boolean"
          ? selector.ignoreCase
          : selector.ignoreCase === "quirks"
            ? !!options.quirksMode
            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
      }
      exports.attributeRules = {
        equals: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                attr.length === value.length &&
                attr.toLowerCase() === value &&
                next(elem)
              );
            };
          }
          return function (elem) {
            return (
              adapter.getAttributeValue(elem, name) === value && next(elem)
            );
          };
        },
        hyphen: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = value.length;
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len).toLowerCase() === value &&
                next(elem)
              );
            };
          }
          return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (
              attr != null &&
              (attr.length === len || attr.charAt(len) === "-") &&
              attr.substr(0, len) === value &&
              next(elem)
            );
          };
        },
        element: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name,
            value = data.value;
          if (/\s/.test(value)) {
            return boolbase_1.falseFunc;
          }
          var regex = new RegExp(
            "(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"),
            shouldIgnoreCase(data, options) ? "i" : "",
          );
          return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (
              attr != null &&
              attr.length >= value.length &&
              regex.test(attr) &&
              next(elem)
            );
          };
        },
        exists: function (next, _a, _b) {
          var name = _a.name;
          var adapter = _b.adapter;
          return function (elem) {
            return adapter.hasAttrib(elem, name) && next(elem);
          };
        },
        start: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = value.length;
          if (len === 0) {
            return boolbase_1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                attr.length >= len &&
                attr.substr(0, len).toLowerCase() === value &&
                next(elem)
              );
            };
          }
          return function (elem) {
            var _a;
            return (
              !!((_a = adapter.getAttributeValue(elem, name)) === null ||
              _a === void 0
                ? void 0
                : _a.startsWith(value)) && next(elem)
            );
          };
        },
        end: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = -value.length;
          if (len === 0) {
            return boolbase_1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var _a;
              return (
                ((_a = adapter.getAttributeValue(elem, name)) === null ||
                _a === void 0
                  ? void 0
                  : _a.substr(len).toLowerCase()) === value && next(elem)
              );
            };
          }
          return function (elem) {
            var _a;
            return (
              !!((_a = adapter.getAttributeValue(elem, name)) === null ||
              _a === void 0
                ? void 0
                : _a.endsWith(value)) && next(elem)
            );
          };
        },
        any: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name,
            value = data.value;
          if (value === "") {
            return boolbase_1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                attr.length >= value.length &&
                regex_1.test(attr) &&
                next(elem)
              );
            };
          }
          return function (elem) {
            var _a;
            return (
              !!((_a = adapter.getAttributeValue(elem, name)) === null ||
              _a === void 0
                ? void 0
                : _a.includes(value)) && next(elem)
            );
          };
        },
        not: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          if (value === "") {
            return function (elem) {
              return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
          } else if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                (attr == null ||
                  attr.length !== value.length ||
                  attr.toLowerCase() !== value) &&
                next(elem)
              );
            };
          }
          return function (elem) {
            return (
              adapter.getAttributeValue(elem, name) !== value && next(elem)
            );
          };
        },
      };
    },
    8318: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
      var css_what_1 = __nccwpck_require__(527);
      var boolbase_1 = __nccwpck_require__(2882);
      var sort_1 = __importDefault(__nccwpck_require__(1779));
      var procedure_1 = __nccwpck_require__(6691);
      var general_1 = __nccwpck_require__(9795);
      var subselects_1 = __nccwpck_require__(5520);
      function compile(selector, options, context) {
        var next = compileUnsafe(selector, options, context);
        return (0, subselects_1.ensureIsTag)(next, options.adapter);
      }
      exports.compile = compile;
      function compileUnsafe(selector, options, context) {
        var token =
          typeof selector === "string"
            ? (0, css_what_1.parse)(selector)
            : selector;
        return compileToken(token, options, context);
      }
      exports.compileUnsafe = compileUnsafe;
      function includesScopePseudo(t) {
        return (
          t.type === "pseudo" &&
          (t.name === "scope" ||
            (Array.isArray(t.data) &&
              t.data.some(function (data) {
                return data.some(includesScopePseudo);
              })))
        );
      }
      var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
      var FLEXIBLE_DESCENDANT_TOKEN = { type: "_flexibleDescendant" };
      var SCOPE_TOKEN = {
        type: css_what_1.SelectorType.Pseudo,
        name: "scope",
        data: null,
      };
      function absolutize(token, _a, context) {
        var adapter = _a.adapter;
        var hasContext = !!(context === null || context === void 0
          ? void 0
          : context.every(function (e) {
              var parent = adapter.isTag(e) && adapter.getParent(e);
              return (
                e === subselects_1.PLACEHOLDER_ELEMENT ||
                (parent && adapter.isTag(parent))
              );
            }));
        for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
          var t = token_1[_i];
          if (
            t.length > 0 &&
            (0, procedure_1.isTraversal)(t[0]) &&
            t[0].type !== "descendant"
          ) {
          } else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
          } else {
            continue;
          }
          t.unshift(SCOPE_TOKEN);
        }
      }
      function compileToken(token, options, context) {
        var _a;
        token = token.filter(function (t) {
          return t.length > 0;
        });
        token.forEach(sort_1.default);
        context =
          (_a = options.context) !== null && _a !== void 0 ? _a : context;
        var isArrayContext = Array.isArray(context);
        var finalContext =
          context && (Array.isArray(context) ? context : [context]);
        absolutize(token, options, finalContext);
        var shouldTestNextSiblings = false;
        var query = token
          .map(function (rules) {
            if (rules.length >= 2) {
              var first = rules[0],
                second = rules[1];
              if (first.type !== "pseudo" || first.name !== "scope") {
              } else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
              } else if (
                second.type === "adjacent" ||
                second.type === "sibling"
              ) {
                shouldTestNextSiblings = true;
              }
            }
            return compileRules(rules, options, finalContext);
          })
          .reduce(reduceRules, boolbase_1.falseFunc);
        query.shouldTestNextSiblings = shouldTestNextSiblings;
        return query;
      }
      exports.compileToken = compileToken;
      function compileRules(rules, options, context) {
        var _a;
        return rules.reduce(
          function (previous, rule) {
            return previous === boolbase_1.falseFunc
              ? boolbase_1.falseFunc
              : (0, general_1.compileGeneralSelector)(
                  previous,
                  rule,
                  options,
                  context,
                  compileToken,
                );
          },
          (_a = options.rootFunc) !== null && _a !== void 0
            ? _a
            : boolbase_1.trueFunc,
        );
      }
      function reduceRules(a, b) {
        if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
          return a;
        }
        if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
          return b;
        }
        return function combine(elem) {
          return a(elem) || b(elem);
        };
      }
    },
    9795: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.compileGeneralSelector = void 0;
      var attributes_1 = __nccwpck_require__(3447);
      var pseudo_selectors_1 = __nccwpck_require__(5308);
      var css_what_1 = __nccwpck_require__(527);
      function compileGeneralSelector(
        next,
        selector,
        options,
        context,
        compileToken,
      ) {
        var adapter = options.adapter,
          equals = options.equals;
        switch (selector.type) {
          case css_what_1.SelectorType.PseudoElement: {
            throw new Error("Pseudo-elements are not supported by css-select");
          }
          case css_what_1.SelectorType.ColumnCombinator: {
            throw new Error(
              "Column combinators are not yet supported by css-select",
            );
          }
          case css_what_1.SelectorType.Attribute: {
            if (selector.namespace != null) {
              throw new Error(
                "Namespaced attributes are not yet supported by css-select",
              );
            }
            if (!options.xmlMode || options.lowerCaseAttributeNames) {
              selector.name = selector.name.toLowerCase();
            }
            return attributes_1.attributeRules[selector.action](
              next,
              selector,
              options,
            );
          }
          case css_what_1.SelectorType.Pseudo: {
            return (0, pseudo_selectors_1.compilePseudoSelector)(
              next,
              selector,
              options,
              context,
              compileToken,
            );
          }
          case css_what_1.SelectorType.Tag: {
            if (selector.namespace != null) {
              throw new Error(
                "Namespaced tag names are not yet supported by css-select",
              );
            }
            var name_1 = selector.name;
            if (!options.xmlMode || options.lowerCaseTags) {
              name_1 = name_1.toLowerCase();
            }
            return function tag(elem) {
              return adapter.getName(elem) === name_1 && next(elem);
            };
          }
          case css_what_1.SelectorType.Descendant: {
            if (
              options.cacheResults === false ||
              typeof WeakSet === "undefined"
            ) {
              return function descendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                  if (adapter.isTag(current) && next(current)) {
                    return true;
                  }
                }
                return false;
              };
            }
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
              var current = elem;
              while ((current = adapter.getParent(current))) {
                if (!isFalseCache_1.has(current)) {
                  if (adapter.isTag(current) && next(current)) {
                    return true;
                  }
                  isFalseCache_1.add(current);
                }
              }
              return false;
            };
          }
          case "_flexibleDescendant": {
            return function flexibleDescendant(elem) {
              var current = elem;
              do {
                if (adapter.isTag(current) && next(current)) return true;
              } while ((current = adapter.getParent(current)));
              return false;
            };
          }
          case css_what_1.SelectorType.Parent: {
            return function parent(elem) {
              return adapter.getChildren(elem).some(function (elem) {
                return adapter.isTag(elem) && next(elem);
              });
            };
          }
          case css_what_1.SelectorType.Child: {
            return function child(elem) {
              var parent = adapter.getParent(elem);
              return parent != null && adapter.isTag(parent) && next(parent);
            };
          }
          case css_what_1.SelectorType.Sibling: {
            return function sibling(elem) {
              var siblings = adapter.getSiblings(elem);
              for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling)) break;
                if (adapter.isTag(currentSibling) && next(currentSibling)) {
                  return true;
                }
              }
              return false;
            };
          }
          case css_what_1.SelectorType.Adjacent: {
            if (adapter.prevElementSibling) {
              return function adjacent(elem) {
                var previous = adapter.prevElementSibling(elem);
                return previous != null && next(previous);
              };
            }
            return function adjacent(elem) {
              var siblings = adapter.getSiblings(elem);
              var lastElement;
              for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling)) break;
                if (adapter.isTag(currentSibling)) {
                  lastElement = currentSibling;
                }
              }
              return !!lastElement && next(lastElement);
            };
          }
          case css_what_1.SelectorType.Universal: {
            if (selector.namespace != null && selector.namespace !== "*") {
              throw new Error(
                "Namespaced universal selectors are not yet supported by css-select",
              );
            }
            return next;
          }
        }
      }
      exports.compileGeneralSelector = compileGeneralSelector;
    },
    9100: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.aliases =
        exports.pseudos =
        exports.filters =
        exports.is =
        exports.selectOne =
        exports.selectAll =
        exports.prepareContext =
        exports._compileToken =
        exports._compileUnsafe =
        exports.compile =
          void 0;
      var DomUtils = __importStar(__nccwpck_require__(4745));
      var boolbase_1 = __nccwpck_require__(2882);
      var compile_1 = __nccwpck_require__(8318);
      var subselects_1 = __nccwpck_require__(5520);
      var defaultEquals = function (a, b) {
        return a === b;
      };
      var defaultOptions = { adapter: DomUtils, equals: defaultEquals };
      function convertOptionFormats(options) {
        var _a, _b, _c, _d;
        var opts =
          options !== null && options !== void 0 ? options : defaultOptions;
        (_a = opts.adapter) !== null && _a !== void 0
          ? _a
          : (opts.adapter = DomUtils);
        (_b = opts.equals) !== null && _b !== void 0
          ? _b
          : (opts.equals =
              (_d =
                (_c = opts.adapter) === null || _c === void 0
                  ? void 0
                  : _c.equals) !== null && _d !== void 0
                ? _d
                : defaultEquals);
        return opts;
      }
      function wrapCompile(func) {
        return function addAdapter(selector, options, context) {
          var opts = convertOptionFormats(options);
          return func(selector, opts, context);
        };
      }
      exports.compile = wrapCompile(compile_1.compile);
      exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
      exports._compileToken = wrapCompile(compile_1.compileToken);
      function getSelectorFunc(searchFunc) {
        return function select(query, elements, options) {
          var opts = convertOptionFormats(options);
          if (typeof query !== "function") {
            query = (0, compile_1.compileUnsafe)(query, opts, elements);
          }
          var filteredElements = prepareContext(
            elements,
            opts.adapter,
            query.shouldTestNextSiblings,
          );
          return searchFunc(query, filteredElements, opts);
        };
      }
      function prepareContext(elems, adapter, shouldTestNextSiblings) {
        if (shouldTestNextSiblings === void 0) {
          shouldTestNextSiblings = false;
        }
        if (shouldTestNextSiblings) {
          elems = appendNextSiblings(elems, adapter);
        }
        return Array.isArray(elems)
          ? adapter.removeSubsets(elems)
          : adapter.getChildren(elems);
      }
      exports.prepareContext = prepareContext;
      function appendNextSiblings(elem, adapter) {
        var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
        var elemsLength = elems.length;
        for (var i = 0; i < elemsLength; i++) {
          var nextSiblings = (0, subselects_1.getNextSiblings)(
            elems[i],
            adapter,
          );
          elems.push.apply(elems, nextSiblings);
        }
        return elems;
      }
      exports.selectAll = getSelectorFunc(function (query, elems, options) {
        return query === boolbase_1.falseFunc || !elems || elems.length === 0
          ? []
          : options.adapter.findAll(query, elems);
      });
      exports.selectOne = getSelectorFunc(function (query, elems, options) {
        return query === boolbase_1.falseFunc || !elems || elems.length === 0
          ? null
          : options.adapter.findOne(query, elems);
      });
      function is(elem, query, options) {
        var opts = convertOptionFormats(options);
        return (
          typeof query === "function"
            ? query
            : (0, compile_1.compile)(query, opts)
        )(elem);
      }
      exports.is = is;
      exports["default"] = exports.selectAll;
      var pseudo_selectors_1 = __nccwpck_require__(5308);
      Object.defineProperty(exports, "filters", {
        enumerable: true,
        get: function () {
          return pseudo_selectors_1.filters;
        },
      });
      Object.defineProperty(exports, "pseudos", {
        enumerable: true,
        get: function () {
          return pseudo_selectors_1.pseudos;
        },
      });
      Object.defineProperty(exports, "aliases", {
        enumerable: true,
        get: function () {
          return pseudo_selectors_1.aliases;
        },
      });
    },
    6691: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isTraversal = exports.procedure = void 0;
      exports.procedure = {
        universal: 50,
        tag: 30,
        attribute: 1,
        pseudo: 0,
        "pseudo-element": 0,
        "column-combinator": -1,
        descendant: -1,
        child: -1,
        parent: -1,
        sibling: -1,
        adjacent: -1,
        _flexibleDescendant: -1,
      };
      function isTraversal(t) {
        return exports.procedure[t.type] < 0;
      }
      exports.isTraversal = isTraversal;
    },
    1748: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.aliases = void 0;
      exports.aliases = {
        "any-link": ":is(a, area, link)[href]",
        link: ":any-link:not(:visited)",
        disabled:
          ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
        enabled: ":not(:disabled)",
        checked:
          ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
        required: ":is(input, select, textarea)[required]",
        optional: ":is(input, select, textarea):not([required])",
        selected:
          "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
        checkbox: "[type=checkbox]",
        file: "[type=file]",
        password: "[type=password]",
        radio: "[type=radio]",
        reset: "[type=reset]",
        image: "[type=image]",
        submit: "[type=submit]",
        parent: ":not(:empty)",
        header: ":is(h1, h2, h3, h4, h5, h6)",
        button: ":is(button, input[type=button])",
        input: ":is(input, textarea, select, button)",
        text: "input:is(:not([type!='']), [type=text])",
      };
    },
    2880: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filters = void 0;
      var nth_check_1 = __importDefault(__nccwpck_require__(8452));
      var boolbase_1 = __nccwpck_require__(2882);
      function getChildFunc(next, adapter) {
        return function (elem) {
          var parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(elem);
        };
      }
      exports.filters = {
        contains: function (next, text, _a) {
          var adapter = _a.adapter;
          return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
          };
        },
        icontains: function (next, text, _a) {
          var adapter = _a.adapter;
          var itext = text.toLowerCase();
          return function icontains(elem) {
            return (
              next(elem) && adapter.getText(elem).toLowerCase().includes(itext)
            );
          };
        },
        "nth-child": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
          return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
              if (equals(elem, siblings[i])) break;
              if (adapter.isTag(siblings[i])) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-last-child": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
          return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
              if (equals(elem, siblings[i])) break;
              if (adapter.isTag(siblings[i])) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-of-type": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
          return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling)) break;
              if (
                adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === adapter.getName(elem)
              ) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-last-of-type": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
          return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling)) break;
              if (
                adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === adapter.getName(elem)
              ) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        root: function (next, _rule, _a) {
          var adapter = _a.adapter;
          return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
          };
        },
        scope: function (next, rule, options, context) {
          var equals = options.equals;
          if (!context || context.length === 0) {
            return exports.filters.root(next, rule, options);
          }
          if (context.length === 1) {
            return function (elem) {
              return equals(context[0], elem) && next(elem);
            };
          }
          return function (elem) {
            return context.includes(elem) && next(elem);
          };
        },
        hover: dynamicStatePseudo("isHovered"),
        visited: dynamicStatePseudo("isVisited"),
        active: dynamicStatePseudo("isActive"),
      };
      function dynamicStatePseudo(name) {
        return function dynamicPseudo(next, _rule, _a) {
          var adapter = _a.adapter;
          var func = adapter[name];
          if (typeof func !== "function") {
            return boolbase_1.falseFunc;
          }
          return function active(elem) {
            return func(elem) && next(elem);
          };
        };
      }
    },
    5308: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.compilePseudoSelector =
        exports.aliases =
        exports.pseudos =
        exports.filters =
          void 0;
      var boolbase_1 = __nccwpck_require__(2882);
      var css_what_1 = __nccwpck_require__(527);
      var filters_1 = __nccwpck_require__(2880);
      Object.defineProperty(exports, "filters", {
        enumerable: true,
        get: function () {
          return filters_1.filters;
        },
      });
      var pseudos_1 = __nccwpck_require__(5238);
      Object.defineProperty(exports, "pseudos", {
        enumerable: true,
        get: function () {
          return pseudos_1.pseudos;
        },
      });
      var aliases_1 = __nccwpck_require__(1748);
      Object.defineProperty(exports, "aliases", {
        enumerable: true,
        get: function () {
          return aliases_1.aliases;
        },
      });
      var subselects_1 = __nccwpck_require__(5520);
      function compilePseudoSelector(
        next,
        selector,
        options,
        context,
        compileToken,
      ) {
        var name = selector.name,
          data = selector.data;
        if (Array.isArray(data)) {
          return subselects_1.subselects[name](
            next,
            data,
            options,
            context,
            compileToken,
          );
        }
        if (name in aliases_1.aliases) {
          if (data != null) {
            throw new Error(
              "Pseudo ".concat(name, " doesn't have any arguments"),
            );
          }
          var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
          return subselects_1.subselects.is(
            next,
            alias,
            options,
            context,
            compileToken,
          );
        }
        if (name in filters_1.filters) {
          return filters_1.filters[name](next, data, options, context);
        }
        if (name in pseudos_1.pseudos) {
          var pseudo_1 = pseudos_1.pseudos[name];
          (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
          return pseudo_1 === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : next === boolbase_1.trueFunc
              ? function (elem) {
                  return pseudo_1(elem, options, data);
                }
              : function (elem) {
                  return pseudo_1(elem, options, data) && next(elem);
                };
        }
        throw new Error("unmatched pseudo-class :".concat(name));
      }
      exports.compilePseudoSelector = compilePseudoSelector;
    },
    5238: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyPseudoArgs = exports.pseudos = void 0;
      exports.pseudos = {
        empty: function (elem, _a) {
          var adapter = _a.adapter;
          return !adapter.getChildren(elem).some(function (elem) {
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
          });
        },
        "first-child": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var firstChild = adapter.getSiblings(elem).find(function (elem) {
            return adapter.isTag(elem);
          });
          return firstChild != null && equals(elem, firstChild);
        },
        "last-child": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var siblings = adapter.getSiblings(elem);
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i])) return true;
            if (adapter.isTag(siblings[i])) break;
          }
          return false;
        },
        "first-of-type": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var siblings = adapter.getSiblings(elem);
          var elemName = adapter.getName(elem);
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling)) return true;
            if (
              adapter.isTag(currentSibling) &&
              adapter.getName(currentSibling) === elemName
            ) {
              break;
            }
          }
          return false;
        },
        "last-of-type": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var siblings = adapter.getSiblings(elem);
          var elemName = adapter.getName(elem);
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling)) return true;
            if (
              adapter.isTag(currentSibling) &&
              adapter.getName(currentSibling) === elemName
            ) {
              break;
            }
          }
          return false;
        },
        "only-of-type": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var elemName = adapter.getName(elem);
          return adapter.getSiblings(elem).every(function (sibling) {
            return (
              equals(elem, sibling) ||
              !adapter.isTag(sibling) ||
              adapter.getName(sibling) !== elemName
            );
          });
        },
        "only-child": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          return adapter.getSiblings(elem).every(function (sibling) {
            return equals(elem, sibling) || !adapter.isTag(sibling);
          });
        },
      };
      function verifyPseudoArgs(func, name, subselect) {
        if (subselect === null) {
          if (func.length > 2) {
            throw new Error(
              "pseudo-selector :".concat(name, " requires an argument"),
            );
          }
        } else if (func.length === 2) {
          throw new Error(
            "pseudo-selector :".concat(name, " doesn't have any arguments"),
          );
        }
      }
      exports.verifyPseudoArgs = verifyPseudoArgs;
    },
    5520: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __spreadArray =
        (this && this.__spreadArray) ||
        function (to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.subselects =
        exports.getNextSiblings =
        exports.ensureIsTag =
        exports.PLACEHOLDER_ELEMENT =
          void 0;
      var boolbase_1 = __nccwpck_require__(2882);
      var procedure_1 = __nccwpck_require__(6691);
      exports.PLACEHOLDER_ELEMENT = {};
      function ensureIsTag(next, adapter) {
        if (next === boolbase_1.falseFunc) return boolbase_1.falseFunc;
        return function (elem) {
          return adapter.isTag(elem) && next(elem);
        };
      }
      exports.ensureIsTag = ensureIsTag;
      function getNextSiblings(elem, adapter) {
        var siblings = adapter.getSiblings(elem);
        if (siblings.length <= 1) return [];
        var elemIndex = siblings.indexOf(elem);
        if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
        return siblings.slice(elemIndex + 1).filter(adapter.isTag);
      }
      exports.getNextSiblings = getNextSiblings;
      var is = function (next, token, options, context, compileToken) {
        var opts = {
          xmlMode: !!options.xmlMode,
          adapter: options.adapter,
          equals: options.equals,
        };
        var func = compileToken(token, opts, context);
        return function (elem) {
          return func(elem) && next(elem);
        };
      };
      exports.subselects = {
        is,
        matches: is,
        where: is,
        not: function (next, token, options, context, compileToken) {
          var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals,
          };
          var func = compileToken(token, opts, context);
          if (func === boolbase_1.falseFunc) return next;
          if (func === boolbase_1.trueFunc) return boolbase_1.falseFunc;
          return function not(elem) {
            return !func(elem) && next(elem);
          };
        },
        has: function (next, subselect, options, _context, compileToken) {
          var adapter = options.adapter;
          var opts = {
            xmlMode: !!options.xmlMode,
            adapter,
            equals: options.equals,
          };
          var context = subselect.some(function (s) {
            return s.some(procedure_1.isTraversal);
          })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
          var compiled = compileToken(subselect, opts, context);
          if (compiled === boolbase_1.falseFunc) return boolbase_1.falseFunc;
          if (compiled === boolbase_1.trueFunc) {
            return function (elem) {
              return (
                adapter.getChildren(elem).some(adapter.isTag) && next(elem)
              );
            };
          }
          var hasElement = ensureIsTag(compiled, adapter);
          var _a = compiled.shouldTestNextSiblings,
            shouldTestNextSiblings = _a === void 0 ? false : _a;
          if (context) {
            return function (elem) {
              context[0] = elem;
              var childs = adapter.getChildren(elem);
              var nextElements = shouldTestNextSiblings
                ? __spreadArray(
                    __spreadArray([], childs, true),
                    getNextSiblings(elem, adapter),
                    true,
                  )
                : childs;
              return next(elem) && adapter.existsOne(hasElement, nextElements);
            };
          }
          return function (elem) {
            return (
              next(elem) &&
              adapter.existsOne(hasElement, adapter.getChildren(elem))
            );
          };
        },
      };
    },
    1779: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var css_what_1 = __nccwpck_require__(527);
      var procedure_1 = __nccwpck_require__(6691);
      var attributes = {
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4,
      };
      function sortByProcedure(arr) {
        var procs = arr.map(getProcedure);
        for (var i = 1; i < arr.length; i++) {
          var procNew = procs[i];
          if (procNew < 0) continue;
          for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
          }
        }
      }
      exports["default"] = sortByProcedure;
      function getProcedure(token) {
        var proc = procedure_1.procedure[token.type];
        if (token.type === css_what_1.SelectorType.Attribute) {
          proc = attributes[token.action];
          if (proc === attributes.equals && token.name === "id") {
            proc = 9;
          }
          if (token.ignoreCase) {
            proc >>= 1;
          }
        } else if (token.type === css_what_1.SelectorType.Pseudo) {
          if (!token.data) {
            proc = 3;
          } else if (token.name === "has" || token.name === "contains") {
            proc = 0;
          } else if (Array.isArray(token.data)) {
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
              if (token.data[i].length !== 1) continue;
              var cur = getProcedure(token.data[i][0]);
              if (cur === 0) {
                proc = 0;
                break;
              }
              if (cur > proc) proc = cur;
            }
            if (token.data.length > 1 && proc > 0) proc -= 1;
          } else {
            proc = 1;
          }
        }
        return proc;
      }
    },
    2779: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const mdnAtrules = __nccwpck_require__(378);
      const mdnProperties = __nccwpck_require__(7279);
      const mdnSyntaxes = __nccwpck_require__(4448);
      const patch = __nccwpck_require__(6174);
      const extendSyntax = /^\s*\|\s*/;
      function preprocessAtrules(dict) {
        const result = Object.create(null);
        for (const atruleName in dict) {
          const atrule = dict[atruleName];
          let descriptors = null;
          if (atrule.descriptors) {
            descriptors = Object.create(null);
            for (const descriptor in atrule.descriptors) {
              descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
          }
          result[atruleName.substr(1)] = {
            prelude:
              atrule.syntax
                .trim()
                .match(/^@\S+\s+([^;\{]*)/)[1]
                .trim() || null,
            descriptors,
          };
        }
        return result;
      }
      function patchDictionary(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          result[key] = dict[key].syntax || dict[key];
        }
        for (const key in patchDict) {
          if (key in dict) {
            if (patchDict[key].syntax) {
              result[key] = extendSyntax.test(patchDict[key].syntax)
                ? result[key] + " " + patchDict[key].syntax.trim()
                : patchDict[key].syntax;
            } else {
              delete result[key];
            }
          } else {
            if (patchDict[key].syntax) {
              result[key] = patchDict[key].syntax.replace(extendSyntax, "");
            }
          }
        }
        return result;
      }
      function unpackSyntaxes(dict) {
        const result = {};
        for (const key in dict) {
          result[key] = dict[key].syntax;
        }
        return result;
      }
      function patchAtrules(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          const patchDescriptors =
            (patchDict[key] && patchDict[key].descriptors) || null;
          result[key] = {
            prelude:
              key in patchDict && "prelude" in patchDict[key]
                ? patchDict[key].prelude
                : dict[key].prelude || null,
            descriptors: dict[key].descriptors
              ? patchDictionary(dict[key].descriptors, patchDescriptors || {})
              : patchDescriptors && unpackSyntaxes(patchDescriptors),
          };
        }
        for (const key in patchDict) {
          if (!hasOwnProperty.call(dict, key)) {
            result[key] = {
              prelude: patchDict[key].prelude || null,
              descriptors:
                patchDict[key].descriptors &&
                unpackSyntaxes(patchDict[key].descriptors),
            };
          }
        }
        return result;
      }
      module.exports = {
        types: patchDictionary(mdnSyntaxes, patch.syntaxes),
        atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
        properties: patchDictionary(mdnProperties, patch.properties),
      };
    },
    9621: (module) => {
      function createItem(data) {
        return { prev: null, next: null, data };
      }
      function allocateCursor(node, prev, next) {
        var cursor;
        if (cursors !== null) {
          cursor = cursors;
          cursors = cursors.cursor;
          cursor.prev = prev;
          cursor.next = next;
          cursor.cursor = node.cursor;
        } else {
          cursor = { prev, next, cursor: node.cursor };
        }
        node.cursor = cursor;
        return cursor;
      }
      function releaseCursor(node) {
        var cursor = node.cursor;
        node.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = cursors;
        cursors = cursor;
      }
      var cursors = null;
      var List = function () {
        this.cursor = null;
        this.head = null;
        this.tail = null;
      };
      List.createItem = createItem;
      List.prototype.createItem = createItem;
      List.prototype.updateCursors = function (
        prevOld,
        prevNew,
        nextOld,
        nextNew,
      ) {
        var cursor = this.cursor;
        while (cursor !== null) {
          if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
          }
          if (cursor.next === nextOld) {
            cursor.next = nextNew;
          }
          cursor = cursor.cursor;
        }
      };
      List.prototype.getSize = function () {
        var size = 0;
        var cursor = this.head;
        while (cursor) {
          size++;
          cursor = cursor.next;
        }
        return size;
      };
      List.prototype.fromArray = function (array) {
        var cursor = null;
        this.head = null;
        for (var i = 0; i < array.length; i++) {
          var item = createItem(array[i]);
          if (cursor !== null) {
            cursor.next = item;
          } else {
            this.head = item;
          }
          item.prev = cursor;
          cursor = item;
        }
        this.tail = cursor;
        return this;
      };
      List.prototype.toArray = function () {
        var cursor = this.head;
        var result = [];
        while (cursor) {
          result.push(cursor.data);
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.toJSON = List.prototype.toArray;
      List.prototype.isEmpty = function () {
        return this.head === null;
      };
      List.prototype.first = function () {
        return this.head && this.head.data;
      };
      List.prototype.last = function () {
        return this.tail && this.tail.data;
      };
      List.prototype.each = function (fn, context) {
        var item;
        if (context === undefined) {
          context = this;
        }
        var cursor = allocateCursor(this, null, this.head);
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          fn.call(context, item.data, item, this);
        }
        releaseCursor(this);
      };
      List.prototype.forEach = List.prototype.each;
      List.prototype.eachRight = function (fn, context) {
        var item;
        if (context === undefined) {
          context = this;
        }
        var cursor = allocateCursor(this, this.tail, null);
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          fn.call(context, item.data, item, this);
        }
        releaseCursor(this);
      };
      List.prototype.forEachRight = List.prototype.eachRight;
      List.prototype.reduce = function (fn, initialValue, context) {
        var item;
        if (context === undefined) {
          context = this;
        }
        var cursor = allocateCursor(this, null, this.head);
        var acc = initialValue;
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          acc = fn.call(context, acc, item.data, item, this);
        }
        releaseCursor(this);
        return acc;
      };
      List.prototype.reduceRight = function (fn, initialValue, context) {
        var item;
        if (context === undefined) {
          context = this;
        }
        var cursor = allocateCursor(this, this.tail, null);
        var acc = initialValue;
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          acc = fn.call(context, acc, item.data, item, this);
        }
        releaseCursor(this);
        return acc;
      };
      List.prototype.nextUntil = function (start, fn, context) {
        if (start === null) {
          return;
        }
        var item;
        if (context === undefined) {
          context = this;
        }
        var cursor = allocateCursor(this, null, start);
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          if (fn.call(context, item.data, item, this)) {
            break;
          }
        }
        releaseCursor(this);
      };
      List.prototype.prevUntil = function (start, fn, context) {
        if (start === null) {
          return;
        }
        var item;
        if (context === undefined) {
          context = this;
        }
        var cursor = allocateCursor(this, start, null);
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          if (fn.call(context, item.data, item, this)) {
            break;
          }
        }
        releaseCursor(this);
      };
      List.prototype.some = function (fn, context) {
        var cursor = this.head;
        if (context === undefined) {
          context = this;
        }
        while (cursor !== null) {
          if (fn.call(context, cursor.data, cursor, this)) {
            return true;
          }
          cursor = cursor.next;
        }
        return false;
      };
      List.prototype.map = function (fn, context) {
        var result = new List();
        var cursor = this.head;
        if (context === undefined) {
          context = this;
        }
        while (cursor !== null) {
          result.appendData(fn.call(context, cursor.data, cursor, this));
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.filter = function (fn, context) {
        var result = new List();
        var cursor = this.head;
        if (context === undefined) {
          context = this;
        }
        while (cursor !== null) {
          if (fn.call(context, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
          }
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.clear = function () {
        this.head = null;
        this.tail = null;
      };
      List.prototype.copy = function () {
        var result = new List();
        var cursor = this.head;
        while (cursor !== null) {
          result.insert(createItem(cursor.data));
          cursor = cursor.next;
        }
        return result;
      };
      List.prototype.prepend = function (item) {
        this.updateCursors(null, item, this.head, item);
        if (this.head !== null) {
          this.head.prev = item;
          item.next = this.head;
        } else {
          this.tail = item;
        }
        this.head = item;
        return this;
      };
      List.prototype.prependData = function (data) {
        return this.prepend(createItem(data));
      };
      List.prototype.append = function (item) {
        return this.insert(item);
      };
      List.prototype.appendData = function (data) {
        return this.insert(createItem(data));
      };
      List.prototype.insert = function (item, before) {
        if (before !== undefined && before !== null) {
          this.updateCursors(before.prev, item, before, item);
          if (before.prev === null) {
            if (this.head !== before) {
              throw new Error("before doesn't belong to list");
            }
            this.head = item;
            before.prev = item;
            item.next = before;
            this.updateCursors(null, item);
          } else {
            before.prev.next = item;
            item.prev = before.prev;
            before.prev = item;
            item.next = before;
          }
        } else {
          this.updateCursors(this.tail, item, null, item);
          if (this.tail !== null) {
            this.tail.next = item;
            item.prev = this.tail;
          } else {
            this.head = item;
          }
          this.tail = item;
        }
        return this;
      };
      List.prototype.insertData = function (data, before) {
        return this.insert(createItem(data), before);
      };
      List.prototype.remove = function (item) {
        this.updateCursors(item, item.prev, item, item.next);
        if (item.prev !== null) {
          item.prev.next = item.next;
        } else {
          if (this.head !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.head = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        } else {
          if (this.tail !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.tail = item.prev;
        }
        item.prev = null;
        item.next = null;
        return item;
      };
      List.prototype.push = function (data) {
        this.insert(createItem(data));
      };
      List.prototype.pop = function () {
        if (this.tail !== null) {
          return this.remove(this.tail);
        }
      };
      List.prototype.unshift = function (data) {
        this.prepend(createItem(data));
      };
      List.prototype.shift = function () {
        if (this.head !== null) {
          return this.remove(this.head);
        }
      };
      List.prototype.prependList = function (list) {
        return this.insertList(list, this.head);
      };
      List.prototype.appendList = function (list) {
        return this.insertList(list);
      };
      List.prototype.insertList = function (list, before) {
        if (list.head === null) {
          return this;
        }
        if (before !== undefined && before !== null) {
          this.updateCursors(before.prev, list.tail, before, list.head);
          if (before.prev !== null) {
            before.prev.next = list.head;
            list.head.prev = before.prev;
          } else {
            this.head = list.head;
          }
          before.prev = list.tail;
          list.tail.next = before;
        } else {
          this.updateCursors(this.tail, list.tail, null, list.head);
          if (this.tail !== null) {
            this.tail.next = list.head;
            list.head.prev = this.tail;
          } else {
            this.head = list.head;
          }
          this.tail = list.tail;
        }
        list.head = null;
        list.tail = null;
        return this;
      };
      List.prototype.replace = function (oldItem, newItemOrList) {
        if ("head" in newItemOrList) {
          this.insertList(newItemOrList, oldItem);
        } else {
          this.insert(newItemOrList, oldItem);
        }
        this.remove(oldItem);
      };
      module.exports = List;
    },
    7500: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var adoptBuffer = __nccwpck_require__(3307);
      var isBOM = __nccwpck_require__(6701).isBOM;
      var N = 10;
      var F = 12;
      var R = 13;
      function computeLinesAndColumns(host, source) {
        var sourceLength = source.length;
        var lines = adoptBuffer(host.lines, sourceLength);
        var line = host.startLine;
        var columns = adoptBuffer(host.columns, sourceLength);
        var column = host.startColumn;
        var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
        for (var i = startOffset; i < sourceLength; i++) {
          var code = source.charCodeAt(i);
          lines[i] = line;
          columns[i] = column++;
          if (code === N || code === R || code === F) {
            if (
              code === R &&
              i + 1 < sourceLength &&
              source.charCodeAt(i + 1) === N
            ) {
              i++;
              lines[i] = line;
              columns[i] = column;
            }
            line++;
            column = 1;
          }
        }
        lines[i] = line;
        columns[i] = column;
        host.lines = lines;
        host.columns = columns;
      }
      var OffsetToLocation = function () {
        this.lines = null;
        this.columns = null;
        this.linesAndColumnsComputed = false;
      };
      OffsetToLocation.prototype = {
        setSource: function (source, startOffset, startLine, startColumn) {
          this.source = source;
          this.startOffset =
            typeof startOffset === "undefined" ? 0 : startOffset;
          this.startLine = typeof startLine === "undefined" ? 1 : startLine;
          this.startColumn =
            typeof startColumn === "undefined" ? 1 : startColumn;
          this.linesAndColumnsComputed = false;
        },
        ensureLinesAndColumnsComputed: function () {
          if (!this.linesAndColumnsComputed) {
            computeLinesAndColumns(this, this.source);
            this.linesAndColumnsComputed = true;
          }
        },
        getLocation: function (offset, filename) {
          this.ensureLinesAndColumnsComputed();
          return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset],
          };
        },
        getLocationRange: function (start, end, filename) {
          this.ensureLinesAndColumnsComputed();
          return {
            source: filename,
            start: {
              offset: this.startOffset + start,
              line: this.lines[start],
              column: this.columns[start],
            },
            end: {
              offset: this.startOffset + end,
              line: this.lines[end],
              column: this.columns[end],
            },
          };
        },
      };
      module.exports = OffsetToLocation;
    },
    1431: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var createCustomError = __nccwpck_require__(7512);
      var MAX_LINE_LENGTH = 100;
      var OFFSET_CORRECTION = 60;
      var TAB_REPLACEMENT = "    ";
      function sourceFragment(error, extraLines) {
        function processLines(start, end) {
          return lines
            .slice(start, end)
            .map(function (line, idx) {
              var num = String(start + idx + 1);
              while (num.length < maxNumLength) {
                num = " " + num;
              }
              return num + " |" + line;
            })
            .join("\n");
        }
        var lines = error.source.split(/\r\n?|\n|\f/);
        var line = error.line;
        var column = error.column;
        var startLine = Math.max(1, line - extraLines) - 1;
        var endLine = Math.min(line + extraLines, lines.length + 1);
        var maxNumLength = Math.max(4, String(endLine).length) + 1;
        var cutLeft = 0;
        column +=
          (TAB_REPLACEMENT.length - 1) *
          (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
        if (column > MAX_LINE_LENGTH) {
          cutLeft = column - OFFSET_CORRECTION + 3;
          column = OFFSET_CORRECTION - 2;
        }
        for (var i = startLine; i <= endLine; i++) {
          if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
              (cutLeft > 0 && lines[i].length > cutLeft ? "…" : "") +
              lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
              (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "…" : "");
          }
        }
        return [
          processLines(startLine, line),
          new Array(column + maxNumLength + 2).join("-") + "^",
          processLines(line, endLine),
        ]
          .filter(Boolean)
          .join("\n");
      }
      var SyntaxError = function (message, source, offset, line, column) {
        var error = createCustomError("SyntaxError", message);
        error.source = source;
        error.offset = offset;
        error.line = line;
        error.column = column;
        error.sourceFragment = function (extraLines) {
          return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
        };
        Object.defineProperty(error, "formattedMessage", {
          get: function () {
            return (
              "Parse error: " + error.message + "\n" + sourceFragment(error, 2)
            );
          },
        });
        error.parseError = { offset, line, column };
        return error;
      };
      module.exports = SyntaxError;
    },
    9313: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var constants = __nccwpck_require__(3276);
      var TYPE = constants.TYPE;
      var NAME = constants.NAME;
      var utils = __nccwpck_require__(7989);
      var cmpStr = utils.cmpStr;
      var EOF = TYPE.EOF;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var OFFSET_MASK = 16777215;
      var TYPE_SHIFT = 24;
      var TokenStream = function () {
        this.offsetAndType = null;
        this.balance = null;
        this.reset();
      };
      TokenStream.prototype = {
        reset: function () {
          this.eof = false;
          this.tokenIndex = -1;
          this.tokenType = 0;
          this.tokenStart = this.firstCharOffset;
          this.tokenEnd = this.firstCharOffset;
        },
        lookupType: function (offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
          }
          return EOF;
        },
        lookupOffset: function (offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
          }
          return this.source.length;
        },
        lookupValue: function (offset, referenceStr) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return cmpStr(
              this.source,
              this.offsetAndType[offset - 1] & OFFSET_MASK,
              this.offsetAndType[offset] & OFFSET_MASK,
              referenceStr,
            );
          }
          return false;
        },
        getTokenStart: function (tokenIndex) {
          if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
          }
          if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
              ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
              : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
          }
          return this.firstCharOffset;
        },
        getRawLength: function (startToken, mode) {
          var cursor = startToken;
          var balanceEnd;
          var offset =
            this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
          var type;
          loop: for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            type = this.offsetAndType[cursor] >> TYPE_SHIFT;
            switch (mode(type, this.source, offset)) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
                offset = this.offsetAndType[cursor] & OFFSET_MASK;
            }
          }
          return cursor - this.tokenIndex;
        },
        isBalanceEdge: function (pos) {
          return this.balance[this.tokenIndex] < pos;
        },
        isDelim: function (code, offset) {
          if (offset) {
            return (
              this.lookupType(offset) === TYPE.Delim &&
              this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
          }
          return (
            this.tokenType === TYPE.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
          );
        },
        getTokenValue: function () {
          return this.source.substring(this.tokenStart, this.tokenEnd);
        },
        getTokenLength: function () {
          return this.tokenEnd - this.tokenStart;
        },
        substrToCursor: function (start) {
          return this.source.substring(start, this.tokenStart);
        },
        skipWS: function () {
          for (
            var i = this.tokenIndex, skipTokenCount = 0;
            i < this.tokenCount;
            i++, skipTokenCount++
          ) {
            if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
              break;
            }
          }
          if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
          }
        },
        skipSC: function () {
          while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
          }
        },
        skip: function (tokenCount) {
          var next = this.tokenIndex + tokenCount;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.next();
          }
        },
        next: function () {
          var next = this.tokenIndex + 1;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.eof = true;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
          }
        },
        forEachToken(fn) {
          for (
            var i = 0, offset = this.firstCharOffset;
            i < this.tokenCount;
            i++
          ) {
            var start = offset;
            var item = this.offsetAndType[i];
            var end = item & OFFSET_MASK;
            var type = item >> TYPE_SHIFT;
            offset = end;
            fn(type, start, end, i);
          }
        },
        dump() {
          var tokens = new Array(this.tokenCount);
          this.forEachToken((type, start, end, index) => {
            tokens[index] = {
              idx: index,
              type: NAME[type],
              chunk: this.source.substring(start, end),
              balance: this.balance[index],
            };
          });
          return tokens;
        },
      };
      module.exports = TokenStream;
    },
    3307: (module) => {
      var MIN_SIZE = 16 * 1024;
      var SafeUint32Array =
        typeof Uint32Array !== "undefined" ? Uint32Array : Array;
      module.exports = function adoptBuffer(buffer, size) {
        if (buffer === null || buffer.length < size) {
          return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
        }
        return buffer;
      };
    },
    5640: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(9621);
      module.exports = function createConvertors(walk) {
        return {
          fromPlainObject: function (ast) {
            walk(ast, {
              enter: function (node) {
                if (node.children && node.children instanceof List === false) {
                  node.children = new List().fromArray(node.children);
                }
              },
            });
            return ast;
          },
          toPlainObject: function (ast) {
            walk(ast, {
              leave: function (node) {
                if (node.children && node.children instanceof List) {
                  node.children = node.children.toArray();
                }
              },
            });
            return ast;
          },
        };
      };
    },
    4198: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var createCustomError = __nccwpck_require__(7512);
      module.exports = function SyntaxError(message, input, offset) {
        var error = createCustomError("SyntaxError", message);
        error.input = input;
        error.offset = offset;
        error.rawMessage = message;
        error.message =
          error.rawMessage +
          "\n" +
          "  " +
          error.input +
          "\n" +
          "--" +
          new Array((error.offset || error.input.length) + 1).join("-") +
          "^";
        return error;
      };
    },
    8806: (module) => {
      function noop(value) {
        return value;
      }
      function generateMultiplier(multiplier) {
        if (multiplier.min === 0 && multiplier.max === 0) {
          return "*";
        }
        if (multiplier.min === 0 && multiplier.max === 1) {
          return "?";
        }
        if (multiplier.min === 1 && multiplier.max === 0) {
          return multiplier.comma ? "#" : "+";
        }
        if (multiplier.min === 1 && multiplier.max === 1) {
          return "";
        }
        return (
          (multiplier.comma ? "#" : "") +
          (multiplier.min === multiplier.max
            ? "{" + multiplier.min + "}"
            : "{" +
              multiplier.min +
              "," +
              (multiplier.max !== 0 ? multiplier.max : "") +
              "}")
        );
      }
      function generateTypeOpts(node) {
        switch (node.type) {
          case "Range":
            return (
              " [" +
              (node.min === null ? "-∞" : node.min) +
              "," +
              (node.max === null ? "∞" : node.max) +
              "]"
            );
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
      }
      function generateSequence(node, decorate, forceBraces, compact) {
        var combinator =
          node.combinator === " " || compact
            ? node.combinator
            : " " + node.combinator + " ";
        var result = node.terms
          .map(function (term) {
            return generate(term, decorate, forceBraces, compact);
          })
          .join(combinator);
        if (node.explicit || forceBraces) {
          result =
            (compact || result[0] === "," ? "[" : "[ ") +
            result +
            (compact ? "]" : " ]");
        }
        return result;
      }
      function generate(node, decorate, forceBraces, compact) {
        var result;
        switch (node.type) {
          case "Group":
            result =
              generateSequence(node, decorate, forceBraces, compact) +
              (node.disallowEmpty ? "!" : "");
            break;
          case "Multiplier":
            return (
              generate(node.term, decorate, forceBraces, compact) +
              decorate(generateMultiplier(node), node)
            );
          case "Type":
            result =
              "<" +
              node.name +
              (node.opts
                ? decorate(generateTypeOpts(node.opts), node.opts)
                : "") +
              ">";
            break;
          case "Property":
            result = "<'" + node.name + "'>";
            break;
          case "Keyword":
            result = node.name;
            break;
          case "AtKeyword":
            result = "@" + node.name;
            break;
          case "Function":
            result = node.name + "(";
            break;
          case "String":
          case "Token":
            result = node.value;
            break;
          case "Comma":
            result = ",";
            break;
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
        return decorate(result, node);
      }
      module.exports = function (node, options) {
        var decorate = noop;
        var forceBraces = false;
        var compact = false;
        if (typeof options === "function") {
          decorate = options;
        } else if (options) {
          forceBraces = Boolean(options.forceBraces);
          compact = Boolean(options.compact);
          if (typeof options.decorate === "function") {
            decorate = options.decorate;
          }
        }
        return generate(node, decorate, forceBraces, compact);
      };
    },
    4102: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        SyntaxError: __nccwpck_require__(4198),
        parse: __nccwpck_require__(4011),
        generate: __nccwpck_require__(8806),
        walk: __nccwpck_require__(9002),
      };
    },
    4011: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var Tokenizer = __nccwpck_require__(9094);
      var TAB = 9;
      var N = 10;
      var F = 12;
      var R = 13;
      var SPACE = 32;
      var EXCLAMATIONMARK = 33;
      var NUMBERSIGN = 35;
      var AMPERSAND = 38;
      var APOSTROPHE = 39;
      var LEFTPARENTHESIS = 40;
      var RIGHTPARENTHESIS = 41;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var COMMA = 44;
      var HYPERMINUS = 45;
      var LESSTHANSIGN = 60;
      var GREATERTHANSIGN = 62;
      var QUESTIONMARK = 63;
      var COMMERCIALAT = 64;
      var LEFTSQUAREBRACKET = 91;
      var RIGHTSQUAREBRACKET = 93;
      var LEFTCURLYBRACKET = 123;
      var VERTICALLINE = 124;
      var RIGHTCURLYBRACKET = 125;
      var INFINITY = 8734;
      var NAME_CHAR = createCharMap(function (ch) {
        return /[a-zA-Z0-9\-]/.test(ch);
      });
      var COMBINATOR_PRECEDENCE = { " ": 1, "&&": 2, "||": 3, "|": 4 };
      function createCharMap(fn) {
        var array =
          typeof Uint32Array === "function"
            ? new Uint32Array(128)
            : new Array(128);
        for (var i = 0; i < 128; i++) {
          array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
        }
        return array;
      }
      function scanSpaces(tokenizer) {
        return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
      }
      function scanWord(tokenizer) {
        var end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          var code = tokenizer.str.charCodeAt(end);
          if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a keyword");
        }
        return tokenizer.substringToPos(end);
      }
      function scanNumber(tokenizer) {
        var end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          var code = tokenizer.str.charCodeAt(end);
          if (code < 48 || code > 57) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a number");
        }
        return tokenizer.substringToPos(end);
      }
      function scanString(tokenizer) {
        var end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
        if (end === -1) {
          tokenizer.pos = tokenizer.str.length;
          tokenizer.error("Expect an apostrophe");
        }
        return tokenizer.substringToPos(end + 1);
      }
      function readMultiplierRange(tokenizer) {
        var min = null;
        var max = null;
        tokenizer.eat(LEFTCURLYBRACKET);
        min = scanNumber(tokenizer);
        if (tokenizer.charCode() === COMMA) {
          tokenizer.pos++;
          if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
          }
        } else {
          max = min;
        }
        tokenizer.eat(RIGHTCURLYBRACKET);
        return { min: Number(min), max: max ? Number(max) : 0 };
      }
      function readMultiplier(tokenizer) {
        var range = null;
        var comma = false;
        switch (tokenizer.charCode()) {
          case ASTERISK:
            tokenizer.pos++;
            range = { min: 0, max: 0 };
            break;
          case PLUSSIGN:
            tokenizer.pos++;
            range = { min: 1, max: 0 };
            break;
          case QUESTIONMARK:
            tokenizer.pos++;
            range = { min: 0, max: 1 };
            break;
          case NUMBERSIGN:
            tokenizer.pos++;
            comma = true;
            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
              range = readMultiplierRange(tokenizer);
            } else {
              range = { min: 1, max: 0 };
            }
            break;
          case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;
          default:
            return null;
        }
        return {
          type: "Multiplier",
          comma,
          min: range.min,
          max: range.max,
          term: null,
        };
      }
      function maybeMultiplied(tokenizer, node) {
        var multiplier = readMultiplier(tokenizer);
        if (multiplier !== null) {
          multiplier.term = node;
          return multiplier;
        }
        return node;
      }
      function maybeToken(tokenizer) {
        var ch = tokenizer.peek();
        if (ch === "") {
          return null;
        }
        return { type: "Token", value: ch };
      }
      function readProperty(tokenizer) {
        var name;
        tokenizer.eat(LESSTHANSIGN);
        tokenizer.eat(APOSTROPHE);
        name = scanWord(tokenizer);
        tokenizer.eat(APOSTROPHE);
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, { type: "Property", name });
      }
      function readTypeRange(tokenizer) {
        var min = null;
        var max = null;
        var sign = 1;
        tokenizer.eat(LEFTSQUAREBRACKET);
        if (tokenizer.charCode() === HYPERMINUS) {
          tokenizer.peek();
          sign = -1;
        }
        if (sign == -1 && tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          min = sign * Number(scanNumber(tokenizer));
        }
        scanSpaces(tokenizer);
        tokenizer.eat(COMMA);
        scanSpaces(tokenizer);
        if (tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          sign = 1;
          if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
          }
          max = sign * Number(scanNumber(tokenizer));
        }
        tokenizer.eat(RIGHTSQUAREBRACKET);
        if (min === null && max === null) {
          return null;
        }
        return { type: "Range", min, max };
      }
      function readType(tokenizer) {
        var name;
        var opts = null;
        tokenizer.eat(LESSTHANSIGN);
        name = scanWord(tokenizer);
        if (
          tokenizer.charCode() === LEFTPARENTHESIS &&
          tokenizer.nextCharCode() === RIGHTPARENTHESIS
        ) {
          tokenizer.pos += 2;
          name += "()";
        }
        if (
          tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) ===
          LEFTSQUAREBRACKET
        ) {
          scanSpaces(tokenizer);
          opts = readTypeRange(tokenizer);
        }
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, { type: "Type", name, opts });
      }
      function readKeywordOrFunction(tokenizer) {
        var name;
        name = scanWord(tokenizer);
        if (tokenizer.charCode() === LEFTPARENTHESIS) {
          tokenizer.pos++;
          return { type: "Function", name };
        }
        return maybeMultiplied(tokenizer, { type: "Keyword", name });
      }
      function regroupTerms(terms, combinators) {
        function createGroup(terms, combinator) {
          return {
            type: "Group",
            terms,
            combinator,
            disallowEmpty: false,
            explicit: false,
          };
        }
        combinators = Object.keys(combinators).sort(function (a, b) {
          return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
        });
        while (combinators.length > 0) {
          var combinator = combinators.shift();
          for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === "Combinator") {
              if (term.value === combinator) {
                if (subgroupStart === -1) {
                  subgroupStart = i - 1;
                }
                terms.splice(i, 1);
                i--;
              } else {
                if (subgroupStart !== -1 && i - subgroupStart > 1) {
                  terms.splice(
                    subgroupStart,
                    i - subgroupStart,
                    createGroup(terms.slice(subgroupStart, i), combinator),
                  );
                  i = subgroupStart + 1;
                }
                subgroupStart = -1;
              }
            }
          }
          if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator),
            );
          }
        }
        return combinator;
      }
      function readImplicitGroup(tokenizer) {
        var terms = [];
        var combinators = {};
        var token;
        var prevToken = null;
        var prevTokenPos = tokenizer.pos;
        while ((token = peek(tokenizer))) {
          if (token.type !== "Spaces") {
            if (token.type === "Combinator") {
              if (prevToken === null || prevToken.type === "Combinator") {
                tokenizer.pos = prevTokenPos;
                tokenizer.error("Unexpected combinator");
              }
              combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== "Combinator") {
              combinators[" "] = true;
              terms.push({ type: "Combinator", value: " " });
            }
            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
          }
        }
        if (prevToken !== null && prevToken.type === "Combinator") {
          tokenizer.pos -= prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }
        return {
          type: "Group",
          terms,
          combinator: regroupTerms(terms, combinators) || " ",
          disallowEmpty: false,
          explicit: false,
        };
      }
      function readGroup(tokenizer) {
        var result;
        tokenizer.eat(LEFTSQUAREBRACKET);
        result = readImplicitGroup(tokenizer);
        tokenizer.eat(RIGHTSQUAREBRACKET);
        result.explicit = true;
        if (tokenizer.charCode() === EXCLAMATIONMARK) {
          tokenizer.pos++;
          result.disallowEmpty = true;
        }
        return result;
      }
      function peek(tokenizer) {
        var code = tokenizer.charCode();
        if (code < 128 && NAME_CHAR[code] === 1) {
          return readKeywordOrFunction(tokenizer);
        }
        switch (code) {
          case RIGHTSQUAREBRACKET:
            break;
          case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));
          case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
              ? readProperty(tokenizer)
              : readType(tokenizer);
          case VERTICALLINE:
            return {
              type: "Combinator",
              value: tokenizer.substringToPos(
                tokenizer.nextCharCode() === VERTICALLINE
                  ? tokenizer.pos + 2
                  : tokenizer.pos + 1,
              ),
            };
          case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);
            return { type: "Combinator", value: "&&" };
          case COMMA:
            tokenizer.pos++;
            return { type: "Comma" };
          case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
              type: "String",
              value: scanString(tokenizer),
            });
          case SPACE:
          case TAB:
          case N:
          case R:
          case F:
            return { type: "Spaces", value: scanSpaces(tokenizer) };
          case COMMERCIALAT:
            code = tokenizer.nextCharCode();
            if (code < 128 && NAME_CHAR[code] === 1) {
              tokenizer.pos++;
              return { type: "AtKeyword", name: scanWord(tokenizer) };
            }
            return maybeToken(tokenizer);
          case ASTERISK:
          case PLUSSIGN:
          case QUESTIONMARK:
          case NUMBERSIGN:
          case EXCLAMATIONMARK:
            break;
          case LEFTCURLYBRACKET:
            code = tokenizer.nextCharCode();
            if (code < 48 || code > 57) {
              return maybeToken(tokenizer);
            }
            break;
          default:
            return maybeToken(tokenizer);
        }
      }
      function parse(source) {
        var tokenizer = new Tokenizer(source);
        var result = readImplicitGroup(tokenizer);
        if (tokenizer.pos !== source.length) {
          tokenizer.error("Unexpected input");
        }
        if (result.terms.length === 1 && result.terms[0].type === "Group") {
          result = result.terms[0];
        }
        return result;
      }
      parse("[a&&<b>#|<'c'>*||e() f{2} /,(% g#{1,2} h{2,})]!");
      module.exports = parse;
    },
    9094: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var SyntaxError = __nccwpck_require__(4198);
      var TAB = 9;
      var N = 10;
      var F = 12;
      var R = 13;
      var SPACE = 32;
      var Tokenizer = function (str) {
        this.str = str;
        this.pos = 0;
      };
      Tokenizer.prototype = {
        charCodeAt: function (pos) {
          return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
        },
        charCode: function () {
          return this.charCodeAt(this.pos);
        },
        nextCharCode: function () {
          return this.charCodeAt(this.pos + 1);
        },
        nextNonWsCode: function (pos) {
          return this.charCodeAt(this.findWsEnd(pos));
        },
        findWsEnd: function (pos) {
          for (; pos < this.str.length; pos++) {
            var code = this.str.charCodeAt(pos);
            if (
              code !== R &&
              code !== N &&
              code !== F &&
              code !== SPACE &&
              code !== TAB
            ) {
              break;
            }
          }
          return pos;
        },
        substringToPos: function (end) {
          return this.str.substring(this.pos, (this.pos = end));
        },
        eat: function (code) {
          if (this.charCode() !== code) {
            this.error("Expect `" + String.fromCharCode(code) + "`");
          }
          this.pos++;
        },
        peek: function () {
          return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
        },
        error: function (message) {
          throw new SyntaxError(message, this.str, this.pos);
        },
      };
      module.exports = Tokenizer;
    },
    9002: (module) => {
      var noop = function () {};
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop;
      }
      module.exports = function (node, options, context) {
        function walk(node) {
          enter.call(context, node);
          switch (node.type) {
            case "Group":
              node.terms.forEach(walk);
              break;
            case "Multiplier":
              walk(node.term);
              break;
            case "Type":
            case "Property":
            case "Keyword":
            case "AtKeyword":
            case "Function":
            case "String":
            case "Token":
            case "Comma":
              break;
            default:
              throw new Error("Unknown type: " + node.type);
          }
          leave.call(context, node);
        }
        var enter = noop;
        var leave = noop;
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
        }
        if (enter === noop && leave === noop) {
          throw new Error(
            "Neither `enter` nor `leave` walker handler is set or both aren't a function",
          );
        }
        walk(node, context);
      };
    },
    4506: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var sourceMap = __nccwpck_require__(5452);
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function processChildren(node, delimeter) {
        var list = node.children;
        var prev = null;
        if (typeof delimeter !== "function") {
          list.forEach(this.node, this);
        } else {
          list.forEach(function (node) {
            if (prev !== null) {
              delimeter.call(this, prev);
            }
            this.node(node);
            prev = node;
          }, this);
        }
      }
      module.exports = function createGenerator(config) {
        function processNode(node) {
          if (hasOwnProperty.call(types, node.type)) {
            types[node.type].call(this, node);
          } else {
            throw new Error("Unknown node type: " + node.type);
          }
        }
        var types = {};
        if (config.node) {
          for (var name in config.node) {
            types[name] = config.node[name].generate;
          }
        }
        return function (node, options) {
          var buffer = "";
          var handlers = {
            children: processChildren,
            node: processNode,
            chunk: function (chunk) {
              buffer += chunk;
            },
            result: function () {
              return buffer;
            },
          };
          if (options) {
            if (typeof options.decorator === "function") {
              handlers = options.decorator(handlers);
            }
            if (options.sourceMap) {
              handlers = sourceMap(handlers);
            }
          }
          handlers.node(node);
          return handlers.result();
        };
      };
    },
    5452: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var SourceMapGenerator = __nccwpck_require__(2364).h;
      var trackNodes = { Atrule: true, Selector: true, Declaration: true };
      module.exports = function generateSourceMap(handlers) {
        var map = new SourceMapGenerator();
        var line = 1;
        var column = 0;
        var generated = { line: 1, column: 0 };
        var original = { line: 0, column: 0 };
        var sourceMappingActive = false;
        var activatedGenerated = { line: 1, column: 0 };
        var activatedMapping = { generated: activatedGenerated };
        var handlersNode = handlers.node;
        handlers.node = function (node) {
          if (
            node.loc &&
            node.loc.start &&
            trackNodes.hasOwnProperty(node.type)
          ) {
            var nodeLine = node.loc.start.line;
            var nodeColumn = node.loc.start.column - 1;
            if (original.line !== nodeLine || original.column !== nodeColumn) {
              original.line = nodeLine;
              original.column = nodeColumn;
              generated.line = line;
              generated.column = column;
              if (sourceMappingActive) {
                sourceMappingActive = false;
                if (
                  generated.line !== activatedGenerated.line ||
                  generated.column !== activatedGenerated.column
                ) {
                  map.addMapping(activatedMapping);
                }
              }
              sourceMappingActive = true;
              map.addMapping({ source: node.loc.source, original, generated });
            }
          }
          handlersNode.call(this, node);
          if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
          }
        };
        var handlersChunk = handlers.chunk;
        handlers.chunk = function (chunk) {
          for (var i = 0; i < chunk.length; i++) {
            if (chunk.charCodeAt(i) === 10) {
              line++;
              column = 0;
            } else {
              column++;
            }
          }
          handlersChunk(chunk);
        };
        var handlersResult = handlers.result;
        handlers.result = function () {
          if (sourceMappingActive) {
            map.addMapping(activatedMapping);
          }
          return { css: handlersResult(), map };
        };
        return handlers;
      };
    },
    4895: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(4869);
    },
    1567: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var SyntaxReferenceError = __nccwpck_require__(7555).SyntaxReferenceError;
      var SyntaxMatchError = __nccwpck_require__(7555).SyntaxMatchError;
      var names = __nccwpck_require__(4337);
      var generic = __nccwpck_require__(7587);
      var parse = __nccwpck_require__(4011);
      var generate = __nccwpck_require__(8806);
      var walk = __nccwpck_require__(9002);
      var prepareTokens = __nccwpck_require__(8480);
      var buildMatchGraph = __nccwpck_require__(6571).buildMatchGraph;
      var matchAsTree = __nccwpck_require__(5991).matchAsTree;
      var trace = __nccwpck_require__(3354);
      var search = __nccwpck_require__(7220);
      var getStructureFromConfig =
        __nccwpck_require__(7591).getStructureFromConfig;
      var cssWideKeywords = buildMatchGraph("inherit | initial | unset");
      var cssWideKeywordsWithExpression = buildMatchGraph(
        "inherit | initial | unset | <-ms-legacy-expression>",
      );
      function dumpMapSyntax(map, compact, syntaxAsAst) {
        var result = {};
        for (var name in map) {
          if (map[name].syntax) {
            result[name] = syntaxAsAst
              ? map[name].syntax
              : generate(map[name].syntax, { compact });
          }
        }
        return result;
      }
      function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
        const result = {};
        for (const [name, atrule] of Object.entries(map)) {
          result[name] = {
            prelude:
              atrule.prelude &&
              (syntaxAsAst
                ? atrule.prelude.syntax
                : generate(atrule.prelude.syntax, { compact })),
            descriptors:
              atrule.descriptors &&
              dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst),
          };
        }
        return result;
      }
      function valueHasVar(tokens) {
        for (var i = 0; i < tokens.length; i++) {
          if (tokens[i].value.toLowerCase() === "var(") {
            return true;
          }
        }
        return false;
      }
      function buildMatchResult(match, error, iterations) {
        return {
          matched: match,
          iterations,
          error,
          getTrace: trace.getTrace,
          isType: trace.isType,
          isProperty: trace.isProperty,
          isKeyword: trace.isKeyword,
        };
      }
      function matchSyntax(lexer, syntax, value, useCommon) {
        var tokens = prepareTokens(value, lexer.syntax);
        var result;
        if (valueHasVar(tokens)) {
          return buildMatchResult(
            null,
            new Error("Matching for a tree with var() is not supported"),
          );
        }
        if (useCommon) {
          result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
        }
        if (!useCommon || !result.match) {
          result = matchAsTree(tokens, syntax.match, lexer);
          if (!result.match) {
            return buildMatchResult(
              null,
              new SyntaxMatchError(result.reason, syntax.syntax, value, result),
              result.iterations,
            );
          }
        }
        return buildMatchResult(result.match, null, result.iterations);
      }
      var Lexer = function (config, syntax, structure) {
        this.valueCommonSyntax = cssWideKeywords;
        this.syntax = syntax;
        this.generic = false;
        this.atrules = {};
        this.properties = {};
        this.types = {};
        this.structure = structure || getStructureFromConfig(config);
        if (config) {
          if (config.types) {
            for (var name in config.types) {
              this.addType_(name, config.types[name]);
            }
          }
          if (config.generic) {
            this.generic = true;
            for (var name in generic) {
              this.addType_(name, generic[name]);
            }
          }
          if (config.atrules) {
            for (var name in config.atrules) {
              this.addAtrule_(name, config.atrules[name]);
            }
          }
          if (config.properties) {
            for (var name in config.properties) {
              this.addProperty_(name, config.properties[name]);
            }
          }
        }
      };
      Lexer.prototype = {
        structure: {},
        checkStructure: function (ast) {
          function collectWarning(node, message) {
            warns.push({ node, message });
          }
          var structure = this.structure;
          var warns = [];
          this.syntax.walk(ast, function (node) {
            if (structure.hasOwnProperty(node.type)) {
              structure[node.type].check(node, collectWarning);
            } else {
              collectWarning(node, "Unknown node type `" + node.type + "`");
            }
          });
          return warns.length ? warns : false;
        },
        createDescriptor: function (syntax, type, name, parent = null) {
          var ref = { type, name };
          var descriptor = { type, name, parent, syntax: null, match: null };
          if (typeof syntax === "function") {
            descriptor.match = buildMatchGraph(syntax, ref);
          } else {
            if (typeof syntax === "string") {
              Object.defineProperty(descriptor, "syntax", {
                get: function () {
                  Object.defineProperty(descriptor, "syntax", {
                    value: parse(syntax),
                  });
                  return descriptor.syntax;
                },
              });
            } else {
              descriptor.syntax = syntax;
            }
            Object.defineProperty(descriptor, "match", {
              get: function () {
                Object.defineProperty(descriptor, "match", {
                  value: buildMatchGraph(descriptor.syntax, ref),
                });
                return descriptor.match;
              },
            });
          }
          return descriptor;
        },
        addAtrule_: function (name, syntax) {
          if (!syntax) {
            return;
          }
          this.atrules[name] = {
            type: "Atrule",
            name,
            prelude: syntax.prelude
              ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name)
              : null,
            descriptors: syntax.descriptors
              ? Object.keys(syntax.descriptors).reduce((res, descName) => {
                  res[descName] = this.createDescriptor(
                    syntax.descriptors[descName],
                    "AtruleDescriptor",
                    descName,
                    name,
                  );
                  return res;
                }, {})
              : null,
          };
        },
        addProperty_: function (name, syntax) {
          if (!syntax) {
            return;
          }
          this.properties[name] = this.createDescriptor(
            syntax,
            "Property",
            name,
          );
        },
        addType_: function (name, syntax) {
          if (!syntax) {
            return;
          }
          this.types[name] = this.createDescriptor(syntax, "Type", name);
          if (syntax === generic["-ms-legacy-expression"]) {
            this.valueCommonSyntax = cssWideKeywordsWithExpression;
          }
        },
        checkAtruleName: function (atruleName) {
          if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError(
              "Unknown at-rule",
              "@" + atruleName,
            );
          }
        },
        checkAtrulePrelude: function (atruleName, prelude) {
          let error = this.checkAtruleName(atruleName);
          if (error) {
            return error;
          }
          var atrule = this.getAtrule(atruleName);
          if (!atrule.prelude && prelude) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` should not contain a prelude",
            );
          }
          if (atrule.prelude && !prelude) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` should contain a prelude",
            );
          }
        },
        checkAtruleDescriptorName: function (atruleName, descriptorName) {
          let error = this.checkAtruleName(atruleName);
          if (error) {
            return error;
          }
          var atrule = this.getAtrule(atruleName);
          var descriptor = names.keyword(descriptorName);
          if (!atrule.descriptors) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` has no known descriptors",
            );
          }
          if (
            !atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]
          ) {
            return new SyntaxReferenceError(
              "Unknown at-rule descriptor",
              descriptorName,
            );
          }
        },
        checkPropertyName: function (propertyName) {
          var property = names.property(propertyName);
          if (property.custom) {
            return new Error(
              "Lexer matching doesn't applicable for custom properties",
            );
          }
          if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError("Unknown property", propertyName);
          }
        },
        matchAtrulePrelude: function (atruleName, prelude) {
          var error = this.checkAtrulePrelude(atruleName, prelude);
          if (error) {
            return buildMatchResult(null, error);
          }
          if (!prelude) {
            return buildMatchResult(null, null);
          }
          return matchSyntax(
            this,
            this.getAtrule(atruleName).prelude,
            prelude,
            false,
          );
        },
        matchAtruleDescriptor: function (atruleName, descriptorName, value) {
          var error = this.checkAtruleDescriptorName(
            atruleName,
            descriptorName,
          );
          if (error) {
            return buildMatchResult(null, error);
          }
          var atrule = this.getAtrule(atruleName);
          var descriptor = names.keyword(descriptorName);
          return matchSyntax(
            this,
            atrule.descriptors[descriptor.name] ||
              atrule.descriptors[descriptor.basename],
            value,
            false,
          );
        },
        matchDeclaration: function (node) {
          if (node.type !== "Declaration") {
            return buildMatchResult(null, new Error("Not a Declaration node"));
          }
          return this.matchProperty(node.property, node.value);
        },
        matchProperty: function (propertyName, value) {
          var error = this.checkPropertyName(propertyName);
          if (error) {
            return buildMatchResult(null, error);
          }
          return matchSyntax(this, this.getProperty(propertyName), value, true);
        },
        matchType: function (typeName, value) {
          var typeSyntax = this.getType(typeName);
          if (!typeSyntax) {
            return buildMatchResult(
              null,
              new SyntaxReferenceError("Unknown type", typeName),
            );
          }
          return matchSyntax(this, typeSyntax, value, false);
        },
        match: function (syntax, value) {
          if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
            return buildMatchResult(
              null,
              new SyntaxReferenceError("Bad syntax"),
            );
          }
          if (typeof syntax === "string" || !syntax.match) {
            syntax = this.createDescriptor(syntax, "Type", "anonymous");
          }
          return matchSyntax(this, syntax, value, false);
        },
        findValueFragments: function (propertyName, value, type, name) {
          return search.matchFragments(
            this,
            value,
            this.matchProperty(propertyName, value),
            type,
            name,
          );
        },
        findDeclarationValueFragments: function (declaration, type, name) {
          return search.matchFragments(
            this,
            declaration.value,
            this.matchDeclaration(declaration),
            type,
            name,
          );
        },
        findAllFragments: function (ast, type, name) {
          var result = [];
          this.syntax.walk(ast, {
            visit: "Declaration",
            enter: function (declaration) {
              result.push.apply(
                result,
                this.findDeclarationValueFragments(declaration, type, name),
              );
            }.bind(this),
          });
          return result;
        },
        getAtrule: function (atruleName, fallbackBasename = true) {
          var atrule = names.keyword(atruleName);
          var atruleEntry =
            atrule.vendor && fallbackBasename
              ? this.atrules[atrule.name] || this.atrules[atrule.basename]
              : this.atrules[atrule.name];
          return atruleEntry || null;
        },
        getAtrulePrelude: function (atruleName, fallbackBasename = true) {
          const atrule = this.getAtrule(atruleName, fallbackBasename);
          return (atrule && atrule.prelude) || null;
        },
        getAtruleDescriptor: function (atruleName, name) {
          return this.atrules.hasOwnProperty(atruleName) &&
            this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
        },
        getProperty: function (propertyName, fallbackBasename = true) {
          var property = names.property(propertyName);
          var propertyEntry =
            property.vendor && fallbackBasename
              ? this.properties[property.name] ||
                this.properties[property.basename]
              : this.properties[property.name];
          return propertyEntry || null;
        },
        getType: function (name) {
          return this.types.hasOwnProperty(name) ? this.types[name] : null;
        },
        validate: function () {
          function validate(syntax, name, broken, descriptor) {
            if (broken.hasOwnProperty(name)) {
              return broken[name];
            }
            broken[name] = false;
            if (descriptor.syntax !== null) {
              walk(
                descriptor.syntax,
                function (node) {
                  if (node.type !== "Type" && node.type !== "Property") {
                    return;
                  }
                  var map =
                    node.type === "Type" ? syntax.types : syntax.properties;
                  var brokenMap =
                    node.type === "Type" ? brokenTypes : brokenProperties;
                  if (
                    !map.hasOwnProperty(node.name) ||
                    validate(syntax, node.name, brokenMap, map[node.name])
                  ) {
                    broken[name] = true;
                  }
                },
                this,
              );
            }
          }
          var brokenTypes = {};
          var brokenProperties = {};
          for (var key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
          }
          for (var key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
          }
          brokenTypes = Object.keys(brokenTypes).filter(function (name) {
            return brokenTypes[name];
          });
          brokenProperties = Object.keys(brokenProperties).filter(
            function (name) {
              return brokenProperties[name];
            },
          );
          if (brokenTypes.length || brokenProperties.length) {
            return { types: brokenTypes, properties: brokenProperties };
          }
          return null;
        },
        dump: function (syntaxAsAst, pretty) {
          return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst),
          };
        },
        toString: function () {
          return JSON.stringify(this.dump());
        },
      };
      module.exports = Lexer;
    },
    7555: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const createCustomError = __nccwpck_require__(7512);
      const generate = __nccwpck_require__(8806);
      const defaultLoc = { offset: 0, line: 1, column: 1 };
      function locateMismatch(matchResult, node) {
        const tokens = matchResult.tokens;
        const longestMatch = matchResult.longestMatch;
        const mismatchNode =
          longestMatch < tokens.length
            ? tokens[longestMatch].node || null
            : null;
        const badNode = mismatchNode !== node ? mismatchNode : null;
        let mismatchOffset = 0;
        let mismatchLength = 0;
        let entries = 0;
        let css = "";
        let start;
        let end;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i].value;
          if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
          }
          if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
              entries++;
            } else {
              entries = 0;
            }
          }
          css += token;
        }
        if (longestMatch === tokens.length || entries > 1) {
          start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
          end = buildLoc(start);
        } else {
          start =
            fromLoc(badNode, "start") ||
            buildLoc(
              fromLoc(node, "start") || defaultLoc,
              css.slice(0, mismatchOffset),
            );
          end =
            fromLoc(badNode, "end") ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
        }
        return { css, mismatchOffset, mismatchLength, start, end };
      }
      function fromLoc(node, point) {
        const value = node && node.loc && node.loc[point];
        if (value) {
          return "line" in value ? buildLoc(value) : value;
        }
        return null;
      }
      function buildLoc({ offset, line, column }, extra) {
        const loc = { offset, line, column };
        if (extra) {
          const lines = extra.split(/\n|\r\n?|\f/);
          loc.offset += extra.length;
          loc.line += lines.length - 1;
          loc.column =
            lines.length === 1
              ? loc.column + extra.length
              : lines.pop().length + 1;
        }
        return loc;
      }
      const SyntaxReferenceError = function (type, referenceName) {
        const error = createCustomError(
          "SyntaxReferenceError",
          type + (referenceName ? " `" + referenceName + "`" : ""),
        );
        error.reference = referenceName;
        return error;
      };
      const SyntaxMatchError = function (message, syntax, node, matchResult) {
        const error = createCustomError("SyntaxMatchError", message);
        const { css, mismatchOffset, mismatchLength, start, end } =
          locateMismatch(matchResult, node);
        error.rawMessage = message;
        error.syntax = syntax ? generate(syntax) : "<generic>";
        error.css = css;
        error.mismatchOffset = mismatchOffset;
        error.mismatchLength = mismatchLength;
        error.message =
          message +
          "\n" +
          "  syntax: " +
          error.syntax +
          "\n" +
          "   value: " +
          (css || "<empty string>") +
          "\n" +
          "  --------" +
          new Array(error.mismatchOffset + 1).join("-") +
          "^";
        Object.assign(error, start);
        error.loc = {
          source: (node && node.loc && node.loc.source) || "<unknown>",
          start,
          end,
        };
        return error;
      };
      module.exports = { SyntaxReferenceError, SyntaxMatchError };
    },
    6728: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isDigit = __nccwpck_require__(6701).isDigit;
      var cmpChar = __nccwpck_require__(6701).cmpChar;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var DELIM = TYPE.Delim;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var N = 110;
      var DISALLOW_SIGN = true;
      var ALLOW_SIGN = false;
      function isDelim(token, code) {
        return (
          token !== null &&
          token.type === DELIM &&
          token.value.charCodeAt(0) === code
        );
      }
      function skipSC(token, offset, getNextToken) {
        while (
          token !== null &&
          (token.type === WHITESPACE || token.type === COMMENT)
        ) {
          token = getNextToken(++offset);
        }
        return offset;
      }
      function checkInteger(token, valueOffset, disallowSign, offset) {
        if (!token) {
          return 0;
        }
        var code = token.value.charCodeAt(valueOffset);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            return 0;
          }
          valueOffset++;
        }
        for (; valueOffset < token.value.length; valueOffset++) {
          if (!isDigit(token.value.charCodeAt(valueOffset))) {
            return 0;
          }
        }
        return offset + 1;
      }
      function consumeB(token, offset_, getNextToken) {
        var sign = false;
        var offset = skipSC(token, offset_, getNextToken);
        token = getNextToken(offset);
        if (token === null) {
          return offset_;
        }
        if (token.type !== NUMBER) {
          if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            if (token === null && token.type !== NUMBER) {
              return 0;
            }
          } else {
            return offset_;
          }
        }
        if (!sign) {
          var code = token.value.charCodeAt(0);
          if (code !== PLUSSIGN && code !== HYPHENMINUS) {
            return 0;
          }
        }
        return checkInteger(token, sign ? 0 : 1, sign, offset);
      }
      module.exports = function anPlusB(token, getNextToken) {
        var offset = 0;
        if (!token) {
          return 0;
        }
        if (token.type === NUMBER) {
          return checkInteger(token, 0, ALLOW_SIGN, offset);
        } else if (
          token.type === IDENT &&
          token.value.charCodeAt(0) === HYPHENMINUS
        ) {
          if (!cmpChar(token.value, 1, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 2:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 3:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 3, DISALLOW_SIGN, offset);
          }
        } else if (
          token.type === IDENT ||
          (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)
        ) {
          if (token.type !== IDENT) {
            token = getNextToken(++offset);
          }
          if (token === null || !cmpChar(token.value, 0, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 1:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 2:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 2, DISALLOW_SIGN, offset);
          }
        } else if (token.type === DIMENSION) {
          var code = token.value.charCodeAt(0);
          var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
          for (var i = sign; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
              break;
            }
          }
          if (i === sign) {
            return 0;
          }
          if (!cmpChar(token.value, i, N)) {
            return 0;
          }
          if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
          } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
              return 0;
            }
            if (i + 2 === token.value.length) {
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            } else {
              return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
          }
        }
        return 0;
      };
    },
    6394: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isHexDigit = __nccwpck_require__(6701).isHexDigit;
      var cmpChar = __nccwpck_require__(6701).cmpChar;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var DELIM = TYPE.Delim;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var QUESTIONMARK = 63;
      var U = 117;
      function isDelim(token, code) {
        return (
          token !== null &&
          token.type === DELIM &&
          token.value.charCodeAt(0) === code
        );
      }
      function startsWith(token, code) {
        return token.value.charCodeAt(0) === code;
      }
      function hexSequence(token, offset, allowDash) {
        for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
          var code = token.value.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
              return 6;
            }
            return 0;
          }
          if (!isHexDigit(code)) {
            return 0;
          }
          if (++hexlen > 6) {
            return 0;
          }
        }
        return hexlen;
      }
      function withQuestionMarkSequence(consumed, length, getNextToken) {
        if (!consumed) {
          return 0;
        }
        while (isDelim(getNextToken(length), QUESTIONMARK)) {
          if (++consumed > 6) {
            return 0;
          }
          length++;
        }
        return length;
      }
      module.exports = function urange(token, getNextToken) {
        var length = 0;
        if (
          token === null ||
          token.type !== IDENT ||
          !cmpChar(token.value, 0, U)
        ) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (isDelim(token, PLUSSIGN)) {
          token = getNextToken(++length);
          if (token === null) {
            return 0;
          }
          if (token.type === IDENT) {
            return withQuestionMarkSequence(
              hexSequence(token, 0, true),
              ++length,
              getNextToken,
            );
          }
          if (isDelim(token, QUESTIONMARK)) {
            return withQuestionMarkSequence(1, ++length, getNextToken);
          }
          return 0;
        }
        if (token.type === NUMBER) {
          if (!startsWith(token, PLUSSIGN)) {
            return 0;
          }
          var consumedHexLength = hexSequence(token, 1, true);
          if (consumedHexLength === 0) {
            return 0;
          }
          token = getNextToken(++length);
          if (token === null) {
            return length;
          }
          if (token.type === DIMENSION || token.type === NUMBER) {
            if (
              !startsWith(token, HYPHENMINUS) ||
              !hexSequence(token, 1, false)
            ) {
              return 0;
            }
            return length + 1;
          }
          return withQuestionMarkSequence(
            consumedHexLength,
            length,
            getNextToken,
          );
        }
        if (token.type === DIMENSION) {
          if (!startsWith(token, PLUSSIGN)) {
            return 0;
          }
          return withQuestionMarkSequence(
            hexSequence(token, 1, true),
            ++length,
            getNextToken,
          );
        }
        return 0;
      };
    },
    7587: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var tokenizer = __nccwpck_require__(6701);
      var isIdentifierStart = tokenizer.isIdentifierStart;
      var isHexDigit = tokenizer.isHexDigit;
      var isDigit = tokenizer.isDigit;
      var cmpStr = tokenizer.cmpStr;
      var consumeNumber = tokenizer.consumeNumber;
      var TYPE = tokenizer.TYPE;
      var anPlusB = __nccwpck_require__(6728);
      var urange = __nccwpck_require__(6394);
      var cssWideKeywords = ["unset", "initial", "inherit"];
      var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
      var LENGTH = {
        px: true,
        mm: true,
        cm: true,
        in: true,
        pt: true,
        pc: true,
        q: true,
        em: true,
        ex: true,
        ch: true,
        rem: true,
        vh: true,
        vw: true,
        vmin: true,
        vmax: true,
        vm: true,
      };
      var ANGLE = { deg: true, grad: true, rad: true, turn: true };
      var TIME = { s: true, ms: true };
      var FREQUENCY = { hz: true, khz: true };
      var RESOLUTION = { dpi: true, dpcm: true, dppx: true, x: true };
      var FLEX = { fr: true };
      var DECIBEL = { db: true };
      var SEMITONES = { st: true };
      function charCode(str, index) {
        return index < str.length ? str.charCodeAt(index) : 0;
      }
      function eqStr(actual, expected) {
        return cmpStr(actual, 0, actual.length, expected);
      }
      function eqStrAny(actual, expected) {
        for (var i = 0; i < expected.length; i++) {
          if (eqStr(actual, expected[i])) {
            return true;
          }
        }
        return false;
      }
      function isPostfixIeHack(str, offset) {
        if (offset !== str.length - 2) {
          return false;
        }
        return (
          str.charCodeAt(offset) === 92 && isDigit(str.charCodeAt(offset + 1))
        );
      }
      function outOfRange(opts, value, numEnd) {
        if (opts && opts.type === "Range") {
          var num = Number(
            numEnd !== undefined && numEnd !== value.length
              ? value.substr(0, numEnd)
              : value,
          );
          if (isNaN(num)) {
            return true;
          }
          if (opts.min !== null && num < opts.min) {
            return true;
          }
          if (opts.max !== null && num > opts.max) {
            return true;
          }
        }
        return false;
      }
      function consumeFunction(token, getNextToken) {
        var startIdx = token.index;
        var length = 0;
        do {
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while ((token = getNextToken(length)));
        return length;
      }
      function calc(next) {
        return function (token, getNextToken, opts) {
          if (token === null) {
            return 0;
          }
          if (
            token.type === TYPE.Function &&
            eqStrAny(token.value, calcFunctionNames)
          ) {
            return consumeFunction(token, getNextToken);
          }
          return next(token, getNextToken, opts);
        };
      }
      function tokenType(expectedTokenType) {
        return function (token) {
          if (token === null || token.type !== expectedTokenType) {
            return 0;
          }
          return 1;
        };
      }
      function func(name) {
        name = name + "(";
        return function (token, getNextToken) {
          if (token !== null && eqStr(token.value, name)) {
            return consumeFunction(token, getNextToken);
          }
          return 0;
        };
      }
      function customIdent(token) {
        if (token === null || token.type !== TYPE.Ident) {
          return 0;
        }
        var name = token.value.toLowerCase();
        if (eqStrAny(name, cssWideKeywords)) {
          return 0;
        }
        if (eqStr(name, "default")) {
          return 0;
        }
        return 1;
      }
      function customPropertyName(token) {
        if (token === null || token.type !== TYPE.Ident) {
          return 0;
        }
        if (
          charCode(token.value, 0) !== 45 ||
          charCode(token.value, 1) !== 45
        ) {
          return 0;
        }
        return 1;
      }
      function hexColor(token) {
        if (token === null || token.type !== TYPE.Hash) {
          return 0;
        }
        var length = token.value.length;
        if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
          return 0;
        }
        for (var i = 1; i < length; i++) {
          if (!isHexDigit(token.value.charCodeAt(i))) {
            return 0;
          }
        }
        return 1;
      }
      function idSelector(token) {
        if (token === null || token.type !== TYPE.Hash) {
          return 0;
        }
        if (
          !isIdentifierStart(
            charCode(token.value, 1),
            charCode(token.value, 2),
            charCode(token.value, 3),
          )
        ) {
          return 0;
        }
        return 1;
      }
      function declarationValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        var length = 0;
        var level = 0;
        var startIdx = token.index;
        scan: do {
          switch (token.type) {
            case TYPE.BadString:
            case TYPE.BadUrl:
              break scan;
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
              if (token.balance > token.index || token.balance < startIdx) {
                break scan;
              }
              level--;
              break;
            case TYPE.Semicolon:
              if (level === 0) {
                break scan;
              }
              break;
            case TYPE.Delim:
              if (token.value === "!" && level === 0) {
                break scan;
              }
              break;
            case TYPE.Function:
            case TYPE.LeftParenthesis:
            case TYPE.LeftSquareBracket:
            case TYPE.LeftCurlyBracket:
              level++;
              break;
          }
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while ((token = getNextToken(length)));
        return length;
      }
      function anyValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        var startIdx = token.index;
        var length = 0;
        scan: do {
          switch (token.type) {
            case TYPE.BadString:
            case TYPE.BadUrl:
              break scan;
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
              if (token.balance > token.index || token.balance < startIdx) {
                break scan;
              }
              break;
          }
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while ((token = getNextToken(length)));
        return length;
      }
      function dimension(type) {
        return function (token, getNextToken, opts) {
          if (token === null || token.type !== TYPE.Dimension) {
            return 0;
          }
          var numberEnd = consumeNumber(token.value, 0);
          if (type !== null) {
            var reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
            var unit =
              reverseSolidusOffset === -1 ||
              !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);
            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
              return 0;
            }
          }
          if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
          }
          return 1;
        };
      }
      function percentage(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Percentage) {
          return 0;
        }
        if (outOfRange(opts, token.value, token.value.length - 1)) {
          return 0;
        }
        return 1;
      }
      function zero(next) {
        if (typeof next !== "function") {
          next = function () {
            return 0;
          };
        }
        return function (token, getNextToken, opts) {
          if (token !== null && token.type === TYPE.Number) {
            if (Number(token.value) === 0) {
              return 1;
            }
          }
          return next(token, getNextToken, opts);
        };
      }
      function number(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        var numberEnd = consumeNumber(token.value, 0);
        var isNumber = numberEnd === token.value.length;
        if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
          return 0;
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      }
      function integer(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Number) {
          return 0;
        }
        var i =
          token.value.charCodeAt(0) === 43 || token.value.charCodeAt(0) === 45
            ? 1
            : 0;
        for (; i < token.value.length; i++) {
          if (!isDigit(token.value.charCodeAt(i))) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, i)) {
          return 0;
        }
        return 1;
      }
      module.exports = {
        "ident-token": tokenType(TYPE.Ident),
        "function-token": tokenType(TYPE.Function),
        "at-keyword-token": tokenType(TYPE.AtKeyword),
        "hash-token": tokenType(TYPE.Hash),
        "string-token": tokenType(TYPE.String),
        "bad-string-token": tokenType(TYPE.BadString),
        "url-token": tokenType(TYPE.Url),
        "bad-url-token": tokenType(TYPE.BadUrl),
        "delim-token": tokenType(TYPE.Delim),
        "number-token": tokenType(TYPE.Number),
        "percentage-token": tokenType(TYPE.Percentage),
        "dimension-token": tokenType(TYPE.Dimension),
        "whitespace-token": tokenType(TYPE.WhiteSpace),
        "CDO-token": tokenType(TYPE.CDO),
        "CDC-token": tokenType(TYPE.CDC),
        "colon-token": tokenType(TYPE.Colon),
        "semicolon-token": tokenType(TYPE.Semicolon),
        "comma-token": tokenType(TYPE.Comma),
        "[-token": tokenType(TYPE.LeftSquareBracket),
        "]-token": tokenType(TYPE.RightSquareBracket),
        "(-token": tokenType(TYPE.LeftParenthesis),
        ")-token": tokenType(TYPE.RightParenthesis),
        "{-token": tokenType(TYPE.LeftCurlyBracket),
        "}-token": tokenType(TYPE.RightCurlyBracket),
        string: tokenType(TYPE.String),
        ident: tokenType(TYPE.Ident),
        "custom-ident": customIdent,
        "custom-property-name": customPropertyName,
        "hex-color": hexColor,
        "id-selector": idSelector,
        "an-plus-b": anPlusB,
        urange,
        "declaration-value": declarationValue,
        "any-value": anyValue,
        dimension: calc(dimension(null)),
        angle: calc(dimension(ANGLE)),
        decibel: calc(dimension(DECIBEL)),
        frequency: calc(dimension(FREQUENCY)),
        flex: calc(dimension(FLEX)),
        length: calc(zero(dimension(LENGTH))),
        resolution: calc(dimension(RESOLUTION)),
        semitones: calc(dimension(SEMITONES)),
        time: calc(dimension(TIME)),
        percentage: calc(percentage),
        zero: zero(),
        number: calc(number),
        integer: calc(integer),
        "-ms-legacy-expression": func("expression"),
      };
    },
    6571: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var parse = __nccwpck_require__(4011);
      var MATCH = { type: "Match" };
      var MISMATCH = { type: "Mismatch" };
      var DISALLOW_EMPTY = { type: "DisallowEmpty" };
      var LEFTPARENTHESIS = 40;
      var RIGHTPARENTHESIS = 41;
      function createCondition(match, thenBranch, elseBranch) {
        if (thenBranch === MATCH && elseBranch === MISMATCH) {
          return match;
        }
        if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
          return match;
        }
        if (
          match.type === "If" &&
          match.else === MISMATCH &&
          thenBranch === MATCH
        ) {
          thenBranch = match.then;
          match = match.match;
        }
        return { type: "If", match, then: thenBranch, else: elseBranch };
      }
      function isFunctionType(name) {
        return (
          name.length > 2 &&
          name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
          name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
        );
      }
      function isEnumCapatible(term) {
        return (
          term.type === "Keyword" ||
          term.type === "AtKeyword" ||
          term.type === "Function" ||
          (term.type === "Type" && isFunctionType(term.name))
        );
      }
      function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
        switch (combinator) {
          case " ":
            var result = MATCH;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              result = createCondition(term, result, MISMATCH);
            }
            return result;
          case "|":
            var result = MISMATCH;
            var map = null;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              if (isEnumCapatible(term)) {
                if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                  map = Object.create(null);
                  result = createCondition(
                    { type: "Enum", map },
                    MATCH,
                    result,
                  );
                }
                if (map !== null) {
                  var key = (
                    isFunctionType(term.name)
                      ? term.name.slice(0, -1)
                      : term.name
                  ).toLowerCase();
                  if (key in map === false) {
                    map[key] = term;
                    continue;
                  }
                }
              }
              map = null;
              result = createCondition(term, MATCH, result);
            }
            return result;
          case "&&":
            if (terms.length > 5) {
              return { type: "MatchOnce", terms, all: true };
            }
            var result = MISMATCH;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              var thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function (newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  false,
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(term, thenClause, result);
            }
            return result;
          case "||":
            if (terms.length > 5) {
              return { type: "MatchOnce", terms, all: false };
            }
            var result = atLeastOneTermMatched ? MATCH : MISMATCH;
            for (var i = terms.length - 1; i >= 0; i--) {
              var term = terms[i];
              var thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function (newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  true,
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(term, thenClause, result);
            }
            return result;
        }
      }
      function buildMultiplierMatchGraph(node) {
        var result = MATCH;
        var matchTerm = buildMatchGraph(node.term);
        if (node.max === 0) {
          matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
          result = createCondition(matchTerm, null, MISMATCH);
          result.then = createCondition(MATCH, MATCH, result);
          if (node.comma) {
            result.then.else = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH,
            );
          }
        } else {
          for (var i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH,
              );
            }
            result = createCondition(
              matchTerm,
              createCondition(MATCH, MATCH, result),
              MISMATCH,
            );
          }
        }
        if (node.min === 0) {
          result = createCondition(MATCH, MATCH, result);
        } else {
          for (var i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH,
              );
            }
            result = createCondition(matchTerm, result, MISMATCH);
          }
        }
        return result;
      }
      function buildMatchGraph(node) {
        if (typeof node === "function") {
          return { type: "Generic", fn: node };
        }
        switch (node.type) {
          case "Group":
            var result = buildGroupMatchGraph(
              node.combinator,
              node.terms.map(buildMatchGraph),
              false,
            );
            if (node.disallowEmpty) {
              result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
            }
            return result;
          case "Multiplier":
            return buildMultiplierMatchGraph(node);
          case "Type":
          case "Property":
            return { type: node.type, name: node.name, syntax: node };
          case "Keyword":
            return {
              type: node.type,
              name: node.name.toLowerCase(),
              syntax: node,
            };
          case "AtKeyword":
            return {
              type: node.type,
              name: "@" + node.name.toLowerCase(),
              syntax: node,
            };
          case "Function":
            return {
              type: node.type,
              name: node.name.toLowerCase() + "(",
              syntax: node,
            };
          case "String":
            if (node.value.length === 3) {
              return {
                type: "Token",
                value: node.value.charAt(1),
                syntax: node,
              };
            }
            return {
              type: node.type,
              value: node.value
                .substr(1, node.value.length - 2)
                .replace(/\\'/g, "'"),
              syntax: node,
            };
          case "Token":
            return { type: node.type, value: node.value, syntax: node };
          case "Comma":
            return { type: node.type, syntax: node };
          default:
            throw new Error("Unknown node type:", node.type);
        }
      }
      module.exports = {
        MATCH,
        MISMATCH,
        DISALLOW_EMPTY,
        buildMatchGraph: function (syntaxTree, ref) {
          if (typeof syntaxTree === "string") {
            syntaxTree = parse(syntaxTree);
          }
          return {
            type: "MatchGraph",
            match: buildMatchGraph(syntaxTree),
            syntax: ref || null,
            source: syntaxTree,
          };
        },
      };
    },
    5991: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var matchGraph = __nccwpck_require__(6571);
      var MATCH = matchGraph.MATCH;
      var MISMATCH = matchGraph.MISMATCH;
      var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
      var TYPE = __nccwpck_require__(3276).TYPE;
      var STUB = 0;
      var TOKEN = 1;
      var OPEN_SYNTAX = 2;
      var CLOSE_SYNTAX = 3;
      var EXIT_REASON_MATCH = "Match";
      var EXIT_REASON_MISMATCH = "Mismatch";
      var EXIT_REASON_ITERATION_LIMIT =
        "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
      var ITERATION_LIMIT = 15e3;
      var totalIterationCount = 0;
      function reverseList(list) {
        var prev = null;
        var next = null;
        var item = list;
        while (item !== null) {
          next = item.prev;
          item.prev = prev;
          prev = item;
          item = next;
        }
        return prev;
      }
      function areStringsEqualCaseInsensitive(testStr, referenceStr) {
        if (testStr.length !== referenceStr.length) {
          return false;
        }
        for (var i = 0; i < testStr.length; i++) {
          var testCode = testStr.charCodeAt(i);
          var referenceCode = referenceStr.charCodeAt(i);
          if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function isContextEdgeDelim(token) {
        if (token.type !== TYPE.Delim) {
          return false;
        }
        return token.value !== "?";
      }
      function isCommaContextStart(token) {
        if (token === null) {
          return true;
        }
        return (
          token.type === TYPE.Comma ||
          token.type === TYPE.Function ||
          token.type === TYPE.LeftParenthesis ||
          token.type === TYPE.LeftSquareBracket ||
          token.type === TYPE.LeftCurlyBracket ||
          isContextEdgeDelim(token)
        );
      }
      function isCommaContextEnd(token) {
        if (token === null) {
          return true;
        }
        return (
          token.type === TYPE.RightParenthesis ||
          token.type === TYPE.RightSquareBracket ||
          token.type === TYPE.RightCurlyBracket ||
          token.type === TYPE.Delim
        );
      }
      function internalMatch(tokens, state, syntaxes) {
        function moveToNextToken() {
          do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          } while (
            token !== null &&
            (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment)
          );
        }
        function getNextToken(offset) {
          var nextIndex = tokenIndex + offset;
          return nextIndex < tokens.length ? tokens[nextIndex] : null;
        }
        function stateSnapshotFromSyntax(nextState, prev) {
          return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev,
          };
        }
        function pushThenStack(nextState) {
          thenStack = { nextState, matchStack, syntaxStack, prev: thenStack };
        }
        function pushElseStack(nextState) {
          elseStack = stateSnapshotFromSyntax(nextState, elseStack);
        }
        function addTokenToMatch() {
          matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token,
            prev: matchStack,
          };
          moveToNextToken();
          syntaxStash = null;
          if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
          }
        }
        function openSyntax() {
          syntaxStack = {
            syntax: state.syntax,
            opts:
              state.syntax.opts ||
              (syntaxStack !== null && syntaxStack.opts) ||
              null,
            prev: syntaxStack,
          };
          matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack,
          };
        }
        function closeSyntax() {
          if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
          } else {
            matchStack = {
              type: CLOSE_SYNTAX,
              syntax: syntaxStack.syntax,
              token: matchStack.token,
              prev: matchStack,
            };
          }
          syntaxStack = syntaxStack.prev;
        }
        var syntaxStack = null;
        var thenStack = null;
        var elseStack = null;
        var syntaxStash = null;
        var iterationCount = 0;
        var exitReason = null;
        var token = null;
        var tokenIndex = -1;
        var longestMatch = 0;
        var matchStack = { type: STUB, syntax: null, token: null, prev: null };
        moveToNextToken();
        while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
          switch (state.type) {
            case "Match":
              if (thenStack === null) {
                if (token !== null) {
                  if (
                    tokenIndex !== tokens.length - 1 ||
                    (token.value !== "\\0" && token.value !== "\\9")
                  ) {
                    state = MISMATCH;
                    break;
                  }
                }
                exitReason = EXIT_REASON_MATCH;
                break;
              }
              state = thenStack.nextState;
              if (state === DISALLOW_EMPTY) {
                if (thenStack.matchStack === matchStack) {
                  state = MISMATCH;
                  break;
                } else {
                  state = MATCH;
                }
              }
              while (thenStack.syntaxStack !== syntaxStack) {
                closeSyntax();
              }
              thenStack = thenStack.prev;
              break;
            case "Mismatch":
              if (syntaxStash !== null && syntaxStash !== false) {
                if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                  elseStack = syntaxStash;
                  syntaxStash = false;
                }
              } else if (elseStack === null) {
                exitReason = EXIT_REASON_MISMATCH;
                break;
              }
              state = elseStack.nextState;
              thenStack = elseStack.thenStack;
              syntaxStack = elseStack.syntaxStack;
              matchStack = elseStack.matchStack;
              tokenIndex = elseStack.tokenIndex;
              token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
              elseStack = elseStack.prev;
              break;
            case "MatchGraph":
              state = state.match;
              break;
            case "If":
              if (state.else !== MISMATCH) {
                pushElseStack(state.else);
              }
              if (state.then !== MATCH) {
                pushThenStack(state.then);
              }
              state = state.match;
              break;
            case "MatchOnce":
              state = {
                type: "MatchOnceBuffer",
                syntax: state,
                index: 0,
                mask: 0,
              };
              break;
            case "MatchOnceBuffer":
              var terms = state.syntax.terms;
              if (state.index === terms.length) {
                if (state.mask === 0 || state.syntax.all) {
                  state = MISMATCH;
                  break;
                }
                state = MATCH;
                break;
              }
              if (state.mask === (1 << terms.length) - 1) {
                state = MATCH;
                break;
              }
              for (; state.index < terms.length; state.index++) {
                var matchFlag = 1 << state.index;
                if ((state.mask & matchFlag) === 0) {
                  pushElseStack(state);
                  pushThenStack({
                    type: "AddMatchOnce",
                    syntax: state.syntax,
                    mask: state.mask | matchFlag,
                  });
                  state = terms[state.index++];
                  break;
                }
              }
              break;
            case "AddMatchOnce":
              state = {
                type: "MatchOnceBuffer",
                syntax: state.syntax,
                index: 0,
                mask: state.mask,
              };
              break;
            case "Enum":
              if (token !== null) {
                var name = token.value.toLowerCase();
                if (name.indexOf("\\") !== -1) {
                  name = name.replace(/\\[09].*$/, "");
                }
                if (hasOwnProperty.call(state.map, name)) {
                  state = state.map[name];
                  break;
                }
              }
              state = MISMATCH;
              break;
            case "Generic":
              var opts = syntaxStack !== null ? syntaxStack.opts : null;
              var lastTokenIndex =
                tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
              if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state = MATCH;
              } else {
                state = MISMATCH;
              }
              break;
            case "Type":
            case "Property":
              var syntaxDict = state.type === "Type" ? "types" : "properties";
              var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict)
                ? syntaxes[syntaxDict][state.name]
                : null;
              if (!dictSyntax || !dictSyntax.match) {
                throw new Error(
                  "Bad syntax reference: " +
                    (state.type === "Type"
                      ? "<" + state.name + ">"
                      : "<'" + state.name + "'>"),
                );
              }
              if (
                syntaxStash !== false &&
                token !== null &&
                state.type === "Type"
              ) {
                var lowPriorityMatching =
                  (state.name === "custom-ident" &&
                    token.type === TYPE.Ident) ||
                  (state.name === "length" && token.value === "0");
                if (lowPriorityMatching) {
                  if (syntaxStash === null) {
                    syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                  }
                  state = MISMATCH;
                  break;
                }
              }
              openSyntax();
              state = dictSyntax.match;
              break;
            case "Keyword":
              var name = state.name;
              if (token !== null) {
                var keywordName = token.value;
                if (keywordName.indexOf("\\") !== -1) {
                  keywordName = keywordName.replace(/\\[09].*$/, "");
                }
                if (areStringsEqualCaseInsensitive(keywordName, name)) {
                  addTokenToMatch();
                  state = MATCH;
                  break;
                }
              }
              state = MISMATCH;
              break;
            case "AtKeyword":
            case "Function":
              if (
                token !== null &&
                areStringsEqualCaseInsensitive(token.value, state.name)
              ) {
                addTokenToMatch();
                state = MATCH;
                break;
              }
              state = MISMATCH;
              break;
            case "Token":
              if (token !== null && token.value === state.value) {
                addTokenToMatch();
                state = MATCH;
                break;
              }
              state = MISMATCH;
              break;
            case "Comma":
              if (token !== null && token.type === TYPE.Comma) {
                if (isCommaContextStart(matchStack.token)) {
                  state = MISMATCH;
                } else {
                  addTokenToMatch();
                  state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                }
              } else {
                state =
                  isCommaContextStart(matchStack.token) ||
                  isCommaContextEnd(token)
                    ? MATCH
                    : MISMATCH;
              }
              break;
            case "String":
              var string = "";
              for (
                var lastTokenIndex = tokenIndex;
                lastTokenIndex < tokens.length &&
                string.length < state.value.length;
                lastTokenIndex++
              ) {
                string += tokens[lastTokenIndex].value;
              }
              if (areStringsEqualCaseInsensitive(string, state.value)) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state = MATCH;
              } else {
                state = MISMATCH;
              }
              break;
            default:
              throw new Error("Unknown node type: " + state.type);
          }
        }
        totalIterationCount += iterationCount;
        switch (exitReason) {
          case null:
            console.warn(
              "[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations",
            );
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;
          case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
              closeSyntax();
            }
            break;
          default:
            matchStack = null;
        }
        return {
          tokens,
          reason: exitReason,
          iterations: iterationCount,
          match: matchStack,
          longestMatch,
        };
      }
      function matchAsList(tokens, matchGraph, syntaxes) {
        var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
        if (matchResult.match !== null) {
          var item = reverseList(matchResult.match).prev;
          matchResult.match = [];
          while (item !== null) {
            switch (item.type) {
              case STUB:
                break;
              case OPEN_SYNTAX:
              case CLOSE_SYNTAX:
                matchResult.match.push({
                  type: item.type,
                  syntax: item.syntax,
                });
                break;
              default:
                matchResult.match.push({
                  token: item.token.value,
                  node: item.token.node,
                });
                break;
            }
            item = item.prev;
          }
        }
        return matchResult;
      }
      function matchAsTree(tokens, matchGraph, syntaxes) {
        var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
        if (matchResult.match === null) {
          return matchResult;
        }
        var item = matchResult.match;
        var host = (matchResult.match = {
          syntax: matchGraph.syntax || null,
          match: [],
        });
        var hostStack = [host];
        item = reverseList(item).prev;
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
              host.match.push((host = { syntax: item.syntax, match: [] }));
              hostStack.push(host);
              break;
            case CLOSE_SYNTAX:
              hostStack.pop();
              host = hostStack[hostStack.length - 1];
              break;
            default:
              host.match.push({
                syntax: item.syntax || null,
                token: item.token.value,
                node: item.token.node,
              });
          }
          item = item.prev;
        }
        return matchResult;
      }
      module.exports = {
        matchAsList,
        matchAsTree,
        getTotalIterationCount: function () {
          return totalIterationCount;
        },
      };
    },
    8480: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var tokenize = __nccwpck_require__(6701);
      var TokenStream = __nccwpck_require__(9313);
      var tokenStream = new TokenStream();
      var astToTokens = {
        decorator: function (handlers) {
          var curNode = null;
          var prev = { len: 0, node: null };
          var nodes = [prev];
          var buffer = "";
          return {
            children: handlers.children,
            node: function (node) {
              var tmp = curNode;
              curNode = node;
              handlers.node.call(this, node);
              curNode = tmp;
            },
            chunk: function (chunk) {
              buffer += chunk;
              if (prev.node !== curNode) {
                nodes.push({ len: chunk.length, node: curNode });
              } else {
                prev.len += chunk.length;
              }
            },
            result: function () {
              return prepareTokens(buffer, nodes);
            },
          };
        },
      };
      function prepareTokens(str, nodes) {
        var tokens = [];
        var nodesOffset = 0;
        var nodesIndex = 0;
        var currentNode = nodes ? nodes[nodesIndex].node : null;
        tokenize(str, tokenStream);
        while (!tokenStream.eof) {
          if (nodes) {
            while (
              nodesIndex < nodes.length &&
              nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart
            ) {
              nodesOffset += nodes[nodesIndex++].len;
              currentNode = nodes[nodesIndex].node;
            }
          }
          tokens.push({
            type: tokenStream.tokenType,
            value: tokenStream.getTokenValue(),
            index: tokenStream.tokenIndex,
            balance: tokenStream.balance[tokenStream.tokenIndex],
            node: currentNode,
          });
          tokenStream.next();
        }
        return tokens;
      }
      module.exports = function (value, syntax) {
        if (typeof value === "string") {
          return prepareTokens(value, null);
        }
        return syntax.generate(value, astToTokens);
      };
    },
    7220: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(9621);
      function getFirstMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getFirstMatchNode(matchNode.match[0]);
      }
      function getLastMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
      }
      function matchFragments(lexer, ast, match, type, name) {
        function findFragments(matchNode) {
          if (
            matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name
          ) {
            var start = getFirstMatchNode(matchNode);
            var end = getLastMatchNode(matchNode);
            lexer.syntax.walk(ast, function (node, item, list) {
              if (node === start) {
                var nodes = new List();
                do {
                  nodes.appendData(item.data);
                  if (item.data === end) {
                    break;
                  }
                  item = item.next;
                } while (item !== null);
                fragments.push({ parent: list, nodes });
              }
            });
          }
          if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
          }
        }
        var fragments = [];
        if (match.matched !== null) {
          findFragments(match.matched);
        }
        return fragments;
      }
      module.exports = { matchFragments };
    },
    7591: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(9621);
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function isValidNumber(value) {
        return (
          typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value &&
          value >= 0
        );
      }
      function isValidLocation(loc) {
        return (
          Boolean(loc) &&
          isValidNumber(loc.offset) &&
          isValidNumber(loc.line) &&
          isValidNumber(loc.column)
        );
      }
      function createNodeStructureChecker(type, fields) {
        return function checkNode(node, warn) {
          if (!node || node.constructor !== Object) {
            return warn(node, "Type of node should be an Object");
          }
          for (var key in node) {
            var valid = true;
            if (hasOwnProperty.call(node, key) === false) {
              continue;
            }
            if (key === "type") {
              if (node.type !== type) {
                warn(
                  node,
                  "Wrong node type `" +
                    node.type +
                    "`, expected `" +
                    type +
                    "`",
                );
              }
            } else if (key === "loc") {
              if (node.loc === null) {
                continue;
              } else if (node.loc && node.loc.constructor === Object) {
                if (typeof node.loc.source !== "string") {
                  key += ".source";
                } else if (!isValidLocation(node.loc.start)) {
                  key += ".start";
                } else if (!isValidLocation(node.loc.end)) {
                  key += ".end";
                } else {
                  continue;
                }
              }
              valid = false;
            } else if (fields.hasOwnProperty(key)) {
              for (
                var i = 0, valid = false;
                !valid && i < fields[key].length;
                i++
              ) {
                var fieldType = fields[key][i];
                switch (fieldType) {
                  case String:
                    valid = typeof node[key] === "string";
                    break;
                  case Boolean:
                    valid = typeof node[key] === "boolean";
                    break;
                  case null:
                    valid = node[key] === null;
                    break;
                  default:
                    if (typeof fieldType === "string") {
                      valid = node[key] && node[key].type === fieldType;
                    } else if (Array.isArray(fieldType)) {
                      valid = node[key] instanceof List;
                    }
                }
              }
            } else {
              warn(
                node,
                "Unknown field `" + key + "` for " + type + " node type",
              );
            }
            if (!valid) {
              warn(node, "Bad value for `" + type + "." + key + "`");
            }
          }
          for (var key in fields) {
            if (
              hasOwnProperty.call(fields, key) &&
              hasOwnProperty.call(node, key) === false
            ) {
              warn(node, "Field `" + type + "." + key + "` is missed");
            }
          }
        };
      }
      function processStructure(name, nodeType) {
        var structure = nodeType.structure;
        var fields = { type: String, loc: true };
        var docs = { type: '"' + name + '"' };
        for (var key in structure) {
          if (hasOwnProperty.call(structure, key) === false) {
            continue;
          }
          var docsTypes = [];
          var fieldTypes = (fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]]);
          for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
              docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
              docsTypes.push("null");
            } else if (typeof fieldType === "string") {
              docsTypes.push("<" + fieldType + ">");
            } else if (Array.isArray(fieldType)) {
              docsTypes.push("List");
            } else {
              throw new Error(
                "Wrong value `" +
                  fieldType +
                  "` in `" +
                  name +
                  "." +
                  key +
                  "` structure definition",
              );
            }
          }
          docs[key] = docsTypes.join(" | ");
        }
        return { docs, check: createNodeStructureChecker(name, fields) };
      }
      module.exports = {
        getStructureFromConfig: function (config) {
          var structure = {};
          if (config.node) {
            for (var name in config.node) {
              if (hasOwnProperty.call(config.node, name)) {
                var nodeType = config.node[name];
                if (nodeType.structure) {
                  structure[name] = processStructure(name, nodeType);
                } else {
                  throw new Error(
                    "Missed `structure` field in `" +
                      name +
                      "` node type definition",
                  );
                }
              }
            }
          }
          return structure;
        },
      };
    },
    3354: (module) => {
      function getTrace(node) {
        function shouldPutToTrace(syntax) {
          if (syntax === null) {
            return false;
          }
          return (
            syntax.type === "Type" ||
            syntax.type === "Property" ||
            syntax.type === "Keyword"
          );
        }
        function hasMatch(matchNode) {
          if (Array.isArray(matchNode.match)) {
            for (var i = 0; i < matchNode.match.length; i++) {
              if (hasMatch(matchNode.match[i])) {
                if (shouldPutToTrace(matchNode.syntax)) {
                  result.unshift(matchNode.syntax);
                }
                return true;
              }
            }
          } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
              ? [matchNode.syntax]
              : [];
            return true;
          }
          return false;
        }
        var result = null;
        if (this.matched !== null) {
          hasMatch(this.matched);
        }
        return result;
      }
      function testNode(match, node, fn) {
        var trace = getTrace.call(match, node);
        if (trace === null) {
          return false;
        }
        return trace.some(fn);
      }
      function isType(node, type) {
        return testNode(this, node, function (matchNode) {
          return matchNode.type === "Type" && matchNode.name === type;
        });
      }
      function isProperty(node, property) {
        return testNode(this, node, function (matchNode) {
          return matchNode.type === "Property" && matchNode.name === property;
        });
      }
      function isKeyword(node) {
        return testNode(this, node, function (matchNode) {
          return matchNode.type === "Keyword";
        });
      }
      module.exports = { getTrace, isType, isProperty, isKeyword };
    },
    469: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var OffsetToLocation = __nccwpck_require__(7500);
      var SyntaxError = __nccwpck_require__(1431);
      var TokenStream = __nccwpck_require__(9313);
      var List = __nccwpck_require__(9621);
      var tokenize = __nccwpck_require__(6701);
      var constants = __nccwpck_require__(3276);
      var { findWhiteSpaceStart, cmpStr } = __nccwpck_require__(7989);
      var sequence = __nccwpck_require__(2451);
      var noop = function () {};
      var TYPE = constants.TYPE;
      var NAME = constants.NAME;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var URL = TYPE.Url;
      var HASH = TYPE.Hash;
      var PERCENTAGE = TYPE.Percentage;
      var NUMBER = TYPE.Number;
      var NUMBERSIGN = 35;
      var NULL = 0;
      function createParseContext(name) {
        return function () {
          return this[name]();
        };
      }
      function processConfig(config) {
        var parserConfig = { context: {}, scope: {}, atrule: {}, pseudo: {} };
        if (config.parseContext) {
          for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
              case "function":
                parserConfig.context[name] = config.parseContext[name];
                break;
              case "string":
                parserConfig.context[name] = createParseContext(
                  config.parseContext[name],
                );
                break;
            }
          }
        }
        if (config.scope) {
          for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
          }
        }
        if (config.atrule) {
          for (var name in config.atrule) {
            var atrule = config.atrule[name];
            if (atrule.parse) {
              parserConfig.atrule[name] = atrule.parse;
            }
          }
        }
        if (config.pseudo) {
          for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];
            if (pseudo.parse) {
              parserConfig.pseudo[name] = pseudo.parse;
            }
          }
        }
        if (config.node) {
          for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
          }
        }
        return parserConfig;
      }
      module.exports = function createParser(config) {
        var parser = {
          scanner: new TokenStream(),
          locationMap: new OffsetToLocation(),
          filename: "<unknown>",
          needPositions: false,
          onParseError: noop,
          onParseErrorThrow: false,
          parseAtrulePrelude: true,
          parseRulePrelude: true,
          parseValue: true,
          parseCustomProperty: false,
          readSequence: sequence,
          createList: function () {
            return new List();
          },
          createSingleNodeList: function (node) {
            return new List().appendData(node);
          },
          getFirstListNode: function (list) {
            return list && list.first();
          },
          getLastListNode: function (list) {
            return list.last();
          },
          parseWithFallback: function (consumer, fallback) {
            var startToken = this.scanner.tokenIndex;
            try {
              return consumer.call(this);
            } catch (e) {
              if (this.onParseErrorThrow) {
                throw e;
              }
              var fallbackNode = fallback.call(this, startToken);
              this.onParseErrorThrow = true;
              this.onParseError(e, fallbackNode);
              this.onParseErrorThrow = false;
              return fallbackNode;
            }
          },
          lookupNonWSType: function (offset) {
            do {
              var type = this.scanner.lookupType(offset++);
              if (type !== WHITESPACE) {
                return type;
              }
            } while (type !== NULL);
            return NULL;
          },
          eat: function (tokenType) {
            if (this.scanner.tokenType !== tokenType) {
              var offset = this.scanner.tokenStart;
              var message = NAME[tokenType] + " is expected";
              switch (tokenType) {
                case IDENT:
                  if (
                    this.scanner.tokenType === FUNCTION ||
                    this.scanner.tokenType === URL
                  ) {
                    offset = this.scanner.tokenEnd - 1;
                    message = "Identifier is expected but function found";
                  } else {
                    message = "Identifier is expected";
                  }
                  break;
                case HASH:
                  if (this.scanner.isDelim(NUMBERSIGN)) {
                    this.scanner.next();
                    offset++;
                    message = "Name is expected";
                  }
                  break;
                case PERCENTAGE:
                  if (this.scanner.tokenType === NUMBER) {
                    offset = this.scanner.tokenEnd;
                    message = "Percent sign is expected";
                  }
                  break;
                default:
                  if (
                    this.scanner.source.charCodeAt(this.scanner.tokenStart) ===
                    tokenType
                  ) {
                    offset = offset + 1;
                  }
              }
              this.error(message, offset);
            }
            this.scanner.next();
          },
          consume: function (tokenType) {
            var value = this.scanner.getTokenValue();
            this.eat(tokenType);
            return value;
          },
          consumeFunctionName: function () {
            var name = this.scanner.source.substring(
              this.scanner.tokenStart,
              this.scanner.tokenEnd - 1,
            );
            this.eat(FUNCTION);
            return name;
          },
          getLocation: function (start, end) {
            if (this.needPositions) {
              return this.locationMap.getLocationRange(
                start,
                end,
                this.filename,
              );
            }
            return null;
          },
          getLocationFromList: function (list) {
            if (this.needPositions) {
              var head = this.getFirstListNode(list);
              var tail = this.getLastListNode(list);
              return this.locationMap.getLocationRange(
                head !== null
                  ? head.loc.start.offset - this.locationMap.startOffset
                  : this.scanner.tokenStart,
                tail !== null
                  ? tail.loc.end.offset - this.locationMap.startOffset
                  : this.scanner.tokenStart,
                this.filename,
              );
            }
            return null;
          },
          error: function (message, offset) {
            var location =
              typeof offset !== "undefined" &&
              offset < this.scanner.source.length
                ? this.locationMap.getLocation(offset)
                : this.scanner.eof
                  ? this.locationMap.getLocation(
                      findWhiteSpaceStart(
                        this.scanner.source,
                        this.scanner.source.length - 1,
                      ),
                    )
                  : this.locationMap.getLocation(this.scanner.tokenStart);
            throw new SyntaxError(
              message || "Unexpected input",
              this.scanner.source,
              location.offset,
              location.line,
              location.column,
            );
          },
        };
        config = processConfig(config || {});
        for (var key in config) {
          parser[key] = config[key];
        }
        return function (source, options) {
          options = options || {};
          var context = options.context || "default";
          var onComment = options.onComment;
          var ast;
          tokenize(source, parser.scanner);
          parser.locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column,
          );
          parser.filename = options.filename || "<unknown>";
          parser.needPositions = Boolean(options.positions);
          parser.onParseError =
            typeof options.onParseError === "function"
              ? options.onParseError
              : noop;
          parser.onParseErrorThrow = false;
          parser.parseAtrulePrelude =
            "parseAtrulePrelude" in options
              ? Boolean(options.parseAtrulePrelude)
              : true;
          parser.parseRulePrelude =
            "parseRulePrelude" in options
              ? Boolean(options.parseRulePrelude)
              : true;
          parser.parseValue =
            "parseValue" in options ? Boolean(options.parseValue) : true;
          parser.parseCustomProperty =
            "parseCustomProperty" in options
              ? Boolean(options.parseCustomProperty)
              : false;
          if (!parser.context.hasOwnProperty(context)) {
            throw new Error("Unknown context `" + context + "`");
          }
          if (typeof onComment === "function") {
            parser.scanner.forEachToken((type, start, end) => {
              if (type === COMMENT) {
                const loc = parser.getLocation(start, end);
                const value = cmpStr(source, end - 2, end, "*/")
                  ? source.slice(start + 2, end - 2)
                  : source.slice(start + 2, end);
                onComment(value, loc);
              }
            });
          }
          ast = parser.context[context].call(parser, options);
          if (!parser.scanner.eof) {
            parser.error();
          }
          return ast;
        };
      };
    },
    2451: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      module.exports = function readSequence(recognizer) {
        var children = this.createList();
        var child = null;
        var context = {
          recognizer,
          space: null,
          ignoreWS: false,
          ignoreWSAfter: false,
        };
        this.scanner.skipSC();
        while (!this.scanner.eof) {
          switch (this.scanner.tokenType) {
            case COMMENT:
              this.scanner.next();
              continue;
            case WHITESPACE:
              if (context.ignoreWS) {
                this.scanner.next();
              } else {
                context.space = this.WhiteSpace();
              }
              continue;
          }
          child = recognizer.getNode.call(this, context);
          if (child === undefined) {
            break;
          }
          if (context.space !== null) {
            children.push(context.space);
            context.space = null;
          }
          children.push(child);
          if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
          } else {
            context.ignoreWS = false;
          }
        }
        return children;
      };
    },
    8026: (module) => {
      module.exports = {
        parse: {
          prelude: null,
          block: function () {
            return this.Block(true);
          },
        },
      };
    },
    9734: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var STRING = TYPE.String;
      var IDENT = TYPE.Ident;
      var URL = TYPE.Url;
      var FUNCTION = TYPE.Function;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      module.exports = {
        parse: {
          prelude: function () {
            var children = this.createList();
            this.scanner.skipSC();
            switch (this.scanner.tokenType) {
              case STRING:
                children.push(this.String());
                break;
              case URL:
              case FUNCTION:
                children.push(this.Url());
                break;
              default:
                this.error("String or url() is expected");
            }
            if (
              this.lookupNonWSType(0) === IDENT ||
              this.lookupNonWSType(0) === LEFTPARENTHESIS
            ) {
              children.push(this.WhiteSpace());
              children.push(this.MediaQueryList());
            }
            return children;
          },
          block: null,
        },
      };
    },
    1530: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        "font-face": __nccwpck_require__(8026),
        import: __nccwpck_require__(9734),
        media: __nccwpck_require__(2052),
        page: __nccwpck_require__(3662),
        supports: __nccwpck_require__(9656),
      };
    },
    2052: (module) => {
      module.exports = {
        parse: {
          prelude: function () {
            return this.createSingleNodeList(this.MediaQueryList());
          },
          block: function () {
            return this.Block(false);
          },
        },
      };
    },
    3662: (module) => {
      module.exports = {
        parse: {
          prelude: function () {
            return this.createSingleNodeList(this.SelectorList());
          },
          block: function () {
            return this.Block(true);
          },
        },
      };
    },
    9656: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var COLON = TYPE.Colon;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      function consumeRaw() {
        return this.createSingleNodeList(
          this.Raw(this.scanner.tokenIndex, null, false),
        );
      }
      function parentheses() {
        this.scanner.skipSC();
        if (
          this.scanner.tokenType === IDENT &&
          this.lookupNonWSType(1) === COLON
        ) {
          return this.createSingleNodeList(this.Declaration());
        }
        return readSequence.call(this);
      }
      function readSequence() {
        var children = this.createList();
        var space = null;
        var child;
        this.scanner.skipSC();
        scan: while (!this.scanner.eof) {
          switch (this.scanner.tokenType) {
            case WHITESPACE:
              space = this.WhiteSpace();
              continue;
            case COMMENT:
              this.scanner.next();
              continue;
            case FUNCTION:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case IDENT:
              child = this.Identifier();
              break;
            case LEFTPARENTHESIS:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          if (space !== null) {
            children.push(space);
            space = null;
          }
          children.push(child);
        }
        return children;
      }
      module.exports = {
        parse: {
          prelude: function () {
            var children = readSequence.call(this);
            if (this.getFirstListNode(children) === null) {
              this.error("Condition is expected");
            }
            return children;
          },
          block: function () {
            return this.Block(false);
          },
        },
      };
    },
    6858: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var data = __nccwpck_require__(2779);
      module.exports = {
        generic: true,
        types: data.types,
        atrules: data.atrules,
        properties: data.properties,
        node: __nccwpck_require__(5841),
      };
    },
    5846: (module) => {
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const shape = {
        generic: true,
        types: appendOrAssign,
        atrules: {
          prelude: appendOrAssignOrNull,
          descriptors: appendOrAssignOrNull,
        },
        properties: appendOrAssign,
        parseContext: assign,
        scope: deepAssign,
        atrule: ["parse"],
        pseudo: ["parse"],
        node: ["name", "structure", "parse", "generate", "walkContext"],
      };
      function isObject(value) {
        return value && value.constructor === Object;
      }
      function copy(value) {
        return isObject(value) ? Object.assign({}, value) : value;
      }
      function assign(dest, src) {
        return Object.assign(dest, src);
      }
      function deepAssign(dest, src) {
        for (const key in src) {
          if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
              deepAssign(dest[key], copy(src[key]));
            } else {
              dest[key] = copy(src[key]);
            }
          }
        }
        return dest;
      }
      function append(a, b) {
        if (typeof b === "string" && /^\s*\|/.test(b)) {
          return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
        }
        return b || null;
      }
      function appendOrAssign(a, b) {
        if (typeof b === "string") {
          return append(a, b);
        }
        const result = Object.assign({}, a);
        for (let key in b) {
          if (hasOwnProperty.call(b, key)) {
            result[key] = append(
              hasOwnProperty.call(a, key) ? a[key] : undefined,
              b[key],
            );
          }
        }
        return result;
      }
      function appendOrAssignOrNull(a, b) {
        const result = appendOrAssign(a, b);
        return !isObject(result) || Object.keys(result).length ? result : null;
      }
      function mix(dest, src, shape) {
        for (const key in shape) {
          if (hasOwnProperty.call(shape, key) === false) {
            continue;
          }
          if (shape[key] === true) {
            if (key in src) {
              if (hasOwnProperty.call(src, key)) {
                dest[key] = copy(src[key]);
              }
            }
          } else if (shape[key]) {
            if (typeof shape[key] === "function") {
              const fn = shape[key];
              dest[key] = fn({}, dest[key]);
              dest[key] = fn(dest[key] || {}, src[key]);
            } else if (isObject(shape[key])) {
              const result = {};
              for (let name in dest[key]) {
                result[name] = mix({}, dest[key][name], shape[key]);
              }
              for (let name in src[key]) {
                result[name] = mix(
                  result[name] || {},
                  src[key][name],
                  shape[key],
                );
              }
              dest[key] = result;
            } else if (Array.isArray(shape[key])) {
              const res = {};
              const innerShape = shape[key].reduce(function (s, k) {
                s[k] = true;
                return s;
              }, {});
              for (const [name, value] of Object.entries(dest[key] || {})) {
                res[name] = {};
                if (value) {
                  mix(res[name], value, innerShape);
                }
              }
              for (const name in src[key]) {
                if (hasOwnProperty.call(src[key], name)) {
                  if (!res[name]) {
                    res[name] = {};
                  }
                  if (src[key] && src[key][name]) {
                    mix(res[name], src[key][name], innerShape);
                  }
                }
              }
              dest[key] = res;
            }
          }
        }
        return dest;
      }
      module.exports = (dest, src) => mix(dest, src, shape);
    },
    8820: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        parseContext: {
          default: "StyleSheet",
          stylesheet: "StyleSheet",
          atrule: "Atrule",
          atrulePrelude: function (options) {
            return this.AtrulePrelude(
              options.atrule ? String(options.atrule) : null,
            );
          },
          mediaQueryList: "MediaQueryList",
          mediaQuery: "MediaQuery",
          rule: "Rule",
          selectorList: "SelectorList",
          selector: "Selector",
          block: function () {
            return this.Block(true);
          },
          declarationList: "DeclarationList",
          declaration: "Declaration",
          value: "Value",
        },
        scope: __nccwpck_require__(1621),
        atrule: __nccwpck_require__(1530),
        pseudo: __nccwpck_require__(9749),
        node: __nccwpck_require__(5841),
      };
    },
    8807: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = { node: __nccwpck_require__(5841) };
    },
    5448: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(9621);
      var SyntaxError = __nccwpck_require__(1431);
      var TokenStream = __nccwpck_require__(9313);
      var Lexer = __nccwpck_require__(1567);
      var definitionSyntax = __nccwpck_require__(4102);
      var tokenize = __nccwpck_require__(6701);
      var createParser = __nccwpck_require__(469);
      var createGenerator = __nccwpck_require__(4506);
      var createConvertor = __nccwpck_require__(5640);
      var createWalker = __nccwpck_require__(1261);
      var clone = __nccwpck_require__(8062);
      var names = __nccwpck_require__(4337);
      var mix = __nccwpck_require__(5846);
      function createSyntax(config) {
        var parse = createParser(config);
        var walk = createWalker(config);
        var generate = createGenerator(config);
        var convert = createConvertor(walk);
        var syntax = {
          List,
          SyntaxError,
          TokenStream,
          Lexer,
          vendorPrefix: names.vendorPrefix,
          keyword: names.keyword,
          property: names.property,
          isCustomProperty: names.isCustomProperty,
          definitionSyntax,
          lexer: null,
          createLexer: function (config) {
            return new Lexer(config, syntax, syntax.lexer.structure);
          },
          tokenize,
          parse,
          walk,
          generate,
          find: walk.find,
          findLast: walk.findLast,
          findAll: walk.findAll,
          clone,
          fromPlainObject: convert.fromPlainObject,
          toPlainObject: convert.toPlainObject,
          createSyntax: function (config) {
            return createSyntax(mix({}, config));
          },
          fork: function (extension) {
            var base = mix({}, config);
            return createSyntax(
              typeof extension === "function"
                ? extension(base, Object.assign)
                : mix(base, extension),
            );
          },
        };
        syntax.lexer = new Lexer(
          {
            generic: true,
            types: config.types,
            atrules: config.atrules,
            properties: config.properties,
            node: config.node,
          },
          syntax,
        );
        return syntax;
      }
      exports.create = function (config) {
        return createSyntax(mix({}, config));
      };
    },
    1317: (module) => {
      module.exports = function () {
        return this.createSingleNodeList(
          this.Raw(this.scanner.tokenIndex, null, false),
        );
      };
    },
    6139: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var rawMode = __nccwpck_require__(9787).mode;
      var COMMA = TYPE.Comma;
      var WHITESPACE = TYPE.WhiteSpace;
      module.exports = function () {
        var children = this.createList();
        this.scanner.skipSC();
        children.push(this.Identifier());
        this.scanner.skipSC();
        if (this.scanner.tokenType === COMMA) {
          children.push(this.Operator());
          const startIndex = this.scanner.tokenIndex;
          const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(
                this.scanner.tokenIndex,
                rawMode.exclamationMarkOrSemicolon,
                false,
              );
          if (value.type === "Value" && value.children.isEmpty()) {
            for (
              let offset = startIndex - this.scanner.tokenIndex;
              offset <= 0;
              offset++
            ) {
              if (this.scanner.lookupType(offset) === WHITESPACE) {
                value.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " ",
                });
                break;
              }
            }
          }
          children.push(value);
        }
        return children;
      };
    },
    4869: (module, __unused_webpack_exports, __nccwpck_require__) => {
      function merge() {
        var dest = {};
        for (var i = 0; i < arguments.length; i++) {
          var src = arguments[i];
          for (var key in src) {
            dest[key] = src[key];
          }
        }
        return dest;
      }
      module.exports = __nccwpck_require__(5448).create(
        merge(
          __nccwpck_require__(6858),
          __nccwpck_require__(8820),
          __nccwpck_require__(8807),
        ),
      );
      module.exports.version = __nccwpck_require__(3684).version;
    },
    9790: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var cmpChar = __nccwpck_require__(6701).cmpChar;
      var isDigit = __nccwpck_require__(6701).isDigit;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var N = 110;
      var DISALLOW_SIGN = true;
      var ALLOW_SIGN = false;
      function checkInteger(offset, disallowSign) {
        var pos = this.scanner.tokenStart + offset;
        var code = this.scanner.source.charCodeAt(pos);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            this.error("Number sign is not allowed");
          }
          pos++;
        }
        for (; pos < this.scanner.tokenEnd; pos++) {
          if (!isDigit(this.scanner.source.charCodeAt(pos))) {
            this.error("Integer is expected", pos);
          }
        }
      }
      function checkTokenIsInteger(disallowSign) {
        return checkInteger.call(this, 0, disallowSign);
      }
      function expectCharCode(offset, code) {
        if (
          !cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)
        ) {
          var msg = "";
          switch (code) {
            case N:
              msg = "N is expected";
              break;
            case HYPHENMINUS:
              msg = "HyphenMinus is expected";
              break;
          }
          this.error(msg, this.scanner.tokenStart + offset);
        }
      }
      function consumeB() {
        var offset = 0;
        var sign = 0;
        var type = this.scanner.tokenType;
        while (type === WHITESPACE || type === COMMENT) {
          type = this.scanner.lookupType(++offset);
        }
        if (type !== NUMBER) {
          if (
            this.scanner.isDelim(PLUSSIGN, offset) ||
            this.scanner.isDelim(HYPHENMINUS, offset)
          ) {
            sign = this.scanner.isDelim(PLUSSIGN, offset)
              ? PLUSSIGN
              : HYPHENMINUS;
            do {
              type = this.scanner.lookupType(++offset);
            } while (type === WHITESPACE || type === COMMENT);
            if (type !== NUMBER) {
              this.scanner.skip(offset);
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
          } else {
            return null;
          }
        }
        if (offset > 0) {
          this.scanner.skip(offset);
        }
        if (sign === 0) {
          type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          if (type !== PLUSSIGN && type !== HYPHENMINUS) {
            this.error("Number sign is expected");
          }
        }
        checkTokenIsInteger.call(this, sign !== 0);
        return sign === HYPHENMINUS
          ? "-" + this.consume(NUMBER)
          : this.consume(NUMBER);
      }
      module.exports = {
        name: "AnPlusB",
        structure: { a: [String, null], b: [String, null] },
        parse: function () {
          var start = this.scanner.tokenStart;
          var a = null;
          var b = null;
          if (this.scanner.tokenType === NUMBER) {
            checkTokenIsInteger.call(this, ALLOW_SIGN);
            b = this.consume(NUMBER);
          } else if (
            this.scanner.tokenType === IDENT &&
            cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)
          ) {
            a = "-1";
            expectCharCode.call(this, 1, N);
            switch (this.scanner.getTokenLength()) {
              case 2:
                this.scanner.next();
                b = consumeB.call(this);
                break;
              case 3:
                expectCharCode.call(this, 2, HYPHENMINUS);
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = "-" + this.consume(NUMBER);
                break;
              default:
                expectCharCode.call(this, 2, HYPHENMINUS);
                checkInteger.call(this, 3, DISALLOW_SIGN);
                this.scanner.next();
                b = this.scanner.substrToCursor(start + 2);
            }
          } else if (
            this.scanner.tokenType === IDENT ||
            (this.scanner.isDelim(PLUSSIGN) &&
              this.scanner.lookupType(1) === IDENT)
          ) {
            var sign = 0;
            a = "1";
            if (this.scanner.isDelim(PLUSSIGN)) {
              sign = 1;
              this.scanner.next();
            }
            expectCharCode.call(this, 0, N);
            switch (this.scanner.getTokenLength()) {
              case 1:
                this.scanner.next();
                b = consumeB.call(this);
                break;
              case 2:
                expectCharCode.call(this, 1, HYPHENMINUS);
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = "-" + this.consume(NUMBER);
                break;
              default:
                expectCharCode.call(this, 1, HYPHENMINUS);
                checkInteger.call(this, 2, DISALLOW_SIGN);
                this.scanner.next();
                b = this.scanner.substrToCursor(start + sign + 1);
            }
          } else if (this.scanner.tokenType === DIMENSION) {
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            var sign = code === PLUSSIGN || code === HYPHENMINUS;
            for (
              var i = this.scanner.tokenStart + sign;
              i < this.scanner.tokenEnd;
              i++
            ) {
              if (!isDigit(this.scanner.source.charCodeAt(i))) {
                break;
              }
            }
            if (i === this.scanner.tokenStart + sign) {
              this.error("Integer is expected", this.scanner.tokenStart + sign);
            }
            expectCharCode.call(this, i - this.scanner.tokenStart, N);
            a = this.scanner.source.substring(start, i);
            if (i + 1 === this.scanner.tokenEnd) {
              this.scanner.next();
              b = consumeB.call(this);
            } else {
              expectCharCode.call(
                this,
                i - this.scanner.tokenStart + 1,
                HYPHENMINUS,
              );
              if (i + 2 === this.scanner.tokenEnd) {
                this.scanner.next();
                this.scanner.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = "-" + this.consume(NUMBER);
              } else {
                checkInteger.call(
                  this,
                  i - this.scanner.tokenStart + 2,
                  DISALLOW_SIGN,
                );
                this.scanner.next();
                b = this.scanner.substrToCursor(i + 1);
              }
            }
          } else {
            this.error();
          }
          if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
            a = a.substr(1);
          }
          if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
            b = b.substr(1);
          }
          return {
            type: "AnPlusB",
            loc: this.getLocation(start, this.scanner.tokenStart),
            a,
            b,
          };
        },
        generate: function (node) {
          var a = node.a !== null && node.a !== undefined;
          var b = node.b !== null && node.b !== undefined;
          if (a) {
            this.chunk(
              node.a === "+1"
                ? "+n"
                : node.a === "1"
                  ? "n"
                  : node.a === "-1"
                    ? "-n"
                    : node.a + "n",
            );
            if (b) {
              b = String(node.b);
              if (b.charAt(0) === "-" || b.charAt(0) === "+") {
                this.chunk(b.charAt(0));
                this.chunk(b.substr(1));
              } else {
                this.chunk("+");
                this.chunk(b);
              }
            }
          } else {
            this.chunk(String(node.b));
          }
        },
      };
    },
    373: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var rawMode = __nccwpck_require__(9787).mode;
      var ATKEYWORD = TYPE.AtKeyword;
      var SEMICOLON = TYPE.Semicolon;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
      function consumeRaw(startToken) {
        return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
      }
      function isDeclarationBlockAtrule() {
        for (
          var offset = 1, type;
          (type = this.scanner.lookupType(offset));
          offset++
        ) {
          if (type === RIGHTCURLYBRACKET) {
            return true;
          }
          if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
            return false;
          }
        }
        return false;
      }
      module.exports = {
        name: "Atrule",
        structure: {
          name: String,
          prelude: ["AtrulePrelude", "Raw", null],
          block: ["Block", null],
        },
        parse: function () {
          var start = this.scanner.tokenStart;
          var name;
          var nameLowerCase;
          var prelude = null;
          var block = null;
          this.eat(ATKEYWORD);
          name = this.scanner.substrToCursor(start + 1);
          nameLowerCase = name.toLowerCase();
          this.scanner.skipSC();
          if (
            this.scanner.eof === false &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON
          ) {
            if (this.parseAtrulePrelude) {
              prelude = this.parseWithFallback(
                this.AtrulePrelude.bind(this, name),
                consumeRaw,
              );
              if (
                prelude.type === "AtrulePrelude" &&
                prelude.children.head === null
              ) {
                prelude = null;
              }
            } else {
              prelude = consumeRaw.call(this, this.scanner.tokenIndex);
            }
            this.scanner.skipSC();
          }
          switch (this.scanner.tokenType) {
            case SEMICOLON:
              this.scanner.next();
              break;
            case LEFTCURLYBRACKET:
              if (
                this.atrule.hasOwnProperty(nameLowerCase) &&
                typeof this.atrule[nameLowerCase].block === "function"
              ) {
                block = this.atrule[nameLowerCase].block.call(this);
              } else {
                block = this.Block(isDeclarationBlockAtrule.call(this));
              }
              break;
          }
          return {
            type: "Atrule",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            prelude,
            block,
          };
        },
        generate: function (node) {
          this.chunk("@");
          this.chunk(node.name);
          if (node.prelude !== null) {
            this.chunk(" ");
            this.node(node.prelude);
          }
          if (node.block) {
            this.node(node.block);
          } else {
            this.chunk(";");
          }
        },
        walkContext: "atrule",
      };
    },
    4659: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var SEMICOLON = TYPE.Semicolon;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      module.exports = {
        name: "AtrulePrelude",
        structure: { children: [[]] },
        parse: function (name) {
          var children = null;
          if (name !== null) {
            name = name.toLowerCase();
          }
          this.scanner.skipSC();
          if (
            this.atrule.hasOwnProperty(name) &&
            typeof this.atrule[name].prelude === "function"
          ) {
            children = this.atrule[name].prelude.call(this);
          } else {
            children = this.readSequence(this.scope.AtrulePrelude);
          }
          this.scanner.skipSC();
          if (
            this.scanner.eof !== true &&
            this.scanner.tokenType !== LEFTCURLYBRACKET &&
            this.scanner.tokenType !== SEMICOLON
          ) {
            this.error("Semicolon or block is expected");
          }
          if (children === null) {
            children = this.createList();
          }
          return {
            type: "AtrulePrelude",
            loc: this.getLocationFromList(children),
            children,
          };
        },
        generate: function (node) {
          this.children(node);
        },
        walkContext: "atrulePrelude",
      };
    },
    9830: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var STRING = TYPE.String;
      var COLON = TYPE.Colon;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
      var DOLLARSIGN = 36;
      var ASTERISK = 42;
      var EQUALSSIGN = 61;
      var CIRCUMFLEXACCENT = 94;
      var VERTICALLINE = 124;
      var TILDE = 126;
      function getAttributeName() {
        if (this.scanner.eof) {
          this.error("Unexpected end of input");
        }
        var start = this.scanner.tokenStart;
        var expectIdent = false;
        var checkColon = true;
        if (this.scanner.isDelim(ASTERISK)) {
          expectIdent = true;
          checkColon = false;
          this.scanner.next();
        } else if (!this.scanner.isDelim(VERTICALLINE)) {
          this.eat(IDENT);
        }
        if (this.scanner.isDelim(VERTICALLINE)) {
          if (
            this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !==
            EQUALSSIGN
          ) {
            this.scanner.next();
            this.eat(IDENT);
          } else if (expectIdent) {
            this.error("Identifier is expected", this.scanner.tokenEnd);
          }
        } else if (expectIdent) {
          this.error("Vertical line is expected");
        }
        if (checkColon && this.scanner.tokenType === COLON) {
          this.scanner.next();
          this.eat(IDENT);
        }
        return {
          type: "Identifier",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start),
        };
      }
      function getOperator() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(start);
        if (
          code !== EQUALSSIGN &&
          code !== TILDE &&
          code !== CIRCUMFLEXACCENT &&
          code !== DOLLARSIGN &&
          code !== ASTERISK &&
          code !== VERTICALLINE
        ) {
          this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
        }
        this.scanner.next();
        if (code !== EQUALSSIGN) {
          if (!this.scanner.isDelim(EQUALSSIGN)) {
            this.error("Equal sign is expected");
          }
          this.scanner.next();
        }
        return this.scanner.substrToCursor(start);
      }
      module.exports = {
        name: "AttributeSelector",
        structure: {
          name: "Identifier",
          matcher: [String, null],
          value: ["String", "Identifier", null],
          flags: [String, null],
        },
        parse: function () {
          var start = this.scanner.tokenStart;
          var name;
          var matcher = null;
          var value = null;
          var flags = null;
          this.eat(LEFTSQUAREBRACKET);
          this.scanner.skipSC();
          name = getAttributeName.call(this);
          this.scanner.skipSC();
          if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
            if (this.scanner.tokenType !== IDENT) {
              matcher = getOperator.call(this);
              this.scanner.skipSC();
              value =
                this.scanner.tokenType === STRING
                  ? this.String()
                  : this.Identifier();
              this.scanner.skipSC();
            }
            if (this.scanner.tokenType === IDENT) {
              flags = this.scanner.getTokenValue();
              this.scanner.next();
              this.scanner.skipSC();
            }
          }
          this.eat(RIGHTSQUAREBRACKET);
          return {
            type: "AttributeSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            matcher,
            value,
            flags,
          };
        },
        generate: function (node) {
          var flagsPrefix = " ";
          this.chunk("[");
          this.node(node.name);
          if (node.matcher !== null) {
            this.chunk(node.matcher);
            if (node.value !== null) {
              this.node(node.value);
              if (node.value.type === "String") {
                flagsPrefix = "";
              }
            }
          }
          if (node.flags !== null) {
            this.chunk(flagsPrefix);
            this.chunk(node.flags);
          }
          this.chunk("]");
        },
      };
    },
    989: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var rawMode = __nccwpck_require__(9787).mode;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var SEMICOLON = TYPE.Semicolon;
      var ATKEYWORD = TYPE.AtKeyword;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, true);
      }
      function consumeRule() {
        return this.parseWithFallback(this.Rule, consumeRaw);
      }
      function consumeRawDeclaration(startToken) {
        return this.Raw(startToken, rawMode.semicolonIncluded, true);
      }
      function consumeDeclaration() {
        if (this.scanner.tokenType === SEMICOLON) {
          return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
        }
        var node = this.parseWithFallback(
          this.Declaration,
          consumeRawDeclaration,
        );
        if (this.scanner.tokenType === SEMICOLON) {
          this.scanner.next();
        }
        return node;
      }
      module.exports = {
        name: "Block",
        structure: { children: [["Atrule", "Rule", "Declaration"]] },
        parse: function (isDeclaration) {
          var consumer = isDeclaration ? consumeDeclaration : consumeRule;
          var start = this.scanner.tokenStart;
          var children = this.createList();
          this.eat(LEFTCURLYBRACKET);
          scan: while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case RIGHTCURLYBRACKET:
                break scan;
              case WHITESPACE:
              case COMMENT:
                this.scanner.next();
                break;
              case ATKEYWORD:
                children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                break;
              default:
                children.push(consumer.call(this));
            }
          }
          if (!this.scanner.eof) {
            this.eat(RIGHTCURLYBRACKET);
          }
          return {
            type: "Block",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children,
          };
        },
        generate: function (node) {
          this.chunk("{");
          this.children(node, function (prev) {
            if (prev.type === "Declaration") {
              this.chunk(";");
            }
          });
          this.chunk("}");
        },
        walkContext: "block",
      };
    },
    5850: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
      module.exports = {
        name: "Brackets",
        structure: { children: [[]] },
        parse: function (readSequence, recognizer) {
          var start = this.scanner.tokenStart;
          var children = null;
          this.eat(LEFTSQUAREBRACKET);
          children = readSequence.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTSQUAREBRACKET);
          }
          return {
            type: "Brackets",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children,
          };
        },
        generate: function (node) {
          this.chunk("[");
          this.children(node);
          this.chunk("]");
        },
      };
    },
    6311: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var CDC = __nccwpck_require__(6701).TYPE.CDC;
      module.exports = {
        name: "CDC",
        structure: [],
        parse: function () {
          var start = this.scanner.tokenStart;
          this.eat(CDC);
          return {
            type: "CDC",
            loc: this.getLocation(start, this.scanner.tokenStart),
          };
        },
        generate: function () {
          this.chunk("--\x3e");
        },
      };
    },
    5167: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var CDO = __nccwpck_require__(6701).TYPE.CDO;
      module.exports = {
        name: "CDO",
        structure: [],
        parse: function () {
          var start = this.scanner.tokenStart;
          this.eat(CDO);
          return {
            type: "CDO",
            loc: this.getLocation(start, this.scanner.tokenStart),
          };
        },
        generate: function () {
          this.chunk("\x3c!--");
        },
      };
    },
    6914: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var FULLSTOP = 46;
      module.exports = {
        name: "ClassSelector",
        structure: { name: String },
        parse: function () {
          if (!this.scanner.isDelim(FULLSTOP)) {
            this.error("Full stop is expected");
          }
          this.scanner.next();
          return {
            type: "ClassSelector",
            loc: this.getLocation(
              this.scanner.tokenStart - 1,
              this.scanner.tokenEnd,
            ),
            name: this.consume(IDENT),
          };
        },
        generate: function (node) {
          this.chunk(".");
          this.chunk(node.name);
        },
      };
    },
    3665: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var PLUSSIGN = 43;
      var SOLIDUS = 47;
      var GREATERTHANSIGN = 62;
      var TILDE = 126;
      module.exports = {
        name: "Combinator",
        structure: { name: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          switch (code) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
              this.scanner.next();
              break;
            case SOLIDUS:
              this.scanner.next();
              if (
                this.scanner.tokenType !== IDENT ||
                this.scanner.lookupValue(0, "deep") === false
              ) {
                this.error("Identifier `deep` is expected");
              }
              this.scanner.next();
              if (!this.scanner.isDelim(SOLIDUS)) {
                this.error("Solidus is expected");
              }
              this.scanner.next();
              break;
            default:
              this.error("Combinator is expected");
          }
          return {
            type: "Combinator",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start),
          };
        },
        generate: function (node) {
          this.chunk(node.name);
        },
      };
    },
    7346: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var COMMENT = TYPE.Comment;
      var ASTERISK = 42;
      var SOLIDUS = 47;
      module.exports = {
        name: "Comment",
        structure: { value: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          var end = this.scanner.tokenEnd;
          this.eat(COMMENT);
          if (
            end - start + 2 >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS
          ) {
            end -= 2;
          }
          return {
            type: "Comment",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end),
          };
        },
        generate: function (node) {
          this.chunk("/*");
          this.chunk(node.value);
          this.chunk("*/");
        },
      };
    },
    4099: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isCustomProperty = __nccwpck_require__(4337).isCustomProperty;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var rawMode = __nccwpck_require__(9787).mode;
      var IDENT = TYPE.Ident;
      var HASH = TYPE.Hash;
      var COLON = TYPE.Colon;
      var SEMICOLON = TYPE.Semicolon;
      var DELIM = TYPE.Delim;
      var WHITESPACE = TYPE.WhiteSpace;
      var EXCLAMATIONMARK = 33;
      var NUMBERSIGN = 35;
      var DOLLARSIGN = 36;
      var AMPERSAND = 38;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var SOLIDUS = 47;
      function consumeValueRaw(startToken) {
        return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
      }
      function consumeCustomPropertyRaw(startToken) {
        return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
      }
      function consumeValue() {
        var startValueToken = this.scanner.tokenIndex;
        var value = this.Value();
        if (
          value.type !== "Raw" &&
          this.scanner.eof === false &&
          this.scanner.tokenType !== SEMICOLON &&
          this.scanner.isDelim(EXCLAMATIONMARK) === false &&
          this.scanner.isBalanceEdge(startValueToken) === false
        ) {
          this.error();
        }
        return value;
      }
      module.exports = {
        name: "Declaration",
        structure: {
          important: [Boolean, String],
          property: String,
          value: ["Value", "Raw"],
        },
        parse: function () {
          var start = this.scanner.tokenStart;
          var startToken = this.scanner.tokenIndex;
          var property = readProperty.call(this);
          var customProperty = isCustomProperty(property);
          var parseValue = customProperty
            ? this.parseCustomProperty
            : this.parseValue;
          var consumeRaw = customProperty
            ? consumeCustomPropertyRaw
            : consumeValueRaw;
          var important = false;
          var value;
          this.scanner.skipSC();
          this.eat(COLON);
          const valueStart = this.scanner.tokenIndex;
          if (!customProperty) {
            this.scanner.skipSC();
          }
          if (parseValue) {
            value = this.parseWithFallback(consumeValue, consumeRaw);
          } else {
            value = consumeRaw.call(this, this.scanner.tokenIndex);
          }
          if (
            customProperty &&
            value.type === "Value" &&
            value.children.isEmpty()
          ) {
            for (
              let offset = valueStart - this.scanner.tokenIndex;
              offset <= 0;
              offset++
            ) {
              if (this.scanner.lookupType(offset) === WHITESPACE) {
                value.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " ",
                });
                break;
              }
            }
          }
          if (this.scanner.isDelim(EXCLAMATIONMARK)) {
            important = getImportant.call(this);
            this.scanner.skipSC();
          }
          if (
            this.scanner.eof === false &&
            this.scanner.tokenType !== SEMICOLON &&
            this.scanner.isBalanceEdge(startToken) === false
          ) {
            this.error();
          }
          return {
            type: "Declaration",
            loc: this.getLocation(start, this.scanner.tokenStart),
            important,
            property,
            value,
          };
        },
        generate: function (node) {
          this.chunk(node.property);
          this.chunk(":");
          this.node(node.value);
          if (node.important) {
            this.chunk(
              node.important === true ? "!important" : "!" + node.important,
            );
          }
        },
        walkContext: "declaration",
      };
      function readProperty() {
        var start = this.scanner.tokenStart;
        var prefix = 0;
        if (this.scanner.tokenType === DELIM) {
          switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
            case ASTERISK:
            case DOLLARSIGN:
            case PLUSSIGN:
            case NUMBERSIGN:
            case AMPERSAND:
              this.scanner.next();
              break;
            case SOLIDUS:
              this.scanner.next();
              if (this.scanner.isDelim(SOLIDUS)) {
                this.scanner.next();
              }
              break;
          }
        }
        if (prefix) {
          this.scanner.skip(prefix);
        }
        if (this.scanner.tokenType === HASH) {
          this.eat(HASH);
        } else {
          this.eat(IDENT);
        }
        return this.scanner.substrToCursor(start);
      }
      function getImportant() {
        this.eat(DELIM);
        this.scanner.skipSC();
        var important = this.consume(IDENT);
        return important === "important" ? true : important;
      }
    },
    1745: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var rawMode = __nccwpck_require__(9787).mode;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var SEMICOLON = TYPE.Semicolon;
      function consumeRaw(startToken) {
        return this.Raw(startToken, rawMode.semicolonIncluded, true);
      }
      module.exports = {
        name: "DeclarationList",
        structure: { children: [["Declaration"]] },
        parse: function () {
          var children = this.createList();
          scan: while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
              case COMMENT:
              case SEMICOLON:
                this.scanner.next();
                break;
              default:
                children.push(
                  this.parseWithFallback(this.Declaration, consumeRaw),
                );
            }
          }
          return {
            type: "DeclarationList",
            loc: this.getLocationFromList(children),
            children,
          };
        },
        generate: function (node) {
          this.children(node, function (prev) {
            if (prev.type === "Declaration") {
              this.chunk(";");
            }
          });
        },
      };
    },
    7061: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var consumeNumber = __nccwpck_require__(7989).consumeNumber;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var DIMENSION = TYPE.Dimension;
      module.exports = {
        name: "Dimension",
        structure: { value: String, unit: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          var numberEnd = consumeNumber(this.scanner.source, start);
          this.eat(DIMENSION);
          return {
            type: "Dimension",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
            unit: this.scanner.source.substring(
              numberEnd,
              this.scanner.tokenStart,
            ),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
          this.chunk(node.unit);
        },
      };
    },
    1098: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "Function",
        structure: { name: String, children: [[]] },
        parse: function (readSequence, recognizer) {
          var start = this.scanner.tokenStart;
          var name = this.consumeFunctionName();
          var nameLowerCase = name.toLowerCase();
          var children;
          children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
          }
          return {
            type: "Function",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children,
          };
        },
        generate: function (node) {
          this.chunk(node.name);
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        },
        walkContext: "function",
      };
    },
    7830: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var HASH = TYPE.Hash;
      module.exports = {
        name: "Hash",
        structure: { value: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          this.eat(HASH);
          return {
            type: "Hash",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1),
          };
        },
        generate: function (node) {
          this.chunk("#");
          this.chunk(node.value);
        },
      };
    },
    3376: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var HASH = TYPE.Hash;
      module.exports = {
        name: "IdSelector",
        structure: { name: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          this.eat(HASH);
          return {
            type: "IdSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start + 1),
          };
        },
        generate: function (node) {
          this.chunk("#");
          this.chunk(node.name);
        },
      };
    },
    4451: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      module.exports = {
        name: "Identifier",
        structure: { name: String },
        parse: function () {
          return {
            type: "Identifier",
            loc: this.getLocation(
              this.scanner.tokenStart,
              this.scanner.tokenEnd,
            ),
            name: this.consume(IDENT),
          };
        },
        generate: function (node) {
          this.chunk(node.name);
        },
      };
    },
    6722: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      var COLON = TYPE.Colon;
      var DELIM = TYPE.Delim;
      module.exports = {
        name: "MediaFeature",
        structure: {
          name: String,
          value: ["Identifier", "Number", "Dimension", "Ratio", null],
        },
        parse: function () {
          var start = this.scanner.tokenStart;
          var name;
          var value = null;
          this.eat(LEFTPARENTHESIS);
          this.scanner.skipSC();
          name = this.consume(IDENT);
          this.scanner.skipSC();
          if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.eat(COLON);
            this.scanner.skipSC();
            switch (this.scanner.tokenType) {
              case NUMBER:
                if (this.lookupNonWSType(1) === DELIM) {
                  value = this.Ratio();
                } else {
                  value = this.Number();
                }
                break;
              case DIMENSION:
                value = this.Dimension();
                break;
              case IDENT:
                value = this.Identifier();
                break;
              default:
                this.error(
                  "Number, dimension, ratio or identifier is expected",
                );
            }
            this.scanner.skipSC();
          }
          this.eat(RIGHTPARENTHESIS);
          return {
            type: "MediaFeature",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            value,
          };
        },
        generate: function (node) {
          this.chunk("(");
          this.chunk(node.name);
          if (node.value !== null) {
            this.chunk(":");
            this.node(node.value);
          }
          this.chunk(")");
        },
      };
    },
    8057: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var IDENT = TYPE.Ident;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      module.exports = {
        name: "MediaQuery",
        structure: { children: [["Identifier", "MediaFeature", "WhiteSpace"]] },
        parse: function () {
          this.scanner.skipSC();
          var children = this.createList();
          var child = null;
          var space = null;
          scan: while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case COMMENT:
                this.scanner.next();
                continue;
              case WHITESPACE:
                space = this.WhiteSpace();
                continue;
              case IDENT:
                child = this.Identifier();
                break;
              case LEFTPARENTHESIS:
                child = this.MediaFeature();
                break;
              default:
                break scan;
            }
            if (space !== null) {
              children.push(space);
              space = null;
            }
            children.push(child);
          }
          if (child === null) {
            this.error("Identifier or parenthesis is expected");
          }
          return {
            type: "MediaQuery",
            loc: this.getLocationFromList(children),
            children,
          };
        },
        generate: function (node) {
          this.children(node);
        },
      };
    },
    7811: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var COMMA = __nccwpck_require__(6701).TYPE.Comma;
      module.exports = {
        name: "MediaQueryList",
        structure: { children: [["MediaQuery"]] },
        parse: function (relative) {
          var children = this.createList();
          this.scanner.skipSC();
          while (!this.scanner.eof) {
            children.push(this.MediaQuery(relative));
            if (this.scanner.tokenType !== COMMA) {
              break;
            }
            this.scanner.next();
          }
          return {
            type: "MediaQueryList",
            loc: this.getLocationFromList(children),
            children,
          };
        },
        generate: function (node) {
          this.children(node, function () {
            this.chunk(",");
          });
        },
      };
    },
    8331: (module) => {
      module.exports = {
        name: "Nth",
        structure: {
          nth: ["AnPlusB", "Identifier"],
          selector: ["SelectorList", null],
        },
        parse: function (allowOfClause) {
          this.scanner.skipSC();
          var start = this.scanner.tokenStart;
          var end = start;
          var selector = null;
          var query;
          if (
            this.scanner.lookupValue(0, "odd") ||
            this.scanner.lookupValue(0, "even")
          ) {
            query = this.Identifier();
          } else {
            query = this.AnPlusB();
          }
          this.scanner.skipSC();
          if (allowOfClause && this.scanner.lookupValue(0, "of")) {
            this.scanner.next();
            selector = this.SelectorList();
            if (this.needPositions) {
              end = this.getLastListNode(selector.children).loc.end.offset;
            }
          } else {
            if (this.needPositions) {
              end = query.loc.end.offset;
            }
          }
          return {
            type: "Nth",
            loc: this.getLocation(start, end),
            nth: query,
            selector,
          };
        },
        generate: function (node) {
          this.node(node.nth);
          if (node.selector !== null) {
            this.chunk(" of ");
            this.node(node.selector);
          }
        },
      };
    },
    8912: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var NUMBER = __nccwpck_require__(6701).TYPE.Number;
      module.exports = {
        name: "Number",
        structure: { value: String },
        parse: function () {
          return {
            type: "Number",
            loc: this.getLocation(
              this.scanner.tokenStart,
              this.scanner.tokenEnd,
            ),
            value: this.consume(NUMBER),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
        },
      };
    },
    7673: (module) => {
      module.exports = {
        name: "Operator",
        structure: { value: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          this.scanner.next();
          return {
            type: "Operator",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
        },
      };
    },
    6160: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "Parentheses",
        structure: { children: [[]] },
        parse: function (readSequence, recognizer) {
          var start = this.scanner.tokenStart;
          var children = null;
          this.eat(LEFTPARENTHESIS);
          children = readSequence.call(this, recognizer);
          if (!this.scanner.eof) {
            this.eat(RIGHTPARENTHESIS);
          }
          return {
            type: "Parentheses",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children,
          };
        },
        generate: function (node) {
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        },
      };
    },
    5125: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var consumeNumber = __nccwpck_require__(7989).consumeNumber;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var PERCENTAGE = TYPE.Percentage;
      module.exports = {
        name: "Percentage",
        structure: { value: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          var numberEnd = consumeNumber(this.scanner.source, start);
          this.eat(PERCENTAGE);
          return {
            type: "Percentage",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start, numberEnd),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
          this.chunk("%");
        },
      };
    },
    4489: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var COLON = TYPE.Colon;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "PseudoClassSelector",
        structure: { name: String, children: [["Raw"], null] },
        parse: function () {
          var start = this.scanner.tokenStart;
          var children = null;
          var name;
          var nameLowerCase;
          this.eat(COLON);
          if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
              this.scanner.skipSC();
              children = this.pseudo[nameLowerCase].call(this);
              this.scanner.skipSC();
            } else {
              children = this.createList();
              children.push(this.Raw(this.scanner.tokenIndex, null, false));
            }
            this.eat(RIGHTPARENTHESIS);
          } else {
            name = this.consume(IDENT);
          }
          return {
            type: "PseudoClassSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children,
          };
        },
        generate: function (node) {
          this.chunk(":");
          this.chunk(node.name);
          if (node.children !== null) {
            this.chunk("(");
            this.children(node);
            this.chunk(")");
          }
        },
        walkContext: "function",
      };
    },
    1905: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var FUNCTION = TYPE.Function;
      var COLON = TYPE.Colon;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "PseudoElementSelector",
        structure: { name: String, children: [["Raw"], null] },
        parse: function () {
          var start = this.scanner.tokenStart;
          var children = null;
          var name;
          var nameLowerCase;
          this.eat(COLON);
          this.eat(COLON);
          if (this.scanner.tokenType === FUNCTION) {
            name = this.consumeFunctionName();
            nameLowerCase = name.toLowerCase();
            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
              this.scanner.skipSC();
              children = this.pseudo[nameLowerCase].call(this);
              this.scanner.skipSC();
            } else {
              children = this.createList();
              children.push(this.Raw(this.scanner.tokenIndex, null, false));
            }
            this.eat(RIGHTPARENTHESIS);
          } else {
            name = this.consume(IDENT);
          }
          return {
            type: "PseudoElementSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name,
            children,
          };
        },
        generate: function (node) {
          this.chunk("::");
          this.chunk(node.name);
          if (node.children !== null) {
            this.chunk("(");
            this.children(node);
            this.chunk(")");
          }
        },
        walkContext: "function",
      };
    },
    5389: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isDigit = __nccwpck_require__(6701).isDigit;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var NUMBER = TYPE.Number;
      var DELIM = TYPE.Delim;
      var SOLIDUS = 47;
      var FULLSTOP = 46;
      function consumeNumber() {
        this.scanner.skipWS();
        var value = this.consume(NUMBER);
        for (var i = 0; i < value.length; i++) {
          var code = value.charCodeAt(i);
          if (!isDigit(code) && code !== FULLSTOP) {
            this.error(
              "Unsigned number is expected",
              this.scanner.tokenStart - value.length + i,
            );
          }
        }
        if (Number(value) === 0) {
          this.error(
            "Zero number is not allowed",
            this.scanner.tokenStart - value.length,
          );
        }
        return value;
      }
      module.exports = {
        name: "Ratio",
        structure: { left: String, right: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          var left = consumeNumber.call(this);
          var right;
          this.scanner.skipWS();
          if (!this.scanner.isDelim(SOLIDUS)) {
            this.error("Solidus is expected");
          }
          this.eat(DELIM);
          right = consumeNumber.call(this);
          return {
            type: "Ratio",
            loc: this.getLocation(start, this.scanner.tokenStart),
            left,
            right,
          };
        },
        generate: function (node) {
          this.chunk(node.left);
          this.chunk("/");
          this.chunk(node.right);
        },
      };
    },
    9787: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var tokenizer = __nccwpck_require__(6701);
      var TYPE = tokenizer.TYPE;
      var WhiteSpace = TYPE.WhiteSpace;
      var Semicolon = TYPE.Semicolon;
      var LeftCurlyBracket = TYPE.LeftCurlyBracket;
      var Delim = TYPE.Delim;
      var EXCLAMATIONMARK = 33;
      function getOffsetExcludeWS() {
        if (this.scanner.tokenIndex > 0) {
          if (this.scanner.lookupType(-1) === WhiteSpace) {
            return this.scanner.tokenIndex > 1
              ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
              : this.scanner.firstCharOffset;
          }
        }
        return this.scanner.tokenStart;
      }
      function balanceEnd() {
        return 0;
      }
      function leftCurlyBracket(tokenType) {
        return tokenType === LeftCurlyBracket ? 1 : 0;
      }
      function leftCurlyBracketOrSemicolon(tokenType) {
        return tokenType === LeftCurlyBracket || tokenType === Semicolon
          ? 1
          : 0;
      }
      function exclamationMarkOrSemicolon(tokenType, source, offset) {
        if (
          tokenType === Delim &&
          source.charCodeAt(offset) === EXCLAMATIONMARK
        ) {
          return 1;
        }
        return tokenType === Semicolon ? 1 : 0;
      }
      function semicolonIncluded(tokenType) {
        return tokenType === Semicolon ? 2 : 0;
      }
      module.exports = {
        name: "Raw",
        structure: { value: String },
        parse: function (startToken, mode, excludeWhiteSpace) {
          var startOffset = this.scanner.getTokenStart(startToken);
          var endOffset;
          this.scanner.skip(
            this.scanner.getRawLength(startToken, mode || balanceEnd),
          );
          if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = getOffsetExcludeWS.call(this);
          } else {
            endOffset = this.scanner.tokenStart;
          }
          return {
            type: "Raw",
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
        },
        mode: {
          default: balanceEnd,
          leftCurlyBracket,
          leftCurlyBracketOrSemicolon,
          exclamationMarkOrSemicolon,
          semicolonIncluded,
        },
      };
    },
    3277: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var rawMode = __nccwpck_require__(9787).mode;
      var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
      function consumeRaw(startToken) {
        return this.Raw(startToken, rawMode.leftCurlyBracket, true);
      }
      function consumePrelude() {
        var prelude = this.SelectorList();
        if (
          prelude.type !== "Raw" &&
          this.scanner.eof === false &&
          this.scanner.tokenType !== LEFTCURLYBRACKET
        ) {
          this.error();
        }
        return prelude;
      }
      module.exports = {
        name: "Rule",
        structure: { prelude: ["SelectorList", "Raw"], block: ["Block"] },
        parse: function () {
          var startToken = this.scanner.tokenIndex;
          var startOffset = this.scanner.tokenStart;
          var prelude;
          var block;
          if (this.parseRulePrelude) {
            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
          } else {
            prelude = consumeRaw.call(this, startToken);
          }
          block = this.Block(true);
          return {
            type: "Rule",
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            prelude,
            block,
          };
        },
        generate: function (node) {
          this.node(node.prelude);
          this.node(node.block);
        },
        walkContext: "rule",
      };
    },
    9555: (module) => {
      module.exports = {
        name: "Selector",
        structure: {
          children: [
            [
              "TypeSelector",
              "IdSelector",
              "ClassSelector",
              "AttributeSelector",
              "PseudoClassSelector",
              "PseudoElementSelector",
              "Combinator",
              "WhiteSpace",
            ],
          ],
        },
        parse: function () {
          var children = this.readSequence(this.scope.Selector);
          if (this.getFirstListNode(children) === null) {
            this.error("Selector is expected");
          }
          return {
            type: "Selector",
            loc: this.getLocationFromList(children),
            children,
          };
        },
        generate: function (node) {
          this.children(node);
        },
      };
    },
    4086: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var COMMA = TYPE.Comma;
      module.exports = {
        name: "SelectorList",
        structure: { children: [["Selector", "Raw"]] },
        parse: function () {
          var children = this.createList();
          while (!this.scanner.eof) {
            children.push(this.Selector());
            if (this.scanner.tokenType === COMMA) {
              this.scanner.next();
              continue;
            }
            break;
          }
          return {
            type: "SelectorList",
            loc: this.getLocationFromList(children),
            children,
          };
        },
        generate: function (node) {
          this.children(node, function () {
            this.chunk(",");
          });
        },
        walkContext: "selector",
      };
    },
    9759: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var STRING = __nccwpck_require__(6701).TYPE.String;
      module.exports = {
        name: "String",
        structure: { value: String },
        parse: function () {
          return {
            type: "String",
            loc: this.getLocation(
              this.scanner.tokenStart,
              this.scanner.tokenEnd,
            ),
            value: this.consume(STRING),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
        },
      };
    },
    1275: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var WHITESPACE = TYPE.WhiteSpace;
      var COMMENT = TYPE.Comment;
      var ATKEYWORD = TYPE.AtKeyword;
      var CDO = TYPE.CDO;
      var CDC = TYPE.CDC;
      var EXCLAMATIONMARK = 33;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, false);
      }
      module.exports = {
        name: "StyleSheet",
        structure: {
          children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]],
        },
        parse: function () {
          var start = this.scanner.tokenStart;
          var children = this.createList();
          var child;
          scan: while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
                this.scanner.next();
                continue;
              case COMMENT:
                if (
                  this.scanner.source.charCodeAt(
                    this.scanner.tokenStart + 2,
                  ) !== EXCLAMATIONMARK
                ) {
                  this.scanner.next();
                  continue;
                }
                child = this.Comment();
                break;
              case CDO:
                child = this.CDO();
                break;
              case CDC:
                child = this.CDC();
                break;
              case ATKEYWORD:
                child = this.parseWithFallback(this.Atrule, consumeRaw);
                break;
              default:
                child = this.parseWithFallback(this.Rule, consumeRaw);
            }
            children.push(child);
          }
          return {
            type: "StyleSheet",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children,
          };
        },
        generate: function (node) {
          this.children(node);
        },
        walkContext: "stylesheet",
      };
    },
    3979: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var ASTERISK = 42;
      var VERTICALLINE = 124;
      function eatIdentifierOrAsterisk() {
        if (
          this.scanner.tokenType !== IDENT &&
          this.scanner.isDelim(ASTERISK) === false
        ) {
          this.error("Identifier or asterisk is expected");
        }
        this.scanner.next();
      }
      module.exports = {
        name: "TypeSelector",
        structure: { name: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          if (this.scanner.isDelim(VERTICALLINE)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
          } else {
            eatIdentifierOrAsterisk.call(this);
            if (this.scanner.isDelim(VERTICALLINE)) {
              this.scanner.next();
              eatIdentifierOrAsterisk.call(this);
            }
          }
          return {
            type: "TypeSelector",
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start),
          };
        },
        generate: function (node) {
          this.chunk(node.name);
        },
      };
    },
    9508: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isHexDigit = __nccwpck_require__(6701).isHexDigit;
      var cmpChar = __nccwpck_require__(6701).cmpChar;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var NAME = __nccwpck_require__(6701).NAME;
      var IDENT = TYPE.Ident;
      var NUMBER = TYPE.Number;
      var DIMENSION = TYPE.Dimension;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var QUESTIONMARK = 63;
      var U = 117;
      function eatHexSequence(offset, allowDash) {
        for (
          var pos = this.scanner.tokenStart + offset, len = 0;
          pos < this.scanner.tokenEnd;
          pos++
        ) {
          var code = this.scanner.source.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && len !== 0) {
            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
              this.error();
            }
            return -1;
          }
          if (!isHexDigit(code)) {
            this.error(
              allowDash && len !== 0
                ? "HyphenMinus" +
                    (len < 6 ? " or hex digit" : "") +
                    " is expected"
                : len < 6
                  ? "Hex digit is expected"
                  : "Unexpected input",
              pos,
            );
          }
          if (++len > 6) {
            this.error("Too many hex digits", pos);
          }
        }
        this.scanner.next();
        return len;
      }
      function eatQuestionMarkSequence(max) {
        var count = 0;
        while (this.scanner.isDelim(QUESTIONMARK)) {
          if (++count > max) {
            this.error("Too many question marks");
          }
          this.scanner.next();
        }
      }
      function startsWith(code) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
          this.error(NAME[code] + " is expected");
        }
      }
      function scanUnicodeRange() {
        var hexLength = 0;
        if (this.scanner.isDelim(PLUSSIGN)) {
          this.scanner.next();
          if (this.scanner.tokenType === IDENT) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            return;
          }
          if (this.scanner.isDelim(QUESTIONMARK)) {
            this.scanner.next();
            eatQuestionMarkSequence.call(this, 5);
            return;
          }
          this.error("Hex digit or question mark is expected");
          return;
        }
        if (this.scanner.tokenType === NUMBER) {
          startsWith.call(this, PLUSSIGN);
          hexLength = eatHexSequence.call(this, 1, true);
          if (this.scanner.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            return;
          }
          if (
            this.scanner.tokenType === DIMENSION ||
            this.scanner.tokenType === NUMBER
          ) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            return;
          }
          return;
        }
        if (this.scanner.tokenType === DIMENSION) {
          startsWith.call(this, PLUSSIGN);
          hexLength = eatHexSequence.call(this, 1, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          return;
        }
        this.error();
      }
      module.exports = {
        name: "UnicodeRange",
        structure: { value: String },
        parse: function () {
          var start = this.scanner.tokenStart;
          if (!cmpChar(this.scanner.source, start, U)) {
            this.error("U is expected");
          }
          if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
            this.error("Plus sign is expected");
          }
          this.scanner.next();
          scanUnicodeRange.call(this);
          return {
            type: "UnicodeRange",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start),
          };
        },
        generate: function (node) {
          this.chunk(node.value);
        },
      };
    },
    1814: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isWhiteSpace = __nccwpck_require__(6701).isWhiteSpace;
      var cmpStr = __nccwpck_require__(6701).cmpStr;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var FUNCTION = TYPE.Function;
      var URL = TYPE.Url;
      var RIGHTPARENTHESIS = TYPE.RightParenthesis;
      module.exports = {
        name: "Url",
        structure: { value: ["String", "Raw"] },
        parse: function () {
          var start = this.scanner.tokenStart;
          var value;
          switch (this.scanner.tokenType) {
            case URL:
              var rawStart = start + 4;
              var rawEnd = this.scanner.tokenEnd - 1;
              while (
                rawStart < rawEnd &&
                isWhiteSpace(this.scanner.source.charCodeAt(rawStart))
              ) {
                rawStart++;
              }
              while (
                rawStart < rawEnd &&
                isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))
              ) {
                rawEnd--;
              }
              value = {
                type: "Raw",
                loc: this.getLocation(rawStart, rawEnd),
                value: this.scanner.source.substring(rawStart, rawEnd),
              };
              this.eat(URL);
              break;
            case FUNCTION:
              if (
                !cmpStr(
                  this.scanner.source,
                  this.scanner.tokenStart,
                  this.scanner.tokenEnd,
                  "url(",
                )
              ) {
                this.error("Function name must be `url`");
              }
              this.eat(FUNCTION);
              this.scanner.skipSC();
              value = this.String();
              this.scanner.skipSC();
              this.eat(RIGHTPARENTHESIS);
              break;
            default:
              this.error("Url or Function is expected");
          }
          return {
            type: "Url",
            loc: this.getLocation(start, this.scanner.tokenStart),
            value,
          };
        },
        generate: function (node) {
          this.chunk("url");
          this.chunk("(");
          this.node(node.value);
          this.chunk(")");
        },
      };
    },
    6932: (module) => {
      module.exports = {
        name: "Value",
        structure: { children: [[]] },
        parse: function () {
          var start = this.scanner.tokenStart;
          var children = this.readSequence(this.scope.Value);
          return {
            type: "Value",
            loc: this.getLocation(start, this.scanner.tokenStart),
            children,
          };
        },
        generate: function (node) {
          this.children(node);
        },
      };
    },
    7696: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var WHITESPACE = __nccwpck_require__(6701).TYPE.WhiteSpace;
      var SPACE = Object.freeze({ type: "WhiteSpace", loc: null, value: " " });
      module.exports = {
        name: "WhiteSpace",
        structure: { value: String },
        parse: function () {
          this.eat(WHITESPACE);
          return SPACE;
        },
        generate: function (node) {
          this.chunk(node.value);
        },
      };
    },
    5841: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        AnPlusB: __nccwpck_require__(9790),
        Atrule: __nccwpck_require__(373),
        AtrulePrelude: __nccwpck_require__(4659),
        AttributeSelector: __nccwpck_require__(9830),
        Block: __nccwpck_require__(989),
        Brackets: __nccwpck_require__(5850),
        CDC: __nccwpck_require__(6311),
        CDO: __nccwpck_require__(5167),
        ClassSelector: __nccwpck_require__(6914),
        Combinator: __nccwpck_require__(3665),
        Comment: __nccwpck_require__(7346),
        Declaration: __nccwpck_require__(4099),
        DeclarationList: __nccwpck_require__(1745),
        Dimension: __nccwpck_require__(7061),
        Function: __nccwpck_require__(1098),
        Hash: __nccwpck_require__(7830),
        Identifier: __nccwpck_require__(4451),
        IdSelector: __nccwpck_require__(3376),
        MediaFeature: __nccwpck_require__(6722),
        MediaQuery: __nccwpck_require__(8057),
        MediaQueryList: __nccwpck_require__(7811),
        Nth: __nccwpck_require__(8331),
        Number: __nccwpck_require__(8912),
        Operator: __nccwpck_require__(7673),
        Parentheses: __nccwpck_require__(6160),
        Percentage: __nccwpck_require__(5125),
        PseudoClassSelector: __nccwpck_require__(4489),
        PseudoElementSelector: __nccwpck_require__(1905),
        Ratio: __nccwpck_require__(5389),
        Raw: __nccwpck_require__(9787),
        Rule: __nccwpck_require__(3277),
        Selector: __nccwpck_require__(9555),
        SelectorList: __nccwpck_require__(4086),
        String: __nccwpck_require__(9759),
        StyleSheet: __nccwpck_require__(1275),
        TypeSelector: __nccwpck_require__(3979),
        UnicodeRange: __nccwpck_require__(9508),
        Url: __nccwpck_require__(1814),
        Value: __nccwpck_require__(6932),
        WhiteSpace: __nccwpck_require__(7696),
      };
    },
    2765: (module) => {
      var DISALLOW_OF_CLAUSE = false;
      module.exports = {
        parse: function nth() {
          return this.createSingleNodeList(this.Nth(DISALLOW_OF_CLAUSE));
        },
      };
    },
    7561: (module) => {
      var ALLOW_OF_CLAUSE = true;
      module.exports = {
        parse: function nthWithOfClause() {
          return this.createSingleNodeList(this.Nth(ALLOW_OF_CLAUSE));
        },
      };
    },
    8330: (module) => {
      module.exports = {
        parse: function selectorList() {
          return this.createSingleNodeList(this.SelectorList());
        },
      };
    },
    3755: (module) => {
      module.exports = {
        parse: function () {
          return this.createSingleNodeList(this.Identifier());
        },
      };
    },
    4262: (module) => {
      module.exports = {
        parse: function () {
          return this.createSingleNodeList(this.SelectorList());
        },
      };
    },
    9749: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        dir: __nccwpck_require__(3755),
        has: __nccwpck_require__(4262),
        lang: __nccwpck_require__(7734),
        matches: __nccwpck_require__(8325),
        not: __nccwpck_require__(3551),
        "nth-child": __nccwpck_require__(5228),
        "nth-last-child": __nccwpck_require__(1794),
        "nth-last-of-type": __nccwpck_require__(3124),
        "nth-of-type": __nccwpck_require__(2549),
        slotted: __nccwpck_require__(7458),
      };
    },
    7734: (module) => {
      module.exports = {
        parse: function () {
          return this.createSingleNodeList(this.Identifier());
        },
      };
    },
    8325: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(8330);
    },
    3551: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(8330);
    },
    5228: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(7561);
    },
    1794: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(7561);
    },
    3124: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(2765);
    },
    2549: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(2765);
    },
    7458: (module) => {
      module.exports = {
        parse: function compoundSelector() {
          return this.createSingleNodeList(this.Selector());
        },
      };
    },
    7368: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = { getNode: __nccwpck_require__(8075) };
    },
    8075: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var cmpChar = __nccwpck_require__(6701).cmpChar;
      var cmpStr = __nccwpck_require__(6701).cmpStr;
      var TYPE = __nccwpck_require__(6701).TYPE;
      var IDENT = TYPE.Ident;
      var STRING = TYPE.String;
      var NUMBER = TYPE.Number;
      var FUNCTION = TYPE.Function;
      var URL = TYPE.Url;
      var HASH = TYPE.Hash;
      var DIMENSION = TYPE.Dimension;
      var PERCENTAGE = TYPE.Percentage;
      var LEFTPARENTHESIS = TYPE.LeftParenthesis;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var COMMA = TYPE.Comma;
      var DELIM = TYPE.Delim;
      var NUMBERSIGN = 35;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var HYPHENMINUS = 45;
      var SOLIDUS = 47;
      var U = 117;
      module.exports = function defaultRecognizer(context) {
        switch (this.scanner.tokenType) {
          case HASH:
            return this.Hash();
          case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();
          case LEFTPARENTHESIS:
            return this.Parentheses(this.readSequence, context.recognizer);
          case LEFTSQUAREBRACKET:
            return this.Brackets(this.readSequence, context.recognizer);
          case STRING:
            return this.String();
          case DIMENSION:
            return this.Dimension();
          case PERCENTAGE:
            return this.Percentage();
          case NUMBER:
            return this.Number();
          case FUNCTION:
            return cmpStr(
              this.scanner.source,
              this.scanner.tokenStart,
              this.scanner.tokenEnd,
              "url(",
            )
              ? this.Url()
              : this.Function(this.readSequence, context.recognizer);
          case URL:
            return this.Url();
          case IDENT:
            if (
              cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
              cmpChar(
                this.scanner.source,
                this.scanner.tokenStart + 1,
                PLUSSIGN,
              )
            ) {
              return this.UnicodeRange();
            } else {
              return this.Identifier();
            }
          case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            if (
              code === SOLIDUS ||
              code === ASTERISK ||
              code === PLUSSIGN ||
              code === HYPHENMINUS
            ) {
              return this.Operator();
            }
            if (code === NUMBERSIGN) {
              this.error(
                "Hex or identifier is expected",
                this.scanner.tokenStart + 1,
              );
            }
            break;
        }
      };
    },
    1621: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        AtrulePrelude: __nccwpck_require__(7368),
        Selector: __nccwpck_require__(3215),
        Value: __nccwpck_require__(6674),
      };
    },
    3215: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TYPE = __nccwpck_require__(6701).TYPE;
      var DELIM = TYPE.Delim;
      var IDENT = TYPE.Ident;
      var DIMENSION = TYPE.Dimension;
      var PERCENTAGE = TYPE.Percentage;
      var NUMBER = TYPE.Number;
      var HASH = TYPE.Hash;
      var COLON = TYPE.Colon;
      var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
      var NUMBERSIGN = 35;
      var ASTERISK = 42;
      var PLUSSIGN = 43;
      var SOLIDUS = 47;
      var FULLSTOP = 46;
      var GREATERTHANSIGN = 62;
      var VERTICALLINE = 124;
      var TILDE = 126;
      function getNode(context) {
        switch (this.scanner.tokenType) {
          case LEFTSQUAREBRACKET:
            return this.AttributeSelector();
          case HASH:
            return this.IdSelector();
          case COLON:
            if (this.scanner.lookupType(1) === COLON) {
              return this.PseudoElementSelector();
            } else {
              return this.PseudoClassSelector();
            }
          case IDENT:
            return this.TypeSelector();
          case NUMBER:
          case PERCENTAGE:
            return this.Percentage();
          case DIMENSION:
            if (
              this.scanner.source.charCodeAt(this.scanner.tokenStart) ===
              FULLSTOP
            ) {
              this.error("Identifier is expected", this.scanner.tokenStart + 1);
            }
            break;
          case DELIM:
            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
            switch (code) {
              case PLUSSIGN:
              case GREATERTHANSIGN:
              case TILDE:
                context.space = null;
                context.ignoreWSAfter = true;
                return this.Combinator();
              case SOLIDUS:
                return this.Combinator();
              case FULLSTOP:
                return this.ClassSelector();
              case ASTERISK:
              case VERTICALLINE:
                return this.TypeSelector();
              case NUMBERSIGN:
                return this.IdSelector();
            }
            break;
        }
      }
      module.exports = { getNode };
    },
    6674: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        getNode: __nccwpck_require__(8075),
        expression: __nccwpck_require__(1317),
        var: __nccwpck_require__(6139),
      };
    },
    1477: (module) => {
      var EOF = 0;
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isHexDigit(code) {
        return (
          isDigit(code) ||
          (code >= 65 && code <= 70) ||
          (code >= 97 && code <= 102)
        );
      }
      function isUppercaseLetter(code) {
        return code >= 65 && code <= 90;
      }
      function isLowercaseLetter(code) {
        return code >= 97 && code <= 122;
      }
      function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
      }
      function isNonAscii(code) {
        return code >= 128;
      }
      function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 95;
      }
      function isName(code) {
        return isNameStart(code) || isDigit(code) || code === 45;
      }
      function isNonPrintable(code) {
        return (
          (code >= 0 && code <= 8) ||
          code === 11 ||
          (code >= 14 && code <= 31) ||
          code === 127
        );
      }
      function isNewline(code) {
        return code === 10 || code === 13 || code === 12;
      }
      function isWhiteSpace(code) {
        return isNewline(code) || code === 32 || code === 9;
      }
      function isValidEscape(first, second) {
        if (first !== 92) {
          return false;
        }
        if (isNewline(second) || second === EOF) {
          return false;
        }
        return true;
      }
      function isIdentifierStart(first, second, third) {
        if (first === 45) {
          return (
            isNameStart(second) || second === 45 || isValidEscape(second, third)
          );
        }
        if (isNameStart(first)) {
          return true;
        }
        if (first === 92) {
          return isValidEscape(first, second);
        }
        return false;
      }
      function isNumberStart(first, second, third) {
        if (first === 43 || first === 45) {
          if (isDigit(second)) {
            return 2;
          }
          return second === 46 && isDigit(third) ? 3 : 0;
        }
        if (first === 46) {
          return isDigit(second) ? 2 : 0;
        }
        if (isDigit(first)) {
          return 1;
        }
        return 0;
      }
      function isBOM(code) {
        if (code === 65279) {
          return 1;
        }
        if (code === 65534) {
          return 1;
        }
        return 0;
      }
      var CATEGORY = new Array(128);
      charCodeCategory.Eof = 128;
      charCodeCategory.WhiteSpace = 130;
      charCodeCategory.Digit = 131;
      charCodeCategory.NameStart = 132;
      charCodeCategory.NonPrintable = 133;
      for (var i = 0; i < CATEGORY.length; i++) {
        switch (true) {
          case isWhiteSpace(i):
            CATEGORY[i] = charCodeCategory.WhiteSpace;
            break;
          case isDigit(i):
            CATEGORY[i] = charCodeCategory.Digit;
            break;
          case isNameStart(i):
            CATEGORY[i] = charCodeCategory.NameStart;
            break;
          case isNonPrintable(i):
            CATEGORY[i] = charCodeCategory.NonPrintable;
            break;
          default:
            CATEGORY[i] = i || charCodeCategory.Eof;
        }
      }
      function charCodeCategory(code) {
        return code < 128 ? CATEGORY[code] : charCodeCategory.NameStart;
      }
      module.exports = {
        isDigit,
        isHexDigit,
        isUppercaseLetter,
        isLowercaseLetter,
        isLetter,
        isNonAscii,
        isNameStart,
        isName,
        isNonPrintable,
        isNewline,
        isWhiteSpace,
        isValidEscape,
        isIdentifierStart,
        isNumberStart,
        isBOM,
        charCodeCategory,
      };
    },
    3276: (module) => {
      var TYPE = {
        EOF: 0,
        Ident: 1,
        Function: 2,
        AtKeyword: 3,
        Hash: 4,
        String: 5,
        BadString: 6,
        Url: 7,
        BadUrl: 8,
        Delim: 9,
        Number: 10,
        Percentage: 11,
        Dimension: 12,
        WhiteSpace: 13,
        CDO: 14,
        CDC: 15,
        Colon: 16,
        Semicolon: 17,
        Comma: 18,
        LeftSquareBracket: 19,
        RightSquareBracket: 20,
        LeftParenthesis: 21,
        RightParenthesis: 22,
        LeftCurlyBracket: 23,
        RightCurlyBracket: 24,
        Comment: 25,
      };
      var NAME = Object.keys(TYPE).reduce(function (result, key) {
        result[TYPE[key]] = key;
        return result;
      }, {});
      module.exports = { TYPE, NAME };
    },
    6701: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var TokenStream = __nccwpck_require__(9313);
      var adoptBuffer = __nccwpck_require__(3307);
      var constants = __nccwpck_require__(3276);
      var TYPE = constants.TYPE;
      var charCodeDefinitions = __nccwpck_require__(1477);
      var isNewline = charCodeDefinitions.isNewline;
      var isName = charCodeDefinitions.isName;
      var isValidEscape = charCodeDefinitions.isValidEscape;
      var isNumberStart = charCodeDefinitions.isNumberStart;
      var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
      var charCodeCategory = charCodeDefinitions.charCodeCategory;
      var isBOM = charCodeDefinitions.isBOM;
      var utils = __nccwpck_require__(7989);
      var cmpStr = utils.cmpStr;
      var getNewlineLength = utils.getNewlineLength;
      var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
      var consumeEscaped = utils.consumeEscaped;
      var consumeName = utils.consumeName;
      var consumeNumber = utils.consumeNumber;
      var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
      var OFFSET_MASK = 16777215;
      var TYPE_SHIFT = 24;
      function tokenize(source, stream) {
        function getCharCode(offset) {
          return offset < sourceLength ? source.charCodeAt(offset) : 0;
        }
        function consumeNumericToken() {
          offset = consumeNumber(source, offset);
          if (
            isIdentifierStart(
              getCharCode(offset),
              getCharCode(offset + 1),
              getCharCode(offset + 2),
            )
          ) {
            type = TYPE.Dimension;
            offset = consumeName(source, offset);
            return;
          }
          if (getCharCode(offset) === 37) {
            type = TYPE.Percentage;
            offset++;
            return;
          }
          type = TYPE.Number;
        }
        function consumeIdentLikeToken() {
          const nameStartOffset = offset;
          offset = consumeName(source, offset);
          if (
            cmpStr(source, nameStartOffset, offset, "url") &&
            getCharCode(offset) === 40
          ) {
            offset = findWhiteSpaceEnd(source, offset + 1);
            if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
              type = TYPE.Function;
              offset = nameStartOffset + 4;
              return;
            }
            consumeUrlToken();
            return;
          }
          if (getCharCode(offset) === 40) {
            type = TYPE.Function;
            offset++;
            return;
          }
          type = TYPE.Ident;
        }
        function consumeStringToken(endingCodePoint) {
          if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
          }
          type = TYPE.String;
          for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);
            switch (charCodeCategory(code)) {
              case endingCodePoint:
                offset++;
                return;
              case charCodeCategory.Eof:
                return;
              case charCodeCategory.WhiteSpace:
                if (isNewline(code)) {
                  offset += getNewlineLength(source, offset, code);
                  type = TYPE.BadString;
                  return;
                }
                break;
              case 92:
                if (offset === source.length - 1) {
                  break;
                }
                var nextCode = getCharCode(offset + 1);
                if (isNewline(nextCode)) {
                  offset += getNewlineLength(source, offset + 1, nextCode);
                } else if (isValidEscape(code, nextCode)) {
                  offset = consumeEscaped(source, offset) - 1;
                }
                break;
            }
          }
        }
        function consumeUrlToken() {
          type = TYPE.Url;
          offset = findWhiteSpaceEnd(source, offset);
          for (; offset < source.length; offset++) {
            var code = source.charCodeAt(offset);
            switch (charCodeCategory(code)) {
              case 41:
                offset++;
                return;
              case charCodeCategory.Eof:
                return;
              case charCodeCategory.WhiteSpace:
                offset = findWhiteSpaceEnd(source, offset);
                if (getCharCode(offset) === 41 || offset >= source.length) {
                  if (offset < source.length) {
                    offset++;
                  }
                  return;
                }
                offset = consumeBadUrlRemnants(source, offset);
                type = TYPE.BadUrl;
                return;
              case 34:
              case 39:
              case 40:
              case charCodeCategory.NonPrintable:
                offset = consumeBadUrlRemnants(source, offset);
                type = TYPE.BadUrl;
                return;
              case 92:
                if (isValidEscape(code, getCharCode(offset + 1))) {
                  offset = consumeEscaped(source, offset) - 1;
                  break;
                }
                offset = consumeBadUrlRemnants(source, offset);
                type = TYPE.BadUrl;
                return;
            }
          }
        }
        if (!stream) {
          stream = new TokenStream();
        }
        source = String(source || "");
        var sourceLength = source.length;
        var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1);
        var balance = adoptBuffer(stream.balance, sourceLength + 1);
        var tokenCount = 0;
        var start = isBOM(getCharCode(0));
        var offset = start;
        var balanceCloseType = 0;
        var balanceStart = 0;
        var balancePrev = 0;
        while (offset < sourceLength) {
          var code = source.charCodeAt(offset);
          var type = 0;
          balance[tokenCount] = sourceLength;
          switch (charCodeCategory(code)) {
            case charCodeCategory.WhiteSpace:
              type = TYPE.WhiteSpace;
              offset = findWhiteSpaceEnd(source, offset + 1);
              break;
            case 34:
              consumeStringToken();
              break;
            case 35:
              if (
                isName(getCharCode(offset + 1)) ||
                isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))
              ) {
                type = TYPE.Hash;
                offset = consumeName(source, offset + 1);
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 39:
              consumeStringToken();
              break;
            case 40:
              type = TYPE.LeftParenthesis;
              offset++;
              break;
            case 41:
              type = TYPE.RightParenthesis;
              offset++;
              break;
            case 43:
              if (
                isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 44:
              type = TYPE.Comma;
              offset++;
              break;
            case 45:
              if (
                isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                if (
                  getCharCode(offset + 1) === 45 &&
                  getCharCode(offset + 2) === 62
                ) {
                  type = TYPE.CDC;
                  offset = offset + 3;
                } else {
                  if (
                    isIdentifierStart(
                      code,
                      getCharCode(offset + 1),
                      getCharCode(offset + 2),
                    )
                  ) {
                    consumeIdentLikeToken();
                  } else {
                    type = TYPE.Delim;
                    offset++;
                  }
                }
              }
              break;
            case 46:
              if (
                isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 47:
              if (getCharCode(offset + 1) === 42) {
                type = TYPE.Comment;
                offset = source.indexOf("*/", offset + 2) + 2;
                if (offset === 1) {
                  offset = source.length;
                }
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 58:
              type = TYPE.Colon;
              offset++;
              break;
            case 59:
              type = TYPE.Semicolon;
              offset++;
              break;
            case 60:
              if (
                getCharCode(offset + 1) === 33 &&
                getCharCode(offset + 2) === 45 &&
                getCharCode(offset + 3) === 45
              ) {
                type = TYPE.CDO;
                offset = offset + 4;
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 64:
              if (
                isIdentifierStart(
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                  getCharCode(offset + 3),
                )
              ) {
                type = TYPE.AtKeyword;
                offset = consumeName(source, offset + 1);
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 91:
              type = TYPE.LeftSquareBracket;
              offset++;
              break;
            case 92:
              if (isValidEscape(code, getCharCode(offset + 1))) {
                consumeIdentLikeToken();
              } else {
                type = TYPE.Delim;
                offset++;
              }
              break;
            case 93:
              type = TYPE.RightSquareBracket;
              offset++;
              break;
            case 123:
              type = TYPE.LeftCurlyBracket;
              offset++;
              break;
            case 125:
              type = TYPE.RightCurlyBracket;
              offset++;
              break;
            case charCodeCategory.Digit:
              consumeNumericToken();
              break;
            case charCodeCategory.NameStart:
              consumeIdentLikeToken();
              break;
            case charCodeCategory.Eof:
              break;
            default:
              type = TYPE.Delim;
              offset++;
          }
          switch (type) {
            case balanceCloseType:
              balancePrev = balanceStart & OFFSET_MASK;
              balanceStart = balance[balancePrev];
              balanceCloseType = balanceStart >> TYPE_SHIFT;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;
              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }
              break;
            case TYPE.LeftParenthesis:
            case TYPE.Function:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE.RightParenthesis;
              balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
              break;
            case TYPE.LeftSquareBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE.RightSquareBracket;
              balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
              break;
            case TYPE.LeftCurlyBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = TYPE.RightCurlyBracket;
              balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
              break;
          }
          offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
        }
        offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset;
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength;
        while (balanceStart !== 0) {
          balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balance[balancePrev] = sourceLength;
        }
        stream.source = source;
        stream.firstCharOffset = start;
        stream.offsetAndType = offsetAndType;
        stream.tokenCount = tokenCount;
        stream.balance = balance;
        stream.reset();
        stream.next();
        return stream;
      }
      Object.keys(constants).forEach(function (key) {
        tokenize[key] = constants[key];
      });
      Object.keys(charCodeDefinitions).forEach(function (key) {
        tokenize[key] = charCodeDefinitions[key];
      });
      Object.keys(utils).forEach(function (key) {
        tokenize[key] = utils[key];
      });
      module.exports = tokenize;
    },
    7989: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var charCodeDef = __nccwpck_require__(1477);
      var isDigit = charCodeDef.isDigit;
      var isHexDigit = charCodeDef.isHexDigit;
      var isUppercaseLetter = charCodeDef.isUppercaseLetter;
      var isName = charCodeDef.isName;
      var isWhiteSpace = charCodeDef.isWhiteSpace;
      var isValidEscape = charCodeDef.isValidEscape;
      function getCharCode(source, offset) {
        return offset < source.length ? source.charCodeAt(offset) : 0;
      }
      function getNewlineLength(source, offset, code) {
        if (code === 13 && getCharCode(source, offset + 1) === 10) {
          return 2;
        }
        return 1;
      }
      function cmpChar(testStr, offset, referenceCode) {
        var code = testStr.charCodeAt(offset);
        if (isUppercaseLetter(code)) {
          code = code | 32;
        }
        return code === referenceCode;
      }
      function cmpStr(testStr, start, end, referenceStr) {
        if (end - start !== referenceStr.length) {
          return false;
        }
        if (start < 0 || end > testStr.length) {
          return false;
        }
        for (var i = start; i < end; i++) {
          var testCode = testStr.charCodeAt(i);
          var referenceCode = referenceStr.charCodeAt(i - start);
          if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function findWhiteSpaceStart(source, offset) {
        for (; offset >= 0; offset--) {
          if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset + 1;
      }
      function findWhiteSpaceEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function findDecimalNumberEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!isDigit(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function consumeEscaped(source, offset) {
        offset += 2;
        if (isHexDigit(getCharCode(source, offset - 1))) {
          for (
            var maxOffset = Math.min(source.length, offset + 5);
            offset < maxOffset;
            offset++
          ) {
            if (!isHexDigit(getCharCode(source, offset))) {
              break;
            }
          }
          var code = getCharCode(source, offset);
          if (isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
          }
        }
        return offset;
      }
      function consumeName(source, offset) {
        for (; offset < source.length; offset++) {
          var code = source.charCodeAt(offset);
          if (isName(code)) {
            continue;
          }
          if (isValidEscape(code, getCharCode(source, offset + 1))) {
            offset = consumeEscaped(source, offset) - 1;
            continue;
          }
          break;
        }
        return offset;
      }
      function consumeNumber(source, offset) {
        var code = source.charCodeAt(offset);
        if (code === 43 || code === 45) {
          code = source.charCodeAt((offset += 1));
        }
        if (isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1);
          code = source.charCodeAt(offset);
        }
        if (code === 46 && isDigit(source.charCodeAt(offset + 1))) {
          code = source.charCodeAt((offset += 2));
          offset = findDecimalNumberEnd(source, offset);
        }
        if (cmpChar(source, offset, 101)) {
          var sign = 0;
          code = source.charCodeAt(offset + 1);
          if (code === 45 || code === 43) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
          }
          if (isDigit(code)) {
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
          }
        }
        return offset;
      }
      function consumeBadUrlRemnants(source, offset) {
        for (; offset < source.length; offset++) {
          var code = source.charCodeAt(offset);
          if (code === 41) {
            offset++;
            break;
          }
          if (isValidEscape(code, getCharCode(source, offset + 1))) {
            offset = consumeEscaped(source, offset);
          }
        }
        return offset;
      }
      module.exports = {
        consumeEscaped,
        consumeName,
        consumeNumber,
        consumeBadUrlRemnants,
        cmpChar,
        cmpStr,
        getNewlineLength,
        findWhiteSpaceStart,
        findWhiteSpaceEnd,
      };
    },
    8062: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(9621);
      module.exports = function clone(node) {
        var result = {};
        for (var key in node) {
          var value = node[key];
          if (value) {
            if (Array.isArray(value) || value instanceof List) {
              value = value.map(clone);
            } else if (value.constructor === Object) {
              value = clone(value);
            }
          }
          result[key] = value;
        }
        return result;
      };
    },
    7512: (module) => {
      module.exports = function createCustomError(name, message) {
        var error = Object.create(SyntaxError.prototype);
        var errorStack = new Error();
        error.name = name;
        error.message = message;
        Object.defineProperty(error, "stack", {
          get: function () {
            return (errorStack.stack || "").replace(
              /^(.+\n){1,3}/,
              name + ": " + message + "\n",
            );
          },
        });
        return error;
      };
    },
    4337: (module) => {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var keywords = Object.create(null);
      var properties = Object.create(null);
      var HYPHENMINUS = 45;
      function isCustomProperty(str, offset) {
        offset = offset || 0;
        return (
          str.length - offset >= 2 &&
          str.charCodeAt(offset) === HYPHENMINUS &&
          str.charCodeAt(offset + 1) === HYPHENMINUS
        );
      }
      function getVendorPrefix(str, offset) {
        offset = offset || 0;
        if (str.length - offset >= 3) {
          if (
            str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS
          ) {
            var secondDashIndex = str.indexOf("-", offset + 2);
            if (secondDashIndex !== -1) {
              return str.substring(offset, secondDashIndex + 1);
            }
          }
        }
        return "";
      }
      function getKeywordDescriptor(keyword) {
        if (hasOwnProperty.call(keywords, keyword)) {
          return keywords[keyword];
        }
        var name = keyword.toLowerCase();
        if (hasOwnProperty.call(keywords, name)) {
          return (keywords[keyword] = keywords[name]);
        }
        var custom = isCustomProperty(name, 0);
        var vendor = !custom ? getVendorPrefix(name, 0) : "";
        return (keywords[keyword] = Object.freeze({
          basename: name.substr(vendor.length),
          name,
          vendor,
          prefix: vendor,
          custom,
        }));
      }
      function getPropertyDescriptor(property) {
        if (hasOwnProperty.call(properties, property)) {
          return properties[property];
        }
        var name = property;
        var hack = property[0];
        if (hack === "/") {
          hack = property[1] === "/" ? "//" : "/";
        } else if (
          hack !== "_" &&
          hack !== "*" &&
          hack !== "$" &&
          hack !== "#" &&
          hack !== "+" &&
          hack !== "&"
        ) {
          hack = "";
        }
        var custom = isCustomProperty(name, hack.length);
        if (!custom) {
          name = name.toLowerCase();
          if (hasOwnProperty.call(properties, name)) {
            return (properties[property] = properties[name]);
          }
        }
        var vendor = !custom ? getVendorPrefix(name, hack.length) : "";
        var prefix = name.substr(0, hack.length + vendor.length);
        return (properties[property] = Object.freeze({
          basename: name.substr(prefix.length),
          name: name.substr(hack.length),
          hack,
          vendor,
          prefix,
          custom,
        }));
      }
      module.exports = {
        keyword: getKeywordDescriptor,
        property: getPropertyDescriptor,
        isCustomProperty,
        vendorPrefix: getVendorPrefix,
      };
    },
    1261: (module) => {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var noop = function () {};
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop;
      }
      function invokeForType(fn, type) {
        return function (node, item, list) {
          if (node.type === type) {
            fn.call(this, node, item, list);
          }
        };
      }
      function getWalkersFromStructure(name, nodeType) {
        var structure = nodeType.structure;
        var walkers = [];
        for (var key in structure) {
          if (hasOwnProperty.call(structure, key) === false) {
            continue;
          }
          var fieldTypes = structure[key];
          var walker = { name: key, type: false, nullable: false };
          if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
          }
          for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
              walker.nullable = true;
            } else if (typeof fieldType === "string") {
              walker.type = "node";
            } else if (Array.isArray(fieldType)) {
              walker.type = "list";
            }
          }
          if (walker.type) {
            walkers.push(walker);
          }
        }
        if (walkers.length) {
          return { context: nodeType.walkContext, fields: walkers };
        }
        return null;
      }
      function getTypesFromConfig(config) {
        var types = {};
        for (var name in config.node) {
          if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];
            if (!nodeType.structure) {
              throw new Error(
                "Missed `structure` field in `" +
                  name +
                  "` node type definition",
              );
            }
            types[name] = getWalkersFromStructure(name, nodeType);
          }
        }
        return types;
      }
      function createTypeIterator(config, reverse) {
        var fields = config.fields.slice();
        var contextName = config.context;
        var useContext = typeof contextName === "string";
        if (reverse) {
          fields.reverse();
        }
        return function (node, context, walk, walkReducer) {
          var prevContextValue;
          if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
          }
          for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];
            if (!field.nullable || ref) {
              if (field.type === "list") {
                var breakWalk = reverse
                  ? ref.reduceRight(walkReducer, false)
                  : ref.reduce(walkReducer, false);
                if (breakWalk) {
                  return true;
                }
              } else if (walk(ref)) {
                return true;
              }
            }
          }
          if (useContext) {
            context[contextName] = prevContextValue;
          }
        };
      }
      function createFastTraveralMap(iterators) {
        return {
          Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
          },
          Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
          },
          Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block,
            DeclarationList: iterators.DeclarationList,
          },
        };
      }
      module.exports = function createWalker(config) {
        var types = getTypesFromConfig(config);
        var iteratorsNatural = {};
        var iteratorsReverse = {};
        var breakWalk = Symbol("break-walk");
        var skipNode = Symbol("skip-node");
        for (var name in types) {
          if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
          }
        }
        var fastTraversalIteratorsNatural =
          createFastTraveralMap(iteratorsNatural);
        var fastTraversalIteratorsReverse =
          createFastTraveralMap(iteratorsReverse);
        var walk = function (root, options) {
          function walkNode(node, item, list) {
            var enterRet = enter.call(context, node, item, list);
            if (enterRet === breakWalk) {
              debugger;
              return true;
            }
            if (enterRet === skipNode) {
              return false;
            }
            if (iterators.hasOwnProperty(node.type)) {
              if (iterators[node.type](node, context, walkNode, walkReducer)) {
                return true;
              }
            }
            if (leave.call(context, node, item, list) === breakWalk) {
              return true;
            }
            return false;
          }
          var walkReducer = (ret, data, item, list) =>
            ret || walkNode(data, item, list);
          var enter = noop;
          var leave = noop;
          var iterators = iteratorsNatural;
          var context = {
            break: breakWalk,
            skip: skipNode,
            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null,
          };
          if (typeof options === "function") {
            enter = options;
          } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);
            if (options.reverse) {
              iterators = iteratorsReverse;
            }
            if (options.visit) {
              if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                iterators = options.reverse
                  ? fastTraversalIteratorsReverse[options.visit]
                  : fastTraversalIteratorsNatural[options.visit];
              } else if (!types.hasOwnProperty(options.visit)) {
                throw new Error(
                  "Bad value `" +
                    options.visit +
                    "` for `visit` option (should be: " +
                    Object.keys(types).join(", ") +
                    ")",
                );
              }
              enter = invokeForType(enter, options.visit);
              leave = invokeForType(leave, options.visit);
            }
          }
          if (enter === noop && leave === noop) {
            throw new Error(
              "Neither `enter` nor `leave` walker handler is set or both aren't a function",
            );
          }
          walkNode(root);
        };
        walk.break = breakWalk;
        walk.skip = skipNode;
        walk.find = function (ast, fn) {
          var found = null;
          walk(ast, function (node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          });
          return found;
        };
        walk.findLast = function (ast, fn) {
          var found = null;
          walk(ast, {
            reverse: true,
            enter: function (node, item, list) {
              if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
              }
            },
          });
          return found;
        };
        walk.findAll = function (ast, fn) {
          var found = [];
          walk(ast, function (node, item, list) {
            if (fn.call(this, node, item, list)) {
              found.push(node);
            }
          });
          return found;
        };
        return walk;
      };
    },
    527: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringify = exports.parse = exports.isTraversal = void 0;
      __exportStar(__nccwpck_require__(5834), exports);
      var parse_1 = __nccwpck_require__(5103);
      Object.defineProperty(exports, "isTraversal", {
        enumerable: true,
        get: function () {
          return parse_1.isTraversal;
        },
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function () {
          return parse_1.parse;
        },
      });
      var stringify_1 = __nccwpck_require__(4243);
      Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function () {
          return stringify_1.stringify;
        },
      });
    },
    5103: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = exports.isTraversal = void 0;
      var types_1 = __nccwpck_require__(5834);
      var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
      var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
      var actionTypes = new Map([
        [126, types_1.AttributeAction.Element],
        [94, types_1.AttributeAction.Start],
        [36, types_1.AttributeAction.End],
        [42, types_1.AttributeAction.Any],
        [33, types_1.AttributeAction.Not],
        [124, types_1.AttributeAction.Hyphen],
      ]);
      var unpackPseudos = new Set([
        "has",
        "not",
        "matches",
        "is",
        "where",
        "host",
        "host-context",
      ]);
      function isTraversal(selector) {
        switch (selector.type) {
          case types_1.SelectorType.Adjacent:
          case types_1.SelectorType.Child:
          case types_1.SelectorType.Descendant:
          case types_1.SelectorType.Parent:
          case types_1.SelectorType.Sibling:
          case types_1.SelectorType.ColumnCombinator:
            return true;
          default:
            return false;
        }
      }
      exports.isTraversal = isTraversal;
      var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
      function funescape(_, escaped, escapedWhitespace) {
        var high = parseInt(escaped, 16) - 65536;
        return high !== high || escapedWhitespace
          ? escaped
          : high < 0
            ? String.fromCharCode(high + 65536)
            : String.fromCharCode((high >> 10) | 55296, (high & 1023) | 56320);
      }
      function unescapeCSS(str) {
        return str.replace(reEscape, funescape);
      }
      function isQuote(c) {
        return c === 39 || c === 34;
      }
      function isWhitespace(c) {
        return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
      }
      function parse(selector) {
        var subselects = [];
        var endIndex = parseSelector(subselects, "".concat(selector), 0);
        if (endIndex < selector.length) {
          throw new Error(
            "Unmatched selector: ".concat(selector.slice(endIndex)),
          );
        }
        return subselects;
      }
      exports.parse = parse;
      function parseSelector(subselects, selector, selectorIndex) {
        var tokens = [];
        function getName(offset) {
          var match = selector.slice(selectorIndex + offset).match(reName);
          if (!match) {
            throw new Error(
              "Expected name, found ".concat(selector.slice(selectorIndex)),
            );
          }
          var name = match[0];
          selectorIndex += offset + name.length;
          return unescapeCSS(name);
        }
        function stripWhitespace(offset) {
          selectorIndex += offset;
          while (
            selectorIndex < selector.length &&
            isWhitespace(selector.charCodeAt(selectorIndex))
          ) {
            selectorIndex++;
          }
        }
        function readValueWithParenthesis() {
          selectorIndex += 1;
          var start = selectorIndex;
          var counter = 1;
          for (
            ;
            counter > 0 && selectorIndex < selector.length;
            selectorIndex++
          ) {
            if (
              selector.charCodeAt(selectorIndex) === 40 &&
              !isEscaped(selectorIndex)
            ) {
              counter++;
            } else if (
              selector.charCodeAt(selectorIndex) === 41 &&
              !isEscaped(selectorIndex)
            ) {
              counter--;
            }
          }
          if (counter) {
            throw new Error("Parenthesis not matched");
          }
          return unescapeCSS(selector.slice(start, selectorIndex - 1));
        }
        function isEscaped(pos) {
          var slashCount = 0;
          while (selector.charCodeAt(--pos) === 92) slashCount++;
          return (slashCount & 1) === 1;
        }
        function ensureNotTraversal() {
          if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
          }
        }
        function addTraversal(type) {
          if (
            tokens.length > 0 &&
            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant
          ) {
            tokens[tokens.length - 1].type = type;
            return;
          }
          ensureNotTraversal();
          tokens.push({ type });
        }
        function addSpecialAttribute(name, action) {
          tokens.push({
            type: types_1.SelectorType.Attribute,
            name,
            action,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks",
          });
        }
        function finalizeSubselector() {
          if (
            tokens.length &&
            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant
          ) {
            tokens.pop();
          }
          if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
          }
          subselects.push(tokens);
        }
        stripWhitespace(0);
        if (selector.length === selectorIndex) {
          return selectorIndex;
        }
        loop: while (selectorIndex < selector.length) {
          var firstChar = selector.charCodeAt(selectorIndex);
          switch (firstChar) {
            case 32:
            case 9:
            case 10:
            case 12:
            case 13: {
              if (
                tokens.length === 0 ||
                tokens[0].type !== types_1.SelectorType.Descendant
              ) {
                ensureNotTraversal();
                tokens.push({ type: types_1.SelectorType.Descendant });
              }
              stripWhitespace(1);
              break;
            }
            case 62: {
              addTraversal(types_1.SelectorType.Child);
              stripWhitespace(1);
              break;
            }
            case 60: {
              addTraversal(types_1.SelectorType.Parent);
              stripWhitespace(1);
              break;
            }
            case 126: {
              addTraversal(types_1.SelectorType.Sibling);
              stripWhitespace(1);
              break;
            }
            case 43: {
              addTraversal(types_1.SelectorType.Adjacent);
              stripWhitespace(1);
              break;
            }
            case 46: {
              addSpecialAttribute("class", types_1.AttributeAction.Element);
              break;
            }
            case 35: {
              addSpecialAttribute("id", types_1.AttributeAction.Equals);
              break;
            }
            case 91: {
              stripWhitespace(1);
              var name_1 = void 0;
              var namespace = null;
              if (selector.charCodeAt(selectorIndex) === 124) {
                name_1 = getName(1);
              } else if (selector.startsWith("*|", selectorIndex)) {
                namespace = "*";
                name_1 = getName(2);
              } else {
                name_1 = getName(0);
                if (
                  selector.charCodeAt(selectorIndex) === 124 &&
                  selector.charCodeAt(selectorIndex + 1) !== 61
                ) {
                  namespace = name_1;
                  name_1 = getName(1);
                }
              }
              stripWhitespace(0);
              var action = types_1.AttributeAction.Exists;
              var possibleAction = actionTypes.get(
                selector.charCodeAt(selectorIndex),
              );
              if (possibleAction) {
                action = possibleAction;
                if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                  throw new Error("Expected `=`");
                }
                stripWhitespace(2);
              } else if (selector.charCodeAt(selectorIndex) === 61) {
                action = types_1.AttributeAction.Equals;
                stripWhitespace(1);
              }
              var value = "";
              var ignoreCase = null;
              if (action !== "exists") {
                if (isQuote(selector.charCodeAt(selectorIndex))) {
                  var quote = selector.charCodeAt(selectorIndex);
                  var sectionEnd = selectorIndex + 1;
                  while (
                    sectionEnd < selector.length &&
                    (selector.charCodeAt(sectionEnd) !== quote ||
                      isEscaped(sectionEnd))
                  ) {
                    sectionEnd += 1;
                  }
                  if (selector.charCodeAt(sectionEnd) !== quote) {
                    throw new Error("Attribute value didn't end");
                  }
                  value = unescapeCSS(
                    selector.slice(selectorIndex + 1, sectionEnd),
                  );
                  selectorIndex = sectionEnd + 1;
                } else {
                  var valueStart = selectorIndex;
                  while (
                    selectorIndex < selector.length &&
                    ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                      selector.charCodeAt(selectorIndex) !== 93) ||
                      isEscaped(selectorIndex))
                  ) {
                    selectorIndex += 1;
                  }
                  value = unescapeCSS(
                    selector.slice(valueStart, selectorIndex),
                  );
                }
                stripWhitespace(0);
                var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
                if (forceIgnore === 115) {
                  ignoreCase = false;
                  stripWhitespace(1);
                } else if (forceIgnore === 105) {
                  ignoreCase = true;
                  stripWhitespace(1);
                }
              }
              if (selector.charCodeAt(selectorIndex) !== 93) {
                throw new Error("Attribute selector didn't terminate");
              }
              selectorIndex += 1;
              var attributeSelector = {
                type: types_1.SelectorType.Attribute,
                name: name_1,
                action,
                value,
                namespace,
                ignoreCase,
              };
              tokens.push(attributeSelector);
              break;
            }
            case 58: {
              if (selector.charCodeAt(selectorIndex + 1) === 58) {
                tokens.push({
                  type: types_1.SelectorType.PseudoElement,
                  name: getName(2).toLowerCase(),
                  data:
                    selector.charCodeAt(selectorIndex) === 40
                      ? readValueWithParenthesis()
                      : null,
                });
                continue;
              }
              var name_2 = getName(1).toLowerCase();
              var data = null;
              if (selector.charCodeAt(selectorIndex) === 40) {
                if (unpackPseudos.has(name_2)) {
                  if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                    throw new Error(
                      "Pseudo-selector ".concat(name_2, " cannot be quoted"),
                    );
                  }
                  data = [];
                  selectorIndex = parseSelector(
                    data,
                    selector,
                    selectorIndex + 1,
                  );
                  if (selector.charCodeAt(selectorIndex) !== 41) {
                    throw new Error(
                      "Missing closing parenthesis in :"
                        .concat(name_2, " (")
                        .concat(selector, ")"),
                    );
                  }
                  selectorIndex += 1;
                } else {
                  data = readValueWithParenthesis();
                  if (stripQuotesFromPseudos.has(name_2)) {
                    var quot = data.charCodeAt(0);
                    if (
                      quot === data.charCodeAt(data.length - 1) &&
                      isQuote(quot)
                    ) {
                      data = data.slice(1, -1);
                    }
                  }
                  data = unescapeCSS(data);
                }
              }
              tokens.push({
                type: types_1.SelectorType.Pseudo,
                name: name_2,
                data,
              });
              break;
            }
            case 44: {
              finalizeSubselector();
              tokens = [];
              stripWhitespace(1);
              break;
            }
            default: {
              if (selector.startsWith("/*", selectorIndex)) {
                var endIndex = selector.indexOf("*/", selectorIndex + 2);
                if (endIndex < 0) {
                  throw new Error("Comment was not terminated");
                }
                selectorIndex = endIndex + 2;
                if (tokens.length === 0) {
                  stripWhitespace(0);
                }
                break;
              }
              var namespace = null;
              var name_3 = void 0;
              if (firstChar === 42) {
                selectorIndex += 1;
                name_3 = "*";
              } else if (firstChar === 124) {
                name_3 = "";
                if (selector.charCodeAt(selectorIndex + 1) === 124) {
                  addTraversal(types_1.SelectorType.ColumnCombinator);
                  stripWhitespace(2);
                  break;
                }
              } else if (reName.test(selector.slice(selectorIndex))) {
                name_3 = getName(0);
              } else {
                break loop;
              }
              if (
                selector.charCodeAt(selectorIndex) === 124 &&
                selector.charCodeAt(selectorIndex + 1) !== 124
              ) {
                namespace = name_3;
                if (selector.charCodeAt(selectorIndex + 1) === 42) {
                  name_3 = "*";
                  selectorIndex += 2;
                } else {
                  name_3 = getName(1);
                }
              }
              tokens.push(
                name_3 === "*"
                  ? { type: types_1.SelectorType.Universal, namespace }
                  : { type: types_1.SelectorType.Tag, name: name_3, namespace },
              );
            }
          }
        }
        finalizeSubselector();
        return selectorIndex;
      }
    },
    4243: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __spreadArray =
        (this && this.__spreadArray) ||
        function (to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringify = void 0;
      var types_1 = __nccwpck_require__(5834);
      var attribValChars = ["\\", '"'];
      var pseudoValChars = __spreadArray(
        __spreadArray([], attribValChars, true),
        ["(", ")"],
        false,
      );
      var charsToEscapeInAttributeValue = new Set(
        attribValChars.map(function (c) {
          return c.charCodeAt(0);
        }),
      );
      var charsToEscapeInPseudoValue = new Set(
        pseudoValChars.map(function (c) {
          return c.charCodeAt(0);
        }),
      );
      var charsToEscapeInName = new Set(
        __spreadArray(
          __spreadArray([], pseudoValChars, true),
          ["~", "^", "$", "*", "+", "!", "|", ":", "[", "]", " ", "."],
          false,
        ).map(function (c) {
          return c.charCodeAt(0);
        }),
      );
      function stringify(selector) {
        return selector
          .map(function (token) {
            return token.map(stringifyToken).join("");
          })
          .join(", ");
      }
      exports.stringify = stringify;
      function stringifyToken(token, index, arr) {
        switch (token.type) {
          case types_1.SelectorType.Child:
            return index === 0 ? "> " : " > ";
          case types_1.SelectorType.Parent:
            return index === 0 ? "< " : " < ";
          case types_1.SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
          case types_1.SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
          case types_1.SelectorType.Descendant:
            return " ";
          case types_1.SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
          case types_1.SelectorType.Universal:
            return token.namespace === "*" &&
              index + 1 < arr.length &&
              "name" in arr[index + 1]
              ? ""
              : "".concat(getNamespace(token.namespace), "*");
          case types_1.SelectorType.Tag:
            return getNamespacedName(token);
          case types_1.SelectorType.PseudoElement:
            return "::"
              .concat(escapeName(token.name, charsToEscapeInName))
              .concat(
                token.data === null
                  ? ""
                  : "(".concat(
                      escapeName(token.data, charsToEscapeInPseudoValue),
                      ")",
                    ),
              );
          case types_1.SelectorType.Pseudo:
            return ":"
              .concat(escapeName(token.name, charsToEscapeInName))
              .concat(
                token.data === null
                  ? ""
                  : "(".concat(
                      typeof token.data === "string"
                        ? escapeName(token.data, charsToEscapeInPseudoValue)
                        : stringify(token.data),
                      ")",
                    ),
              );
          case types_1.SelectorType.Attribute: {
            if (
              token.name === "id" &&
              token.action === types_1.AttributeAction.Equals &&
              token.ignoreCase === "quirks" &&
              !token.namespace
            ) {
              return "#".concat(escapeName(token.value, charsToEscapeInName));
            }
            if (
              token.name === "class" &&
              token.action === types_1.AttributeAction.Element &&
              token.ignoreCase === "quirks" &&
              !token.namespace
            ) {
              return ".".concat(escapeName(token.value, charsToEscapeInName));
            }
            var name_1 = getNamespacedName(token);
            if (token.action === types_1.AttributeAction.Exists) {
              return "[".concat(name_1, "]");
            }
            return "["
              .concat(name_1)
              .concat(getActionValue(token.action), '="')
              .concat(
                escapeName(token.value, charsToEscapeInAttributeValue),
                '"',
              )
              .concat(
                token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s",
                "]",
              );
          }
        }
      }
      function getActionValue(action) {
        switch (action) {
          case types_1.AttributeAction.Equals:
            return "";
          case types_1.AttributeAction.Element:
            return "~";
          case types_1.AttributeAction.Start:
            return "^";
          case types_1.AttributeAction.End:
            return "$";
          case types_1.AttributeAction.Any:
            return "*";
          case types_1.AttributeAction.Not:
            return "!";
          case types_1.AttributeAction.Hyphen:
            return "|";
          case types_1.AttributeAction.Exists:
            throw new Error("Shouldn't be here");
        }
      }
      function getNamespacedName(token) {
        return ""
          .concat(getNamespace(token.namespace))
          .concat(escapeName(token.name, charsToEscapeInName));
      }
      function getNamespace(namespace) {
        return namespace !== null
          ? "".concat(
              namespace === "*"
                ? "*"
                : escapeName(namespace, charsToEscapeInName),
              "|",
            )
          : "";
      }
      function escapeName(str, charsToEscape) {
        var lastIdx = 0;
        var ret = "";
        for (var i = 0; i < str.length; i++) {
          if (charsToEscape.has(str.charCodeAt(i))) {
            ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
            lastIdx = i + 1;
          }
        }
        return ret.length > 0 ? ret + str.slice(lastIdx) : str;
      }
    },
    5834: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AttributeAction =
        exports.IgnoreCaseMode =
        exports.SelectorType =
          void 0;
      var SelectorType;
      (function (SelectorType) {
        SelectorType["Attribute"] = "attribute";
        SelectorType["Pseudo"] = "pseudo";
        SelectorType["PseudoElement"] = "pseudo-element";
        SelectorType["Tag"] = "tag";
        SelectorType["Universal"] = "universal";
        SelectorType["Adjacent"] = "adjacent";
        SelectorType["Child"] = "child";
        SelectorType["Descendant"] = "descendant";
        SelectorType["Parent"] = "parent";
        SelectorType["Sibling"] = "sibling";
        SelectorType["ColumnCombinator"] = "column-combinator";
      })((SelectorType = exports.SelectorType || (exports.SelectorType = {})));
      exports.IgnoreCaseMode = {
        Unknown: null,
        QuirksMode: "quirks",
        IgnoreCase: true,
        CaseSensitive: false,
      };
      var AttributeAction;
      (function (AttributeAction) {
        AttributeAction["Any"] = "any";
        AttributeAction["Element"] = "element";
        AttributeAction["End"] = "end";
        AttributeAction["Equals"] = "equals";
        AttributeAction["Exists"] = "exists";
        AttributeAction["Hyphen"] = "hyphen";
        AttributeAction["Not"] = "not";
        AttributeAction["Start"] = "start";
      })(
        (AttributeAction =
          exports.AttributeAction || (exports.AttributeAction = {})),
      );
    },
    6652: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var resolveKeyword = __nccwpck_require__(4895).keyword;
      var { hasNoChildren } = __nccwpck_require__(36);
      module.exports = function cleanAtrule(node, item, list) {
        if (node.block) {
          if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
          }
          if (hasNoChildren(node.block)) {
            list.remove(item);
            return;
          }
        }
        switch (node.name) {
          case "charset":
            if (hasNoChildren(node.prelude)) {
              list.remove(item);
              return;
            }
            if (item.prev) {
              list.remove(item);
              return;
            }
            break;
          case "import":
            if (
              this.stylesheet === null ||
              !this.stylesheet.firstAtrulesAllowed
            ) {
              list.remove(item);
              return;
            }
            list.prevUntil(
              item.prev,
              function (rule) {
                if (rule.type === "Atrule") {
                  if (rule.name === "import" || rule.name === "charset") {
                    return;
                  }
                }
                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
              },
              this,
            );
            break;
          default:
            var name = resolveKeyword(node.name).basename;
            if (
              name === "keyframes" ||
              name === "media" ||
              name === "supports"
            ) {
              if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
                list.remove(item);
              }
            }
        }
      };
    },
    1805: (module) => {
      module.exports = function cleanComment(data, item, list) {
        list.remove(item);
      };
    },
    7183: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var property = __nccwpck_require__(4895).property;
      module.exports = function cleanDeclartion(node, item, list) {
        if (node.value.children && node.value.children.isEmpty()) {
          list.remove(item);
          return;
        }
        if (property(node.property).custom) {
          if (/\S/.test(node.value.value)) {
            node.value.value = node.value.value.trim();
          }
        }
      };
    },
    2930: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var { isNodeChildrenList } = __nccwpck_require__(36);
      module.exports = function cleanRaw(node, item, list) {
        if (
          isNodeChildrenList(this.stylesheet, list) ||
          isNodeChildrenList(this.block, list)
        ) {
          list.remove(item);
        }
      };
    },
    1859: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var walk = __nccwpck_require__(4895).walk;
      var { hasNoChildren } = __nccwpck_require__(36);
      function cleanUnused(selectorList, usageData) {
        selectorList.children.each(function (selector, item, list) {
          var shouldRemove = false;
          walk(selector, function (node) {
            if (this.selector === null || this.selector === selectorList) {
              switch (node.type) {
                case "SelectorList":
                  if (
                    this.function === null ||
                    this.function.name.toLowerCase() !== "not"
                  ) {
                    if (cleanUnused(node, usageData)) {
                      shouldRemove = true;
                    }
                  }
                  break;
                case "ClassSelector":
                  if (
                    usageData.whitelist !== null &&
                    usageData.whitelist.classes !== null &&
                    !hasOwnProperty.call(usageData.whitelist.classes, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  if (
                    usageData.blacklist !== null &&
                    usageData.blacklist.classes !== null &&
                    hasOwnProperty.call(usageData.blacklist.classes, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  break;
                case "IdSelector":
                  if (
                    usageData.whitelist !== null &&
                    usageData.whitelist.ids !== null &&
                    !hasOwnProperty.call(usageData.whitelist.ids, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  if (
                    usageData.blacklist !== null &&
                    usageData.blacklist.ids !== null &&
                    hasOwnProperty.call(usageData.blacklist.ids, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  break;
                case "TypeSelector":
                  if (node.name.charAt(node.name.length - 1) !== "*") {
                    if (
                      usageData.whitelist !== null &&
                      usageData.whitelist.tags !== null &&
                      !hasOwnProperty.call(
                        usageData.whitelist.tags,
                        node.name.toLowerCase(),
                      )
                    ) {
                      shouldRemove = true;
                    }
                    if (
                      usageData.blacklist !== null &&
                      usageData.blacklist.tags !== null &&
                      hasOwnProperty.call(
                        usageData.blacklist.tags,
                        node.name.toLowerCase(),
                      )
                    ) {
                      shouldRemove = true;
                    }
                  }
                  break;
              }
            }
          });
          if (shouldRemove) {
            list.remove(item);
          }
        });
        return selectorList.children.isEmpty();
      }
      module.exports = function cleanRule(node, item, list, options) {
        if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
          list.remove(item);
          return;
        }
        var usageData = options.usage;
        if (
          usageData &&
          (usageData.whitelist !== null || usageData.blacklist !== null)
        ) {
          cleanUnused(node.prelude, usageData);
          if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
          }
        }
      };
    },
    4502: (module) => {
      module.exports = function cleanTypeSelector(node, item, list) {
        var name = item.data.name;
        if (name !== "*") {
          return;
        }
        var nextType = item.next && item.next.data.type;
        if (
          nextType === "IdSelector" ||
          nextType === "ClassSelector" ||
          nextType === "AttributeSelector" ||
          nextType === "PseudoClassSelector" ||
          nextType === "PseudoElementSelector"
        ) {
          list.remove(item);
        }
      };
    },
    6484: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var { isNodeChildrenList } = __nccwpck_require__(36);
      function isSafeOperator(node) {
        return (
          node.type === "Operator" && node.value !== "+" && node.value !== "-"
        );
      }
      module.exports = function cleanWhitespace(node, item, list) {
        if (item.next === null || item.prev === null) {
          list.remove(item);
          return;
        }
        if (
          isNodeChildrenList(this.stylesheet, list) ||
          isNodeChildrenList(this.block, list)
        ) {
          list.remove(item);
          return;
        }
        if (item.next.data.type === "WhiteSpace") {
          list.remove(item);
          return;
        }
        if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
          list.remove(item);
          return;
        }
      };
    },
    3842: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var walk = __nccwpck_require__(4895).walk;
      var handlers = {
        Atrule: __nccwpck_require__(6652),
        Comment: __nccwpck_require__(1805),
        Declaration: __nccwpck_require__(7183),
        Raw: __nccwpck_require__(2930),
        Rule: __nccwpck_require__(1859),
        TypeSelector: __nccwpck_require__(4502),
        WhiteSpace: __nccwpck_require__(6484),
      };
      module.exports = function (ast, options) {
        walk(ast, {
          leave: function (node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
              handlers[node.type].call(this, node, item, list, options);
            }
          },
        });
      };
    },
    36: (module) => {
      module.exports = {
        hasNoChildren: function (node) {
          return !node || !node.children || node.children.isEmpty();
        },
        isNodeChildrenList: function (node, list) {
          return node !== null && node.children === list;
        },
      };
    },
    6956: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(4895).List;
      var clone = __nccwpck_require__(4895).clone;
      var usageUtils = __nccwpck_require__(245);
      var clean = __nccwpck_require__(3842);
      var replace = __nccwpck_require__(4454);
      var restructure = __nccwpck_require__(2640);
      var walk = __nccwpck_require__(4895).walk;
      function readChunk(children, specialComments) {
        var buffer = new List();
        var nonSpaceTokenInBuffer = false;
        var protectedComment;
        children.nextUntil(children.head, function (node, item, list) {
          if (node.type === "Comment") {
            if (!specialComments || node.value.charAt(0) !== "!") {
              list.remove(item);
              return;
            }
            if (nonSpaceTokenInBuffer || protectedComment) {
              return true;
            }
            list.remove(item);
            protectedComment = node;
            return;
          }
          if (node.type !== "WhiteSpace") {
            nonSpaceTokenInBuffer = true;
          }
          buffer.insert(list.remove(item));
        });
        return {
          comment: protectedComment,
          stylesheet: { type: "StyleSheet", loc: null, children: buffer },
        };
      }
      function compressChunk(ast, firstAtrulesAllowed, num, options) {
        options.logger("Compress block #" + num, null, true);
        var seed = 1;
        if (ast.type === "StyleSheet") {
          ast.firstAtrulesAllowed = firstAtrulesAllowed;
          ast.id = seed++;
        }
        walk(ast, {
          visit: "Atrule",
          enter: function markScopes(node) {
            if (node.block !== null) {
              node.block.id = seed++;
            }
          },
        });
        options.logger("init", ast);
        clean(ast, options);
        options.logger("clean", ast);
        replace(ast, options);
        options.logger("replace", ast);
        if (options.restructuring) {
          restructure(ast, options);
        }
        return ast;
      }
      function getCommentsOption(options) {
        var comments = "comments" in options ? options.comments : "exclamation";
        if (typeof comments === "boolean") {
          comments = comments ? "exclamation" : false;
        } else if (
          comments !== "exclamation" &&
          comments !== "first-exclamation"
        ) {
          comments = false;
        }
        return comments;
      }
      function getRestructureOption(options) {
        if ("restructure" in options) {
          return options.restructure;
        }
        return "restructuring" in options ? options.restructuring : true;
      }
      function wrapBlock(block) {
        return new List().appendData({
          type: "Rule",
          loc: null,
          prelude: {
            type: "SelectorList",
            loc: null,
            children: new List().appendData({
              type: "Selector",
              loc: null,
              children: new List().appendData({
                type: "TypeSelector",
                loc: null,
                name: "x",
              }),
            }),
          },
          block,
        });
      }
      module.exports = function compress(ast, options) {
        ast = ast || { type: "StyleSheet", loc: null, children: new List() };
        options = options || {};
        var compressOptions = {
          logger:
            typeof options.logger === "function"
              ? options.logger
              : function () {},
          restructuring: getRestructureOption(options),
          forceMediaMerge: Boolean(options.forceMediaMerge),
          usage: options.usage ? usageUtils.buildIndex(options.usage) : false,
        };
        var specialComments = getCommentsOption(options);
        var firstAtrulesAllowed = true;
        var input;
        var output = new List();
        var chunk;
        var chunkNum = 1;
        var chunkChildren;
        if (options.clone) {
          ast = clone(ast);
        }
        if (ast.type === "StyleSheet") {
          input = ast.children;
          ast.children = output;
        } else {
          input = wrapBlock(ast);
        }
        do {
          chunk = readChunk(input, Boolean(specialComments));
          compressChunk(
            chunk.stylesheet,
            firstAtrulesAllowed,
            chunkNum++,
            compressOptions,
          );
          chunkChildren = chunk.stylesheet.children;
          if (chunk.comment) {
            if (!output.isEmpty()) {
              output.insert(List.createItem({ type: "Raw", value: "\n" }));
            }
            output.insert(List.createItem(chunk.comment));
            if (!chunkChildren.isEmpty()) {
              output.insert(List.createItem({ type: "Raw", value: "\n" }));
            }
          }
          if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
            var lastRule = chunkChildren.last();
            if (
              lastRule.type !== "Atrule" ||
              (lastRule.name !== "import" && lastRule.name !== "charset")
            ) {
              firstAtrulesAllowed = false;
            }
          }
          if (specialComments !== "exclamation") {
            specialComments = false;
          }
          output.appendList(chunkChildren);
        } while (!input.isEmpty());
        return { ast };
      };
    },
    3027: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var csstree = __nccwpck_require__(4895);
      var parse = csstree.parse;
      var compress = __nccwpck_require__(6956);
      var generate = csstree.generate;
      function debugOutput(name, options, startTime, data) {
        if (options.debug) {
          console.error(
            "## " + name + " done in %d ms\n",
            Date.now() - startTime,
          );
        }
        return data;
      }
      function createDefaultLogger(level) {
        var lastDebug;
        return function logger(title, ast) {
          var line = title;
          if (ast) {
            line =
              "[" + ((Date.now() - lastDebug) / 1e3).toFixed(3) + "s] " + line;
          }
          if (level > 1 && ast) {
            var css = generate(ast);
            if (level === 2 && css.length > 256) {
              css = css.substr(0, 256) + "...";
            }
            line += "\n  " + css + "\n";
          }
          console.error(line);
          lastDebug = Date.now();
        };
      }
      function copy(obj) {
        var result = {};
        for (var key in obj) {
          result[key] = obj[key];
        }
        return result;
      }
      function buildCompressOptions(options) {
        options = copy(options);
        if (typeof options.logger !== "function" && options.debug) {
          options.logger = createDefaultLogger(options.debug);
        }
        return options;
      }
      function runHandler(ast, options, handlers) {
        if (!Array.isArray(handlers)) {
          handlers = [handlers];
        }
        handlers.forEach(function (fn) {
          fn(ast, options);
        });
      }
      function minify(context, source, options) {
        options = options || {};
        var filename = options.filename || "<unknown>";
        var result;
        var ast = debugOutput(
          "parsing",
          options,
          Date.now(),
          parse(source, {
            context,
            filename,
            positions: Boolean(options.sourceMap),
          }),
        );
        if (options.beforeCompress) {
          debugOutput(
            "beforeCompress",
            options,
            Date.now(),
            runHandler(ast, options, options.beforeCompress),
          );
        }
        var compressResult = debugOutput(
          "compress",
          options,
          Date.now(),
          compress(ast, buildCompressOptions(options)),
        );
        if (options.afterCompress) {
          debugOutput(
            "afterCompress",
            options,
            Date.now(),
            runHandler(compressResult, options, options.afterCompress),
          );
        }
        if (options.sourceMap) {
          result = debugOutput(
            "generate(sourceMap: true)",
            options,
            Date.now(),
            (function () {
              var tmp = generate(compressResult.ast, { sourceMap: true });
              tmp.map._file = filename;
              tmp.map.setSourceContent(filename, source);
              return tmp;
            })(),
          );
        } else {
          result = debugOutput("generate", options, Date.now(), {
            css: generate(compressResult.ast),
            map: null,
          });
        }
        return result;
      }
      function minifyStylesheet(source, options) {
        return minify("stylesheet", source, options);
      }
      function minifyBlock(source, options) {
        return minify("declarationList", source, options);
      }
      module.exports = {
        version: __nccwpck_require__(3684).version,
        minify: minifyStylesheet,
        minifyBlock,
        syntax: Object.assign({ compress }, csstree),
      };
    },
    9293: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var resolveKeyword = __nccwpck_require__(4895).keyword;
      var compressKeyframes = __nccwpck_require__(6134);
      module.exports = function (node) {
        if (resolveKeyword(node.name).basename === "keyframes") {
          compressKeyframes(node);
        }
      };
    },
    6454: (module) => {
      var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
      var blockUnquoteRx =
        /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
      function canUnquote(value) {
        if (value === "" || value === "-") {
          return;
        }
        value = value.replace(escapesRx, "a");
        return !blockUnquoteRx.test(value);
      }
      module.exports = function (node) {
        var attrValue = node.value;
        if (!attrValue || attrValue.type !== "String") {
          return;
        }
        var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, "$2");
        if (canUnquote(unquotedValue)) {
          node.value = {
            type: "Identifier",
            loc: attrValue.loc,
            name: unquotedValue,
          };
        }
      };
    },
    7714: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var packNumber = __nccwpck_require__(9190).pack;
      var MATH_FUNCTIONS = { calc: true, min: true, max: true, clamp: true };
      var LENGTH_UNIT = {
        px: true,
        mm: true,
        cm: true,
        in: true,
        pt: true,
        pc: true,
        em: true,
        ex: true,
        ch: true,
        rem: true,
        vh: true,
        vw: true,
        vmin: true,
        vmax: true,
        vm: true,
      };
      module.exports = function compressDimension(node, item) {
        var value = packNumber(node.value, item);
        node.value = value;
        if (
          value === "0" &&
          this.declaration !== null &&
          this.atrulePrelude === null
        ) {
          var unit = node.unit.toLowerCase();
          if (!LENGTH_UNIT.hasOwnProperty(unit)) {
            return;
          }
          if (
            this.declaration.property === "-ms-flex" ||
            this.declaration.property === "flex"
          ) {
            return;
          }
          if (
            this.function &&
            MATH_FUNCTIONS.hasOwnProperty(this.function.name)
          ) {
            return;
          }
          item.data = { type: "Number", loc: node.loc, value };
        }
      };
    },
    9190: (module) => {
      var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
      var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
      var unsafeToRemovePlusSignAfter = {
        Dimension: true,
        Hash: true,
        Identifier: true,
        Number: true,
        Raw: true,
        UnicodeRange: true,
      };
      function packNumber(value, item) {
        var regexp =
          item &&
          item.prev !== null &&
          unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type)
            ? KEEP_PLUSSIGN
            : OMIT_PLUSSIGN;
        value = String(value).replace(regexp, "$1$2$3");
        if (value === "" || value === "-") {
          value = "0";
        }
        return value;
      }
      module.exports = function (node, item) {
        node.value = packNumber(node.value, item);
      };
      module.exports.pack = packNumber;
    },
    7559: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var lexer = __nccwpck_require__(4895).lexer;
      var packNumber = __nccwpck_require__(9190).pack;
      var blacklist = new Set([
        "width",
        "min-width",
        "max-width",
        "height",
        "min-height",
        "max-height",
        "flex",
        "-ms-flex",
      ]);
      module.exports = function compressPercentage(node, item) {
        node.value = packNumber(node.value, item);
        if (
          node.value === "0" &&
          this.declaration &&
          !blacklist.has(this.declaration.property)
        ) {
          item.data = { type: "Number", loc: node.loc, value: node.value };
          if (
            !lexer
              .matchDeclaration(this.declaration)
              .isType(item.data, "length")
          ) {
            item.data = node;
          }
        }
      };
    },
    4202: (module) => {
      module.exports = function (node) {
        var value = node.value;
        value = value.replace(/\\(\r\n|\r|\n|\f)/g, "");
        node.value = value;
      };
    },
    1598: (module) => {
      var UNICODE = "\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?";
      var ESCAPE = "(" + UNICODE + "|\\\\[^\\n\\r\\f0-9a-fA-F])";
      var NONPRINTABLE = "\0\b\v-";
      var SAFE_URL = new RegExp(
        "^(" + ESCAPE + "|[^\"'\\(\\)\\\\\\s" + NONPRINTABLE + "])*$",
        "i",
      );
      module.exports = function (node) {
        var value = node.value;
        if (value.type !== "String") {
          return;
        }
        var quote = value.value[0];
        var url = value.value.substr(1, value.value.length - 2);
        url = url.replace(/\\\\/g, "/");
        if (SAFE_URL.test(url)) {
          node.value = { type: "Raw", loc: node.value.loc, value: url };
        } else {
          node.value.value =
            url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
        }
      };
    },
    8881: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var resolveName = __nccwpck_require__(4895).property;
      var handlers = {
        font: __nccwpck_require__(6385),
        "font-weight": __nccwpck_require__(2716),
        background: __nccwpck_require__(4194),
        border: __nccwpck_require__(4750),
        outline: __nccwpck_require__(4750),
      };
      module.exports = function compressValue(node) {
        if (!this.declaration) {
          return;
        }
        var property = resolveName(this.declaration.property);
        if (handlers.hasOwnProperty(property.basename)) {
          handlers[property.basename](node);
        }
      };
    },
    6134: (module) => {
      module.exports = function (node) {
        node.block.children.each(function (rule) {
          rule.prelude.children.each(function (simpleselector) {
            simpleselector.children.each(function (data, item) {
              if (data.type === "Percentage" && data.value === "100") {
                item.data = { type: "TypeSelector", loc: data.loc, name: "to" };
              } else if (data.type === "TypeSelector" && data.name === "from") {
                item.data = { type: "Percentage", loc: data.loc, value: "0" };
              }
            });
          });
        });
      };
    },
    2437: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var lexer = __nccwpck_require__(4895).lexer;
      var packNumber = __nccwpck_require__(9190).pack;
      var NAME_TO_HEX = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgrey: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        grey: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "639",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32",
      };
      var HEX_TO_NAME = {
        8e5: "maroon",
        800080: "purple",
        808e3: "olive",
        808080: "gray",
        "00ffff": "cyan",
        f0ffff: "azure",
        f5f5dc: "beige",
        ffe4c4: "bisque",
        "000000": "black",
        "0000ff": "blue",
        a52a2a: "brown",
        ff7f50: "coral",
        ffd700: "gold",
        "008000": "green",
        "4b0082": "indigo",
        fffff0: "ivory",
        f0e68c: "khaki",
        "00ff00": "lime",
        faf0e6: "linen",
        "000080": "navy",
        ffa500: "orange",
        da70d6: "orchid",
        cd853f: "peru",
        ffc0cb: "pink",
        dda0dd: "plum",
        f00: "red",
        ff0000: "red",
        fa8072: "salmon",
        a0522d: "sienna",
        c0c0c0: "silver",
        fffafa: "snow",
        d2b48c: "tan",
        "008080": "teal",
        ff6347: "tomato",
        ee82ee: "violet",
        f5deb3: "wheat",
        ffffff: "white",
        ffff00: "yellow",
      };
      function hueToRgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      }
      function hslToRgb(h, s, l, a) {
        var r;
        var g;
        var b;
        if (s === 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hueToRgb(p, q, h + 1 / 3);
          g = hueToRgb(p, q, h);
          b = hueToRgb(p, q, h - 1 / 3);
        }
        return [
          Math.round(r * 255),
          Math.round(g * 255),
          Math.round(b * 255),
          a,
        ];
      }
      function toHex(value) {
        value = value.toString(16);
        return value.length === 1 ? "0" + value : value;
      }
      function parseFunctionArgs(functionArgs, count, rgb) {
        var cursor = functionArgs.head;
        var args = [];
        var wasValue = false;
        while (cursor !== null) {
          var node = cursor.data;
          var type = node.type;
          switch (type) {
            case "Number":
            case "Percentage":
              if (wasValue) {
                return;
              }
              wasValue = true;
              args.push({ type, value: Number(node.value) });
              break;
            case "Operator":
              if (node.value === ",") {
                if (!wasValue) {
                  return;
                }
                wasValue = false;
              } else if (wasValue || node.value !== "+") {
                return;
              }
              break;
            default:
              return;
          }
          cursor = cursor.next;
        }
        if (args.length !== count) {
          return;
        }
        if (args.length === 4) {
          if (args[3].type !== "Number") {
            return;
          }
          args[3].type = "Alpha";
        }
        if (rgb) {
          if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            return;
          }
        } else {
          if (
            args[0].type !== "Number" ||
            args[1].type !== "Percentage" ||
            args[2].type !== "Percentage"
          ) {
            return;
          }
          args[0].type = "Angle";
        }
        return args.map(function (arg) {
          var value = Math.max(0, arg.value);
          switch (arg.type) {
            case "Number":
              value = Math.min(value, 255);
              break;
            case "Percentage":
              value = Math.min(value, 100) / 100;
              if (!rgb) {
                return value;
              }
              value = 255 * value;
              break;
            case "Angle":
              return (((value % 360) + 360) % 360) / 360;
            case "Alpha":
              return Math.min(value, 1);
          }
          return Math.round(value);
        });
      }
      function compressFunction(node, item, list) {
        var functionName = node.name;
        var args;
        if (functionName === "rgba" || functionName === "hsla") {
          args = parseFunctionArgs(node.children, 4, functionName === "rgba");
          if (!args) {
            return;
          }
          if (functionName === "hsla") {
            args = hslToRgb.apply(null, args);
            node.name = "rgba";
          }
          if (args[3] === 0) {
            var scopeFunctionName = this.function && this.function.name;
            if (
              (args[0] === 0 && args[1] === 0 && args[2] === 0) ||
              !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)
            ) {
              item.data = {
                type: "Identifier",
                loc: node.loc,
                name: "transparent",
              };
              return;
            }
          }
          if (args[3] !== 1) {
            node.children.each(function (node, item, list) {
              if (node.type === "Operator") {
                if (node.value !== ",") {
                  list.remove(item);
                }
                return;
              }
              item.data = {
                type: "Number",
                loc: node.loc,
                value: packNumber(args.shift(), null),
              };
            });
            return;
          }
          functionName = "rgb";
        }
        if (functionName === "hsl") {
          args = args || parseFunctionArgs(node.children, 3, false);
          if (!args) {
            return;
          }
          args = hslToRgb.apply(null, args);
          functionName = "rgb";
        }
        if (functionName === "rgb") {
          args = args || parseFunctionArgs(node.children, 3, true);
          if (!args) {
            return;
          }
          var next = item.next;
          if (next && next.data.type !== "WhiteSpace") {
            list.insert(
              list.createItem({ type: "WhiteSpace", value: " " }),
              next,
            );
          }
          item.data = {
            type: "Hash",
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2]),
          };
          compressHex(item.data, item);
        }
      }
      function compressIdent(node, item) {
        if (this.declaration === null) {
          return;
        }
        var color = node.name.toLowerCase();
        if (
          NAME_TO_HEX.hasOwnProperty(color) &&
          lexer.matchDeclaration(this.declaration).isType(node, "color")
        ) {
          var hex = NAME_TO_HEX[color];
          if (hex.length + 1 <= color.length) {
            item.data = { type: "Hash", loc: node.loc, value: hex };
          } else {
            if (color === "grey") {
              color = "gray";
            }
            node.name = color;
          }
        }
      }
      function compressHex(node, item) {
        var color = node.value.toLowerCase();
        if (
          color.length === 6 &&
          color[0] === color[1] &&
          color[2] === color[3] &&
          color[4] === color[5]
        ) {
          color = color[0] + color[2] + color[4];
        }
        if (HEX_TO_NAME[color]) {
          item.data = {
            type: "Identifier",
            loc: node.loc,
            name: HEX_TO_NAME[color],
          };
        } else {
          node.value = color;
        }
      }
      module.exports = { compressFunction, compressIdent, compressHex };
    },
    4454: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var walk = __nccwpck_require__(4895).walk;
      var handlers = {
        Atrule: __nccwpck_require__(9293),
        AttributeSelector: __nccwpck_require__(6454),
        Value: __nccwpck_require__(8881),
        Dimension: __nccwpck_require__(7714),
        Percentage: __nccwpck_require__(7559),
        Number: __nccwpck_require__(9190),
        String: __nccwpck_require__(4202),
        Url: __nccwpck_require__(1598),
        Hash: __nccwpck_require__(2437).compressHex,
        Identifier: __nccwpck_require__(2437).compressIdent,
        Function: __nccwpck_require__(2437).compressFunction,
      };
      module.exports = function (ast) {
        walk(ast, {
          leave: function (node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
              handlers[node.type].call(this, node, item, list);
            }
          },
        });
      };
    },
    4194: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(4895).List;
      module.exports = function compressBackground(node) {
        function lastType() {
          if (buffer.length) {
            return buffer[buffer.length - 1].type;
          }
        }
        function flush() {
          if (lastType() === "WhiteSpace") {
            buffer.pop();
          }
          if (!buffer.length) {
            buffer.unshift(
              { type: "Number", loc: null, value: "0" },
              { type: "WhiteSpace", value: " " },
              { type: "Number", loc: null, value: "0" },
            );
          }
          newValue.push.apply(newValue, buffer);
          buffer = [];
        }
        var newValue = [];
        var buffer = [];
        node.children.each(function (node) {
          if (node.type === "Operator" && node.value === ",") {
            flush();
            newValue.push(node);
            return;
          }
          if (node.type === "Identifier") {
            if (
              node.name === "transparent" ||
              node.name === "none" ||
              node.name === "repeat" ||
              node.name === "scroll"
            ) {
              return;
            }
          }
          if (
            node.type === "WhiteSpace" &&
            (!buffer.length || lastType() === "WhiteSpace")
          ) {
            return;
          }
          buffer.push(node);
        });
        flush();
        node.children = new List().fromArray(newValue);
      };
    },
    4750: (module) => {
      function removeItemAndRedundantWhiteSpace(list, item) {
        var prev = item.prev;
        var next = item.next;
        if (next !== null) {
          if (
            next.data.type === "WhiteSpace" &&
            (prev === null || prev.data.type === "WhiteSpace")
          ) {
            list.remove(next);
          }
        } else if (prev !== null && prev.data.type === "WhiteSpace") {
          list.remove(prev);
        }
        list.remove(item);
      }
      module.exports = function compressBorder(node) {
        node.children.each(function (node, item, list) {
          if (
            node.type === "Identifier" &&
            node.name.toLowerCase() === "none"
          ) {
            if (list.head === list.tail) {
              item.data = { type: "Number", loc: node.loc, value: "0" };
            } else {
              removeItemAndRedundantWhiteSpace(list, item);
            }
          }
        });
      };
    },
    2716: (module) => {
      module.exports = function compressFontWeight(node) {
        var value = node.children.head.data;
        if (value.type === "Identifier") {
          switch (value.name) {
            case "normal":
              node.children.head.data = {
                type: "Number",
                loc: value.loc,
                value: "400",
              };
              break;
            case "bold":
              node.children.head.data = {
                type: "Number",
                loc: value.loc,
                value: "700",
              };
              break;
          }
        }
      };
    },
    6385: (module) => {
      module.exports = function compressFont(node) {
        var list = node.children;
        list.eachRight(function (node, item) {
          if (node.type === "Identifier") {
            if (node.name === "bold") {
              item.data = { type: "Number", loc: node.loc, value: "700" };
            } else if (node.name === "normal") {
              var prev = item.prev;
              if (
                prev &&
                prev.data.type === "Operator" &&
                prev.data.value === "/"
              ) {
                this.remove(prev);
              }
              this.remove(item);
            } else if (node.name === "medium") {
              var next = item.next;
              if (!next || next.data.type !== "Operator") {
                this.remove(item);
              }
            }
          }
        });
        list.each(function (node, item) {
          if (node.type === "WhiteSpace") {
            if (
              !item.prev ||
              !item.next ||
              item.next.data.type === "WhiteSpace"
            ) {
              this.remove(item);
            }
          }
        });
        if (list.isEmpty()) {
          list.insert(list.createItem({ type: "Identifier", name: "normal" }));
        }
      };
    },
    6372: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(4895).List;
      var resolveKeyword = __nccwpck_require__(4895).keyword;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var walk = __nccwpck_require__(4895).walk;
      function addRuleToMap(map, item, list, single) {
        var node = item.data;
        var name = resolveKeyword(node.name).basename;
        var id =
          node.name.toLowerCase() +
          "/" +
          (node.prelude ? node.prelude.id : null);
        if (!hasOwnProperty.call(map, name)) {
          map[name] = Object.create(null);
        }
        if (single) {
          delete map[name][id];
        }
        if (!hasOwnProperty.call(map[name], id)) {
          map[name][id] = new List();
        }
        map[name][id].append(list.remove(item));
      }
      function relocateAtrules(ast, options) {
        var collected = Object.create(null);
        var topInjectPoint = null;
        ast.children.each(function (node, item, list) {
          if (node.type === "Atrule") {
            var name = resolveKeyword(node.name).basename;
            switch (name) {
              case "keyframes":
                addRuleToMap(collected, item, list, true);
                return;
              case "media":
                if (options.forceMediaMerge) {
                  addRuleToMap(collected, item, list, false);
                  return;
                }
                break;
            }
            if (
              topInjectPoint === null &&
              name !== "charset" &&
              name !== "import"
            ) {
              topInjectPoint = item;
            }
          } else {
            if (topInjectPoint === null) {
              topInjectPoint = item;
            }
          }
        });
        for (var atrule in collected) {
          for (var id in collected[atrule]) {
            ast.children.insertList(
              collected[atrule][id],
              atrule === "media" ? null : topInjectPoint,
            );
          }
        }
      }
      function isMediaRule(node) {
        return node.type === "Atrule" && node.name === "media";
      }
      function processAtrule(node, item, list) {
        if (!isMediaRule(node)) {
          return;
        }
        var prev = item.prev && item.prev.data;
        if (!prev || !isMediaRule(prev)) {
          return;
        }
        if (
          node.prelude &&
          prev.prelude &&
          node.prelude.id === prev.prelude.id
        ) {
          prev.block.children.appendList(node.block.children);
          list.remove(item);
        }
      }
      module.exports = function rejoinAtrule(ast, options) {
        relocateAtrules(ast, options);
        walk(ast, { visit: "Atrule", reverse: true, enter: processAtrule });
      };
    },
    3905: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var walk = __nccwpck_require__(4895).walk;
      var utils = __nccwpck_require__(2851);
      function processRule(node, item, list) {
        var selectors = node.prelude.children;
        var declarations = node.block.children;
        list.prevUntil(item.prev, function (prev) {
          if (prev.type !== "Rule") {
            return utils.unsafeToSkipNode.call(selectors, prev);
          }
          var prevSelectors = prev.prelude.children;
          var prevDeclarations = prev.block.children;
          if (node.pseudoSignature === prev.pseudoSignature) {
            if (utils.isEqualSelectors(prevSelectors, selectors)) {
              prevDeclarations.appendList(declarations);
              list.remove(item);
              return true;
            }
            if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
              utils.addSelectors(prevSelectors, selectors);
              list.remove(item);
              return true;
            }
          }
          return utils.hasSimilarSelectors(selectors, prevSelectors);
        });
      }
      module.exports = function initialMergeRule(ast) {
        walk(ast, { visit: "Rule", enter: processRule });
      };
    },
    9356: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(4895).List;
      var walk = __nccwpck_require__(4895).walk;
      function processRule(node, item, list) {
        var selectors = node.prelude.children;
        while (selectors.head !== selectors.tail) {
          var newSelectors = new List();
          newSelectors.insert(selectors.remove(selectors.head));
          list.insert(
            list.createItem({
              type: "Rule",
              loc: node.loc,
              prelude: {
                type: "SelectorList",
                loc: node.prelude.loc,
                children: newSelectors,
              },
              block: {
                type: "Block",
                loc: node.block.loc,
                children: node.block.children.copy(),
              },
              pseudoSignature: node.pseudoSignature,
            }),
            item,
          );
        }
      }
      module.exports = function disjoinRule(ast) {
        walk(ast, { visit: "Rule", reverse: true, enter: processRule });
      };
    },
    6226: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(4895).List;
      var generate = __nccwpck_require__(4895).generate;
      var walk = __nccwpck_require__(4895).walk;
      var REPLACE = 1;
      var REMOVE = 2;
      var TOP = 0;
      var RIGHT = 1;
      var BOTTOM = 2;
      var LEFT = 3;
      var SIDES = ["top", "right", "bottom", "left"];
      var SIDE = {
        "margin-top": "top",
        "margin-right": "right",
        "margin-bottom": "bottom",
        "margin-left": "left",
        "padding-top": "top",
        "padding-right": "right",
        "padding-bottom": "bottom",
        "padding-left": "left",
        "border-top-color": "top",
        "border-right-color": "right",
        "border-bottom-color": "bottom",
        "border-left-color": "left",
        "border-top-width": "top",
        "border-right-width": "right",
        "border-bottom-width": "bottom",
        "border-left-width": "left",
        "border-top-style": "top",
        "border-right-style": "right",
        "border-bottom-style": "bottom",
        "border-left-style": "left",
      };
      var MAIN_PROPERTY = {
        margin: "margin",
        "margin-top": "margin",
        "margin-right": "margin",
        "margin-bottom": "margin",
        "margin-left": "margin",
        padding: "padding",
        "padding-top": "padding",
        "padding-right": "padding",
        "padding-bottom": "padding",
        "padding-left": "padding",
        "border-color": "border-color",
        "border-top-color": "border-color",
        "border-right-color": "border-color",
        "border-bottom-color": "border-color",
        "border-left-color": "border-color",
        "border-width": "border-width",
        "border-top-width": "border-width",
        "border-right-width": "border-width",
        "border-bottom-width": "border-width",
        "border-left-width": "border-width",
        "border-style": "border-style",
        "border-top-style": "border-style",
        "border-right-style": "border-style",
        "border-bottom-style": "border-style",
        "border-left-style": "border-style",
      };
      function TRBL(name) {
        this.name = name;
        this.loc = null;
        this.iehack = undefined;
        this.sides = { top: null, right: null, bottom: null, left: null };
      }
      TRBL.prototype.getValueSequence = function (declaration, count) {
        var values = [];
        var iehack = "";
        var hasBadValues =
          declaration.value.type !== "Value" ||
          declaration.value.children.some(function (child) {
            var special = false;
            switch (child.type) {
              case "Identifier":
                switch (child.name) {
                  case "\\0":
                  case "\\9":
                    iehack = child.name;
                    return;
                  case "inherit":
                  case "initial":
                  case "unset":
                  case "revert":
                    special = child.name;
                    break;
                }
                break;
              case "Dimension":
                switch (child.unit) {
                  case "rem":
                  case "vw":
                  case "vh":
                  case "vmin":
                  case "vmax":
                  case "vm":
                    special = child.unit;
                    break;
                }
                break;
              case "Hash":
              case "Number":
              case "Percentage":
                break;
              case "Function":
                if (child.name === "var") {
                  return true;
                }
                special = child.name;
                break;
              case "WhiteSpace":
                return false;
              default:
                return true;
            }
            values.push({
              node: child,
              special,
              important: declaration.important,
            });
          });
        if (hasBadValues || values.length > count) {
          return false;
        }
        if (typeof this.iehack === "string" && this.iehack !== iehack) {
          return false;
        }
        this.iehack = iehack;
        return values;
      };
      TRBL.prototype.canOverride = function (side, value) {
        var currentValue = this.sides[side];
        return !currentValue || (value.important && !currentValue.important);
      };
      TRBL.prototype.add = function (name, declaration) {
        function attemptToAdd() {
          var sides = this.sides;
          var side = SIDE[name];
          if (side) {
            if (side in sides === false) {
              return false;
            }
            var values = this.getValueSequence(declaration, 1);
            if (!values || !values.length) {
              return false;
            }
            for (var key in sides) {
              if (
                sides[key] !== null &&
                sides[key].special !== values[0].special
              ) {
                return false;
              }
            }
            if (!this.canOverride(side, values[0])) {
              return true;
            }
            sides[side] = values[0];
            return true;
          } else if (name === this.name) {
            var values = this.getValueSequence(declaration, 4);
            if (!values || !values.length) {
              return false;
            }
            switch (values.length) {
              case 1:
                values[RIGHT] = values[TOP];
                values[BOTTOM] = values[TOP];
                values[LEFT] = values[TOP];
                break;
              case 2:
                values[BOTTOM] = values[TOP];
                values[LEFT] = values[RIGHT];
                break;
              case 3:
                values[LEFT] = values[RIGHT];
                break;
            }
            for (var i = 0; i < 4; i++) {
              for (var key in sides) {
                if (
                  sides[key] !== null &&
                  sides[key].special !== values[i].special
                ) {
                  return false;
                }
              }
            }
            for (var i = 0; i < 4; i++) {
              if (this.canOverride(SIDES[i], values[i])) {
                sides[SIDES[i]] = values[i];
              }
            }
            return true;
          }
        }
        if (!attemptToAdd.call(this)) {
          return false;
        }
        if (!this.loc) {
          this.loc = declaration.loc;
        }
        return true;
      };
      TRBL.prototype.isOkToMinimize = function () {
        var top = this.sides.top;
        var right = this.sides.right;
        var bottom = this.sides.bottom;
        var left = this.sides.left;
        if (top && right && bottom && left) {
          var important =
            top.important + right.important + bottom.important + left.important;
          return important === 0 || important === 4;
        }
        return false;
      };
      TRBL.prototype.getValue = function () {
        var result = new List();
        var sides = this.sides;
        var values = [sides.top, sides.right, sides.bottom, sides.left];
        var stringValues = [
          generate(sides.top.node),
          generate(sides.right.node),
          generate(sides.bottom.node),
          generate(sides.left.node),
        ];
        if (stringValues[LEFT] === stringValues[RIGHT]) {
          values.pop();
          if (stringValues[BOTTOM] === stringValues[TOP]) {
            values.pop();
            if (stringValues[RIGHT] === stringValues[TOP]) {
              values.pop();
            }
          }
        }
        for (var i = 0; i < values.length; i++) {
          if (i) {
            result.appendData({ type: "WhiteSpace", value: " " });
          }
          result.appendData(values[i].node);
        }
        if (this.iehack) {
          result.appendData({ type: "WhiteSpace", value: " " });
          result.appendData({
            type: "Identifier",
            loc: null,
            name: this.iehack,
          });
        }
        return { type: "Value", loc: null, children: result };
      };
      TRBL.prototype.getDeclaration = function () {
        return {
          type: "Declaration",
          loc: this.loc,
          important: this.sides.top.important,
          property: this.name,
          value: this.getValue(),
        };
      };
      function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
        var declarations = rule.block.children;
        var selector = rule.prelude.children.first().id;
        rule.block.children.eachRight(function (declaration, item) {
          var property = declaration.property;
          if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
          }
          var key = MAIN_PROPERTY[property];
          var shorthand;
          var operation;
          if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
              operation = REMOVE;
              shorthand = shorts[key];
            }
          }
          if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);
            if (!shorthand.add(property, declaration)) {
              lastShortSelector = null;
              return;
            }
          }
          shorts[key] = shorthand;
          shortDeclarations.push({
            operation,
            block: declarations,
            item,
            shorthand,
          });
          lastShortSelector = selector;
        });
        return lastShortSelector;
      }
      function processShorthands(shortDeclarations, markDeclaration) {
        shortDeclarations.forEach(function (item) {
          var shorthand = item.shorthand;
          if (!shorthand.isOkToMinimize()) {
            return;
          }
          if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
          } else {
            item.block.remove(item.item);
          }
        });
      }
      module.exports = function restructBlock(ast, indexer) {
        var stylesheetMap = {};
        var shortDeclarations = [];
        walk(ast, {
          visit: "Rule",
          reverse: true,
          enter: function (node) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId =
              (node.pseudoSignature || "") +
              "|" +
              node.prelude.children.first().id;
            var ruleMap;
            var shorts;
            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
              ruleMap = { lastShortSelector: null };
              stylesheetMap[stylesheet.id] = ruleMap;
            } else {
              ruleMap = stylesheetMap[stylesheet.id];
            }
            if (ruleMap.hasOwnProperty(ruleId)) {
              shorts = ruleMap[ruleId];
            } else {
              shorts = {};
              ruleMap[ruleId] = shorts;
            }
            ruleMap.lastShortSelector = processRule.call(
              this,
              node,
              shorts,
              shortDeclarations,
              ruleMap.lastShortSelector,
            );
          },
        });
        processShorthands(shortDeclarations, indexer.declaration);
      };
    },
    4346: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var resolveProperty = __nccwpck_require__(4895).property;
      var resolveKeyword = __nccwpck_require__(4895).keyword;
      var walk = __nccwpck_require__(4895).walk;
      var generate = __nccwpck_require__(4895).generate;
      var fingerprintId = 1;
      var dontRestructure = { src: 1 };
      var DONT_MIX_VALUE = {
        display: /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
        "text-align": /^(start|end|match-parent|justify-all)$/i,
      };
      var SAFE_VALUES = {
        cursor: [
          "auto",
          "crosshair",
          "default",
          "move",
          "text",
          "wait",
          "help",
          "n-resize",
          "e-resize",
          "s-resize",
          "w-resize",
          "ne-resize",
          "nw-resize",
          "se-resize",
          "sw-resize",
          "pointer",
          "progress",
          "not-allowed",
          "no-drop",
          "vertical-text",
          "all-scroll",
          "col-resize",
          "row-resize",
        ],
        overflow: ["hidden", "visible", "scroll", "auto"],
        position: ["static", "relative", "absolute", "fixed"],
      };
      var NEEDLESS_TABLE = {
        "border-width": ["border"],
        "border-style": ["border"],
        "border-color": ["border"],
        "border-top": ["border"],
        "border-right": ["border"],
        "border-bottom": ["border"],
        "border-left": ["border"],
        "border-top-width": ["border-top", "border-width", "border"],
        "border-right-width": ["border-right", "border-width", "border"],
        "border-bottom-width": ["border-bottom", "border-width", "border"],
        "border-left-width": ["border-left", "border-width", "border"],
        "border-top-style": ["border-top", "border-style", "border"],
        "border-right-style": ["border-right", "border-style", "border"],
        "border-bottom-style": ["border-bottom", "border-style", "border"],
        "border-left-style": ["border-left", "border-style", "border"],
        "border-top-color": ["border-top", "border-color", "border"],
        "border-right-color": ["border-right", "border-color", "border"],
        "border-bottom-color": ["border-bottom", "border-color", "border"],
        "border-left-color": ["border-left", "border-color", "border"],
        "margin-top": ["margin"],
        "margin-right": ["margin"],
        "margin-bottom": ["margin"],
        "margin-left": ["margin"],
        "padding-top": ["padding"],
        "padding-right": ["padding"],
        "padding-bottom": ["padding"],
        "padding-left": ["padding"],
        "font-style": ["font"],
        "font-variant": ["font"],
        "font-weight": ["font"],
        "font-size": ["font"],
        "font-family": ["font"],
        "list-style-type": ["list-style"],
        "list-style-position": ["list-style"],
        "list-style-image": ["list-style"],
      };
      function getPropertyFingerprint(propertyName, declaration, fingerprints) {
        var realName = resolveProperty(propertyName).basename;
        if (realName === "background") {
          return propertyName + ":" + generate(declaration.value);
        }
        var declarationId = declaration.id;
        var fingerprint = fingerprints[declarationId];
        if (!fingerprint) {
          switch (declaration.value.type) {
            case "Value":
              var vendorId = "";
              var iehack = "";
              var special = {};
              var raw = false;
              declaration.value.children.each(function walk(node) {
                switch (node.type) {
                  case "Value":
                  case "Brackets":
                  case "Parentheses":
                    node.children.each(walk);
                    break;
                  case "Raw":
                    raw = true;
                    break;
                  case "Identifier":
                    var name = node.name;
                    if (!vendorId) {
                      vendorId = resolveKeyword(name).vendor;
                    }
                    if (/\\[09]/.test(name)) {
                      iehack = RegExp.lastMatch;
                    }
                    if (SAFE_VALUES.hasOwnProperty(realName)) {
                      if (SAFE_VALUES[realName].indexOf(name) === -1) {
                        special[name] = true;
                      }
                    } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                      if (DONT_MIX_VALUE[realName].test(name)) {
                        special[name] = true;
                      }
                    }
                    break;
                  case "Function":
                    var name = node.name;
                    if (!vendorId) {
                      vendorId = resolveKeyword(name).vendor;
                    }
                    if (name === "rect") {
                      var hasComma = node.children.some(function (node) {
                        return node.type === "Operator" && node.value === ",";
                      });
                      if (!hasComma) {
                        name = "rect-backward";
                      }
                    }
                    special[name + "()"] = true;
                    node.children.each(walk);
                    break;
                  case "Dimension":
                    var unit = node.unit;
                    if (/\\[09]/.test(unit)) {
                      iehack = RegExp.lastMatch;
                    }
                    switch (unit) {
                      case "rem":
                      case "vw":
                      case "vh":
                      case "vmin":
                      case "vmax":
                      case "vm":
                        special[unit] = true;
                        break;
                    }
                    break;
                }
              });
              fingerprint = raw
                ? "!" + fingerprintId++
                : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
              break;
            case "Raw":
              fingerprint = "!" + declaration.value.value;
              break;
            default:
              fingerprint = generate(declaration.value);
          }
          fingerprints[declarationId] = fingerprint;
        }
        return propertyName + fingerprint;
      }
      function needless(props, declaration, fingerprints) {
        var property = resolveProperty(declaration.property);
        if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
          var table = NEEDLESS_TABLE[property.basename];
          for (var i = 0; i < table.length; i++) {
            var ppre = getPropertyFingerprint(
              property.prefix + table[i],
              declaration,
              fingerprints,
            );
            var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
            if (prev && (!declaration.important || prev.item.data.important)) {
              return prev;
            }
          }
        }
      }
      function processRule(rule, item, list, props, fingerprints) {
        var declarations = rule.block.children;
        declarations.eachRight(function (declaration, declarationItem) {
          var property = declaration.property;
          var fingerprint = getPropertyFingerprint(
            property,
            declaration,
            fingerprints,
          );
          var prev = props[fingerprint];
          if (prev && !dontRestructure.hasOwnProperty(property)) {
            if (declaration.important && !prev.item.data.important) {
              props[fingerprint] = {
                block: declarations,
                item: declarationItem,
              };
              prev.block.remove(prev.item);
            } else {
              declarations.remove(declarationItem);
            }
          } else {
            var prev = needless(props, declaration, fingerprints);
            if (prev) {
              declarations.remove(declarationItem);
            } else {
              declaration.fingerprint = fingerprint;
              props[fingerprint] = {
                block: declarations,
                item: declarationItem,
              };
            }
          }
        });
        if (declarations.isEmpty()) {
          list.remove(item);
        }
      }
      module.exports = function restructBlock(ast) {
        var stylesheetMap = {};
        var fingerprints = Object.create(null);
        walk(ast, {
          visit: "Rule",
          reverse: true,
          enter: function (node, item, list) {
            var stylesheet = this.block || this.stylesheet;
            var ruleId =
              (node.pseudoSignature || "") +
              "|" +
              node.prelude.children.first().id;
            var ruleMap;
            var props;
            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
              ruleMap = {};
              stylesheetMap[stylesheet.id] = ruleMap;
            } else {
              ruleMap = stylesheetMap[stylesheet.id];
            }
            if (ruleMap.hasOwnProperty(ruleId)) {
              props = ruleMap[ruleId];
            } else {
              props = {};
              ruleMap[ruleId] = props;
            }
            processRule.call(this, node, item, list, props, fingerprints);
          },
        });
      };
    },
    2787: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var walk = __nccwpck_require__(4895).walk;
      var utils = __nccwpck_require__(2851);
      function processRule(node, item, list) {
        var selectors = node.prelude.children;
        var declarations = node.block.children;
        var nodeCompareMarker = selectors.first().compareMarker;
        var skippedCompareMarkers = {};
        list.nextUntil(item.next, function (next, nextItem) {
          if (next.type !== "Rule") {
            return utils.unsafeToSkipNode.call(selectors, next);
          }
          if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
          }
          var nextFirstSelector = next.prelude.children.head;
          var nextDeclarations = next.block.children;
          var nextCompareMarker = nextFirstSelector.data.compareMarker;
          if (nextCompareMarker in skippedCompareMarkers) {
            return true;
          }
          if (selectors.head === selectors.tail) {
            if (selectors.first().id === nextFirstSelector.data.id) {
              declarations.appendList(nextDeclarations);
              list.remove(nextItem);
              return;
            }
          }
          if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
            var nextStr = nextFirstSelector.data.id;
            selectors.some(function (data, item) {
              var curStr = data.id;
              if (nextStr < curStr) {
                selectors.insert(nextFirstSelector, item);
                return true;
              }
              if (!item.next) {
                selectors.insert(nextFirstSelector);
                return true;
              }
            });
            list.remove(nextItem);
            return;
          }
          if (nextCompareMarker === nodeCompareMarker) {
            return true;
          }
          skippedCompareMarkers[nextCompareMarker] = true;
        });
      }
      module.exports = function mergeRule(ast) {
        walk(ast, { visit: "Rule", enter: processRule });
      };
    },
    2938: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var List = __nccwpck_require__(4895).List;
      var walk = __nccwpck_require__(4895).walk;
      var utils = __nccwpck_require__(2851);
      function calcSelectorLength(list) {
        var length = 0;
        list.each(function (data) {
          length += data.id.length + 1;
        });
        return length - 1;
      }
      function calcDeclarationsLength(tokens) {
        var length = 0;
        for (var i = 0; i < tokens.length; i++) {
          length += tokens[i].length;
        }
        return length + tokens.length - 1;
      }
      function processRule(node, item, list) {
        var avoidRulesMerge =
          this.block !== null ? this.block.avoidRulesMerge : false;
        var selectors = node.prelude.children;
        var block = node.block;
        var disallowDownMarkers = Object.create(null);
        var allowMergeUp = true;
        var allowMergeDown = true;
        list.prevUntil(item.prev, function (prev, prevItem) {
          var prevBlock = prev.block;
          var prevType = prev.type;
          if (prevType !== "Rule") {
            var unsafe = utils.unsafeToSkipNode.call(selectors, prev);
            if (!unsafe && prevType === "Atrule" && prevBlock) {
              walk(prevBlock, {
                visit: "Rule",
                enter: function (node) {
                  node.prelude.children.each(function (data) {
                    disallowDownMarkers[data.compareMarker] = true;
                  });
                },
              });
            }
            return unsafe;
          }
          var prevSelectors = prev.prelude.children;
          if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
          }
          allowMergeDown = !prevSelectors.some(function (selector) {
            return selector.compareMarker in disallowDownMarkers;
          });
          if (!allowMergeDown && !allowMergeUp) {
            return true;
          }
          if (
            allowMergeUp &&
            utils.isEqualSelectors(prevSelectors, selectors)
          ) {
            prevBlock.children.appendList(block.children);
            list.remove(item);
            return true;
          }
          var diff = utils.compareDeclarations(
            block.children,
            prevBlock.children,
          );
          if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
              if (allowMergeDown) {
                utils.addSelectors(selectors, prevSelectors);
                list.remove(prevItem);
              }
              return true;
            } else if (!avoidRulesMerge) {
              if (diff.ne1.length && !diff.ne2.length) {
                var selectorLength = calcSelectorLength(selectors);
                var blockLength = calcDeclarationsLength(diff.eq);
                if (allowMergeUp && selectorLength < blockLength) {
                  utils.addSelectors(prevSelectors, selectors);
                  block.children = new List().fromArray(diff.ne1);
                }
              } else if (!diff.ne1.length && diff.ne2.length) {
                var selectorLength = calcSelectorLength(prevSelectors);
                var blockLength = calcDeclarationsLength(diff.eq);
                if (allowMergeDown && selectorLength < blockLength) {
                  utils.addSelectors(selectors, prevSelectors);
                  prevBlock.children = new List().fromArray(diff.ne2);
                }
              } else {
                var newSelector = {
                  type: "SelectorList",
                  loc: null,
                  children: utils.addSelectors(prevSelectors.copy(), selectors),
                };
                var newBlockLength =
                  calcSelectorLength(newSelector.children) + 2;
                var blockLength = calcDeclarationsLength(diff.eq);
                if (blockLength >= newBlockLength) {
                  var newItem = list.createItem({
                    type: "Rule",
                    loc: null,
                    prelude: newSelector,
                    block: {
                      type: "Block",
                      loc: null,
                      children: new List().fromArray(diff.eq),
                    },
                    pseudoSignature: node.pseudoSignature,
                  });
                  block.children = new List().fromArray(diff.ne1);
                  prevBlock.children = new List().fromArray(diff.ne2overrided);
                  if (allowMergeUp) {
                    list.insert(newItem, prevItem);
                  } else {
                    list.insert(newItem, item);
                  }
                  return true;
                }
              }
            }
          }
          if (allowMergeUp) {
            allowMergeUp = !prevSelectors.some(function (prevSelector) {
              return selectors.some(function (selector) {
                return selector.compareMarker === prevSelector.compareMarker;
              });
            });
          }
          prevSelectors.each(function (data) {
            disallowDownMarkers[data.compareMarker] = true;
          });
        });
      }
      module.exports = function restructRule(ast) {
        walk(ast, { visit: "Rule", reverse: true, enter: processRule });
      };
    },
    2640: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var prepare = __nccwpck_require__(5067);
      var mergeAtrule = __nccwpck_require__(6372);
      var initialMergeRuleset = __nccwpck_require__(3905);
      var disjoinRuleset = __nccwpck_require__(9356);
      var restructShorthand = __nccwpck_require__(6226);
      var restructBlock = __nccwpck_require__(4346);
      var mergeRuleset = __nccwpck_require__(2787);
      var restructRuleset = __nccwpck_require__(2938);
      module.exports = function (ast, options) {
        var indexer = prepare(ast, options);
        options.logger("prepare", ast);
        mergeAtrule(ast, options);
        options.logger("mergeAtrule", ast);
        initialMergeRuleset(ast);
        options.logger("initialMergeRuleset", ast);
        disjoinRuleset(ast);
        options.logger("disjoinRuleset", ast);
        restructShorthand(ast, indexer);
        options.logger("restructShorthand", ast);
        restructBlock(ast);
        options.logger("restructBlock", ast);
        mergeRuleset(ast);
        options.logger("mergeRuleset", ast);
        restructRuleset(ast);
        options.logger("restructRuleset", ast);
      };
    },
    9272: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var generate = __nccwpck_require__(4895).generate;
      function Index() {
        this.seed = 0;
        this.map = Object.create(null);
      }
      Index.prototype.resolve = function (str) {
        var index = this.map[str];
        if (!index) {
          index = ++this.seed;
          this.map[str] = index;
        }
        return index;
      };
      module.exports = function createDeclarationIndexer() {
        var ids = new Index();
        return function markDeclaration(node) {
          var id = generate(node);
          node.id = ids.resolve(id);
          node.length = id.length;
          node.fingerprint = null;
          return node;
        };
      };
    },
    5067: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var resolveKeyword = __nccwpck_require__(4895).keyword;
      var walk = __nccwpck_require__(4895).walk;
      var generate = __nccwpck_require__(4895).generate;
      var createDeclarationIndexer = __nccwpck_require__(9272);
      var processSelector = __nccwpck_require__(8111);
      module.exports = function prepare(ast, options) {
        var markDeclaration = createDeclarationIndexer();
        walk(ast, {
          visit: "Rule",
          enter: function processRule(node) {
            node.block.children.each(markDeclaration);
            processSelector(node, options.usage);
          },
        });
        walk(ast, {
          visit: "Atrule",
          enter: function (node) {
            if (node.prelude) {
              node.prelude.id = null;
              node.prelude.id = generate(node.prelude);
            }
            if (resolveKeyword(node.name).basename === "keyframes") {
              node.block.avoidRulesMerge = true;
              node.block.children.each(function (rule) {
                rule.prelude.children.each(function (simpleselector) {
                  simpleselector.compareMarker = simpleselector.id;
                });
              });
            }
          },
        });
        return { declaration: markDeclaration };
      };
    },
    8111: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var generate = __nccwpck_require__(4895).generate;
      var specificity = __nccwpck_require__(7876);
      var nonFreezePseudoElements = {
        "first-letter": true,
        "first-line": true,
        after: true,
        before: true,
      };
      var nonFreezePseudoClasses = {
        link: true,
        visited: true,
        hover: true,
        active: true,
        "first-letter": true,
        "first-line": true,
        after: true,
        before: true,
      };
      module.exports = function freeze(node, usageData) {
        var pseudos = Object.create(null);
        var hasPseudo = false;
        node.prelude.children.each(function (simpleSelector) {
          var tagName = "*";
          var scope = 0;
          simpleSelector.children.each(function (node) {
            switch (node.type) {
              case "ClassSelector":
                if (usageData && usageData.scopes) {
                  var classScope = usageData.scopes[node.name] || 0;
                  if (scope !== 0 && classScope !== scope) {
                    throw new Error(
                      "Selector can't has classes from different scopes: " +
                        generate(simpleSelector),
                    );
                  }
                  scope = classScope;
                }
                break;
              case "PseudoClassSelector":
                var name = node.name.toLowerCase();
                if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                  pseudos[":" + name] = true;
                  hasPseudo = true;
                }
                break;
              case "PseudoElementSelector":
                var name = node.name.toLowerCase();
                if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                  pseudos["::" + name] = true;
                  hasPseudo = true;
                }
                break;
              case "TypeSelector":
                tagName = node.name.toLowerCase();
                break;
              case "AttributeSelector":
                if (node.flags) {
                  pseudos["[" + node.flags.toLowerCase() + "]"] = true;
                  hasPseudo = true;
                }
                break;
              case "WhiteSpace":
              case "Combinator":
                tagName = "*";
                break;
            }
          });
          simpleSelector.compareMarker = specificity(simpleSelector).toString();
          simpleSelector.id = null;
          simpleSelector.id = generate(simpleSelector);
          if (scope) {
            simpleSelector.compareMarker += ":" + scope;
          }
          if (tagName !== "*") {
            simpleSelector.compareMarker += "," + tagName;
          }
        });
        node.pseudoSignature =
          hasPseudo && Object.keys(pseudos).sort().join(",");
      };
    },
    7876: (module) => {
      module.exports = function specificity(simpleSelector) {
        var A = 0;
        var B = 0;
        var C = 0;
        simpleSelector.children.each(function walk(node) {
          switch (node.type) {
            case "SelectorList":
            case "Selector":
              node.children.each(walk);
              break;
            case "IdSelector":
              A++;
              break;
            case "ClassSelector":
            case "AttributeSelector":
              B++;
              break;
            case "PseudoClassSelector":
              switch (node.name.toLowerCase()) {
                case "not":
                  node.children.each(walk);
                  break;
                case "before":
                case "after":
                case "first-line":
                case "first-letter":
                  C++;
                  break;
                default:
                  B++;
              }
              break;
            case "PseudoElementSelector":
              C++;
              break;
            case "TypeSelector":
              if (node.name.charAt(node.name.length - 1) !== "*") {
                C++;
              }
              break;
          }
        });
        return [A, B, C];
      };
    },
    2851: (module) => {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function isEqualSelectors(a, b) {
        var cursor1 = a.head;
        var cursor2 = b.head;
        while (
          cursor1 !== null &&
          cursor2 !== null &&
          cursor1.data.id === cursor2.data.id
        ) {
          cursor1 = cursor1.next;
          cursor2 = cursor2.next;
        }
        return cursor1 === null && cursor2 === null;
      }
      function isEqualDeclarations(a, b) {
        var cursor1 = a.head;
        var cursor2 = b.head;
        while (
          cursor1 !== null &&
          cursor2 !== null &&
          cursor1.data.id === cursor2.data.id
        ) {
          cursor1 = cursor1.next;
          cursor2 = cursor2.next;
        }
        return cursor1 === null && cursor2 === null;
      }
      function compareDeclarations(declarations1, declarations2) {
        var result = { eq: [], ne1: [], ne2: [], ne2overrided: [] };
        var fingerprints = Object.create(null);
        var declarations2hash = Object.create(null);
        for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
          declarations2hash[cursor.data.id] = true;
        }
        for (var cursor = declarations1.head; cursor; cursor = cursor.next) {
          var data = cursor.data;
          if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
          }
          if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
          } else {
            result.ne1.push(data);
          }
        }
        for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
          var data = cursor.data;
          if (declarations2hash[data.id]) {
            if (
              !hasOwnProperty.call(fingerprints, data.fingerprint) ||
              (!fingerprints[data.fingerprint] && data.important)
            ) {
              result.ne2.push(data);
            }
            result.ne2overrided.push(data);
          }
        }
        return result;
      }
      function addSelectors(dest, source) {
        source.each(function (sourceData) {
          var newStr = sourceData.id;
          var cursor = dest.head;
          while (cursor) {
            var nextStr = cursor.data.id;
            if (nextStr === newStr) {
              return;
            }
            if (nextStr > newStr) {
              break;
            }
            cursor = cursor.next;
          }
          dest.insert(dest.createItem(sourceData), cursor);
        });
        return dest;
      }
      function hasSimilarSelectors(selectors1, selectors2) {
        var cursor1 = selectors1.head;
        while (cursor1 !== null) {
          var cursor2 = selectors2.head;
          while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
              return true;
            }
            cursor2 = cursor2.next;
          }
          cursor1 = cursor1.next;
        }
        return false;
      }
      function unsafeToSkipNode(node) {
        switch (node.type) {
          case "Rule":
            return hasSimilarSelectors(node.prelude.children, this);
          case "Atrule":
            if (node.block) {
              return node.block.children.some(unsafeToSkipNode, this);
            }
            break;
          case "Declaration":
            return false;
        }
        return true;
      }
      module.exports = {
        isEqualSelectors,
        isEqualDeclarations,
        compareDeclarations,
        addSelectors,
        hasSimilarSelectors,
        unsafeToSkipNode,
      };
    },
    245: (module) => {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function buildMap(list, caseInsensitive) {
        var map = Object.create(null);
        if (!Array.isArray(list)) {
          return null;
        }
        for (var i = 0; i < list.length; i++) {
          var name = list[i];
          if (caseInsensitive) {
            name = name.toLowerCase();
          }
          map[name] = true;
        }
        return map;
      }
      function buildList(data) {
        if (!data) {
          return null;
        }
        var tags = buildMap(data.tags, true);
        var ids = buildMap(data.ids);
        var classes = buildMap(data.classes);
        if (tags === null && ids === null && classes === null) {
          return null;
        }
        return { tags, ids, classes };
      }
      function buildIndex(data) {
        var scopes = false;
        if (data.scopes && Array.isArray(data.scopes)) {
          scopes = Object.create(null);
          for (var i = 0; i < data.scopes.length; i++) {
            var list = data.scopes[i];
            if (!list || !Array.isArray(list)) {
              throw new Error("Wrong usage format");
            }
            for (var j = 0; j < list.length; j++) {
              var name = list[j];
              if (hasOwnProperty.call(scopes, name)) {
                throw new Error(
                  "Class can't be used for several scopes: " + name,
                );
              }
              scopes[name] = i + 1;
            }
          }
        }
        return {
          whitelist: buildList(data),
          blacklist: buildList(data.blacklist),
          scopes,
        };
      }
      module.exports = { buildIndex };
    },
    1666: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.attributeNames = exports.elementNames = void 0;
      exports.elementNames = new Map([
        ["altglyph", "altGlyph"],
        ["altglyphdef", "altGlyphDef"],
        ["altglyphitem", "altGlyphItem"],
        ["animatecolor", "animateColor"],
        ["animatemotion", "animateMotion"],
        ["animatetransform", "animateTransform"],
        ["clippath", "clipPath"],
        ["feblend", "feBlend"],
        ["fecolormatrix", "feColorMatrix"],
        ["fecomponenttransfer", "feComponentTransfer"],
        ["fecomposite", "feComposite"],
        ["feconvolvematrix", "feConvolveMatrix"],
        ["fediffuselighting", "feDiffuseLighting"],
        ["fedisplacementmap", "feDisplacementMap"],
        ["fedistantlight", "feDistantLight"],
        ["fedropshadow", "feDropShadow"],
        ["feflood", "feFlood"],
        ["fefunca", "feFuncA"],
        ["fefuncb", "feFuncB"],
        ["fefuncg", "feFuncG"],
        ["fefuncr", "feFuncR"],
        ["fegaussianblur", "feGaussianBlur"],
        ["feimage", "feImage"],
        ["femerge", "feMerge"],
        ["femergenode", "feMergeNode"],
        ["femorphology", "feMorphology"],
        ["feoffset", "feOffset"],
        ["fepointlight", "fePointLight"],
        ["fespecularlighting", "feSpecularLighting"],
        ["fespotlight", "feSpotLight"],
        ["fetile", "feTile"],
        ["feturbulence", "feTurbulence"],
        ["foreignobject", "foreignObject"],
        ["glyphref", "glyphRef"],
        ["lineargradient", "linearGradient"],
        ["radialgradient", "radialGradient"],
        ["textpath", "textPath"],
      ]);
      exports.attributeNames = new Map([
        ["definitionurl", "definitionURL"],
        ["attributename", "attributeName"],
        ["attributetype", "attributeType"],
        ["basefrequency", "baseFrequency"],
        ["baseprofile", "baseProfile"],
        ["calcmode", "calcMode"],
        ["clippathunits", "clipPathUnits"],
        ["diffuseconstant", "diffuseConstant"],
        ["edgemode", "edgeMode"],
        ["filterunits", "filterUnits"],
        ["glyphref", "glyphRef"],
        ["gradienttransform", "gradientTransform"],
        ["gradientunits", "gradientUnits"],
        ["kernelmatrix", "kernelMatrix"],
        ["kernelunitlength", "kernelUnitLength"],
        ["keypoints", "keyPoints"],
        ["keysplines", "keySplines"],
        ["keytimes", "keyTimes"],
        ["lengthadjust", "lengthAdjust"],
        ["limitingconeangle", "limitingConeAngle"],
        ["markerheight", "markerHeight"],
        ["markerunits", "markerUnits"],
        ["markerwidth", "markerWidth"],
        ["maskcontentunits", "maskContentUnits"],
        ["maskunits", "maskUnits"],
        ["numoctaves", "numOctaves"],
        ["pathlength", "pathLength"],
        ["patterncontentunits", "patternContentUnits"],
        ["patterntransform", "patternTransform"],
        ["patternunits", "patternUnits"],
        ["pointsatx", "pointsAtX"],
        ["pointsaty", "pointsAtY"],
        ["pointsatz", "pointsAtZ"],
        ["preservealpha", "preserveAlpha"],
        ["preserveaspectratio", "preserveAspectRatio"],
        ["primitiveunits", "primitiveUnits"],
        ["refx", "refX"],
        ["refy", "refY"],
        ["repeatcount", "repeatCount"],
        ["repeatdur", "repeatDur"],
        ["requiredextensions", "requiredExtensions"],
        ["requiredfeatures", "requiredFeatures"],
        ["specularconstant", "specularConstant"],
        ["specularexponent", "specularExponent"],
        ["spreadmethod", "spreadMethod"],
        ["startoffset", "startOffset"],
        ["stddeviation", "stdDeviation"],
        ["stitchtiles", "stitchTiles"],
        ["surfacescale", "surfaceScale"],
        ["systemlanguage", "systemLanguage"],
        ["tablevalues", "tableValues"],
        ["targetx", "targetX"],
        ["targety", "targetY"],
        ["textlength", "textLength"],
        ["viewbox", "viewBox"],
        ["viewtarget", "viewTarget"],
        ["xchannelselector", "xChannelSelector"],
        ["ychannelselector", "yChannelSelector"],
        ["zoomandpan", "zoomAndPan"],
      ]);
    },
    1553: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __assign =
        (this && this.__assign) ||
        function () {
          __assign =
            Object.assign ||
            function (t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
            };
          return __assign.apply(this, arguments);
        };
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      var ElementType = __importStar(__nccwpck_require__(1810));
      var entities_1 = __nccwpck_require__(302);
      var foreignNames_1 = __nccwpck_require__(1666);
      var unencodedElements = new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript",
      ]);
      function formatAttributes(attributes, opts) {
        if (!attributes) return;
        return Object.keys(attributes)
          .map(function (key) {
            var _a, _b;
            var value =
              (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
              key =
                (_b = foreignNames_1.attributeNames.get(key)) !== null &&
                _b !== void 0
                  ? _b
                  : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
              return key;
            }
            return (
              key +
              '="' +
              (opts.decodeEntities !== false
                ? entities_1.encodeXML(value)
                : value.replace(/"/g, "&quot;")) +
              '"'
            );
          })
          .join(" ");
      }
      var singleTag = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
      ]);
      function render(node, options) {
        if (options === void 0) {
          options = {};
        }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i = 0; i < nodes.length; i++) {
          output += renderNode(nodes[i], options);
        }
        return output;
      }
      exports["default"] = render;
      function renderNode(node, options) {
        switch (node.type) {
          case ElementType.Root:
            return render(node.children, options);
          case ElementType.Directive:
          case ElementType.Doctype:
            return renderDirective(node);
          case ElementType.Comment:
            return renderComment(node);
          case ElementType.CDATA:
            return renderCdata(node);
          case ElementType.Script:
          case ElementType.Style:
          case ElementType.Tag:
            return renderTag(node, options);
          case ElementType.Text:
            return renderText(node, options);
        }
      }
      var foreignModeIntegrationPoints = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
      ]);
      var foreignElements = new Set(["svg", "math"]);
      function renderTag(elem, opts) {
        var _a;
        if (opts.xmlMode === "foreign") {
          elem.name =
            (_a = foreignNames_1.elementNames.get(elem.name)) !== null &&
            _a !== void 0
              ? _a
              : elem.name;
          if (
            elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)
          ) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
          }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<" + elem.name;
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
          tag += " " + attribs;
        }
        if (
          elem.children.length === 0 &&
          (opts.xmlMode
            ? opts.selfClosingTags !== false
            : opts.selfClosingTags && singleTag.has(elem.name))
        ) {
          if (!opts.xmlMode) tag += " ";
          tag += "/>";
        } else {
          tag += ">";
          if (elem.children.length > 0) {
            tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
          }
        }
        return tag;
      }
      function renderDirective(elem) {
        return "<" + elem.data + ">";
      }
      function renderText(elem, opts) {
        var data = elem.data || "";
        if (
          opts.decodeEntities !== false &&
          !(
            !opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name)
          )
        ) {
          data = entities_1.encodeXML(data);
        }
        return data;
      }
      function renderCdata(elem) {
        return "<![CDATA[" + elem.children[0].data + "]]>";
      }
      function renderComment(elem) {
        return "\x3c!--" + elem.data + "--\x3e";
      }
    },
    1810: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Doctype =
        exports.CDATA =
        exports.Tag =
        exports.Style =
        exports.Script =
        exports.Comment =
        exports.Directive =
        exports.Text =
        exports.Root =
        exports.isTag =
        exports.ElementType =
          void 0;
      var ElementType;
      (function (ElementType) {
        ElementType["Root"] = "root";
        ElementType["Text"] = "text";
        ElementType["Directive"] = "directive";
        ElementType["Comment"] = "comment";
        ElementType["Script"] = "script";
        ElementType["Style"] = "style";
        ElementType["Tag"] = "tag";
        ElementType["CDATA"] = "cdata";
        ElementType["Doctype"] = "doctype";
      })((ElementType = exports.ElementType || (exports.ElementType = {})));
      function isTag(elem) {
        return (
          elem.type === ElementType.Tag ||
          elem.type === ElementType.Script ||
          elem.type === ElementType.Style
        );
      }
      exports.isTag = isTag;
      exports.Root = ElementType.Root;
      exports.Text = ElementType.Text;
      exports.Directive = ElementType.Directive;
      exports.Comment = ElementType.Comment;
      exports.Script = ElementType.Script;
      exports.Style = ElementType.Style;
      exports.Tag = ElementType.Tag;
      exports.CDATA = ElementType.CDATA;
      exports.Doctype = ElementType.Doctype;
    },
    3291: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DomHandler = void 0;
      var domelementtype_1 = __nccwpck_require__(1810);
      var node_1 = __nccwpck_require__(9898);
      __exportStar(__nccwpck_require__(9898), exports);
      var reWhitespace = /\s+/g;
      var defaultOpts = {
        normalizeWhitespace: false,
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false,
      };
      var DomHandler = (function () {
        function DomHandler(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = undefined;
          }
          this.callback =
            callback !== null && callback !== void 0 ? callback : null;
          this.options =
            options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB =
            elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler.prototype.onparserinit = function (parser) {
          this.parser = parser;
        };
        DomHandler.prototype.onreset = function () {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler.prototype.onend = function () {
          if (this.done) return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler.prototype.onerror = function (error) {
          this.handleCallback(error);
        };
        DomHandler.prototype.onclosetag = function () {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB) this.elementCB(elem);
        };
        DomHandler.prototype.onopentag = function (name, attribs) {
          var type = this.options.xmlMode
            ? domelementtype_1.ElementType.Tag
            : undefined;
          var element = new node_1.Element(name, attribs, undefined, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler.prototype.ontext = function (data) {
          var normalizeWhitespace = this.options.normalizeWhitespace;
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
              lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            } else {
              lastNode.data += data;
            }
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            if (normalizeWhitespace) {
              data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler.prototype.oncomment = function (data) {
          if (
            this.lastNode &&
            this.lastNode.type === domelementtype_1.ElementType.Comment
          ) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler.prototype.oncommentend = function () {
          this.lastNode = null;
        };
        DomHandler.prototype.oncdatastart = function () {
          var text = new node_1.Text("");
          var node = new node_1.NodeWithChildren(
            domelementtype_1.ElementType.CDATA,
            [text],
          );
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler.prototype.oncdataend = function () {
          this.lastNode = null;
        };
        DomHandler.prototype.onprocessinginstruction = function (name, data) {
          var node = new node_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler.prototype.handleCallback = function (error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler.prototype.addNode = function (node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler;
      })();
      exports.DomHandler = DomHandler;
      exports["default"] = DomHandler;
    },
    9898: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __extends =
        (this && this.__extends) ||
        (function () {
          var extendStatics = function (d, b) {
            extendStatics =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (d, b) {
                  d.__proto__ = b;
                }) ||
              function (d, b) {
                for (var p in b)
                  if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
              };
            return extendStatics(d, b);
          };
          return function (d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError(
                "Class extends value " +
                  String(b) +
                  " is not a constructor or null",
              );
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype =
              b === null
                ? Object.create(b)
                : ((__.prototype = b.prototype), new __());
          };
        })();
      var __assign =
        (this && this.__assign) ||
        function () {
          __assign =
            Object.assign ||
            function (t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
            };
          return __assign.apply(this, arguments);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.cloneNode =
        exports.hasChildren =
        exports.isDocument =
        exports.isDirective =
        exports.isComment =
        exports.isText =
        exports.isCDATA =
        exports.isTag =
        exports.Element =
        exports.Document =
        exports.NodeWithChildren =
        exports.ProcessingInstruction =
        exports.Comment =
        exports.Text =
        exports.DataNode =
        exports.Node =
          void 0;
      var domelementtype_1 = __nccwpck_require__(1810);
      var nodeTypes = new Map([
        [domelementtype_1.ElementType.Tag, 1],
        [domelementtype_1.ElementType.Script, 1],
        [domelementtype_1.ElementType.Style, 1],
        [domelementtype_1.ElementType.Directive, 1],
        [domelementtype_1.ElementType.Text, 3],
        [domelementtype_1.ElementType.CDATA, 4],
        [domelementtype_1.ElementType.Comment, 8],
        [domelementtype_1.ElementType.Root, 9],
      ]);
      var Node = (function () {
        function Node(type) {
          this.type = type;
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node.prototype, "nodeType", {
          get: function () {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0
              ? _a
              : 1;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node.prototype, "parentNode", {
          get: function () {
            return this.parent;
          },
          set: function (parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node.prototype, "previousSibling", {
          get: function () {
            return this.prev;
          },
          set: function (prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node.prototype, "nextSibling", {
          get: function () {
            return this.next;
          },
          set: function (next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true,
        });
        Node.prototype.cloneNode = function (recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node;
      })();
      exports.Node = Node;
      var DataNode = (function (_super) {
        __extends(DataNode, _super);
        function DataNode(type, data) {
          var _this = _super.call(this, type) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode.prototype, "nodeValue", {
          get: function () {
            return this.data;
          },
          set: function (data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true,
        });
        return DataNode;
      })(Node);
      exports.DataNode = DataNode;
      var Text = (function (_super) {
        __extends(Text, _super);
        function Text(data) {
          return (
            _super.call(this, domelementtype_1.ElementType.Text, data) || this
          );
        }
        return Text;
      })(DataNode);
      exports.Text = Text;
      var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment(data) {
          return (
            _super.call(this, domelementtype_1.ElementType.Comment, data) ||
            this
          );
        }
        return Comment;
      })(DataNode);
      exports.Comment = Comment;
      var ProcessingInstruction = (function (_super) {
        __extends(ProcessingInstruction, _super);
        function ProcessingInstruction(name, data) {
          var _this =
            _super.call(this, domelementtype_1.ElementType.Directive, data) ||
            this;
          _this.name = name;
          return _this;
        }
        return ProcessingInstruction;
      })(DataNode);
      exports.ProcessingInstruction = ProcessingInstruction;
      var NodeWithChildren = (function (_super) {
        __extends(NodeWithChildren, _super);
        function NodeWithChildren(type, children) {
          var _this = _super.call(this, type) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
          get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0
              ? _a
              : null;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
          get: function () {
            return this.children.length > 0
              ? this.children[this.children.length - 1]
              : null;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
          get: function () {
            return this.children;
          },
          set: function (children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true,
        });
        return NodeWithChildren;
      })(Node);
      exports.NodeWithChildren = NodeWithChildren;
      var Document = (function (_super) {
        __extends(Document, _super);
        function Document(children) {
          return (
            _super.call(this, domelementtype_1.ElementType.Root, children) ||
            this
          );
        }
        return Document;
      })(NodeWithChildren);
      exports.Document = Document;
      var Element = (function (_super) {
        __extends(Element, _super);
        function Element(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type =
              name === "script"
                ? domelementtype_1.ElementType.Script
                : name === "style"
                  ? domelementtype_1.ElementType.Style
                  : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, type, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          return _this;
        }
        Object.defineProperty(Element.prototype, "tagName", {
          get: function () {
            return this.name;
          },
          set: function (name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Element.prototype, "attributes", {
          get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace:
                  (_a = _this["x-attribsNamespace"]) === null || _a === void 0
                    ? void 0
                    : _a[name],
                prefix:
                  (_b = _this["x-attribsPrefix"]) === null || _b === void 0
                    ? void 0
                    : _b[name],
              };
            });
          },
          enumerable: false,
          configurable: true,
        });
        return Element;
      })(NodeWithChildren);
      exports.Element = Element;
      function isTag(node) {
        return (0, domelementtype_1.isTag)(node);
      }
      exports.isTag = isTag;
      function isCDATA(node) {
        return node.type === domelementtype_1.ElementType.CDATA;
      }
      exports.isCDATA = isCDATA;
      function isText(node) {
        return node.type === domelementtype_1.ElementType.Text;
      }
      exports.isText = isText;
      function isComment(node) {
        return node.type === domelementtype_1.ElementType.Comment;
      }
      exports.isComment = isComment;
      function isDirective(node) {
        return node.type === domelementtype_1.ElementType.Directive;
      }
      exports.isDirective = isDirective;
      function isDocument(node) {
        return node.type === domelementtype_1.ElementType.Root;
      }
      exports.isDocument = isDocument;
      function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
      }
      exports.hasChildren = hasChildren;
      function cloneNode(node, recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        var result;
        if (isText(node)) {
          result = new Text(node.data);
        } else if (isComment(node)) {
          result = new Comment(node.data);
        } else if (isTag(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_1 = new Element(
            node.name,
            __assign({}, node.attribs),
            children,
          );
          children.forEach(function (child) {
            return (child.parent = clone_1);
          });
          if (node.namespace != null) {
            clone_1.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign(
              {},
              node["x-attribsNamespace"],
            );
          }
          if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
          }
          result = clone_1;
        } else if (isCDATA(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_2 = new NodeWithChildren(
            domelementtype_1.ElementType.CDATA,
            children,
          );
          children.forEach(function (child) {
            return (child.parent = clone_2);
          });
          result = clone_2;
        } else if (isDocument(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_3 = new Document(children);
          children.forEach(function (child) {
            return (child.parent = clone_3);
          });
          if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
          }
          result = clone_3;
        } else if (isDirective(node)) {
          var instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
        } else {
          throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
      }
      exports.cloneNode = cloneNode;
      function cloneChildren(childs) {
        var children = childs.map(function (child) {
          return cloneNode(child, true);
        });
        for (var i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
        }
        return children;
      }
    },
    5114: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFeed = void 0;
      var stringify_1 = __nccwpck_require__(9397);
      var legacy_1 = __nccwpck_require__(7121);
      function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot
          ? null
          : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
      }
      exports.getFeed = getFeed;
      function getAtomFeed(feedRoot) {
        var _a;
        var childs = feedRoot.children;
        var feed = {
          type: "atom",
          items: (0, legacy_1.getElementsByTagName)("entry", childs).map(
            function (item) {
              var _a;
              var children = item.children;
              var entry = { media: getMediaElements(children) };
              addConditionally(entry, "id", "id", children);
              addConditionally(entry, "title", "title", children);
              var href =
                (_a = getOneElement("link", children)) === null || _a === void 0
                  ? void 0
                  : _a.attribs.href;
              if (href) {
                entry.link = href;
              }
              var description =
                fetch("summary", children) || fetch("content", children);
              if (description) {
                entry.description = description;
              }
              var pubDate = fetch("updated", children);
              if (pubDate) {
                entry.pubDate = new Date(pubDate);
              }
              return entry;
            },
          ),
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href =
          (_a = getOneElement("link", childs)) === null || _a === void 0
            ? void 0
            : _a.attribs.href;
        if (href) {
          feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch("updated", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
      }
      function getRssFeed(feedRoot) {
        var _a, _b;
        var childs =
          (_b =
            (_a = getOneElement("channel", feedRoot.children)) === null ||
            _a === void 0
              ? void 0
              : _a.children) !== null && _b !== void 0
            ? _b
            : [];
        var feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: (0, legacy_1.getElementsByTagName)(
            "item",
            feedRoot.children,
          ).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children);
            if (pubDate) entry.pubDate = new Date(pubDate);
            return entry;
          }),
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch("lastBuildDate", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
      }
      var MEDIA_KEYS_STRING = ["url", "type", "lang"];
      var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width",
      ];
      function getMediaElements(where) {
        return (0, legacy_1.getElementsByTagName)("media:content", where).map(
          function (elem) {
            var attribs = elem.attribs;
            var media = {
              medium: attribs.medium,
              isDefault: !!attribs.isDefault,
            };
            for (
              var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;
              _i < MEDIA_KEYS_STRING_1.length;
              _i++
            ) {
              var attrib = MEDIA_KEYS_STRING_1[_i];
              if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
              }
            }
            for (
              var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;
              _a < MEDIA_KEYS_INT_1.length;
              _a++
            ) {
              var attrib = MEDIA_KEYS_INT_1[_a];
              if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
              }
            }
            if (attribs.expression) {
              media.expression = attribs.expression;
            }
            return media;
          },
        );
      }
      function getOneElement(tagName, node) {
        return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
      }
      function fetch(tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        return (0, stringify_1.textContent)(
          (0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1),
        ).trim();
      }
      function addConditionally(obj, prop, tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        var val = fetch(tagName, where, recurse);
        if (val) obj[prop] = val;
      }
      function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
      }
    },
    8822: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.uniqueSort =
        exports.compareDocumentPosition =
        exports.removeSubsets =
          void 0;
      var domhandler_1 = __nccwpck_require__(3291);
      function removeSubsets(nodes) {
        var idx = nodes.length;
        while (--idx >= 0) {
          var node = nodes[idx];
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
          }
          for (
            var ancestor = node.parent;
            ancestor;
            ancestor = ancestor.parent
          ) {
            if (nodes.includes(ancestor)) {
              nodes.splice(idx, 1);
              break;
            }
          }
        }
        return nodes;
      }
      exports.removeSubsets = removeSubsets;
      function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
          return 0;
        }
        var current = (0, domhandler_1.hasChildren)(nodeA)
          ? nodeA
          : nodeA.parent;
        while (current) {
          aParents.unshift(current);
          current = current.parent;
        }
        current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
          bParents.unshift(current);
          current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
        }
        if (idx === 0) {
          return 1;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
            return 4 | 16;
          }
          return 4;
        }
        if (sharedParent === nodeA) {
          return 2 | 8;
        }
        return 2;
      }
      exports.compareDocumentPosition = compareDocumentPosition;
      function uniqueSort(nodes) {
        nodes = nodes.filter(function (node, i, arr) {
          return !arr.includes(node, i + 1);
        });
        nodes.sort(function (a, b) {
          var relative = compareDocumentPosition(a, b);
          if (relative & 2) {
            return -1;
          } else if (relative & 4) {
            return 1;
          }
          return 0;
        });
        return nodes;
      }
      exports.uniqueSort = uniqueSort;
    },
    4745: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasChildren =
        exports.isDocument =
        exports.isComment =
        exports.isText =
        exports.isCDATA =
        exports.isTag =
          void 0;
      __exportStar(__nccwpck_require__(9397), exports);
      __exportStar(__nccwpck_require__(4229), exports);
      __exportStar(__nccwpck_require__(2506), exports);
      __exportStar(__nccwpck_require__(7281), exports);
      __exportStar(__nccwpck_require__(7121), exports);
      __exportStar(__nccwpck_require__(8822), exports);
      __exportStar(__nccwpck_require__(5114), exports);
      var domhandler_1 = __nccwpck_require__(3291);
      Object.defineProperty(exports, "isTag", {
        enumerable: true,
        get: function () {
          return domhandler_1.isTag;
        },
      });
      Object.defineProperty(exports, "isCDATA", {
        enumerable: true,
        get: function () {
          return domhandler_1.isCDATA;
        },
      });
      Object.defineProperty(exports, "isText", {
        enumerable: true,
        get: function () {
          return domhandler_1.isText;
        },
      });
      Object.defineProperty(exports, "isComment", {
        enumerable: true,
        get: function () {
          return domhandler_1.isComment;
        },
      });
      Object.defineProperty(exports, "isDocument", {
        enumerable: true,
        get: function () {
          return domhandler_1.isDocument;
        },
      });
      Object.defineProperty(exports, "hasChildren", {
        enumerable: true,
        get: function () {
          return domhandler_1.hasChildren;
        },
      });
    },
    7121: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getElementsByTagType =
        exports.getElementsByTagName =
        exports.getElementById =
        exports.getElements =
        exports.testElement =
          void 0;
      var domhandler_1 = __nccwpck_require__(3291);
      var querying_1 = __nccwpck_require__(7281);
      var Checks = {
        tag_name: function (name) {
          if (typeof name === "function") {
            return function (elem) {
              return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
          } else if (name === "*") {
            return domhandler_1.isTag;
          }
          return function (elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
          };
        },
        tag_type: function (type) {
          if (typeof type === "function") {
            return function (elem) {
              return type(elem.type);
            };
          }
          return function (elem) {
            return elem.type === type;
          };
        },
        tag_contains: function (data) {
          if (typeof data === "function") {
            return function (elem) {
              return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
          }
          return function (elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
          };
        },
      };
      function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
          return function (elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
          };
        }
        return function (elem) {
          return (
            (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value
          );
        };
      }
      function combineFuncs(a, b) {
        return function (elem) {
          return a(elem) || b(elem);
        };
      }
      function compileTest(options) {
        var funcs = Object.keys(options).map(function (key) {
          var value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
      }
      function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
      }
      exports.testElement = testElement;
      function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) {
          limit = Infinity;
        }
        var test = compileTest(options);
        return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
      }
      exports.getElements = getElements;
      function getElementById(id, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (!Array.isArray(nodes)) nodes = [nodes];
        return (0, querying_1.findOne)(
          getAttribCheck("id", id),
          nodes,
          recurse,
        );
      }
      exports.getElementById = getElementById;
      function getElementsByTagName(tagName, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_1.filter)(
          Checks.tag_name(tagName),
          nodes,
          recurse,
          limit,
        );
      }
      exports.getElementsByTagName = getElementsByTagName;
      function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_1.filter)(
          Checks.tag_type(type),
          nodes,
          recurse,
          limit,
        );
      }
      exports.getElementsByTagType = getElementsByTagType;
    },
    2506: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.prepend =
        exports.prependChild =
        exports.append =
        exports.appendChild =
        exports.replaceElement =
        exports.removeElement =
          void 0;
      function removeElement(elem) {
        if (elem.prev) elem.prev.next = elem.next;
        if (elem.next) elem.next.prev = elem.prev;
        if (elem.parent) {
          var childs = elem.parent.children;
          childs.splice(childs.lastIndexOf(elem), 1);
        }
      }
      exports.removeElement = removeElement;
      function replaceElement(elem, replacement) {
        var prev = (replacement.prev = elem.prev);
        if (prev) {
          prev.next = replacement;
        }
        var next = (replacement.next = elem.next);
        if (next) {
          next.prev = replacement;
        }
        var parent = (replacement.parent = elem.parent);
        if (parent) {
          var childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
        }
      }
      exports.replaceElement = replaceElement;
      function appendChild(elem, child) {
        removeElement(child);
        child.next = null;
        child.parent = elem;
        if (elem.children.push(child) > 1) {
          var sibling = elem.children[elem.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
        } else {
          child.prev = null;
        }
      }
      exports.appendChild = appendChild;
      function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
          currNext.prev = next;
          if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
        } else if (parent) {
          parent.children.push(next);
        }
      }
      exports.append = append;
      function prependChild(elem, child) {
        removeElement(child);
        child.parent = elem;
        child.prev = null;
        if (elem.children.unshift(child) !== 1) {
          var sibling = elem.children[1];
          sibling.prev = child;
          child.next = sibling;
        } else {
          child.next = null;
        }
      }
      exports.prependChild = prependChild;
      function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
          elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
      }
      exports.prepend = prepend;
    },
    7281: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findAll =
        exports.existsOne =
        exports.findOne =
        exports.findOneChild =
        exports.find =
        exports.filter =
          void 0;
      var domhandler_1 = __nccwpck_require__(3291);
      function filter(test, node, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        if (!Array.isArray(node)) node = [node];
        return find(test, node, recurse, limit);
      }
      exports.filter = filter;
      function find(test, nodes, recurse, limit) {
        var result = [];
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
          var elem = nodes_1[_i];
          if (test(elem)) {
            result.push(elem);
            if (--limit <= 0) break;
          }
          if (
            recurse &&
            (0, domhandler_1.hasChildren)(elem) &&
            elem.children.length > 0
          ) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0) break;
          }
        }
        return result;
      }
      exports.find = find;
      function findOneChild(test, nodes) {
        return nodes.find(test);
      }
      exports.findOneChild = findOneChild;
      function findOne(test, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        var elem = null;
        for (var i = 0; i < nodes.length && !elem; i++) {
          var checked = nodes[i];
          if (!(0, domhandler_1.isTag)(checked)) {
            continue;
          } else if (test(checked)) {
            elem = checked;
          } else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
          }
        }
        return elem;
      }
      exports.findOne = findOne;
      function existsOne(test, nodes) {
        return nodes.some(function (checked) {
          return (
            (0, domhandler_1.isTag)(checked) &&
            (test(checked) ||
              (checked.children.length > 0 &&
                existsOne(test, checked.children)))
          );
        });
      }
      exports.existsOne = existsOne;
      function findAll(test, nodes) {
        var _a;
        var result = [];
        var stack = nodes.filter(domhandler_1.isTag);
        var elem;
        while ((elem = stack.shift())) {
          var children =
            (_a = elem.children) === null || _a === void 0
              ? void 0
              : _a.filter(domhandler_1.isTag);
          if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
          }
          if (test(elem)) result.push(elem);
        }
        return result;
      }
      exports.findAll = findAll;
    },
    9397: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.innerText =
        exports.textContent =
        exports.getText =
        exports.getInnerHTML =
        exports.getOuterHTML =
          void 0;
      var domhandler_1 = __nccwpck_require__(3291);
      var dom_serializer_1 = __importDefault(__nccwpck_require__(1553));
      var domelementtype_1 = __nccwpck_require__(1810);
      function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
      }
      exports.getOuterHTML = getOuterHTML;
      function getInnerHTML(node, options) {
        return (0, domhandler_1.hasChildren)(node)
          ? node.children
              .map(function (node) {
                return getOuterHTML(node, options);
              })
              .join("")
          : "";
      }
      exports.getInnerHTML = getInnerHTML;
      function getText(node) {
        if (Array.isArray(node)) return node.map(getText).join("");
        if ((0, domhandler_1.isTag)(node))
          return node.name === "br" ? "\n" : getText(node.children);
        if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
        if ((0, domhandler_1.isText)(node)) return node.data;
        return "";
      }
      exports.getText = getText;
      function textContent(node) {
        if (Array.isArray(node)) return node.map(textContent).join("");
        if (
          (0, domhandler_1.hasChildren)(node) &&
          !(0, domhandler_1.isComment)(node)
        ) {
          return textContent(node.children);
        }
        if ((0, domhandler_1.isText)(node)) return node.data;
        return "";
      }
      exports.textContent = textContent;
      function innerText(node) {
        if (Array.isArray(node)) return node.map(innerText).join("");
        if (
          (0, domhandler_1.hasChildren)(node) &&
          (node.type === domelementtype_1.ElementType.Tag ||
            (0, domhandler_1.isCDATA)(node))
        ) {
          return innerText(node.children);
        }
        if ((0, domhandler_1.isText)(node)) return node.data;
        return "";
      }
      exports.innerText = innerText;
    },
    4229: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.prevElementSibling =
        exports.nextElementSibling =
        exports.getName =
        exports.hasAttrib =
        exports.getAttributeValue =
        exports.getSiblings =
        exports.getParent =
        exports.getChildren =
          void 0;
      var domhandler_1 = __nccwpck_require__(3291);
      var emptyArray = [];
      function getChildren(elem) {
        var _a;
        return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
      }
      exports.getChildren = getChildren;
      function getParent(elem) {
        return elem.parent || null;
      }
      exports.getParent = getParent;
      function getSiblings(elem) {
        var _a, _b;
        var parent = getParent(elem);
        if (parent != null) return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev,
          next = elem.next;
        while (prev != null) {
          siblings.unshift(prev);
          (_a = prev), (prev = _a.prev);
        }
        while (next != null) {
          siblings.push(next);
          (_b = next), (next = _b.next);
        }
        return siblings;
      }
      exports.getSiblings = getSiblings;
      function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0
          ? void 0
          : _a[name];
      }
      exports.getAttributeValue = getAttributeValue;
      function hasAttrib(elem, name) {
        return (
          elem.attribs != null &&
          Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
          elem.attribs[name] != null
        );
      }
      exports.hasAttrib = hasAttrib;
      function getName(elem) {
        return elem.name;
      }
      exports.getName = getName;
      function nextElementSibling(elem) {
        var _a;
        var next = elem.next;
        while (next !== null && !(0, domhandler_1.isTag)(next))
          (_a = next), (next = _a.next);
        return next;
      }
      exports.nextElementSibling = nextElementSibling;
      function prevElementSibling(elem) {
        var _a;
        var prev = elem.prev;
        while (prev !== null && !(0, domhandler_1.isTag)(prev))
          (_a = prev), (prev = _a.prev);
        return prev;
      }
      exports.prevElementSibling = prevElementSibling;
    },
    8531: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decodeHTML =
        exports.decodeHTMLStrict =
        exports.decodeXML =
          void 0;
      var entities_json_1 = __importDefault(__nccwpck_require__(8844));
      var legacy_json_1 = __importDefault(__nccwpck_require__(3380));
      var xml_json_1 = __importDefault(__nccwpck_require__(3024));
      var decode_codepoint_1 = __importDefault(__nccwpck_require__(9230));
      var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      exports.decodeXML = getStrictDecoder(xml_json_1.default);
      exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
      function getStrictDecoder(map) {
        var replace = getReplacer(map);
        return function (str) {
          return String(str).replace(strictEntityRe, replace);
        };
      }
      var sorter = function (a, b) {
        return a < b ? 1 : -1;
      };
      exports.decodeHTML = (function () {
        var legacy = Object.keys(legacy_json_1.default).sort(sorter);
        var keys = Object.keys(entities_json_1.default).sort(sorter);
        for (var i = 0, j = 0; i < keys.length; i++) {
          if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
          } else {
            keys[i] += ";";
          }
        }
        var re = new RegExp(
          "&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)",
          "g",
        );
        var replace = getReplacer(entities_json_1.default);
        function replacer(str) {
          if (str.substr(-1) !== ";") str += ";";
          return replace(str);
        }
        return function (str) {
          return String(str).replace(re, replacer);
        };
      })();
      function getReplacer(map) {
        return function replace(str) {
          if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
              return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
          }
          return map[str.slice(1, -1)] || str;
        };
      }
    },
    9230: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      var decode_json_1 = __importDefault(__nccwpck_require__(710));
      var fromCodePoint =
        String.fromCodePoint ||
        function (codePoint) {
          var output = "";
          if (codePoint > 65535) {
            codePoint -= 65536;
            output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
            codePoint = 56320 | (codePoint & 1023);
          }
          output += String.fromCharCode(codePoint);
          return output;
        };
      function decodeCodePoint(codePoint) {
        if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
          return "�";
        }
        if (codePoint in decode_json_1.default) {
          codePoint = decode_json_1.default[codePoint];
        }
        return fromCodePoint(codePoint);
      }
      exports["default"] = decodeCodePoint;
    },
    7850: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.escapeUTF8 =
        exports.escape =
        exports.encodeNonAsciiHTML =
        exports.encodeHTML =
        exports.encodeXML =
          void 0;
      var xml_json_1 = __importDefault(__nccwpck_require__(3024));
      var inverseXML = getInverseObj(xml_json_1.default);
      var xmlReplacer = getInverseReplacer(inverseXML);
      exports.encodeXML = getASCIIEncoder(inverseXML);
      var entities_json_1 = __importDefault(__nccwpck_require__(8844));
      var inverseHTML = getInverseObj(entities_json_1.default);
      var htmlReplacer = getInverseReplacer(inverseHTML);
      exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
      exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
      function getInverseObj(obj) {
        return Object.keys(obj)
          .sort()
          .reduce(function (inverse, name) {
            inverse[obj[name]] = "&" + name + ";";
            return inverse;
          }, {});
      }
      function getInverseReplacer(inverse) {
        var single = [];
        var multiple = [];
        for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
          var k = _a[_i];
          if (k.length === 1) {
            single.push("\\" + k);
          } else {
            multiple.push(k);
          }
        }
        single.sort();
        for (var start = 0; start < single.length - 1; start++) {
          var end = start;
          while (
            end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)
          ) {
            end += 1;
          }
          var count = 1 + end - start;
          if (count < 3) continue;
          single.splice(start, count, single[start] + "-" + single[end]);
        }
        multiple.unshift("[" + single.join("") + "]");
        return new RegExp(multiple.join("|"), "g");
      }
      var reNonASCII =
        /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      var getCodePoint =
        String.prototype.codePointAt != null
          ? function (str) {
              return str.codePointAt(0);
            }
          : function (c) {
              return (
                (c.charCodeAt(0) - 55296) * 1024 +
                c.charCodeAt(1) -
                56320 +
                65536
              );
            };
      function singleCharReplacer(c) {
        return (
          "&#x" +
          (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
            .toString(16)
            .toUpperCase() +
          ";"
        );
      }
      function getInverse(inverse, re) {
        return function (data) {
          return data
            .replace(re, function (name) {
              return inverse[name];
            })
            .replace(reNonASCII, singleCharReplacer);
        };
      }
      var reEscapeChars = new RegExp(
        xmlReplacer.source + "|" + reNonASCII.source,
        "g",
      );
      function escape(data) {
        return data.replace(reEscapeChars, singleCharReplacer);
      }
      exports.escape = escape;
      function escapeUTF8(data) {
        return data.replace(xmlReplacer, singleCharReplacer);
      }
      exports.escapeUTF8 = escapeUTF8;
      function getASCIIEncoder(obj) {
        return function (data) {
          return data.replace(reEscapeChars, function (c) {
            return obj[c] || singleCharReplacer(c);
          });
        };
      }
    },
    302: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decodeXMLStrict =
        exports.decodeHTML5Strict =
        exports.decodeHTML4Strict =
        exports.decodeHTML5 =
        exports.decodeHTML4 =
        exports.decodeHTMLStrict =
        exports.decodeHTML =
        exports.decodeXML =
        exports.encodeHTML5 =
        exports.encodeHTML4 =
        exports.escapeUTF8 =
        exports.escape =
        exports.encodeNonAsciiHTML =
        exports.encodeHTML =
        exports.encodeXML =
        exports.encode =
        exports.decodeStrict =
        exports.decode =
          void 0;
      var decode_1 = __nccwpck_require__(8531);
      var encode_1 = __nccwpck_require__(7850);
      function decode(data, level) {
        return (
          !level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML
        )(data);
      }
      exports.decode = decode;
      function decodeStrict(data, level) {
        return (
          !level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict
        )(data);
      }
      exports.decodeStrict = decodeStrict;
      function encode(data, level) {
        return (
          !level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML
        )(data);
      }
      exports.encode = encode;
      var encode_2 = __nccwpck_require__(7850);
      Object.defineProperty(exports, "encodeXML", {
        enumerable: true,
        get: function () {
          return encode_2.encodeXML;
        },
      });
      Object.defineProperty(exports, "encodeHTML", {
        enumerable: true,
        get: function () {
          return encode_2.encodeHTML;
        },
      });
      Object.defineProperty(exports, "encodeNonAsciiHTML", {
        enumerable: true,
        get: function () {
          return encode_2.encodeNonAsciiHTML;
        },
      });
      Object.defineProperty(exports, "escape", {
        enumerable: true,
        get: function () {
          return encode_2.escape;
        },
      });
      Object.defineProperty(exports, "escapeUTF8", {
        enumerable: true,
        get: function () {
          return encode_2.escapeUTF8;
        },
      });
      Object.defineProperty(exports, "encodeHTML4", {
        enumerable: true,
        get: function () {
          return encode_2.encodeHTML;
        },
      });
      Object.defineProperty(exports, "encodeHTML5", {
        enumerable: true,
        get: function () {
          return encode_2.encodeHTML;
        },
      });
      var decode_2 = __nccwpck_require__(8531);
      Object.defineProperty(exports, "decodeXML", {
        enumerable: true,
        get: function () {
          return decode_2.decodeXML;
        },
      });
      Object.defineProperty(exports, "decodeHTML", {
        enumerable: true,
        get: function () {
          return decode_2.decodeHTML;
        },
      });
      Object.defineProperty(exports, "decodeHTMLStrict", {
        enumerable: true,
        get: function () {
          return decode_2.decodeHTMLStrict;
        },
      });
      Object.defineProperty(exports, "decodeHTML4", {
        enumerable: true,
        get: function () {
          return decode_2.decodeHTML;
        },
      });
      Object.defineProperty(exports, "decodeHTML5", {
        enumerable: true,
        get: function () {
          return decode_2.decodeHTML;
        },
      });
      Object.defineProperty(exports, "decodeHTML4Strict", {
        enumerable: true,
        get: function () {
          return decode_2.decodeHTMLStrict;
        },
      });
      Object.defineProperty(exports, "decodeHTML5Strict", {
        enumerable: true,
        get: function () {
          return decode_2.decodeHTMLStrict;
        },
      });
      Object.defineProperty(exports, "decodeXMLStrict", {
        enumerable: true,
        get: function () {
          return decode_2.decodeXML;
        },
      });
    },
    2901: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generate = exports.compile = void 0;
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      function compile(parsed) {
        var a = parsed[0];
        var b = parsed[1] - 1;
        if (b < 0 && a <= 0) return boolbase_1.default.falseFunc;
        if (a === -1)
          return function (index) {
            return index <= b;
          };
        if (a === 0)
          return function (index) {
            return index === b;
          };
        if (a === 1)
          return b < 0
            ? boolbase_1.default.trueFunc
            : function (index) {
                return index >= b;
              };
        var absA = Math.abs(a);
        var bMod = ((b % absA) + absA) % absA;
        return a > 1
          ? function (index) {
              return index >= b && index % absA === bMod;
            }
          : function (index) {
              return index <= b && index % absA === bMod;
            };
      }
      exports.compile = compile;
      function generate(parsed) {
        var a = parsed[0];
        var b = parsed[1] - 1;
        var n = 0;
        if (a < 0) {
          var aPos_1 = -a;
          var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
          return function () {
            var val = minValue_1 + aPos_1 * n++;
            return val > b ? null : val;
          };
        }
        if (a === 0)
          return b < 0
            ? function () {
                return null;
              }
            : function () {
                return n++ === 0 ? b : null;
              };
        if (b < 0) {
          b += a * Math.ceil(-b / a);
        }
        return function () {
          return a * n++ + b;
        };
      }
      exports.generate = generate;
    },
    8452: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequence =
        exports.generate =
        exports.compile =
        exports.parse =
          void 0;
      var parse_js_1 = __nccwpck_require__(3056);
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function () {
          return parse_js_1.parse;
        },
      });
      var compile_js_1 = __nccwpck_require__(2901);
      Object.defineProperty(exports, "compile", {
        enumerable: true,
        get: function () {
          return compile_js_1.compile;
        },
      });
      Object.defineProperty(exports, "generate", {
        enumerable: true,
        get: function () {
          return compile_js_1.generate;
        },
      });
      function nthCheck(formula) {
        return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
      }
      exports["default"] = nthCheck;
      function sequence(formula) {
        return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
      }
      exports.sequence = sequence;
    },
    3056: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = void 0;
      var whitespace = new Set([9, 10, 12, 13, 32]);
      var ZERO = "0".charCodeAt(0);
      var NINE = "9".charCodeAt(0);
      function parse(formula) {
        formula = formula.trim().toLowerCase();
        if (formula === "even") {
          return [2, 0];
        } else if (formula === "odd") {
          return [2, 1];
        }
        var idx = 0;
        var a = 0;
        var sign = readSign();
        var number = readNumber();
        if (idx < formula.length && formula.charAt(idx) === "n") {
          idx++;
          a = sign * (number !== null && number !== void 0 ? number : 1);
          skipWhitespace();
          if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
          } else {
            sign = number = 0;
          }
        }
        if (number === null || idx < formula.length) {
          throw new Error(
            "n-th rule couldn't be parsed ('".concat(formula, "')"),
          );
        }
        return [a, sign * number];
        function readSign() {
          if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
          }
          if (formula.charAt(idx) === "+") {
            idx++;
          }
          return 1;
        }
        function readNumber() {
          var start = idx;
          var value = 0;
          while (
            idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE
          ) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
          }
          return idx === start ? null : value;
        }
        function skipWhitespace() {
          while (
            idx < formula.length &&
            whitespace.has(formula.charCodeAt(idx))
          ) {
            idx++;
          }
        }
      }
      exports.parse = parse;
    },
    4700: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var util = __nccwpck_require__(935);
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? new Map() : Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(
        aArray,
        aAllowDuplicates,
      ) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap
          ? this._set.size
          : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap
          ? this.has(aStr)
          : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.I = ArraySet;
    },
    5021: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var base64 = __nccwpck_require__(4591);
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    },
    4591: (__unused_webpack_module, exports) => {
      var intToCharMap =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
          "",
        );
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function (charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    },
    9913: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var util = __nccwpck_require__(935);
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return (
          lineB > lineA ||
          (lineB == lineA && columnB >= columnA) ||
          util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
        );
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(
        aCallback,
        aThisArg,
      ) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.H = MappingList;
    },
    2364: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var base64VLQ = __nccwpck_require__(5021);
      var util = __nccwpck_require__(935);
      var ArraySet = __nccwpck_require__(4700).I;
      var MappingList = __nccwpck_require__(9913).H;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot,
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn,
              },
            };
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(
                  sourceRoot,
                  newMapping.source,
                );
              }
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn,
              };
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var sourceRelative = sourceFile;
            if (sourceRoot !== null) {
              sourceRelative = util.relative(sourceRoot, sourceFile);
            }
            if (!generator._sources.has(sourceRelative)) {
              generator._sources.add(sourceRelative);
            }
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, "generated");
          var original = util.getArg(aArgs, "original", null);
          var source = util.getArg(aArgs, "source", null);
          var name = util.getArg(aArgs, "name", null);
          if (!this._skipValidation) {
            this._validateMapping(generated, original, source, name);
          }
          if (source != null) {
            source = String(source);
            if (!this._sources.has(source)) {
              this._sources.add(source);
            }
          }
          if (name != null) {
            name = String(name);
            if (!this._names.has(name)) {
              this._names.add(name);
            }
          }
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source,
            name,
          });
        };
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(
          aSourceFile,
          aSourceContent,
        ) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
          if (aSourceContent != null) {
            if (!this._sourcesContents) {
              this._sourcesContents = Object.create(null);
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(
          aSourceMapConsumer,
          aSourceFile,
          aSourceMapPath,
        ) {
          var sourceFile = aSourceFile;
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
                  'or the source map\'s "file" property. Both were omitted.',
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          var newSources = new ArraySet();
          var newNames = new ArraySet();
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn,
              });
              if (original.source != null) {
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
          }, this);
          this._sources = newSources;
          this._names = newNames;
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(
          aGenerated,
          aOriginal,
          aSource,
          aName,
        ) {
          if (
            aOriginal &&
            typeof aOriginal.line !== "number" &&
            typeof aOriginal.column !== "number"
          ) {
            throw new Error(
              "original.line and original.column are not numbers -- you probably meant to omit " +
                "the original mapping entirely and only map the generated position. If so, pass " +
                "null for the original mapping instead of an object with empty or null values.",
            );
          }
          if (
            aGenerated &&
            "line" in aGenerated &&
            "column" in aGenerated &&
            aGenerated.line > 0 &&
            aGenerated.column >= 0 &&
            !aOriginal &&
            !aSource &&
            !aName
          ) {
            return;
          } else if (
            aGenerated &&
            "line" in aGenerated &&
            "column" in aGenerated &&
            aOriginal &&
            "line" in aOriginal &&
            "column" in aOriginal &&
            aGenerated.line > 0 &&
            aGenerated.column >= 0 &&
            aOriginal.line > 0 &&
            aOriginal.column >= 0 &&
            aSource
          ) {
            return;
          } else {
            throw new Error(
              "Invalid mapping: " +
                JSON.stringify({
                  generated: aGenerated,
                  source: aSource,
                  original: aOriginal,
                  name: aName,
                }),
            );
          }
        };
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = "";
          var next;
          var mapping;
          var nameIdx;
          var sourceIdx;
          var mappings = this._mappings.toArray();
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
            next = "";
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                next += ";";
                previousGeneratedLine++;
              }
            } else {
              if (i > 0) {
                if (
                  !util.compareByGeneratedPositionsInflated(
                    mapping,
                    mappings[i - 1],
                  )
                ) {
                  continue;
                }
                next += ",";
              }
            }
            next += base64VLQ.encode(
              mapping.generatedColumn - previousGeneratedColumn,
            );
            previousGeneratedColumn = mapping.generatedColumn;
            if (mapping.source != null) {
              sourceIdx = this._sources.indexOf(mapping.source);
              next += base64VLQ.encode(sourceIdx - previousSource);
              previousSource = sourceIdx;
              next += base64VLQ.encode(
                mapping.originalLine - 1 - previousOriginalLine,
              );
              previousOriginalLine = mapping.originalLine - 1;
              next += base64VLQ.encode(
                mapping.originalColumn - previousOriginalColumn,
              );
              previousOriginalColumn = mapping.originalColumn;
              if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
              }
            }
            result += next;
          }
          return result;
        };
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(
          aSources,
          aSourceRoot,
        ) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(
              this._sourcesContents,
              key,
            )
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings(),
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(
              map.sources,
              map.sourceRoot,
            );
          }
          return map;
        };
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
      exports.h = SourceMapGenerator;
    },
    935: (__unused_webpack_module, exports) => {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp =
        /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5],
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined =
          aPath.charAt(0) === "/"
            ? aPath
            : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = (function () {
        var obj = Object.create(null);
        return !("__proto__" in obj);
      })();
      function identity(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (
          s.charCodeAt(length - 1) !== 95 ||
          s.charCodeAt(length - 2) !== 95 ||
          s.charCodeAt(length - 3) !== 111 ||
          s.charCodeAt(length - 4) !== 116 ||
          s.charCodeAt(length - 5) !== 111 ||
          s.charCodeAt(length - 6) !== 114 ||
          s.charCodeAt(length - 7) !== 112 ||
          s.charCodeAt(length - 8) !== 95 ||
          s.charCodeAt(length - 9) !== 95
        ) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(
        mappingA,
        mappingB,
        onlyCompareOriginal,
      ) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(
        mappingA,
        mappingB,
        onlyCompareGenerated,
      ) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated =
        compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated =
        compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (
            sourceRoot[sourceRoot.length - 1] !== "/" &&
            sourceURL[0] !== "/"
          ) {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    },
    5685: function (module) {
      //! stable.js 0.1.8, https://github.com/Two-Screen/stable
      //! © 2018 Angry Bytes and contributors. MIT licensed.
      (function (global, factory) {
        true ? (module.exports = factory()) : 0;
      })(this, function () {
        "use strict";
        var stable = function (arr, comp) {
          return exec(arr.slice(), comp);
        };
        stable.inplace = function (arr, comp) {
          var result = exec(arr, comp);
          if (result !== arr) {
            pass(result, null, arr.length, arr);
          }
          return arr;
        };
        function exec(arr, comp) {
          if (typeof comp !== "function") {
            comp = function (a, b) {
              return String(a).localeCompare(b);
            };
          }
          var len = arr.length;
          if (len <= 1) {
            return arr;
          }
          var buffer = new Array(len);
          for (var chk = 1; chk < len; chk *= 2) {
            pass(arr, comp, chk, buffer);
            var tmp = arr;
            arr = buffer;
            buffer = tmp;
          }
          return arr;
        }
        var pass = function (arr, comp, chk, result) {
          var len = arr.length;
          var i = 0;
          var dbl = chk * 2;
          var l, r, e;
          var li, ri;
          for (l = 0; l < len; l += dbl) {
            r = l + chk;
            e = r + chk;
            if (r > len) r = len;
            if (e > len) e = len;
            li = l;
            ri = r;
            while (true) {
              if (li < r && ri < e) {
                if (comp(arr[li], arr[ri]) <= 0) {
                  result[i++] = arr[li++];
                } else {
                  result[i++] = arr[ri++];
                }
              } else if (li < r) {
                result[i++] = arr[li++];
              } else if (ri < e) {
                result[i++] = arr[ri++];
              } else {
                break;
              }
            }
          }
        };
        return stable;
      });
    },
    6198: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { optimize, loadConfig } = __nccwpck_require__(3044);
      const loaderUtils = __nccwpck_require__(9429);
      async function loader(source) {
        const { configFile, ...options } = loaderUtils.getOptions(this) || {};
        let config;
        if (typeof configFile === "string") {
          config = await loadConfig(configFile, this.context);
        } else if (configFile !== false) {
          config = await loadConfig(null, this.context);
        }
        const result = optimize(source, {
          path: this.resourcePath,
          ...config,
          ...options,
        });
        if (result.error) {
          throw Error(result.error);
        }
        return result.data;
      }
      module.exports = function (source) {
        const callback = this.async();
        loader
          .call(this, source)
          .then((result) => callback(null, result))
          .catch((error) => callback(error));
      };
    },
    4050: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var csstree = __nccwpck_require__(4895),
        List = csstree.List,
        stable = __nccwpck_require__(5685),
        specificity = __nccwpck_require__(7876);
      function flattenToSelectors(cssAst) {
        var selectors = [];
        csstree.walk(cssAst, {
          visit: "Rule",
          enter: function (node) {
            if (node.type !== "Rule") {
              return;
            }
            var atrule = this.atrule;
            var rule = node;
            node.prelude.children.each(function (selectorNode, selectorItem) {
              var selector = { item: selectorItem, atrule, rule, pseudos: [] };
              selectorNode.children.each(
                function (
                  selectorChildNode,
                  selectorChildItem,
                  selectorChildList,
                ) {
                  if (
                    selectorChildNode.type === "PseudoClassSelector" ||
                    selectorChildNode.type === "PseudoElementSelector"
                  ) {
                    selector.pseudos.push({
                      item: selectorChildItem,
                      list: selectorChildList,
                    });
                  }
                },
              );
              selectors.push(selector);
            });
          },
        });
        return selectors;
      }
      function filterByMqs(selectors, useMqs) {
        return selectors.filter(function (selector) {
          if (selector.atrule === null) {
            return ~useMqs.indexOf("");
          }
          var mqName = selector.atrule.name;
          var mqStr = mqName;
          if (
            selector.atrule.expression &&
            selector.atrule.expression.children.first().type ===
              "MediaQueryList"
          ) {
            var mqExpr = csstree.generate(selector.atrule.expression);
            mqStr = [mqName, mqExpr].join(" ");
          }
          return ~useMqs.indexOf(mqStr);
        });
      }
      function filterByPseudos(selectors, usePseudos) {
        return selectors.filter(function (selector) {
          var pseudoSelectorsStr = csstree.generate({
            type: "Selector",
            children: new List().fromArray(
              selector.pseudos.map(function (pseudo) {
                return pseudo.item.data;
              }),
            ),
          });
          return ~usePseudos.indexOf(pseudoSelectorsStr);
        });
      }
      function cleanPseudos(selectors) {
        selectors.forEach(function (selector) {
          selector.pseudos.forEach(function (pseudo) {
            pseudo.list.remove(pseudo.item);
          });
        });
      }
      function compareSpecificity(aSpecificity, bSpecificity) {
        for (var i = 0; i < 4; i += 1) {
          if (aSpecificity[i] < bSpecificity[i]) {
            return -1;
          } else if (aSpecificity[i] > bSpecificity[i]) {
            return 1;
          }
        }
        return 0;
      }
      function compareSimpleSelectorNode(
        aSimpleSelectorNode,
        bSimpleSelectorNode,
      ) {
        var aSpecificity = specificity(aSimpleSelectorNode),
          bSpecificity = specificity(bSimpleSelectorNode);
        return compareSpecificity(aSpecificity, bSpecificity);
      }
      function _bySelectorSpecificity(selectorA, selectorB) {
        return compareSimpleSelectorNode(
          selectorA.item.data,
          selectorB.item.data,
        );
      }
      function sortSelectors(selectors) {
        return stable(selectors, _bySelectorSpecificity);
      }
      function csstreeToStyleDeclaration(declaration) {
        var propertyName = declaration.property,
          propertyValue = csstree.generate(declaration.value),
          propertyPriority = declaration.important ? "important" : "";
        return {
          name: propertyName,
          value: propertyValue,
          priority: propertyPriority,
        };
      }
      function getCssStr(elem) {
        if (
          elem.children.length > 0 &&
          (elem.children[0].type === "text" ||
            elem.children[0].type === "cdata")
        ) {
          return elem.children[0].value;
        }
        return "";
      }
      function setCssStr(elem, css) {
        if (elem.children.length === 0) {
          elem.children.push({ type: "text", value: "" });
        }
        if (
          elem.children[0].type !== "text" &&
          elem.children[0].type !== "cdata"
        ) {
          return css;
        }
        elem.children[0].value = css;
        return css;
      }
      module.exports.flattenToSelectors = flattenToSelectors;
      module.exports.filterByMqs = filterByMqs;
      module.exports.filterByPseudos = filterByPseudos;
      module.exports.cleanPseudos = cleanPseudos;
      module.exports.compareSpecificity = compareSpecificity;
      module.exports.compareSimpleSelectorNode = compareSimpleSelectorNode;
      module.exports.sortSelectors = sortSelectors;
      module.exports.csstreeToStyleDeclaration = csstreeToStyleDeclaration;
      module.exports.getCssStr = getCssStr;
      module.exports.setCssStr = setCssStr;
    },
    1432: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const SAX = __nccwpck_require__(6049);
      const JSAPI = __nccwpck_require__(1877);
      const { textElems } = __nccwpck_require__(6173);
      class SvgoParserError extends Error {
        constructor(message, line, column, source, file) {
          super(message);
          this.name = "SvgoParserError";
          this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
          this.reason = message;
          this.line = line;
          this.column = column;
          this.source = source;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, SvgoParserError);
          }
        }
        toString() {
          const lines = this.source.split(/\r?\n/);
          const startLine = Math.max(this.line - 3, 0);
          const endLine = Math.min(this.line + 2, lines.length);
          const lineNumberWidth = String(endLine).length;
          const startColumn = Math.max(this.column - 54, 0);
          const endColumn = Math.max(this.column + 20, 80);
          const code = lines
            .slice(startLine, endLine)
            .map((line, index) => {
              const lineSlice = line.slice(startColumn, endColumn);
              let ellipsisPrefix = "";
              let ellipsisSuffix = "";
              if (startColumn !== 0) {
                ellipsisPrefix = startColumn > line.length - 1 ? " " : "…";
              }
              if (endColumn < line.length - 1) {
                ellipsisSuffix = "…";
              }
              const number = startLine + 1 + index;
              const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
              if (number === this.line) {
                const gutterSpacing = gutter.replace(/[^|]/g, " ");
                const lineSpacing = (
                  ellipsisPrefix + line.slice(startColumn, this.column - 1)
                ).replace(/[^\t]/g, " ");
                const spacing = gutterSpacing + lineSpacing;
                return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\n ${spacing}^`;
              }
              return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
            })
            .join("\n");
          return `${this.name}: ${this.message}\n\n${code}\n`;
        }
      }
      const entityDeclaration =
        /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
      const config = {
        strict: true,
        trim: false,
        normalize: false,
        lowercase: true,
        xmlns: true,
        position: true,
      };
      const parseSvg = (data, from) => {
        const sax = SAX.parser(config.strict, config);
        const root = new JSAPI({ type: "root", children: [] });
        let current = root;
        const stack = [root];
        const pushToContent = (node) => {
          const wrapped = new JSAPI(node, current);
          current.children.push(wrapped);
          return wrapped;
        };
        sax.ondoctype = (doctype) => {
          const node = { type: "doctype", name: "svg", data: { doctype } };
          pushToContent(node);
          const subsetStart = doctype.indexOf("[");
          if (subsetStart >= 0) {
            entityDeclaration.lastIndex = subsetStart;
            let entityMatch = entityDeclaration.exec(data);
            while (entityMatch != null) {
              sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
              entityMatch = entityDeclaration.exec(data);
            }
          }
        };
        sax.onprocessinginstruction = (data) => {
          const node = {
            type: "instruction",
            name: data.name,
            value: data.body,
          };
          pushToContent(node);
        };
        sax.oncomment = (comment) => {
          const node = { type: "comment", value: comment.trim() };
          pushToContent(node);
        };
        sax.oncdata = (cdata) => {
          const node = { type: "cdata", value: cdata };
          pushToContent(node);
        };
        sax.onopentag = (data) => {
          let element = {
            type: "element",
            name: data.name,
            attributes: {},
            children: [],
          };
          for (const [name, attr] of Object.entries(data.attributes)) {
            element.attributes[name] = attr.value;
          }
          element = pushToContent(element);
          current = element;
          stack.push(element);
        };
        sax.ontext = (text) => {
          if (current.type === "element") {
            if (textElems.includes(current.name)) {
              const node = { type: "text", value: text };
              pushToContent(node);
            } else if (/\S/.test(text)) {
              const node = { type: "text", value: text.trim() };
              pushToContent(node);
            }
          }
        };
        sax.onclosetag = () => {
          stack.pop();
          current = stack[stack.length - 1];
        };
        sax.onerror = (e) => {
          const error = new SvgoParserError(
            e.reason,
            e.line + 1,
            e.column,
            data,
            from,
          );
          if (e.message.indexOf("Unexpected end") === -1) {
            throw error;
          }
        };
        sax.write(data).close();
        return root;
      };
      exports.parseSvg = parseSvg;
    },
    740: (__unused_webpack_module, exports) => {
      "use strict";
      const argsCountPerCommand = {
        M: 2,
        m: 2,
        Z: 0,
        z: 0,
        L: 2,
        l: 2,
        H: 1,
        h: 1,
        V: 1,
        v: 1,
        C: 6,
        c: 6,
        S: 4,
        s: 4,
        Q: 4,
        q: 4,
        T: 2,
        t: 2,
        A: 7,
        a: 7,
      };
      const isCommand = (c) => c in argsCountPerCommand;
      const isWsp = (c) => {
        const codePoint = c.codePointAt(0);
        return (
          codePoint === 32 ||
          codePoint === 9 ||
          codePoint === 13 ||
          codePoint === 10
        );
      };
      const isDigit = (c) => {
        const codePoint = c.codePointAt(0);
        if (codePoint == null) {
          return false;
        }
        return 48 <= codePoint && codePoint <= 57;
      };
      const readNumber = (string, cursor) => {
        let i = cursor;
        let value = "";
        let state = "none";
        for (; i < string.length; i += 1) {
          const c = string[i];
          if (c === "+" || c === "-") {
            if (state === "none") {
              state = "sign";
              value += c;
              continue;
            }
            if (state === "e") {
              state = "exponent_sign";
              value += c;
              continue;
            }
          }
          if (isDigit(c)) {
            if (state === "none" || state === "sign" || state === "whole") {
              state = "whole";
              value += c;
              continue;
            }
            if (state === "decimal_point" || state === "decimal") {
              state = "decimal";
              value += c;
              continue;
            }
            if (
              state === "e" ||
              state === "exponent_sign" ||
              state === "exponent"
            ) {
              state = "exponent";
              value += c;
              continue;
            }
          }
          if (c === ".") {
            if (state === "none" || state === "sign" || state === "whole") {
              state = "decimal_point";
              value += c;
              continue;
            }
          }
          if (c === "E" || c == "e") {
            if (
              state === "whole" ||
              state === "decimal_point" ||
              state === "decimal"
            ) {
              state = "e";
              value += c;
              continue;
            }
          }
          break;
        }
        const number = Number.parseFloat(value);
        if (Number.isNaN(number)) {
          return [cursor, null];
        } else {
          return [i - 1, number];
        }
      };
      const parsePathData = (string) => {
        const pathData = [];
        let command = null;
        let args = [];
        let argsCount = 0;
        let canHaveComma = false;
        let hadComma = false;
        for (let i = 0; i < string.length; i += 1) {
          const c = string.charAt(i);
          if (isWsp(c)) {
            continue;
          }
          if (canHaveComma && c === ",") {
            if (hadComma) {
              break;
            }
            hadComma = true;
            continue;
          }
          if (isCommand(c)) {
            if (hadComma) {
              return pathData;
            }
            if (command == null) {
              if (c !== "M" && c !== "m") {
                return pathData;
              }
            } else {
              if (args.length !== 0) {
                return pathData;
              }
            }
            command = c;
            args = [];
            argsCount = argsCountPerCommand[command];
            canHaveComma = false;
            if (argsCount === 0) {
              pathData.push({ command, args });
            }
            continue;
          }
          if (command == null) {
            return pathData;
          }
          let newCursor = i;
          let number = null;
          if (command === "A" || command === "a") {
            const position = args.length;
            if (position === 0 || position === 1) {
              if (c !== "+" && c !== "-") {
                [newCursor, number] = readNumber(string, i);
              }
            }
            if (position === 2 || position === 5 || position === 6) {
              [newCursor, number] = readNumber(string, i);
            }
            if (position === 3 || position === 4) {
              if (c === "0") {
                number = 0;
              }
              if (c === "1") {
                number = 1;
              }
            }
          } else {
            [newCursor, number] = readNumber(string, i);
          }
          if (number == null) {
            return pathData;
          }
          args.push(number);
          canHaveComma = true;
          hadComma = false;
          i = newCursor;
          if (args.length === argsCount) {
            pathData.push({ command, args });
            if (command === "M") {
              command = "L";
            }
            if (command === "m") {
              command = "l";
            }
            args = [];
          }
        }
        return pathData;
      };
      exports.parsePathData = parsePathData;
      const stringifyNumber = (number, precision) => {
        if (precision != null) {
          const ratio = 10 ** precision;
          number = Math.round(number * ratio) / ratio;
        }
        return number.toString().replace(/^0\./, ".").replace(/^-0\./, "-.");
      };
      const stringifyArgs = (
        command,
        args,
        precision,
        disableSpaceAfterFlags,
      ) => {
        let result = "";
        let prev = "";
        for (let i = 0; i < args.length; i += 1) {
          const number = args[i];
          const numberString = stringifyNumber(number, precision);
          if (
            disableSpaceAfterFlags &&
            (command === "A" || command === "a") &&
            (i % 7 === 4 || i % 7 === 5)
          ) {
            result += numberString;
          } else if (i === 0 || numberString.startsWith("-")) {
            result += numberString;
          } else if (prev.includes(".") && numberString.startsWith(".")) {
            result += numberString;
          } else {
            result += ` ${numberString}`;
          }
          prev = numberString;
        }
        return result;
      };
      const stringifyPathData = ({
        pathData,
        precision,
        disableSpaceAfterFlags,
      }) => {
        let combined = [];
        for (let i = 0; i < pathData.length; i += 1) {
          const { command, args } = pathData[i];
          if (i === 0) {
            combined.push({ command, args });
          } else {
            const last = combined[combined.length - 1];
            if (i === 1) {
              if (command === "L") {
                last.command = "M";
              }
              if (command === "l") {
                last.command = "m";
              }
            }
            if (
              (last.command === command &&
                last.command !== "M" &&
                last.command !== "m") ||
              (last.command === "M" && command === "L") ||
              (last.command === "m" && command === "l")
            ) {
              last.args = [...last.args, ...args];
            } else {
              combined.push({ command, args });
            }
          }
        }
        let result = "";
        for (const { command, args } of combined) {
          result +=
            command +
            stringifyArgs(command, args, precision, disableSpaceAfterFlags);
        }
        return result;
      };
      exports.stringifyPathData = stringifyPathData;
    },
    7774: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { textElems } = __nccwpck_require__(6173);
      const encodeEntity = (char) => entities[char];
      const defaults = {
        doctypeStart: "<!DOCTYPE",
        doctypeEnd: ">",
        procInstStart: "<?",
        procInstEnd: "?>",
        tagOpenStart: "<",
        tagOpenEnd: ">",
        tagCloseStart: "</",
        tagCloseEnd: ">",
        tagShortStart: "<",
        tagShortEnd: "/>",
        attrStart: '="',
        attrEnd: '"',
        commentStart: "\x3c!--",
        commentEnd: "--\x3e",
        cdataStart: "<![CDATA[",
        cdataEnd: "]]>",
        textStart: "",
        textEnd: "",
        indent: 4,
        regEntities: /[&'"<>]/g,
        regValEntities: /[&"<>]/g,
        encodeEntity,
        pretty: false,
        useShortTags: true,
        eol: "lf",
        finalNewline: false,
      };
      const entities = {
        "&": "&amp;",
        "'": "&apos;",
        '"': "&quot;",
        ">": "&gt;",
        "<": "&lt;",
      };
      const stringifySvg = (data, userOptions = {}) => {
        const config = { ...defaults, ...userOptions };
        const indent = config.indent;
        let newIndent = "    ";
        if (typeof indent === "number" && Number.isNaN(indent) === false) {
          newIndent = indent < 0 ? "\t" : " ".repeat(indent);
        } else if (typeof indent === "string") {
          newIndent = indent;
        }
        const state = {
          width: undefined,
          height: undefined,
          indent: newIndent,
          textContext: null,
          indentLevel: 0,
        };
        const eol = config.eol === "crlf" ? "\r\n" : "\n";
        if (config.pretty) {
          config.doctypeEnd += eol;
          config.procInstEnd += eol;
          config.commentEnd += eol;
          config.cdataEnd += eol;
          config.tagShortEnd += eol;
          config.tagOpenEnd += eol;
          config.tagCloseEnd += eol;
          config.textEnd += eol;
        }
        let svg = stringifyNode(data, config, state);
        if (
          config.finalNewline &&
          svg.length > 0 &&
          svg[svg.length - 1] !== "\n"
        ) {
          svg += eol;
        }
        return {
          data: svg,
          info: { width: state.width, height: state.height },
        };
      };
      exports.stringifySvg = stringifySvg;
      const stringifyNode = (data, config, state) => {
        let svg = "";
        state.indentLevel += 1;
        for (const item of data.children) {
          if (item.type === "element") {
            svg += stringifyElement(item, config, state);
          }
          if (item.type === "text") {
            svg += stringifyText(item, config, state);
          }
          if (item.type === "doctype") {
            svg += stringifyDoctype(item, config);
          }
          if (item.type === "instruction") {
            svg += stringifyInstruction(item, config);
          }
          if (item.type === "comment") {
            svg += stringifyComment(item, config);
          }
          if (item.type === "cdata") {
            svg += stringifyCdata(item, config, state);
          }
        }
        state.indentLevel -= 1;
        return svg;
      };
      const createIndent = (config, state) => {
        let indent = "";
        if (config.pretty && state.textContext == null) {
          indent = state.indent.repeat(state.indentLevel - 1);
        }
        return indent;
      };
      const stringifyDoctype = (node, config) =>
        config.doctypeStart + node.data.doctype + config.doctypeEnd;
      const stringifyInstruction = (node, config) =>
        config.procInstStart +
        node.name +
        " " +
        node.value +
        config.procInstEnd;
      const stringifyComment = (node, config) =>
        config.commentStart + node.value + config.commentEnd;
      const stringifyCdata = (node, config, state) =>
        createIndent(config, state) +
        config.cdataStart +
        node.value +
        config.cdataEnd;
      const stringifyElement = (node, config, state) => {
        if (
          node.name === "svg" &&
          node.attributes.width != null &&
          node.attributes.height != null
        ) {
          state.width = node.attributes.width;
          state.height = node.attributes.height;
        }
        if (node.children.length === 0) {
          if (config.useShortTags) {
            return (
              createIndent(config, state) +
              config.tagShortStart +
              node.name +
              stringifyAttributes(node, config) +
              config.tagShortEnd
            );
          } else {
            return (
              createIndent(config, state) +
              config.tagShortStart +
              node.name +
              stringifyAttributes(node, config) +
              config.tagOpenEnd +
              config.tagCloseStart +
              node.name +
              config.tagCloseEnd
            );
          }
        } else {
          let tagOpenStart = config.tagOpenStart;
          let tagOpenEnd = config.tagOpenEnd;
          let tagCloseStart = config.tagCloseStart;
          let tagCloseEnd = config.tagCloseEnd;
          let openIndent = createIndent(config, state);
          let closeIndent = createIndent(config, state);
          if (state.textContext) {
            tagOpenStart = defaults.tagOpenStart;
            tagOpenEnd = defaults.tagOpenEnd;
            tagCloseStart = defaults.tagCloseStart;
            tagCloseEnd = defaults.tagCloseEnd;
            openIndent = "";
          } else if (textElems.includes(node.name)) {
            tagOpenEnd = defaults.tagOpenEnd;
            tagCloseStart = defaults.tagCloseStart;
            closeIndent = "";
            state.textContext = node;
          }
          const children = stringifyNode(node, config, state);
          if (state.textContext === node) {
            state.textContext = null;
          }
          return (
            openIndent +
            tagOpenStart +
            node.name +
            stringifyAttributes(node, config) +
            tagOpenEnd +
            children +
            closeIndent +
            tagCloseStart +
            node.name +
            tagCloseEnd
          );
        }
      };
      const stringifyAttributes = (node, config) => {
        let attrs = "";
        for (const [name, value] of Object.entries(node.attributes)) {
          if (value !== undefined) {
            const encodedValue = value
              .toString()
              .replace(config.regValEntities, config.encodeEntity);
            attrs +=
              " " + name + config.attrStart + encodedValue + config.attrEnd;
          } else {
            attrs += " " + name;
          }
        }
        return attrs;
      };
      const stringifyText = (node, config, state) =>
        createIndent(config, state) +
        config.textStart +
        node.value.replace(config.regEntities, config.encodeEntity) +
        (state.textContext ? "" : config.textEnd);
    },
    2618: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const stable = __nccwpck_require__(5685);
      const csstree = __nccwpck_require__(4895);
      const specificity = __nccwpck_require__(7876);
      const { visit, matches } = __nccwpck_require__(143);
      const {
        attrsGroups,
        inheritableAttrs,
        presentationNonInheritableGroupAttrs,
      } = __nccwpck_require__(6173);
      const csstreeWalkSkip = csstree.walk.skip;
      const parseRule = (ruleNode, dynamic) => {
        let selectors;
        let selectorsSpecificity;
        const declarations = [];
        csstree.walk(ruleNode, (cssNode) => {
          if (cssNode.type === "SelectorList") {
            selectorsSpecificity = specificity(cssNode);
            const newSelectorsNode = csstree.clone(cssNode);
            csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
              if (pseudoClassNode.type === "PseudoClassSelector") {
                dynamic = true;
                list.remove(item);
              }
            });
            selectors = csstree.generate(newSelectorsNode);
            return csstreeWalkSkip;
          }
          if (cssNode.type === "Declaration") {
            declarations.push({
              name: cssNode.property,
              value: csstree.generate(cssNode.value),
              important: cssNode.important === true,
            });
            return csstreeWalkSkip;
          }
        });
        if (selectors == null || selectorsSpecificity == null) {
          throw Error("assert");
        }
        return {
          dynamic,
          selectors,
          specificity: selectorsSpecificity,
          declarations,
        };
      };
      const parseStylesheet = (css, dynamic) => {
        const rules = [];
        const ast = csstree.parse(css, {
          parseValue: false,
          parseAtrulePrelude: false,
        });
        csstree.walk(ast, (cssNode) => {
          if (cssNode.type === "Rule") {
            rules.push(parseRule(cssNode, dynamic || false));
            return csstreeWalkSkip;
          }
          if (cssNode.type === "Atrule") {
            if (cssNode.name === "keyframes") {
              return csstreeWalkSkip;
            }
            csstree.walk(cssNode, (ruleNode) => {
              if (ruleNode.type === "Rule") {
                rules.push(parseRule(ruleNode, dynamic || true));
                return csstreeWalkSkip;
              }
            });
            return csstreeWalkSkip;
          }
        });
        return rules;
      };
      const parseStyleDeclarations = (css) => {
        const declarations = [];
        const ast = csstree.parse(css, {
          context: "declarationList",
          parseValue: false,
        });
        csstree.walk(ast, (cssNode) => {
          if (cssNode.type === "Declaration") {
            declarations.push({
              name: cssNode.property,
              value: csstree.generate(cssNode.value),
              important: cssNode.important === true,
            });
          }
        });
        return declarations;
      };
      const computeOwnStyle = (stylesheet, node) => {
        const computedStyle = {};
        const importantStyles = new Map();
        for (const [name, value] of Object.entries(node.attributes)) {
          if (attrsGroups.presentation.includes(name)) {
            computedStyle[name] = { type: "static", inherited: false, value };
            importantStyles.set(name, false);
          }
        }
        for (const { selectors, declarations, dynamic } of stylesheet.rules) {
          if (matches(node, selectors)) {
            for (const { name, value, important } of declarations) {
              const computed = computedStyle[name];
              if (computed && computed.type === "dynamic") {
                continue;
              }
              if (dynamic) {
                computedStyle[name] = { type: "dynamic", inherited: false };
                continue;
              }
              if (
                computed == null ||
                important === true ||
                importantStyles.get(name) === false
              ) {
                computedStyle[name] = {
                  type: "static",
                  inherited: false,
                  value,
                };
                importantStyles.set(name, important);
              }
            }
          }
        }
        const styleDeclarations =
          node.attributes.style == null
            ? []
            : parseStyleDeclarations(node.attributes.style);
        for (const { name, value, important } of styleDeclarations) {
          const computed = computedStyle[name];
          if (computed && computed.type === "dynamic") {
            continue;
          }
          if (
            computed == null ||
            important === true ||
            importantStyles.get(name) === false
          ) {
            computedStyle[name] = { type: "static", inherited: false, value };
            importantStyles.set(name, important);
          }
        }
        return computedStyle;
      };
      const compareSpecificity = (a, b) => {
        for (var i = 0; i < 4; i += 1) {
          if (a[i] < b[i]) {
            return -1;
          } else if (a[i] > b[i]) {
            return 1;
          }
        }
        return 0;
      };
      const collectStylesheet = (root) => {
        const rules = [];
        const parents = new Map();
        visit(root, {
          element: {
            enter: (node, parentNode) => {
              parents.set(node, parentNode);
              if (node.name === "style") {
                const dynamic =
                  node.attributes.media != null &&
                  node.attributes.media !== "all";
                if (
                  node.attributes.type == null ||
                  node.attributes.type === "" ||
                  node.attributes.type === "text/css"
                ) {
                  const children = node.children;
                  for (const child of children) {
                    if (child.type === "text" || child.type === "cdata") {
                      rules.push(...parseStylesheet(child.value, dynamic));
                    }
                  }
                }
              }
            },
          },
        });
        stable.inplace(rules, (a, b) =>
          compareSpecificity(a.specificity, b.specificity),
        );
        return { rules, parents };
      };
      exports.collectStylesheet = collectStylesheet;
      const computeStyle = (stylesheet, node) => {
        const { parents } = stylesheet;
        const computedStyles = computeOwnStyle(stylesheet, node);
        let parent = parents.get(node);
        while (parent != null && parent.type !== "root") {
          const inheritedStyles = computeOwnStyle(stylesheet, parent);
          for (const [name, computed] of Object.entries(inheritedStyles)) {
            if (
              computedStyles[name] == null &&
              inheritableAttrs.includes(name) === true &&
              presentationNonInheritableGroupAttrs.includes(name) === false
            ) {
              computedStyles[name] = { ...computed, inherited: true };
            }
          }
          parent = parents.get(parent);
        }
        return computedStyles;
      };
      exports.computeStyle = computeStyle;
    },
    3044: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const os = __nccwpck_require__(2037);
      const fs = __nccwpck_require__(7147);
      const { pathToFileURL } = __nccwpck_require__(7310);
      const path = __nccwpck_require__(1017);
      const {
        extendDefaultPlugins,
        optimize: optimizeAgnostic,
        createContentItem,
      } = __nccwpck_require__(7608);
      exports.extendDefaultPlugins = extendDefaultPlugins;
      exports.createContentItem = createContentItem;
      const importConfig = async (configFile) => {
        let config;
        if (configFile.endsWith(".cjs")) {
          config = require(configFile);
        } else {
          try {
            const { default: imported } = await __nccwpck_require__(1503)(
              pathToFileURL(configFile),
            );
            config = imported;
          } catch (importError) {
            try {
              config = require(configFile);
            } catch (requireError) {
              if (requireError.code === "ERR_REQUIRE_ESM") {
                throw importError;
              } else {
                throw requireError;
              }
            }
          }
        }
        if (
          config == null ||
          typeof config !== "object" ||
          Array.isArray(config)
        ) {
          throw Error(`Invalid config file "${configFile}"`);
        }
        return config;
      };
      const isFile = async (file) => {
        try {
          const stats = await fs.promises.stat(file);
          return stats.isFile();
        } catch {
          return false;
        }
      };
      const loadConfig = async (configFile, cwd = process.cwd()) => {
        if (configFile != null) {
          if (path.isAbsolute(configFile)) {
            return await importConfig(configFile);
          } else {
            return await importConfig(path.join(cwd, configFile));
          }
        }
        let dir = cwd;
        while (true) {
          const js = path.join(dir, "svgo.config.js");
          if (await isFile(js)) {
            return await importConfig(js);
          }
          const mjs = path.join(dir, "svgo.config.mjs");
          if (await isFile(mjs)) {
            return await importConfig(mjs);
          }
          const cjs = path.join(dir, "svgo.config.cjs");
          if (await isFile(cjs)) {
            return await importConfig(cjs);
          }
          const parent = path.dirname(dir);
          if (dir === parent) {
            return null;
          }
          dir = parent;
        }
      };
      exports.loadConfig = loadConfig;
      const optimize = (input, config) => {
        if (config == null) {
          config = {};
        }
        if (typeof config !== "object") {
          throw Error("Config should be an object");
        }
        return optimizeAgnostic(input, {
          ...config,
          js2svg: { eol: os.EOL === "\r\n" ? "crlf" : "lf", ...config.js2svg },
        });
      };
      exports.optimize = optimize;
    },
    7608: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { defaultPlugins, resolvePluginConfig, extendDefaultPlugins } =
        __nccwpck_require__(2592);
      const { parseSvg } = __nccwpck_require__(1432);
      const { stringifySvg } = __nccwpck_require__(7774);
      const { invokePlugins } = __nccwpck_require__(9180);
      const JSAPI = __nccwpck_require__(1877);
      const { encodeSVGDatauri } = __nccwpck_require__(6614);
      exports.extendDefaultPlugins = extendDefaultPlugins;
      const optimize = (input, config) => {
        if (config == null) {
          config = {};
        }
        if (typeof config !== "object") {
          throw Error("Config should be an object");
        }
        const maxPassCount = config.multipass ? 10 : 1;
        let prevResultSize = Number.POSITIVE_INFINITY;
        let svgjs = null;
        const info = {};
        if (config.path != null) {
          info.path = config.path;
        }
        for (let i = 0; i < maxPassCount; i += 1) {
          info.multipassCount = i;
          try {
            svgjs = parseSvg(input, config.path);
          } catch (error) {
            return { error: error.toString(), modernError: error };
          }
          if (svgjs.error != null) {
            if (config.path != null) {
              svgjs.path = config.path;
            }
            return svgjs;
          }
          const plugins = config.plugins || defaultPlugins;
          if (Array.isArray(plugins) === false) {
            throw Error(
              "Invalid plugins list. Provided 'plugins' in config should be an array.",
            );
          }
          const resolvedPlugins = plugins.map(resolvePluginConfig);
          const globalOverrides = {};
          if (config.floatPrecision != null) {
            globalOverrides.floatPrecision = config.floatPrecision;
          }
          svgjs = invokePlugins(
            svgjs,
            info,
            resolvedPlugins,
            null,
            globalOverrides,
          );
          svgjs = stringifySvg(svgjs, config.js2svg);
          if (svgjs.data.length < prevResultSize) {
            input = svgjs.data;
            prevResultSize = svgjs.data.length;
          } else {
            if (config.datauri) {
              svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
            }
            if (config.path != null) {
              svgjs.path = config.path;
            }
            return svgjs;
          }
        }
        return svgjs;
      };
      exports.optimize = optimize;
      const createContentItem = (data) => new JSAPI(data);
      exports.createContentItem = createContentItem;
    },
    2592: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const pluginsMap = __nccwpck_require__(868);
      const pluginsOrder = [
        "removeDoctype",
        "removeXMLProcInst",
        "removeComments",
        "removeMetadata",
        "removeXMLNS",
        "removeEditorsNSData",
        "cleanupAttrs",
        "mergeStyles",
        "inlineStyles",
        "minifyStyles",
        "convertStyleToAttrs",
        "cleanupIDs",
        "prefixIds",
        "removeRasterImages",
        "removeUselessDefs",
        "cleanupNumericValues",
        "cleanupListOfValues",
        "convertColors",
        "removeUnknownsAndDefaults",
        "removeNonInheritableGroupAttrs",
        "removeUselessStrokeAndFill",
        "removeViewBox",
        "cleanupEnableBackground",
        "removeHiddenElems",
        "removeEmptyText",
        "convertShapeToPath",
        "convertEllipseToCircle",
        "moveElemsAttrsToGroup",
        "moveGroupAttrsToElems",
        "collapseGroups",
        "convertPathData",
        "convertTransform",
        "removeEmptyAttrs",
        "removeEmptyContainers",
        "mergePaths",
        "removeUnusedNS",
        "sortAttrs",
        "sortDefsChildren",
        "removeTitle",
        "removeDesc",
        "removeDimensions",
        "removeAttrs",
        "removeAttributesBySelector",
        "removeElementsByAttr",
        "addClassesToSVGElement",
        "removeStyleElement",
        "removeScriptElement",
        "addAttributesToSVGElement",
        "removeOffCanvasPaths",
        "reusePaths",
      ];
      const defaultPlugins = pluginsOrder.filter(
        (name) => pluginsMap[name].active,
      );
      exports.defaultPlugins = defaultPlugins;
      const extendDefaultPlugins = (plugins) => {
        console.warn(
          '\n"extendDefaultPlugins" utility is deprecated.\n' +
            'Use "preset-default" plugin with overrides instead.\n' +
            "For example:\n" +
            `{\n` +
            `  name: 'preset-default',\n` +
            `  params: {\n` +
            `    overrides: {\n` +
            `      // customize plugin options\n` +
            `      convertShapeToPath: {\n` +
            `        convertArcs: true\n` +
            `      },\n` +
            `      // disable plugins\n` +
            `      convertPathData: false\n` +
            `    }\n` +
            `  }\n` +
            `}\n`,
        );
        const extendedPlugins = pluginsOrder.map((name) => ({
          name,
          active: pluginsMap[name].active,
        }));
        for (const plugin of plugins) {
          const resolvedPlugin = resolvePluginConfig(plugin);
          const index = pluginsOrder.indexOf(resolvedPlugin.name);
          if (index === -1) {
            extendedPlugins.push(plugin);
          } else {
            extendedPlugins[index] = plugin;
          }
        }
        return extendedPlugins;
      };
      exports.extendDefaultPlugins = extendDefaultPlugins;
      const resolvePluginConfig = (plugin) => {
        let configParams = {};
        if (typeof plugin === "string") {
          const pluginConfig = pluginsMap[plugin];
          if (pluginConfig == null) {
            throw Error(`Unknown builtin plugin "${plugin}" specified.`);
          }
          return {
            ...pluginConfig,
            name: plugin,
            active: true,
            params: { ...pluginConfig.params, ...configParams },
          };
        }
        if (typeof plugin === "object" && plugin != null) {
          if (plugin.name == null) {
            throw Error(`Plugin name should be specified`);
          }
          if (plugin.fn) {
            return {
              active: true,
              ...plugin,
              params: { ...configParams, ...plugin.params },
            };
          } else {
            const pluginConfig = pluginsMap[plugin.name];
            if (pluginConfig == null) {
              throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
            }
            return {
              ...pluginConfig,
              active: true,
              ...plugin,
              params: {
                ...pluginConfig.params,
                ...configParams,
                ...plugin.params,
              },
            };
          }
        }
        return null;
      };
      exports.resolvePluginConfig = resolvePluginConfig;
    },
    4182: (module) => {
      "use strict";
      var CSSClassList = function (node) {
        this.parentNode = node;
        this.classNames = new Set();
        const value = node.attributes.class;
        if (value != null) {
          this.addClassValueHandler();
          this.setClassValue(value);
        }
      };
      CSSClassList.prototype.addClassValueHandler = function () {
        Object.defineProperty(this.parentNode.attributes, "class", {
          get: this.getClassValue.bind(this),
          set: this.setClassValue.bind(this),
          enumerable: true,
          configurable: true,
        });
      };
      CSSClassList.prototype.getClassValue = function () {
        var arrClassNames = Array.from(this.classNames);
        return arrClassNames.join(" ");
      };
      CSSClassList.prototype.setClassValue = function (newValue) {
        if (typeof newValue === "undefined") {
          this.classNames.clear();
          return;
        }
        var arrClassNames = newValue.split(" ");
        this.classNames = new Set(arrClassNames);
      };
      CSSClassList.prototype.add = function () {
        this.addClassValueHandler();
        Object.values(arguments).forEach(this._addSingle.bind(this));
      };
      CSSClassList.prototype._addSingle = function (className) {
        this.classNames.add(className);
      };
      CSSClassList.prototype.remove = function () {
        this.addClassValueHandler();
        Object.values(arguments).forEach(this._removeSingle.bind(this));
      };
      CSSClassList.prototype._removeSingle = function (className) {
        this.classNames.delete(className);
      };
      CSSClassList.prototype.item = function (index) {
        var arrClassNames = Array.from(this.classNames);
        return arrClassNames[index];
      };
      CSSClassList.prototype.toggle = function (className, force) {
        if (this.contains(className) || force === false) {
          this.classNames.delete(className);
        }
        this.classNames.add(className);
      };
      CSSClassList.prototype.contains = function (className) {
        return this.classNames.has(className);
      };
      module.exports = CSSClassList;
    },
    9332: (module) => {
      "use strict";
      const isTag = (node) => node.type === "element";
      const existsOne = (test, elems) =>
        elems.some((elem) => {
          if (isTag(elem)) {
            return test(elem) || existsOne(test, getChildren(elem));
          } else {
            return false;
          }
        });
      const getAttributeValue = (elem, name) => elem.attributes[name];
      const getChildren = (node) => node.children || [];
      const getName = (elemAst) => elemAst.name;
      const getParent = (node) => node.parentNode || null;
      const getSiblings = (elem) => {
        var parent = getParent(elem);
        return parent ? getChildren(parent) : [];
      };
      const getText = (node) => {
        if (
          node.children[0].type === "text" &&
          node.children[0].type === "cdata"
        ) {
          return node.children[0].value;
        }
        return "";
      };
      const hasAttrib = (elem, name) => elem.attributes[name] !== undefined;
      const removeSubsets = (nodes) => {
        let idx = nodes.length;
        let node;
        let ancestor;
        let replace;
        while (--idx > -1) {
          node = ancestor = nodes[idx];
          nodes[idx] = null;
          replace = true;
          while (ancestor) {
            if (nodes.includes(ancestor)) {
              replace = false;
              nodes.splice(idx, 1);
              break;
            }
            ancestor = getParent(ancestor);
          }
          if (replace) {
            nodes[idx] = node;
          }
        }
        return nodes;
      };
      const findAll = (test, elems) => {
        const result = [];
        for (const elem of elems) {
          if (isTag(elem)) {
            if (test(elem)) {
              result.push(elem);
            }
            result.push(...findAll(test, getChildren(elem)));
          }
        }
        return result;
      };
      const findOne = (test, elems) => {
        for (const elem of elems) {
          if (isTag(elem)) {
            if (test(elem)) {
              return elem;
            }
            const result = findOne(test, getChildren(elem));
            if (result) {
              return result;
            }
          }
        }
        return null;
      };
      const svgoCssSelectAdapter = {
        isTag,
        existsOne,
        getAttributeValue,
        getChildren,
        getName,
        getParent,
        getSiblings,
        getText,
        hasAttrib,
        removeSubsets,
        findAll,
        findOne,
      };
      module.exports = svgoCssSelectAdapter;
    },
    2649: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var csstree = __nccwpck_require__(4895),
        csstools = __nccwpck_require__(4050);
      var CSSStyleDeclaration = function (node) {
        this.parentNode = node;
        this.properties = new Map();
        this.hasSynced = false;
        this.styleValue = null;
        this.parseError = false;
        const value = node.attributes.style;
        if (value != null) {
          this.addStyleValueHandler();
          this.setStyleValue(value);
        }
      };
      CSSStyleDeclaration.prototype.addStyleValueHandler = function () {
        Object.defineProperty(this.parentNode.attributes, "style", {
          get: this.getStyleValue.bind(this),
          set: this.setStyleValue.bind(this),
          enumerable: true,
          configurable: true,
        });
      };
      CSSStyleDeclaration.prototype.getStyleValue = function () {
        return this.getCssText();
      };
      CSSStyleDeclaration.prototype.setStyleValue = function (newValue) {
        this.properties.clear();
        this.styleValue = newValue;
        this.hasSynced = false;
      };
      CSSStyleDeclaration.prototype._loadCssText = function () {
        if (this.hasSynced) {
          return;
        }
        this.hasSynced = true;
        if (!this.styleValue || this.styleValue.length === 0) {
          return;
        }
        var inlineCssStr = this.styleValue;
        var declarations = {};
        try {
          declarations = csstree.parse(inlineCssStr, {
            context: "declarationList",
            parseValue: false,
          });
        } catch (parseError) {
          this.parseError = parseError;
          return;
        }
        this.parseError = false;
        var self = this;
        declarations.children.each(function (declaration) {
          try {
            var styleDeclaration =
              csstools.csstreeToStyleDeclaration(declaration);
            self.setProperty(
              styleDeclaration.name,
              styleDeclaration.value,
              styleDeclaration.priority,
            );
          } catch (styleError) {
            if (styleError.message !== "Unknown node type: undefined") {
              self.parseError = styleError;
            }
          }
        });
      };
      CSSStyleDeclaration.prototype.getCssText = function () {
        var properties = this.getProperties();
        if (this.parseError) {
          return this.styleValue;
        }
        var cssText = [];
        properties.forEach(function (property, propertyName) {
          var strImportant =
            property.priority === "important" ? "!important" : "";
          cssText.push(
            propertyName.trim() + ":" + property.value.trim() + strImportant,
          );
        });
        return cssText.join(";");
      };
      CSSStyleDeclaration.prototype._handleParseError = function () {
        if (this.parseError) {
          console.warn(
            "Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr('style').value. Error details: " +
              this.parseError,
          );
        }
      };
      CSSStyleDeclaration.prototype._getProperty = function (propertyName) {
        if (typeof propertyName === "undefined") {
          throw Error("1 argument required, but only 0 present.");
        }
        var properties = this.getProperties();
        this._handleParseError();
        var property = properties.get(propertyName.trim());
        return property;
      };
      CSSStyleDeclaration.prototype.getPropertyPriority = function (
        propertyName,
      ) {
        var property = this._getProperty(propertyName);
        return property ? property.priority : "";
      };
      CSSStyleDeclaration.prototype.getPropertyValue = function (propertyName) {
        var property = this._getProperty(propertyName);
        return property ? property.value : null;
      };
      CSSStyleDeclaration.prototype.item = function (index) {
        if (typeof index === "undefined") {
          throw Error("1 argument required, but only 0 present.");
        }
        var properties = this.getProperties();
        this._handleParseError();
        return Array.from(properties.keys())[index];
      };
      CSSStyleDeclaration.prototype.getProperties = function () {
        this._loadCssText();
        return this.properties;
      };
      CSSStyleDeclaration.prototype.removeProperty = function (propertyName) {
        if (typeof propertyName === "undefined") {
          throw Error("1 argument required, but only 0 present.");
        }
        this.addStyleValueHandler();
        var properties = this.getProperties();
        this._handleParseError();
        var oldValue = this.getPropertyValue(propertyName);
        properties.delete(propertyName.trim());
        return oldValue;
      };
      CSSStyleDeclaration.prototype.setProperty = function (
        propertyName,
        value,
        priority,
      ) {
        if (typeof propertyName === "undefined") {
          throw Error("propertyName argument required, but only not present.");
        }
        this.addStyleValueHandler();
        var properties = this.getProperties();
        this._handleParseError();
        var property = { value: value.trim(), priority: priority.trim() };
        properties.set(propertyName.trim(), property);
        return property;
      };
      module.exports = CSSStyleDeclaration;
    },
    1877: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { selectAll, selectOne, is } = __nccwpck_require__(9100);
      const svgoCssSelectAdapter = __nccwpck_require__(9332);
      const CSSClassList = __nccwpck_require__(4182);
      const CSSStyleDeclaration = __nccwpck_require__(2649);
      const parseName = (name) => {
        if (name == null) {
          return { prefix: "", local: "" };
        }
        if (name === "xmlns") {
          return { prefix: "xmlns", local: "" };
        }
        const chunks = name.split(":");
        if (chunks.length === 1) {
          return { prefix: "", local: chunks[0] };
        }
        return { prefix: chunks[0], local: chunks[1] };
      };
      var cssSelectOpts = { xmlMode: true, adapter: svgoCssSelectAdapter };
      const attrsHandler = {
        get: (attributes, name) => {
          if (attributes.hasOwnProperty(name)) {
            return {
              name,
              get value() {
                return attributes[name];
              },
              set value(value) {
                attributes[name] = value;
              },
            };
          }
        },
        set: (attributes, name, attr) => {
          attributes[name] = attr.value;
          return true;
        },
      };
      var JSAPI = function (data, parentNode) {
        Object.assign(this, data);
        if (this.type === "element") {
          if (this.attributes == null) {
            this.attributes = {};
          }
          if (this.children == null) {
            this.children = [];
          }
          Object.defineProperty(this, "class", {
            writable: true,
            configurable: true,
            value: new CSSClassList(this),
          });
          Object.defineProperty(this, "style", {
            writable: true,
            configurable: true,
            value: new CSSStyleDeclaration(this),
          });
          Object.defineProperty(this, "parentNode", {
            writable: true,
            value: parentNode,
          });
          const element = this;
          Object.defineProperty(this, "attrs", {
            configurable: true,
            get() {
              return new Proxy(element.attributes, attrsHandler);
            },
            set(value) {
              const newAttributes = {};
              for (const attr of Object.values(value)) {
                newAttributes[attr.name] = attr.value;
              }
              element.attributes = newAttributes;
            },
          });
        }
      };
      module.exports = JSAPI;
      JSAPI.prototype.clone = function () {
        const { children, ...nodeData } = this;
        const clonedNode = new JSAPI(
          JSON.parse(JSON.stringify(nodeData)),
          null,
        );
        if (children) {
          clonedNode.children = children.map((child) => {
            const clonedChild = child.clone();
            clonedChild.parentNode = clonedNode;
            return clonedChild;
          });
        }
        return clonedNode;
      };
      JSAPI.prototype.isElem = function (param) {
        if (this.type !== "element") {
          return false;
        }
        if (param == null) {
          return true;
        }
        if (Array.isArray(param)) {
          return param.includes(this.name);
        }
        return this.name === param;
      };
      JSAPI.prototype.renameElem = function (name) {
        if (name && typeof name === "string") this.name = name;
        return this;
      };
      JSAPI.prototype.isEmpty = function () {
        return !this.children || !this.children.length;
      };
      JSAPI.prototype.closestElem = function (elemName) {
        var elem = this;
        while ((elem = elem.parentNode) && !elem.isElem(elemName));
        return elem;
      };
      JSAPI.prototype.spliceContent = function (start, n, insertion) {
        if (arguments.length < 2) return [];
        if (!Array.isArray(insertion))
          insertion = Array.apply(null, arguments).slice(2);
        insertion.forEach(function (inner) {
          inner.parentNode = this;
        }, this);
        return this.children.splice.apply(
          this.children,
          [start, n].concat(insertion),
        );
      };
      JSAPI.prototype.hasAttr = function (name, val) {
        if (this.type !== "element") {
          return false;
        }
        if (Object.keys(this.attributes).length === 0) {
          return false;
        }
        if (name == null) {
          return true;
        }
        if (this.attributes.hasOwnProperty(name) === false) {
          return false;
        }
        if (val !== undefined) {
          return this.attributes[name] === val.toString();
        }
        return true;
      };
      JSAPI.prototype.hasAttrLocal = function (localName, val) {
        if (!this.attrs || !Object.keys(this.attrs).length) return false;
        if (!arguments.length) return !!this.attrs;
        var callback;
        switch (val != null && val.constructor && val.constructor.name) {
          case "Number":
          case "String":
            callback = stringValueTest;
            break;
          case "RegExp":
            callback = regexpValueTest;
            break;
          case "Function":
            callback = funcValueTest;
            break;
          default:
            callback = nameTest;
        }
        return this.someAttr(callback);
        function nameTest(attr) {
          const { local } = parseName(attr.name);
          return local === localName;
        }
        function stringValueTest(attr) {
          const { local } = parseName(attr.name);
          return local === localName && val == attr.value;
        }
        function regexpValueTest(attr) {
          const { local } = parseName(attr.name);
          return local === localName && val.test(attr.value);
        }
        function funcValueTest(attr) {
          const { local } = parseName(attr.name);
          return local === localName && val(attr.value);
        }
      };
      JSAPI.prototype.attr = function (name, val) {
        if (this.hasAttr(name, val)) {
          return this.attrs[name];
        }
      };
      JSAPI.prototype.computedAttr = function (name, val) {
        if (!arguments.length) return;
        for (
          var elem = this;
          elem && (!elem.hasAttr(name) || !elem.attributes[name]);
          elem = elem.parentNode
        );
        if (val != null) {
          return elem ? elem.hasAttr(name, val) : false;
        } else if (elem && elem.hasAttr(name)) {
          return elem.attributes[name];
        }
      };
      JSAPI.prototype.removeAttr = function (name, val) {
        if (this.type !== "element") {
          return false;
        }
        if (arguments.length === 0) {
          return false;
        }
        if (Array.isArray(name)) {
          for (const nameItem of name) {
            this.removeAttr(nameItem, val);
          }
          return false;
        }
        if (this.hasAttr(name, val) === false) {
          return false;
        }
        delete this.attributes[name];
        return true;
      };
      JSAPI.prototype.addAttr = function (attr) {
        attr = attr || {};
        if (attr.name === undefined) return false;
        this.attributes[attr.name] = attr.value;
        if (attr.name === "class") {
          this.class.addClassValueHandler();
        }
        if (attr.name === "style") {
          this.style.addStyleValueHandler();
        }
        return this.attrs[attr.name];
      };
      JSAPI.prototype.eachAttr = function (callback, context) {
        if (this.type !== "element") {
          return false;
        }
        if (callback == null) {
          return false;
        }
        for (const attr of Object.values(this.attrs)) {
          callback.call(context, attr);
        }
        return true;
      };
      JSAPI.prototype.someAttr = function (callback, context) {
        if (this.type !== "element") {
          return false;
        }
        for (const attr of Object.values(this.attrs)) {
          if (callback.call(context, attr)) return true;
        }
        return false;
      };
      JSAPI.prototype.querySelectorAll = function (selectors) {
        var matchedEls = selectAll(selectors, this, cssSelectOpts);
        return matchedEls.length > 0 ? matchedEls : null;
      };
      JSAPI.prototype.querySelector = function (selectors) {
        return selectOne(selectors, this, cssSelectOpts);
      };
      JSAPI.prototype.matches = function (selector) {
        return is(this, selector, cssSelectOpts);
      };
    },
    9180: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit } = __nccwpck_require__(143);
      const invokePlugins = (
        ast,
        info,
        plugins,
        overrides,
        globalOverrides,
      ) => {
        for (const plugin of plugins) {
          const override = overrides == null ? null : overrides[plugin.name];
          if (override === false) {
            continue;
          }
          const params = { ...plugin.params, ...globalOverrides, ...override };
          if (plugin.type === "perItem") {
            ast = perItem(ast, info, plugin, params);
          }
          if (plugin.type === "perItemReverse") {
            ast = perItem(ast, info, plugin, params, true);
          }
          if (plugin.type === "full") {
            if (plugin.active) {
              ast = plugin.fn(ast, params, info);
            }
          }
          if (plugin.type === "visitor") {
            if (plugin.active) {
              const visitor = plugin.fn(ast, params, info);
              if (visitor != null) {
                visit(ast, visitor);
              }
            }
          }
        }
        return ast;
      };
      exports.invokePlugins = invokePlugins;
      function perItem(data, info, plugin, params, reverse) {
        function monkeys(items) {
          items.children = items.children.filter(function (item) {
            if (reverse && item.children) {
              monkeys(item);
            }
            let kept = true;
            if (plugin.active) {
              kept = plugin.fn(item, params, info) !== false;
            }
            if (!reverse && item.children) {
              monkeys(item);
            }
            return kept;
          });
          return items;
        }
        return monkeys(data);
      }
      const createPreset = ({ name, plugins }) => ({
        name,
        type: "full",
        fn: (ast, params, info) => {
          const { floatPrecision, overrides } = params;
          const globalOverrides = {};
          if (floatPrecision != null) {
            globalOverrides.floatPrecision = floatPrecision;
          }
          if (overrides) {
            for (const [pluginName, override] of Object.entries(overrides)) {
              if (override === true) {
                console.warn(
                  `You are trying to enable ${pluginName} which is not part of preset.\n` +
                    `Try to put it before or after preset, for example\n\n` +
                    `plugins: [\n` +
                    `  {\n` +
                    `    name: 'preset-default',\n` +
                    `  },\n` +
                    `  'cleanupListOfValues'\n` +
                    `]\n`,
                );
              }
            }
          }
          return invokePlugins(ast, info, plugins, overrides, globalOverrides);
        },
      });
      exports.createPreset = createPreset;
    },
    6614: (__unused_webpack_module, exports) => {
      "use strict";
      exports.encodeSVGDatauri = (str, type) => {
        var prefix = "data:image/svg+xml";
        if (!type || type === "base64") {
          prefix += ";base64,";
          str = prefix + Buffer.from(str).toString("base64");
        } else if (type === "enc") {
          str = prefix + "," + encodeURIComponent(str);
        } else if (type === "unenc") {
          str = prefix + "," + str;
        }
        return str;
      };
      exports.decodeSVGDatauri = (str) => {
        var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
        var match = regexp.exec(str);
        if (!match) return str;
        var data = match[3];
        if (match[2]) {
          str = Buffer.from(data, "base64").toString("utf8");
        } else if (data.charAt(0) === "%") {
          str = decodeURIComponent(data);
        } else if (data.charAt(0) === "<") {
          str = data;
        }
        return str;
      };
      exports.cleanupOutData = (data, params, command) => {
        let str = "";
        let delimiter;
        let prev;
        data.forEach((item, i) => {
          delimiter = " ";
          if (i == 0) delimiter = "";
          if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
            var pos = i % 7;
            if (pos == 4 || pos == 5) delimiter = "";
          }
          const itemStr = params.leadingZero
            ? removeLeadingZero(item)
            : item.toString();
          if (
            params.negativeExtraSpace &&
            delimiter != "" &&
            (item < 0 || (itemStr.charAt(0) === "." && prev % 1 !== 0))
          ) {
            delimiter = "";
          }
          prev = item;
          str += delimiter + itemStr;
        });
        return str;
      };
      const removeLeadingZero = (num) => {
        var strNum = num.toString();
        if (0 < num && num < 1 && strNum.charAt(0) === "0") {
          strNum = strNum.slice(1);
        } else if (-1 < num && num < 0 && strNum.charAt(1) === "0") {
          strNum = strNum.charAt(0) + strNum.slice(2);
        }
        return strNum;
      };
      exports.removeLeadingZero = removeLeadingZero;
    },
    143: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { selectAll, selectOne, is } = __nccwpck_require__(9100);
      const xastAdaptor = __nccwpck_require__(9332);
      const cssSelectOptions = { xmlMode: true, adapter: xastAdaptor };
      const querySelectorAll = (node, selector) =>
        selectAll(selector, node, cssSelectOptions);
      exports.querySelectorAll = querySelectorAll;
      const querySelector = (node, selector) =>
        selectOne(selector, node, cssSelectOptions);
      exports.querySelector = querySelector;
      const matches = (node, selector) => is(node, selector, cssSelectOptions);
      exports.matches = matches;
      const closestByName = (node, name) => {
        let currentNode = node;
        while (currentNode) {
          if (currentNode.type === "element" && currentNode.name === name) {
            return currentNode;
          }
          currentNode = currentNode.parentNode;
        }
        return null;
      };
      exports.closestByName = closestByName;
      const visitSkip = Symbol();
      exports.visitSkip = visitSkip;
      const visit = (node, visitor, parentNode) => {
        const callbacks = visitor[node.type];
        if (callbacks && callbacks.enter) {
          const symbol = callbacks.enter(node, parentNode);
          if (symbol === visitSkip) {
            return;
          }
        }
        if (node.type === "root") {
          for (const child of node.children) {
            visit(child, visitor, node);
          }
        }
        if (node.type === "element") {
          if (parentNode.children.includes(node)) {
            for (const child of node.children) {
              visit(child, visitor, node);
            }
          }
        }
        if (callbacks && callbacks.exit) {
          callbacks.exit(node, parentNode);
        }
      };
      exports.visit = visit;
      const detachNodeFromParent = (node, parentNode) => {
        parentNode.children = parentNode.children.filter(
          (child) => child !== node,
        );
      };
      exports.detachNodeFromParent = detachNodeFromParent;
    },
    8611: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { transformsMultiply, transform2js, transformArc } =
        __nccwpck_require__(552);
      const { removeLeadingZero } = __nccwpck_require__(6614);
      const { referencesProps, attrsGroupsDefaults } =
        __nccwpck_require__(6173);
      const regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
      const defaultStrokeWidth =
        attrsGroupsDefaults.presentation["stroke-width"];
      const applyTransforms = (elem, pathData, params) => {
        if (
          elem.attributes.transform == null ||
          elem.attributes.transform === "" ||
          elem.attributes.style != null ||
          Object.entries(elem.attributes).some(
            ([name, value]) =>
              referencesProps.includes(name) && value.includes("url("),
          )
        ) {
          return;
        }
        const matrix = transformsMultiply(
          transform2js(elem.attributes.transform),
        );
        const stroke = elem.computedAttr("stroke");
        const id = elem.computedAttr("id");
        const transformPrecision = params.transformPrecision;
        if (stroke && stroke != "none") {
          if (
            !params.applyTransformsStroked ||
            ((matrix.data[0] != matrix.data[3] ||
              matrix.data[1] != -matrix.data[2]) &&
              (matrix.data[0] != -matrix.data[3] ||
                matrix.data[1] != matrix.data[2]))
          )
            return;
          if (id) {
            let idElem = elem;
            let hasStrokeWidth = false;
            do {
              if (idElem.attributes["stroke-width"]) {
                hasStrokeWidth = true;
              }
            } while (
              idElem.attributes.id !== id &&
              !hasStrokeWidth &&
              (idElem = idElem.parentNode)
            );
            if (!hasStrokeWidth) return;
          }
          const scale = +Math.sqrt(
            matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1],
          ).toFixed(transformPrecision);
          if (scale !== 1) {
            const strokeWidth =
              elem.computedAttr("stroke-width") || defaultStrokeWidth;
            if (
              elem.attributes["vector-effect"] == null ||
              elem.attributes["vector-effect"] !== "non-scaling-stroke"
            ) {
              if (elem.attributes["stroke-width"] != null) {
                elem.attributes["stroke-width"] = elem.attributes[
                  "stroke-width"
                ]
                  .trim()
                  .replace(regNumericValues, (num) =>
                    removeLeadingZero(num * scale),
                  );
              } else {
                elem.attributes["stroke-width"] = strokeWidth.replace(
                  regNumericValues,
                  (num) => removeLeadingZero(num * scale),
                );
              }
              if (elem.attributes["stroke-dashoffset"] != null) {
                elem.attributes["stroke-dashoffset"] = elem.attributes[
                  "stroke-dashoffset"
                ]
                  .trim()
                  .replace(regNumericValues, (num) =>
                    removeLeadingZero(num * scale),
                  );
              }
              if (elem.attributes["stroke-dasharray"] != null) {
                elem.attributes["stroke-dasharray"] = elem.attributes[
                  "stroke-dasharray"
                ]
                  .trim()
                  .replace(regNumericValues, (num) =>
                    removeLeadingZero(num * scale),
                  );
              }
            }
          }
        } else if (id) {
          return;
        }
        applyMatrixToPathData(pathData, matrix.data);
        delete elem.attributes.transform;
        return;
      };
      exports.applyTransforms = applyTransforms;
      const transformAbsolutePoint = (matrix, x, y) => {
        const newX = matrix[0] * x + matrix[2] * y + matrix[4];
        const newY = matrix[1] * x + matrix[3] * y + matrix[5];
        return [newX, newY];
      };
      const transformRelativePoint = (matrix, x, y) => {
        const newX = matrix[0] * x + matrix[2] * y;
        const newY = matrix[1] * x + matrix[3] * y;
        return [newX, newY];
      };
      const applyMatrixToPathData = (pathData, matrix) => {
        const start = [0, 0];
        const cursor = [0, 0];
        for (const pathItem of pathData) {
          let { command, args } = pathItem;
          if (command === "M") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
            const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "m") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
            const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "H") {
            command = "L";
            args = [args[0], cursor[1]];
          }
          if (command === "h") {
            command = "l";
            args = [args[0], 0];
          }
          if (command === "V") {
            command = "L";
            args = [cursor[0], args[0]];
          }
          if (command === "v") {
            command = "l";
            args = [0, args[0]];
          }
          if (command === "L") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "l") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "C") {
            cursor[0] = args[4];
            cursor[1] = args[5];
            const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
            const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
            const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x2;
            args[3] = y2;
            args[4] = x;
            args[5] = y;
          }
          if (command === "c") {
            cursor[0] += args[4];
            cursor[1] += args[5];
            const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
            const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
            const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x2;
            args[3] = y2;
            args[4] = x;
            args[5] = y;
          }
          if (command === "S") {
            cursor[0] = args[2];
            cursor[1] = args[3];
            const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
            const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
            args[0] = x2;
            args[1] = y2;
            args[2] = x;
            args[3] = y;
          }
          if (command === "s") {
            cursor[0] += args[2];
            cursor[1] += args[3];
            const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
            const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
            args[0] = x2;
            args[1] = y2;
            args[2] = x;
            args[3] = y;
          }
          if (command === "Q") {
            cursor[0] = args[2];
            cursor[1] = args[3];
            const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
            const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x;
            args[3] = y;
          }
          if (command === "q") {
            cursor[0] += args[2];
            cursor[1] += args[3];
            const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
            const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x;
            args[3] = y;
          }
          if (command === "T") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "t") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "A") {
            transformArc(cursor, args, matrix);
            cursor[0] = args[5];
            cursor[1] = args[6];
            if (Math.abs(args[2]) > 80) {
              const a = args[0];
              const rotation = args[2];
              args[0] = args[1];
              args[1] = a;
              args[2] = rotation + (rotation > 0 ? -90 : 90);
            }
            const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
            args[5] = x;
            args[6] = y;
          }
          if (command === "a") {
            transformArc([0, 0], args, matrix);
            cursor[0] += args[5];
            cursor[1] += args[6];
            if (Math.abs(args[2]) > 80) {
              const a = args[0];
              const rotation = args[2];
              args[0] = args[1];
              args[1] = a;
              args[2] = rotation + (rotation > 0 ? -90 : 90);
            }
            const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
            args[5] = x;
            args[6] = y;
          }
          if (command === "z" || command === "Z") {
            cursor[0] = start[0];
            cursor[1] = start[1];
          }
          pathItem.command = command;
          pathItem.args = args;
        }
      };
    },
    6173: (__unused_webpack_module, exports) => {
      "use strict";
      exports.elemsGroups = {
        animation: [
          "animate",
          "animateColor",
          "animateMotion",
          "animateTransform",
          "set",
        ],
        descriptive: ["desc", "metadata", "title"],
        shape: [
          "circle",
          "ellipse",
          "line",
          "path",
          "polygon",
          "polyline",
          "rect",
        ],
        structural: ["defs", "g", "svg", "symbol", "use"],
        paintServer: [
          "solidColor",
          "linearGradient",
          "radialGradient",
          "meshGradient",
          "pattern",
          "hatch",
        ],
        nonRendering: [
          "linearGradient",
          "radialGradient",
          "pattern",
          "clipPath",
          "mask",
          "marker",
          "symbol",
          "filter",
          "solidColor",
        ],
        container: [
          "a",
          "defs",
          "g",
          "marker",
          "mask",
          "missing-glyph",
          "pattern",
          "svg",
          "switch",
          "symbol",
          "foreignObject",
        ],
        textContent: [
          "altGlyph",
          "altGlyphDef",
          "altGlyphItem",
          "glyph",
          "glyphRef",
          "textPath",
          "text",
          "tref",
          "tspan",
        ],
        textContentChild: ["altGlyph", "textPath", "tref", "tspan"],
        lightSource: [
          "feDiffuseLighting",
          "feSpecularLighting",
          "feDistantLight",
          "fePointLight",
          "feSpotLight",
        ],
        filterPrimitive: [
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDropShadow",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "feSpecularLighting",
          "feTile",
          "feTurbulence",
        ],
      };
      exports.textElems = exports.elemsGroups.textContent.concat("title");
      exports.pathElems = ["path", "glyph", "missing-glyph"];
      exports.attrsGroups = {
        animationAddition: ["additive", "accumulate"],
        animationAttributeTarget: ["attributeType", "attributeName"],
        animationEvent: ["onbegin", "onend", "onrepeat", "onload"],
        animationTiming: [
          "begin",
          "dur",
          "end",
          "min",
          "max",
          "restart",
          "repeatCount",
          "repeatDur",
          "fill",
        ],
        animationValue: [
          "calcMode",
          "values",
          "keyTimes",
          "keySplines",
          "from",
          "to",
          "by",
        ],
        conditionalProcessing: [
          "requiredFeatures",
          "requiredExtensions",
          "systemLanguage",
        ],
        core: ["id", "tabindex", "xml:base", "xml:lang", "xml:space"],
        graphicalEvent: [
          "onfocusin",
          "onfocusout",
          "onactivate",
          "onclick",
          "onmousedown",
          "onmouseup",
          "onmouseover",
          "onmousemove",
          "onmouseout",
          "onload",
        ],
        presentation: [
          "alignment-baseline",
          "baseline-shift",
          "clip",
          "clip-path",
          "clip-rule",
          "color",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "cursor",
          "direction",
          "display",
          "dominant-baseline",
          "enable-background",
          "fill",
          "fill-opacity",
          "fill-rule",
          "filter",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "mask",
          "opacity",
          "overflow",
          "paint-order",
          "pointer-events",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "stroke",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-overflow",
          "text-rendering",
          "transform",
          "transform-origin",
          "unicode-bidi",
          "vector-effect",
          "visibility",
          "word-spacing",
          "writing-mode",
        ],
        xlink: [
          "xlink:href",
          "xlink:show",
          "xlink:actuate",
          "xlink:type",
          "xlink:role",
          "xlink:arcrole",
          "xlink:title",
        ],
        documentEvent: [
          "onunload",
          "onabort",
          "onerror",
          "onresize",
          "onscroll",
          "onzoom",
        ],
        filterPrimitive: ["x", "y", "width", "height", "result"],
        transferFunction: [
          "type",
          "tableValues",
          "slope",
          "intercept",
          "amplitude",
          "exponent",
          "offset",
        ],
      };
      exports.attrsGroupsDefaults = {
        core: { "xml:space": "default" },
        presentation: {
          clip: "auto",
          "clip-path": "none",
          "clip-rule": "nonzero",
          mask: "none",
          opacity: "1",
          "stop-color": "#000",
          "stop-opacity": "1",
          "fill-opacity": "1",
          "fill-rule": "nonzero",
          fill: "#000",
          stroke: "none",
          "stroke-width": "1",
          "stroke-linecap": "butt",
          "stroke-linejoin": "miter",
          "stroke-miterlimit": "4",
          "stroke-dasharray": "none",
          "stroke-dashoffset": "0",
          "stroke-opacity": "1",
          "paint-order": "normal",
          "vector-effect": "none",
          display: "inline",
          visibility: "visible",
          "marker-start": "none",
          "marker-mid": "none",
          "marker-end": "none",
          "color-interpolation": "sRGB",
          "color-interpolation-filters": "linearRGB",
          "color-rendering": "auto",
          "shape-rendering": "auto",
          "text-rendering": "auto",
          "image-rendering": "auto",
          "font-style": "normal",
          "font-variant": "normal",
          "font-weight": "normal",
          "font-stretch": "normal",
          "font-size": "medium",
          "font-size-adjust": "none",
          kerning: "auto",
          "letter-spacing": "normal",
          "word-spacing": "normal",
          "text-decoration": "none",
          "text-anchor": "start",
          "text-overflow": "clip",
          "writing-mode": "lr-tb",
          "glyph-orientation-vertical": "auto",
          "glyph-orientation-horizontal": "0deg",
          direction: "ltr",
          "unicode-bidi": "normal",
          "dominant-baseline": "auto",
          "alignment-baseline": "baseline",
          "baseline-shift": "baseline",
        },
        transferFunction: {
          slope: "1",
          intercept: "0",
          amplitude: "1",
          exponent: "1",
          offset: "0",
        },
      };
      exports.elems = {
        a: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "target",
          ],
          defaults: { target: "_self" },
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
            "tspan",
          ],
        },
        altGlyph: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "x",
            "y",
            "dx",
            "dy",
            "glyphRef",
            "format",
            "rotate",
          ],
        },
        altGlyphDef: { attrsGroups: ["core"], content: ["glyphRef"] },
        altGlyphItem: {
          attrsGroups: ["core"],
          content: ["glyphRef", "altGlyphItem"],
        },
        animate: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "animationAddition",
            "animationAttributeTarget",
            "animationEvent",
            "animationTiming",
            "animationValue",
            "presentation",
            "xlink",
          ],
          attrs: ["externalResourcesRequired"],
          contentGroups: ["descriptive"],
        },
        animateColor: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "animationEvent",
            "xlink",
            "animationAttributeTarget",
            "animationTiming",
            "animationValue",
            "animationAddition",
            "presentation",
          ],
          attrs: ["externalResourcesRequired"],
          contentGroups: ["descriptive"],
        },
        animateMotion: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "animationEvent",
            "xlink",
            "animationTiming",
            "animationValue",
            "animationAddition",
          ],
          attrs: [
            "externalResourcesRequired",
            "path",
            "keyPoints",
            "rotate",
            "origin",
          ],
          defaults: { rotate: "0" },
          contentGroups: ["descriptive"],
          content: ["mpath"],
        },
        animateTransform: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "animationEvent",
            "xlink",
            "animationAttributeTarget",
            "animationTiming",
            "animationValue",
            "animationAddition",
          ],
          attrs: ["externalResourcesRequired", "type"],
          contentGroups: ["descriptive"],
        },
        circle: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "cx",
            "cy",
            "r",
          ],
          defaults: { cx: "0", cy: "0" },
          contentGroups: ["animation", "descriptive"],
        },
        clipPath: {
          attrsGroups: ["conditionalProcessing", "core", "presentation"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "clipPathUnits",
          ],
          defaults: { clipPathUnits: "userSpaceOnUse" },
          contentGroups: ["animation", "descriptive", "shape"],
          content: ["text", "use"],
        },
        "color-profile": {
          attrsGroups: ["core", "xlink"],
          attrs: ["local", "name", "rendering-intent"],
          defaults: { name: "sRGB", "rendering-intent": "auto" },
          contentGroups: ["descriptive"],
        },
        cursor: {
          attrsGroups: ["core", "conditionalProcessing", "xlink"],
          attrs: ["externalResourcesRequired", "x", "y"],
          defaults: { x: "0", y: "0" },
          contentGroups: ["descriptive"],
        },
        defs: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: ["class", "style", "externalResourcesRequired", "transform"],
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        desc: { attrsGroups: ["core"], attrs: ["class", "style"] },
        ellipse: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "cx",
            "cy",
            "rx",
            "ry",
          ],
          defaults: { cx: "0", cy: "0" },
          contentGroups: ["animation", "descriptive"],
        },
        feBlend: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in", "in2", "mode"],
          defaults: { mode: "normal" },
          content: ["animate", "set"],
        },
        feColorMatrix: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in", "type", "values"],
          defaults: { type: "matrix" },
          content: ["animate", "set"],
        },
        feComponentTransfer: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in"],
          content: ["feFuncA", "feFuncB", "feFuncG", "feFuncR"],
        },
        feComposite: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: [
            "class",
            "style",
            "in",
            "in2",
            "operator",
            "k1",
            "k2",
            "k3",
            "k4",
          ],
          defaults: { operator: "over", k1: "0", k2: "0", k3: "0", k4: "0" },
          content: ["animate", "set"],
        },
        feConvolveMatrix: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: [
            "class",
            "style",
            "in",
            "order",
            "kernelMatrix",
            "divisor",
            "bias",
            "targetX",
            "targetY",
            "edgeMode",
            "kernelUnitLength",
            "preserveAlpha",
          ],
          defaults: {
            order: "3",
            bias: "0",
            edgeMode: "duplicate",
            preserveAlpha: "false",
          },
          content: ["animate", "set"],
        },
        feDiffuseLighting: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: [
            "class",
            "style",
            "in",
            "surfaceScale",
            "diffuseConstant",
            "kernelUnitLength",
          ],
          defaults: { surfaceScale: "1", diffuseConstant: "1" },
          contentGroups: ["descriptive"],
          content: ["feDistantLight", "fePointLight", "feSpotLight"],
        },
        feDisplacementMap: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: [
            "class",
            "style",
            "in",
            "in2",
            "scale",
            "xChannelSelector",
            "yChannelSelector",
          ],
          defaults: {
            scale: "0",
            xChannelSelector: "A",
            yChannelSelector: "A",
          },
          content: ["animate", "set"],
        },
        feDistantLight: {
          attrsGroups: ["core"],
          attrs: ["azimuth", "elevation"],
          defaults: { azimuth: "0", elevation: "0" },
          content: ["animate", "set"],
        },
        feFlood: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style"],
          content: ["animate", "animateColor", "set"],
        },
        feFuncA: {
          attrsGroups: ["core", "transferFunction"],
          content: ["set", "animate"],
        },
        feFuncB: {
          attrsGroups: ["core", "transferFunction"],
          content: ["set", "animate"],
        },
        feFuncG: {
          attrsGroups: ["core", "transferFunction"],
          content: ["set", "animate"],
        },
        feFuncR: {
          attrsGroups: ["core", "transferFunction"],
          content: ["set", "animate"],
        },
        feGaussianBlur: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in", "stdDeviation"],
          defaults: { stdDeviation: "0" },
          content: ["set", "animate"],
        },
        feImage: {
          attrsGroups: ["core", "presentation", "filterPrimitive", "xlink"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "preserveAspectRatio",
            "href",
            "xlink:href",
          ],
          defaults: { preserveAspectRatio: "xMidYMid meet" },
          content: ["animate", "animateTransform", "set"],
        },
        feMerge: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style"],
          content: ["feMergeNode"],
        },
        feMergeNode: {
          attrsGroups: ["core"],
          attrs: ["in"],
          content: ["animate", "set"],
        },
        feMorphology: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in", "operator", "radius"],
          defaults: { operator: "erode", radius: "0" },
          content: ["animate", "set"],
        },
        feOffset: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in", "dx", "dy"],
          defaults: { dx: "0", dy: "0" },
          content: ["animate", "set"],
        },
        fePointLight: {
          attrsGroups: ["core"],
          attrs: ["x", "y", "z"],
          defaults: { x: "0", y: "0", z: "0" },
          content: ["animate", "set"],
        },
        feSpecularLighting: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: [
            "class",
            "style",
            "in",
            "surfaceScale",
            "specularConstant",
            "specularExponent",
            "kernelUnitLength",
          ],
          defaults: {
            surfaceScale: "1",
            specularConstant: "1",
            specularExponent: "1",
          },
          contentGroups: ["descriptive", "lightSource"],
        },
        feSpotLight: {
          attrsGroups: ["core"],
          attrs: [
            "x",
            "y",
            "z",
            "pointsAtX",
            "pointsAtY",
            "pointsAtZ",
            "specularExponent",
            "limitingConeAngle",
          ],
          defaults: {
            x: "0",
            y: "0",
            z: "0",
            pointsAtX: "0",
            pointsAtY: "0",
            pointsAtZ: "0",
            specularExponent: "1",
          },
          content: ["animate", "set"],
        },
        feTile: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: ["class", "style", "in"],
          content: ["animate", "set"],
        },
        feTurbulence: {
          attrsGroups: ["core", "presentation", "filterPrimitive"],
          attrs: [
            "class",
            "style",
            "baseFrequency",
            "numOctaves",
            "seed",
            "stitchTiles",
            "type",
          ],
          defaults: {
            baseFrequency: "0",
            numOctaves: "1",
            seed: "0",
            stitchTiles: "noStitch",
            type: "turbulence",
          },
          content: ["animate", "set"],
        },
        filter: {
          attrsGroups: ["core", "presentation", "xlink"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "x",
            "y",
            "width",
            "height",
            "filterRes",
            "filterUnits",
            "primitiveUnits",
            "href",
            "xlink:href",
          ],
          defaults: {
            primitiveUnits: "userSpaceOnUse",
            x: "-10%",
            y: "-10%",
            width: "120%",
            height: "120%",
          },
          contentGroups: ["descriptive", "filterPrimitive"],
          content: ["animate", "set"],
        },
        font: {
          attrsGroups: ["core", "presentation"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "horiz-origin-x",
            "horiz-origin-y",
            "horiz-adv-x",
            "vert-origin-x",
            "vert-origin-y",
            "vert-adv-y",
          ],
          defaults: { "horiz-origin-x": "0", "horiz-origin-y": "0" },
          contentGroups: ["descriptive"],
          content: ["font-face", "glyph", "hkern", "missing-glyph", "vkern"],
        },
        "font-face": {
          attrsGroups: ["core"],
          attrs: [
            "font-family",
            "font-style",
            "font-variant",
            "font-weight",
            "font-stretch",
            "font-size",
            "unicode-range",
            "units-per-em",
            "panose-1",
            "stemv",
            "stemh",
            "slope",
            "cap-height",
            "x-height",
            "accent-height",
            "ascent",
            "descent",
            "widths",
            "bbox",
            "ideographic",
            "alphabetic",
            "mathematical",
            "hanging",
            "v-ideographic",
            "v-alphabetic",
            "v-mathematical",
            "v-hanging",
            "underline-position",
            "underline-thickness",
            "strikethrough-position",
            "strikethrough-thickness",
            "overline-position",
            "overline-thickness",
          ],
          defaults: {
            "font-style": "all",
            "font-variant": "normal",
            "font-weight": "all",
            "font-stretch": "normal",
            "unicode-range": "U+0-10FFFF",
            "units-per-em": "1000",
            "panose-1": "0 0 0 0 0 0 0 0 0 0",
            slope: "0",
          },
          contentGroups: ["descriptive"],
          content: ["font-face-src"],
        },
        "font-face-format": { attrsGroups: ["core"], attrs: ["string"] },
        "font-face-name": { attrsGroups: ["core"], attrs: ["name"] },
        "font-face-src": {
          attrsGroups: ["core"],
          content: ["font-face-name", "font-face-uri"],
        },
        "font-face-uri": {
          attrsGroups: ["core", "xlink"],
          attrs: ["href", "xlink:href"],
          content: ["font-face-format"],
        },
        foreignObject: {
          attrsGroups: [
            "core",
            "conditionalProcessing",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "x",
            "y",
            "width",
            "height",
          ],
          defaults: { x: "0", y: "0" },
        },
        g: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: ["class", "style", "externalResourcesRequired", "transform"],
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        glyph: {
          attrsGroups: ["core", "presentation"],
          attrs: [
            "class",
            "style",
            "d",
            "horiz-adv-x",
            "vert-origin-x",
            "vert-origin-y",
            "vert-adv-y",
            "unicode",
            "glyph-name",
            "orientation",
            "arabic-form",
            "lang",
          ],
          defaults: { "arabic-form": "initial" },
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        glyphRef: {
          attrsGroups: ["core", "presentation"],
          attrs: [
            "class",
            "style",
            "d",
            "horiz-adv-x",
            "vert-origin-x",
            "vert-origin-y",
            "vert-adv-y",
          ],
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        hatch: {
          attrsGroups: ["core", "presentation", "xlink"],
          attrs: [
            "class",
            "style",
            "x",
            "y",
            "pitch",
            "rotate",
            "hatchUnits",
            "hatchContentUnits",
            "transform",
          ],
          defaults: {
            hatchUnits: "objectBoundingBox",
            hatchContentUnits: "userSpaceOnUse",
            x: "0",
            y: "0",
            pitch: "0",
            rotate: "0",
          },
          contentGroups: ["animation", "descriptive"],
          content: ["hatchPath"],
        },
        hatchPath: {
          attrsGroups: ["core", "presentation", "xlink"],
          attrs: ["class", "style", "d", "offset"],
          defaults: { offset: "0" },
          contentGroups: ["animation", "descriptive"],
        },
        hkern: { attrsGroups: ["core"], attrs: ["u1", "g1", "u2", "g2", "k"] },
        image: {
          attrsGroups: [
            "core",
            "conditionalProcessing",
            "graphicalEvent",
            "xlink",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "preserveAspectRatio",
            "transform",
            "x",
            "y",
            "width",
            "height",
            "href",
            "xlink:href",
          ],
          defaults: { x: "0", y: "0", preserveAspectRatio: "xMidYMid meet" },
          contentGroups: ["animation", "descriptive"],
        },
        line: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "x1",
            "y1",
            "x2",
            "y2",
          ],
          defaults: { x1: "0", y1: "0", x2: "0", y2: "0" },
          contentGroups: ["animation", "descriptive"],
        },
        linearGradient: {
          attrsGroups: ["core", "presentation", "xlink"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "x1",
            "y1",
            "x2",
            "y2",
            "gradientUnits",
            "gradientTransform",
            "spreadMethod",
            "href",
            "xlink:href",
          ],
          defaults: {
            x1: "0",
            y1: "0",
            x2: "100%",
            y2: "0",
            spreadMethod: "pad",
          },
          contentGroups: ["descriptive"],
          content: ["animate", "animateTransform", "set", "stop"],
        },
        marker: {
          attrsGroups: ["core", "presentation"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "viewBox",
            "preserveAspectRatio",
            "refX",
            "refY",
            "markerUnits",
            "markerWidth",
            "markerHeight",
            "orient",
          ],
          defaults: {
            markerUnits: "strokeWidth",
            refX: "0",
            refY: "0",
            markerWidth: "3",
            markerHeight: "3",
          },
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        mask: {
          attrsGroups: ["conditionalProcessing", "core", "presentation"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "x",
            "y",
            "width",
            "height",
            "mask-type",
            "maskUnits",
            "maskContentUnits",
          ],
          defaults: {
            maskUnits: "objectBoundingBox",
            maskContentUnits: "userSpaceOnUse",
            x: "-10%",
            y: "-10%",
            width: "120%",
            height: "120%",
          },
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        metadata: { attrsGroups: ["core"] },
        "missing-glyph": {
          attrsGroups: ["core", "presentation"],
          attrs: [
            "class",
            "style",
            "d",
            "horiz-adv-x",
            "vert-origin-x",
            "vert-origin-y",
            "vert-adv-y",
          ],
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        mpath: {
          attrsGroups: ["core", "xlink"],
          attrs: ["externalResourcesRequired", "href", "xlink:href"],
          contentGroups: ["descriptive"],
        },
        path: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "d",
            "pathLength",
          ],
          contentGroups: ["animation", "descriptive"],
        },
        pattern: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "presentation",
            "xlink",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "viewBox",
            "preserveAspectRatio",
            "x",
            "y",
            "width",
            "height",
            "patternUnits",
            "patternContentUnits",
            "patternTransform",
            "href",
            "xlink:href",
          ],
          defaults: {
            patternUnits: "objectBoundingBox",
            patternContentUnits: "userSpaceOnUse",
            x: "0",
            y: "0",
            width: "0",
            height: "0",
            preserveAspectRatio: "xMidYMid meet",
          },
          contentGroups: [
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        polygon: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "points",
          ],
          contentGroups: ["animation", "descriptive"],
        },
        polyline: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "points",
          ],
          contentGroups: ["animation", "descriptive"],
        },
        radialGradient: {
          attrsGroups: ["core", "presentation", "xlink"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "cx",
            "cy",
            "r",
            "fx",
            "fy",
            "fr",
            "gradientUnits",
            "gradientTransform",
            "spreadMethod",
            "href",
            "xlink:href",
          ],
          defaults: {
            gradientUnits: "objectBoundingBox",
            cx: "50%",
            cy: "50%",
            r: "50%",
          },
          contentGroups: ["descriptive"],
          content: ["animate", "animateTransform", "set", "stop"],
        },
        meshGradient: {
          attrsGroups: ["core", "presentation", "xlink"],
          attrs: ["class", "style", "x", "y", "gradientUnits", "transform"],
          contentGroups: ["descriptive", "paintServer", "animation"],
          content: ["meshRow"],
        },
        meshRow: {
          attrsGroups: ["core", "presentation"],
          attrs: ["class", "style"],
          contentGroups: ["descriptive"],
          content: ["meshPatch"],
        },
        meshPatch: {
          attrsGroups: ["core", "presentation"],
          attrs: ["class", "style"],
          contentGroups: ["descriptive"],
          content: ["stop"],
        },
        rect: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "x",
            "y",
            "width",
            "height",
            "rx",
            "ry",
          ],
          defaults: { x: "0", y: "0" },
          contentGroups: ["animation", "descriptive"],
        },
        script: {
          attrsGroups: ["core", "xlink"],
          attrs: ["externalResourcesRequired", "type", "href", "xlink:href"],
        },
        set: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "animation",
            "xlink",
            "animationAttributeTarget",
            "animationTiming",
          ],
          attrs: ["externalResourcesRequired", "to"],
          contentGroups: ["descriptive"],
        },
        solidColor: {
          attrsGroups: ["core", "presentation"],
          attrs: ["class", "style"],
          contentGroups: ["paintServer"],
        },
        stop: {
          attrsGroups: ["core", "presentation"],
          attrs: ["class", "style", "offset", "path"],
          content: ["animate", "animateColor", "set"],
        },
        style: {
          attrsGroups: ["core"],
          attrs: ["type", "media", "title"],
          defaults: { type: "text/css" },
        },
        svg: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "documentEvent",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "x",
            "y",
            "width",
            "height",
            "viewBox",
            "preserveAspectRatio",
            "zoomAndPan",
            "version",
            "baseProfile",
            "contentScriptType",
            "contentStyleType",
          ],
          defaults: {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            preserveAspectRatio: "xMidYMid meet",
            zoomAndPan: "magnify",
            version: "1.1",
            baseProfile: "none",
            contentScriptType: "application/ecmascript",
            contentStyleType: "text/css",
          },
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        switch: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: ["class", "style", "externalResourcesRequired", "transform"],
          contentGroups: ["animation", "descriptive", "shape"],
          content: [
            "a",
            "foreignObject",
            "g",
            "image",
            "svg",
            "switch",
            "text",
            "use",
          ],
        },
        symbol: {
          attrsGroups: ["core", "graphicalEvent", "presentation"],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "preserveAspectRatio",
            "viewBox",
            "refX",
            "refY",
          ],
          defaults: { refX: "0", refY: "0" },
          contentGroups: [
            "animation",
            "descriptive",
            "shape",
            "structural",
            "paintServer",
          ],
          content: [
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font",
            "font-face",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ],
        },
        text: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "lengthAdjust",
            "x",
            "y",
            "dx",
            "dy",
            "rotate",
            "textLength",
          ],
          defaults: { x: "0", y: "0", lengthAdjust: "spacing" },
          contentGroups: ["animation", "descriptive", "textContentChild"],
          content: ["a"],
        },
        textPath: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "href",
            "xlink:href",
            "startOffset",
            "method",
            "spacing",
            "d",
          ],
          defaults: { startOffset: "0", method: "align", spacing: "exact" },
          contentGroups: ["descriptive"],
          content: [
            "a",
            "altGlyph",
            "animate",
            "animateColor",
            "set",
            "tref",
            "tspan",
          ],
        },
        title: { attrsGroups: ["core"], attrs: ["class", "style"] },
        tref: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "href",
            "xlink:href",
          ],
          contentGroups: ["descriptive"],
          content: ["animate", "animateColor", "set"],
        },
        tspan: {
          attrsGroups: [
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "x",
            "y",
            "dx",
            "dy",
            "rotate",
            "textLength",
            "lengthAdjust",
          ],
          contentGroups: ["descriptive"],
          content: [
            "a",
            "altGlyph",
            "animate",
            "animateColor",
            "set",
            "tref",
            "tspan",
          ],
        },
        use: {
          attrsGroups: [
            "core",
            "conditionalProcessing",
            "graphicalEvent",
            "presentation",
            "xlink",
          ],
          attrs: [
            "class",
            "style",
            "externalResourcesRequired",
            "transform",
            "x",
            "y",
            "width",
            "height",
            "href",
            "xlink:href",
          ],
          defaults: { x: "0", y: "0" },
          contentGroups: ["animation", "descriptive"],
        },
        view: {
          attrsGroups: ["core"],
          attrs: [
            "externalResourcesRequired",
            "viewBox",
            "preserveAspectRatio",
            "zoomAndPan",
            "viewTarget",
          ],
          contentGroups: ["descriptive"],
        },
        vkern: { attrsGroups: ["core"], attrs: ["u1", "g1", "u2", "g2", "k"] },
      };
      exports.editorNamespaces = [
        "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
        "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
        "http://www.inkscape.org/namespaces/inkscape",
        "http://www.bohemiancoding.com/sketch/ns",
        "http://ns.adobe.com/AdobeIllustrator/10.0/",
        "http://ns.adobe.com/Graphs/1.0/",
        "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
        "http://ns.adobe.com/Variables/1.0/",
        "http://ns.adobe.com/SaveForWeb/1.0/",
        "http://ns.adobe.com/Extensibility/1.0/",
        "http://ns.adobe.com/Flows/1.0/",
        "http://ns.adobe.com/ImageReplacement/1.0/",
        "http://ns.adobe.com/GenericCustomNamespace/1.0/",
        "http://ns.adobe.com/XPath/1.0/",
        "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
        "http://taptrix.com/vectorillustrator/svg_extensions",
        "http://www.figma.com/figma/ns",
        "http://purl.org/dc/elements/1.1/",
        "http://creativecommons.org/ns#",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "http://www.serif.com/",
        "http://www.vector.evaxdesign.sk",
      ];
      exports.referencesProps = [
        "clip-path",
        "color-profile",
        "fill",
        "filter",
        "marker-start",
        "marker-mid",
        "marker-end",
        "mask",
        "stroke",
        "style",
      ];
      exports.inheritableAttrs = [
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "cursor",
        "direction",
        "dominant-baseline",
        "fill",
        "fill-opacity",
        "fill-rule",
        "font",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "marker",
        "marker-end",
        "marker-mid",
        "marker-start",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-rendering",
        "transform",
        "visibility",
        "word-spacing",
        "writing-mode",
      ];
      exports.presentationNonInheritableGroupAttrs = [
        "display",
        "clip-path",
        "filter",
        "mask",
        "opacity",
        "text-decoration",
        "transform",
        "unicode-bidi",
      ];
      exports.colorsNames = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#0ff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000",
        blanchedalmond: "#ffebcd",
        blue: "#00f",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#0ff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#f0f",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#789",
        lightslategrey: "#789",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#0f0",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#f0f",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#639",
        red: "#f00",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#fff",
        whitesmoke: "#f5f5f5",
        yellow: "#ff0",
        yellowgreen: "#9acd32",
      };
      exports.colorsShortNames = {
        "#f0ffff": "azure",
        "#f5f5dc": "beige",
        "#ffe4c4": "bisque",
        "#a52a2a": "brown",
        "#ff7f50": "coral",
        "#ffd700": "gold",
        "#808080": "gray",
        "#008000": "green",
        "#4b0082": "indigo",
        "#fffff0": "ivory",
        "#f0e68c": "khaki",
        "#faf0e6": "linen",
        "#800000": "maroon",
        "#000080": "navy",
        "#808000": "olive",
        "#ffa500": "orange",
        "#da70d6": "orchid",
        "#cd853f": "peru",
        "#ffc0cb": "pink",
        "#dda0dd": "plum",
        "#800080": "purple",
        "#f00": "red",
        "#ff0000": "red",
        "#fa8072": "salmon",
        "#a0522d": "sienna",
        "#c0c0c0": "silver",
        "#fffafa": "snow",
        "#d2b48c": "tan",
        "#008080": "teal",
        "#ff6347": "tomato",
        "#ee82ee": "violet",
        "#f5deb3": "wheat",
      };
      exports.colorsProps = [
        "color",
        "fill",
        "stroke",
        "stop-color",
        "flood-color",
        "lighting-color",
      ];
    },
    1624: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { parsePathData, stringifyPathData } = __nccwpck_require__(740);
      var prevCtrlPoint;
      const path2js = (path) => {
        if (path.pathJS) return path.pathJS;
        const pathData = [];
        const newPathData = parsePathData(path.attributes.d);
        for (const { command, args } of newPathData) {
          pathData.push({ command, args });
        }
        if (pathData.length && pathData[0].command == "m") {
          pathData[0].command = "M";
        }
        path.pathJS = pathData;
        return pathData;
      };
      exports.path2js = path2js;
      const convertRelativeToAbsolute = (data) => {
        const newData = [];
        let start = [0, 0];
        let cursor = [0, 0];
        for (let { command, args } of data) {
          args = args.slice();
          if (command === "m") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            command = "M";
          }
          if (command === "M") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
          }
          if (command === "h") {
            args[0] += cursor[0];
            command = "H";
          }
          if (command === "H") {
            cursor[0] = args[0];
          }
          if (command === "v") {
            args[0] += cursor[1];
            command = "V";
          }
          if (command === "V") {
            cursor[1] = args[0];
          }
          if (command === "l") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            command = "L";
          }
          if (command === "L") {
            cursor[0] = args[0];
            cursor[1] = args[1];
          }
          if (command === "c") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            args[2] += cursor[0];
            args[3] += cursor[1];
            args[4] += cursor[0];
            args[5] += cursor[1];
            command = "C";
          }
          if (command === "C") {
            cursor[0] = args[4];
            cursor[1] = args[5];
          }
          if (command === "s") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            args[2] += cursor[0];
            args[3] += cursor[1];
            command = "S";
          }
          if (command === "S") {
            cursor[0] = args[2];
            cursor[1] = args[3];
          }
          if (command === "q") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            args[2] += cursor[0];
            args[3] += cursor[1];
            command = "Q";
          }
          if (command === "Q") {
            cursor[0] = args[2];
            cursor[1] = args[3];
          }
          if (command === "t") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            command = "T";
          }
          if (command === "T") {
            cursor[0] = args[0];
            cursor[1] = args[1];
          }
          if (command === "a") {
            args[5] += cursor[0];
            args[6] += cursor[1];
            command = "A";
          }
          if (command === "A") {
            cursor[0] = args[5];
            cursor[1] = args[6];
          }
          if (command === "z" || command === "Z") {
            cursor[0] = start[0];
            cursor[1] = start[1];
            command = "z";
          }
          newData.push({ command, args });
        }
        return newData;
      };
      exports.js2path = function (path, data, params) {
        path.pathJS = data;
        const pathData = [];
        for (const item of data) {
          if (
            pathData.length !== 0 &&
            (item.command === "M" || item.command === "m")
          ) {
            const last = pathData[pathData.length - 1];
            if (last.command === "M" || last.command === "m") {
              pathData.pop();
            }
          }
          pathData.push({ command: item.command, args: item.args });
        }
        path.attributes.d = stringifyPathData({
          pathData,
          precision: params.floatPrecision,
          disableSpaceAfterFlags: params.noSpaceAfterFlags,
        });
      };
      function set(dest, source) {
        dest[0] = source[source.length - 2];
        dest[1] = source[source.length - 1];
        return dest;
      }
      exports.intersects = function (path1, path2) {
        const points1 = gatherPoints(convertRelativeToAbsolute(path1));
        const points2 = gatherPoints(convertRelativeToAbsolute(path2));
        if (
          points1.maxX <= points2.minX ||
          points2.maxX <= points1.minX ||
          points1.maxY <= points2.minY ||
          points2.maxY <= points1.minY ||
          points1.list.every((set1) =>
            points2.list.every(
              (set2) =>
                set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||
                set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||
                set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||
                set2.list[set2.maxY][1] <= set1.list[set1.minY][1],
            ),
          )
        )
          return false;
        const hullNest1 = points1.list.map(convexHull);
        const hullNest2 = points2.list.map(convexHull);
        return hullNest1.some(function (hull1) {
          if (hull1.list.length < 3) return false;
          return hullNest2.some(function (hull2) {
            if (hull2.list.length < 3) return false;
            var simplex = [getSupport(hull1, hull2, [1, 0])],
              direction = minus(simplex[0]);
            var iterations = 1e4;
            while (true) {
              if (iterations-- == 0) {
                console.error(
                  "Error: infinite loop while processing mergePaths plugin.",
                );
                return true;
              }
              simplex.push(getSupport(hull1, hull2, direction));
              if (dot(direction, simplex[simplex.length - 1]) <= 0)
                return false;
              if (processSimplex(simplex, direction)) return true;
            }
          });
        });
        function getSupport(a, b, direction) {
          return sub(
            supportPoint(a, direction),
            supportPoint(b, minus(direction)),
          );
        }
        function supportPoint(polygon, direction) {
          var index =
              direction[1] >= 0
                ? direction[0] < 0
                  ? polygon.maxY
                  : polygon.maxX
                : direction[0] < 0
                  ? polygon.minX
                  : polygon.minY,
            max = -Infinity,
            value;
          while ((value = dot(polygon.list[index], direction)) > max) {
            max = value;
            index = ++index % polygon.list.length;
          }
          return polygon.list[(index || polygon.list.length) - 1];
        }
      };
      function processSimplex(simplex, direction) {
        if (simplex.length == 2) {
          let a = simplex[1],
            b = simplex[0],
            AO = minus(simplex[1]),
            AB = sub(b, a);
          if (dot(AO, AB) > 0) {
            set(direction, orth(AB, a));
          } else {
            set(direction, AO);
            simplex.shift();
          }
        } else {
          let a = simplex[2],
            b = simplex[1],
            c = simplex[0],
            AB = sub(b, a),
            AC = sub(c, a),
            AO = minus(a),
            ACB = orth(AB, AC),
            ABC = orth(AC, AB);
          if (dot(ACB, AO) > 0) {
            if (dot(AB, AO) > 0) {
              set(direction, ACB);
              simplex.shift();
            } else {
              set(direction, AO);
              simplex.splice(0, 2);
            }
          } else if (dot(ABC, AO) > 0) {
            if (dot(AC, AO) > 0) {
              set(direction, ABC);
              simplex.splice(1, 1);
            } else {
              set(direction, AO);
              simplex.splice(0, 2);
            }
          } else return true;
        }
        return false;
      }
      function minus(v) {
        return [-v[0], -v[1]];
      }
      function sub(v1, v2) {
        return [v1[0] - v2[0], v1[1] - v2[1]];
      }
      function dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      }
      function orth(v, from) {
        var o = [-v[1], v[0]];
        return dot(o, minus(from)) < 0 ? minus(o) : o;
      }
      function gatherPoints(pathData) {
        const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
        const addPoint = (path, point) => {
          if (!path.list.length || point[1] > path.list[path.maxY][1]) {
            path.maxY = path.list.length;
            points.maxY = points.list.length
              ? Math.max(point[1], points.maxY)
              : point[1];
          }
          if (!path.list.length || point[0] > path.list[path.maxX][0]) {
            path.maxX = path.list.length;
            points.maxX = points.list.length
              ? Math.max(point[0], points.maxX)
              : point[0];
          }
          if (!path.list.length || point[1] < path.list[path.minY][1]) {
            path.minY = path.list.length;
            points.minY = points.list.length
              ? Math.min(point[1], points.minY)
              : point[1];
          }
          if (!path.list.length || point[0] < path.list[path.minX][0]) {
            path.minX = path.list.length;
            points.minX = points.list.length
              ? Math.min(point[0], points.minX)
              : point[0];
          }
          path.list.push(point);
        };
        for (let i = 0; i < pathData.length; i += 1) {
          const pathDataItem = pathData[i];
          let subPath =
            points.list.length === 0
              ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }
              : points.list[points.list.length - 1];
          let prev = i === 0 ? null : pathData[i - 1];
          let basePoint =
            subPath.list.length === 0
              ? null
              : subPath.list[subPath.list.length - 1];
          let data = pathDataItem.args;
          let ctrlPoint = basePoint;
          const toAbsolute = (n, i) =>
            n + (basePoint == null ? 0 : basePoint[i % 2]);
          switch (pathDataItem.command) {
            case "M":
              subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
              points.list.push(subPath);
              break;
            case "H":
              if (basePoint != null) {
                addPoint(subPath, [data[0], basePoint[1]]);
              }
              break;
            case "V":
              if (basePoint != null) {
                addPoint(subPath, [basePoint[0], data[0]]);
              }
              break;
            case "Q":
              addPoint(subPath, data.slice(0, 2));
              prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
              break;
            case "T":
              if (
                basePoint != null &&
                prev != null &&
                (prev.command == "Q" || prev.command == "T")
              ) {
                ctrlPoint = [
                  basePoint[0] + prevCtrlPoint[0],
                  basePoint[1] + prevCtrlPoint[1],
                ];
                addPoint(subPath, ctrlPoint);
                prevCtrlPoint = [
                  data[0] - ctrlPoint[0],
                  data[1] - ctrlPoint[1],
                ];
              }
              break;
            case "C":
              if (basePoint != null) {
                addPoint(subPath, [
                  0.5 * (basePoint[0] + data[0]),
                  0.5 * (basePoint[1] + data[1]),
                ]);
              }
              addPoint(subPath, [
                0.5 * (data[0] + data[2]),
                0.5 * (data[1] + data[3]),
              ]);
              addPoint(subPath, [
                0.5 * (data[2] + data[4]),
                0.5 * (data[3] + data[5]),
              ]);
              prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
              break;
            case "S":
              if (
                basePoint != null &&
                prev != null &&
                (prev.command == "C" || prev.command == "S")
              ) {
                addPoint(subPath, [
                  basePoint[0] + 0.5 * prevCtrlPoint[0],
                  basePoint[1] + 0.5 * prevCtrlPoint[1],
                ]);
                ctrlPoint = [
                  basePoint[0] + prevCtrlPoint[0],
                  basePoint[1] + prevCtrlPoint[1],
                ];
              }
              if (ctrlPoint != null) {
                addPoint(subPath, [
                  0.5 * (ctrlPoint[0] + data[0]),
                  0.5 * (ctrlPoint[1] + data[1]),
                ]);
              }
              addPoint(subPath, [
                0.5 * (data[0] + data[2]),
                0.5 * (data[1] + data[3]),
              ]);
              prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
              break;
            case "A":
              if (basePoint != null) {
                var curves = a2c.apply(0, basePoint.concat(data));
                for (
                  var cData;
                  (cData = curves.splice(0, 6).map(toAbsolute)).length;

                ) {
                  if (basePoint != null) {
                    addPoint(subPath, [
                      0.5 * (basePoint[0] + cData[0]),
                      0.5 * (basePoint[1] + cData[1]),
                    ]);
                  }
                  addPoint(subPath, [
                    0.5 * (cData[0] + cData[2]),
                    0.5 * (cData[1] + cData[3]),
                  ]);
                  addPoint(subPath, [
                    0.5 * (cData[2] + cData[4]),
                    0.5 * (cData[3] + cData[5]),
                  ]);
                  if (curves.length)
                    addPoint(subPath, (basePoint = cData.slice(-2)));
                }
              }
              break;
          }
          if (data.length >= 2) addPoint(subPath, data.slice(-2));
        }
        return points;
      }
      function convexHull(points) {
        points.list.sort(function (a, b) {
          return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
        });
        var lower = [],
          minY = 0,
          bottom = 0;
        for (let i = 0; i < points.list.length; i++) {
          while (
            lower.length >= 2 &&
            cross(
              lower[lower.length - 2],
              lower[lower.length - 1],
              points.list[i],
            ) <= 0
          ) {
            lower.pop();
          }
          if (points.list[i][1] < points.list[minY][1]) {
            minY = i;
            bottom = lower.length;
          }
          lower.push(points.list[i]);
        }
        var upper = [],
          maxY = points.list.length - 1,
          top = 0;
        for (let i = points.list.length; i--; ) {
          while (
            upper.length >= 2 &&
            cross(
              upper[upper.length - 2],
              upper[upper.length - 1],
              points.list[i],
            ) <= 0
          ) {
            upper.pop();
          }
          if (points.list[i][1] > points.list[maxY][1]) {
            maxY = i;
            top = upper.length;
          }
          upper.push(points.list[i]);
        }
        upper.pop();
        lower.pop();
        const hullList = lower.concat(upper);
        const hull = {
          list: hullList,
          minX: 0,
          maxX: lower.length,
          minY: bottom,
          maxY: (lower.length + top) % hullList.length,
        };
        return hull;
      }
      function cross(o, a, b) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
      const a2c = (
        x1,
        y1,
        rx,
        ry,
        angle,
        large_arc_flag,
        sweep_flag,
        x2,
        y2,
        recursive,
      ) => {
        const _120 = (Math.PI * 120) / 180;
        const rad = (Math.PI / 180) * (+angle || 0);
        let res = [];
        const rotateX = (x, y, rad) => x * Math.cos(rad) - y * Math.sin(rad);
        const rotateY = (x, y, rad) => x * Math.sin(rad) + y * Math.cos(rad);
        if (!recursive) {
          x1 = rotateX(x1, y1, -rad);
          y1 = rotateY(x1, y1, -rad);
          x2 = rotateX(x2, y2, -rad);
          y2 = rotateY(x2, y2, -rad);
          var x = (x1 - x2) / 2,
            y = (y1 - y2) / 2;
          var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
          if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
          }
          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k =
            (large_arc_flag == sweep_flag ? -1 : 1) *
            Math.sqrt(
              Math.abs(
                (rx2 * ry2 - rx2 * y * y - ry2 * x * x) /
                  (rx2 * y * y + ry2 * x * x),
              ),
            );
          var cx = (k * rx * y) / ry + (x1 + x2) / 2;
          var cy = (k * -ry * x) / rx + (y1 + y2) / 2;
          var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
          var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x2 < cx ? Math.PI - f2 : f2;
          f1 < 0 && (f1 = Math.PI * 2 + f1);
          f2 < 0 && (f2 = Math.PI * 2 + f2);
          if (sweep_flag && f1 > f2) {
            f1 = f1 - Math.PI * 2;
          }
          if (!sweep_flag && f2 > f1) {
            f2 = f2 - Math.PI * 2;
          }
        } else {
          f1 = recursive[0];
          f2 = recursive[1];
          cx = recursive[2];
          cy = recursive[3];
        }
        var df = f2 - f1;
        if (Math.abs(df) > _120) {
          var f2old = f2,
            x2old = x2,
            y2old = y2;
          f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
            f2,
            f2old,
            cx,
            cy,
          ]);
        }
        df = f2 - f1;
        var c1 = Math.cos(f1),
          s1 = Math.sin(f1),
          c2 = Math.cos(f2),
          s2 = Math.sin(f2),
          t = Math.tan(df / 4),
          hx = (4 / 3) * rx * t,
          hy = (4 / 3) * ry * t,
          m = [
            -hx * s1,
            hy * c1,
            x2 + hx * s2 - x1,
            y2 - hy * c2 - y1,
            x2 - x1,
            y2 - y1,
          ];
        if (recursive) {
          return m.concat(res);
        } else {
          res = m.concat(res);
          var newres = [];
          for (var i = 0, n = res.length; i < n; i++) {
            newres[i] =
              i % 2
                ? rotateY(res[i - 1], res[i], rad)
                : rotateX(res[i], res[i + 1], rad);
          }
          return newres;
        }
      };
    },
    552: (__unused_webpack_module, exports) => {
      "use strict";
      const regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;
      const regTransformSplit =
        /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
      const regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
      exports.transform2js = (transformString) => {
        const transforms = [];
        let current = null;
        for (const item of transformString.split(regTransformSplit)) {
          var num;
          if (item) {
            if (regTransformTypes.test(item)) {
              current = { name: item, data: [] };
              transforms.push(current);
            } else {
              while ((num = regNumericValues.exec(item))) {
                num = Number(num);
                if (current != null) {
                  current.data.push(num);
                }
              }
            }
          }
        }
        return current == null || current.data.length == 0 ? [] : transforms;
      };
      exports.transformsMultiply = (transforms) => {
        const matrixData = transforms.map((transform) => {
          if (transform.name === "matrix") {
            return transform.data;
          }
          return transformToMatrix(transform);
        });
        const matrixTransform = {
          name: "matrix",
          data:
            matrixData.length > 0
              ? matrixData.reduce(multiplyTransformMatrices)
              : [],
        };
        return matrixTransform;
      };
      const mth = {
        rad: (deg) => (deg * Math.PI) / 180,
        deg: (rad) => (rad * 180) / Math.PI,
        cos: (deg) => Math.cos(mth.rad(deg)),
        acos: (val, floatPrecision) =>
          Number(mth.deg(Math.acos(val)).toFixed(floatPrecision)),
        sin: (deg) => Math.sin(mth.rad(deg)),
        asin: (val, floatPrecision) =>
          Number(mth.deg(Math.asin(val)).toFixed(floatPrecision)),
        tan: (deg) => Math.tan(mth.rad(deg)),
        atan: (val, floatPrecision) =>
          Number(mth.deg(Math.atan(val)).toFixed(floatPrecision)),
      };
      exports.matrixToTransform = (transform, params) => {
        let floatPrecision = params.floatPrecision;
        let data = transform.data;
        let transforms = [];
        let sx = Number(
          Math.hypot(data[0], data[1]).toFixed(params.transformPrecision),
        );
        let sy = Number(
          ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(
            params.transformPrecision,
          ),
        );
        let colsSum = data[0] * data[2] + data[1] * data[3];
        let rowsSum = data[0] * data[1] + data[2] * data[3];
        let scaleBefore = rowsSum != 0 || sx == sy;
        if (data[4] || data[5]) {
          transforms.push({
            name: "translate",
            data: data.slice(4, data[5] ? 6 : 5),
          });
        }
        if (!data[1] && data[2]) {
          transforms.push({
            name: "skewX",
            data: [mth.atan(data[2] / sy, floatPrecision)],
          });
        } else if (data[1] && !data[2]) {
          transforms.push({
            name: "skewY",
            data: [mth.atan(data[1] / data[0], floatPrecision)],
          });
          sx = data[0];
          sy = data[3];
        } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {
          if (!scaleBefore) {
            sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);
            sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);
            transforms.push({ name: "scale", data: [sx, sy] });
          }
          var angle = Math.min(Math.max(-1, data[0] / sx), 1),
            rotate = [
              mth.acos(angle, floatPrecision) *
                ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),
            ];
          if (rotate[0]) transforms.push({ name: "rotate", data: rotate });
          if (rowsSum && colsSum)
            transforms.push({
              name: "skewX",
              data: [mth.atan(colsSum / (sx * sx), floatPrecision)],
            });
          if (rotate[0] && (data[4] || data[5])) {
            transforms.shift();
            var cos = data[0] / sx,
              sin = data[1] / (scaleBefore ? sx : sy),
              x = data[4] * (scaleBefore ? 1 : sy),
              y = data[5] * (scaleBefore ? 1 : sx),
              denom =
                (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) *
                (scaleBefore ? 1 : sx * sy);
            rotate.push(((1 - cos) * x - sin * y) / denom);
            rotate.push(((1 - cos) * y + sin * x) / denom);
          }
        } else if (data[1] || data[2]) {
          return [transform];
        }
        if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)
          transforms.push({ name: "scale", data: sx == sy ? [sx] : [sx, sy] });
        return transforms;
      };
      const transformToMatrix = (transform) => {
        if (transform.name === "matrix") {
          return transform.data;
        }
        switch (transform.name) {
          case "translate":
            return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
          case "scale":
            return [
              transform.data[0],
              0,
              0,
              transform.data[1] || transform.data[0],
              0,
              0,
            ];
          case "rotate":
            var cos = mth.cos(transform.data[0]),
              sin = mth.sin(transform.data[0]),
              cx = transform.data[1] || 0,
              cy = transform.data[2] || 0;
            return [
              cos,
              sin,
              -sin,
              cos,
              (1 - cos) * cx + sin * cy,
              (1 - cos) * cy - sin * cx,
            ];
          case "skewX":
            return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
          case "skewY":
            return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
          default:
            throw Error(`Unknown transform ${transform.name}`);
        }
      };
      exports.transformArc = (cursor, arc, transform) => {
        const x = arc[5] - cursor[0];
        const y = arc[6] - cursor[1];
        let a = arc[0];
        let b = arc[1];
        const rot = (arc[2] * Math.PI) / 180;
        const cos = Math.cos(rot);
        const sin = Math.sin(rot);
        if (a > 0 && b > 0) {
          let h =
            Math.pow(x * cos + y * sin, 2) / (4 * a * a) +
            Math.pow(y * cos - x * sin, 2) / (4 * b * b);
          if (h > 1) {
            h = Math.sqrt(h);
            a *= h;
            b *= h;
          }
        }
        const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
        const m = multiplyTransformMatrices(transform, ellipse);
        const lastCol = m[2] * m[2] + m[3] * m[3];
        const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
        const root =
          Math.hypot(m[0] - m[3], m[1] + m[2]) *
          Math.hypot(m[0] + m[3], m[1] - m[2]);
        if (!root) {
          arc[0] = arc[1] = Math.sqrt(squareSum / 2);
          arc[2] = 0;
        } else {
          const majorAxisSqr = (squareSum + root) / 2;
          const minorAxisSqr = (squareSum - root) / 2;
          const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
          const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
          const rowsSum = m[0] * m[2] + m[1] * m[3];
          const term1 = m[0] * sub + m[2] * rowsSum;
          const term2 = m[1] * sub + m[3] * rowsSum;
          arc[0] = Math.sqrt(majorAxisSqr);
          arc[1] = Math.sqrt(minorAxisSqr);
          arc[2] =
            (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
              Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *
              180) /
            Math.PI;
        }
        if (transform[0] < 0 !== transform[3] < 0) {
          arc[4] = 1 - arc[4];
        }
        return arc;
      };
      const multiplyTransformMatrices = (a, b) => [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5],
      ];
    },
    3713: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "addAttributesToSVGElement";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "adds attributes to an outer <svg> element";
      var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.\nIt should have a list of "attributes" or one "attribute".\nConfig example:\n\nplugins: [\n  {\n    name: 'addAttributesToSVGElement',\n    params: {\n      attribute: "mySvg"\n    }\n  }\n]\n\nplugins: [\n  {\n    name: 'addAttributesToSVGElement',\n    params: {\n      attributes: ["mySvg", "size-big"]\n    }\n  }\n]\n\nplugins: [\n  {\n    name: 'addAttributesToSVGElement',\n    params: {\n      attributes: [\n        {\n          focusable: false\n        },\n        {\n          'data-image': icon\n        }\n      ]\n    }\n  }\n]\n`;
      exports.fn = (root, params) => {
        if (!Array.isArray(params.attributes) && !params.attribute) {
          console.error(ENOCLS);
          return null;
        }
        const attributes = params.attributes || [params.attribute];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                for (const attribute of attributes) {
                  if (typeof attribute === "string") {
                    if (node.attributes[attribute] == null) {
                      node.attributes[attribute] = undefined;
                    }
                  }
                  if (typeof attribute === "object") {
                    for (const key of Object.keys(attribute)) {
                      if (node.attributes[key] == null) {
                        node.attributes[key] = attribute[key];
                      }
                    }
                  }
                }
              }
            },
          },
        };
      };
    },
    4651: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "addClassesToSVGElement";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "adds classnames to an outer <svg> element";
      var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.\nIt should have a list of classes in "classNames" or one "className".\nConfig example:\n\nplugins: [\n  {\n    name: "addClassesToSVGElement",\n    params: {\n      className: "mySvg"\n    }\n  }\n]\n\nplugins: [\n  {\n    name: "addClassesToSVGElement",\n    params: {\n      classNames: ["mySvg", "size-big"]\n    }\n  }\n]\n`;
      exports.fn = (root, params) => {
        if (
          !(
            Array.isArray(params.classNames) && params.classNames.some(String)
          ) &&
          !params.className
        ) {
          console.error(ENOCLS);
          return null;
        }
        const classNames = params.classNames || [params.className];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                const classList = new Set(
                  node.attributes.class == null
                    ? null
                    : node.attributes.class.split(" "),
                );
                for (const className of classNames) {
                  if (className != null) {
                    classList.add(className);
                  }
                }
                node.attributes.class = Array.from(classList).join(" ");
              }
            },
          },
        };
      };
    },
    9171: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "cleanupAttrs";
      exports.type = "visitor";
      exports.active = true;
      exports.description =
        "cleanups attributes from newlines, trailing and repeating spaces";
      const regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
      const regNewlines = /\r?\n/g;
      const regSpaces = /\s{2,}/g;
      exports.fn = (root, params) => {
        const { newlines = true, trim = true, spaces = true } = params;
        return {
          element: {
            enter: (node) => {
              for (const name of Object.keys(node.attributes)) {
                if (newlines) {
                  node.attributes[name] = node.attributes[name].replace(
                    regNewlinesNeedSpace,
                    (match, p1, p2) => p1 + " " + p2,
                  );
                  node.attributes[name] = node.attributes[name].replace(
                    regNewlines,
                    "",
                  );
                }
                if (trim) {
                  node.attributes[name] = node.attributes[name].trim();
                }
                if (spaces) {
                  node.attributes[name] = node.attributes[name].replace(
                    regSpaces,
                    " ",
                  );
                }
              }
            },
          },
        };
      };
    },
    8298: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit } = __nccwpck_require__(143);
      exports.type = "visitor";
      exports.name = "cleanupEnableBackground";
      exports.active = true;
      exports.description =
        "remove or cleanup enable-background attribute when possible";
      exports.fn = (root) => {
        const regEnableBackground =
          /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
        let hasFilter = false;
        visit(root, {
          element: {
            enter: (node) => {
              if (node.name === "filter") {
                hasFilter = true;
              }
            },
          },
        });
        return {
          element: {
            enter: (node) => {
              if (node.attributes["enable-background"] == null) {
                return;
              }
              if (hasFilter) {
                if (
                  (node.name === "svg" ||
                    node.name === "mask" ||
                    node.name === "pattern") &&
                  node.attributes.width != null &&
                  node.attributes.height != null
                ) {
                  const match =
                    node.attributes["enable-background"].match(
                      regEnableBackground,
                    );
                  if (
                    match != null &&
                    node.attributes.width === match[1] &&
                    node.attributes.height === match[3]
                  ) {
                    if (node.name === "svg") {
                      delete node.attributes["enable-background"];
                    } else {
                      node.attributes["enable-background"] = "new";
                    }
                  }
                }
              } else {
                delete node.attributes["enable-background"];
              }
            },
          },
        };
      };
    },
    7156: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip } = __nccwpck_require__(143);
      const { referencesProps } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "cleanupIDs";
      exports.active = true;
      exports.description = "removes unused IDs and minifies used";
      const regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/;
      const regReferencesHref = /^#(.+?)$/;
      const regReferencesBegin = /(\w+)\./;
      const generateIDchars = [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
      ];
      const maxIDindex = generateIDchars.length - 1;
      const hasStringPrefix = (string, prefixes) => {
        for (const prefix of prefixes) {
          if (string.startsWith(prefix)) {
            return true;
          }
        }
        return false;
      };
      const generateID = (currentID) => {
        if (currentID == null) {
          return [0];
        }
        currentID[currentID.length - 1] += 1;
        for (let i = currentID.length - 1; i > 0; i--) {
          if (currentID[i] > maxIDindex) {
            currentID[i] = 0;
            if (currentID[i - 1] !== undefined) {
              currentID[i - 1]++;
            }
          }
        }
        if (currentID[0] > maxIDindex) {
          currentID[0] = 0;
          currentID.unshift(0);
        }
        return currentID;
      };
      const getIDstring = (arr, prefix) =>
        prefix + arr.map((i) => generateIDchars[i]).join("");
      exports.fn = (_root, params) => {
        const {
          remove = true,
          minify = true,
          prefix = "",
          preserve = [],
          preservePrefixes = [],
          force = false,
        } = params;
        const preserveIDs = new Set(
          Array.isArray(preserve) ? preserve : preserve ? [preserve] : [],
        );
        const preserveIDPrefixes = Array.isArray(preservePrefixes)
          ? preservePrefixes
          : preservePrefixes
            ? [preservePrefixes]
            : [];
        const nodeById = new Map();
        const referencesById = new Map();
        let deoptimized = false;
        return {
          element: {
            enter: (node) => {
              if (force == false) {
                if (
                  (node.name === "style" || node.name === "script") &&
                  node.children.length !== 0
                ) {
                  deoptimized = true;
                  return;
                }
                if (node.name === "svg") {
                  let hasDefsOnly = true;
                  for (const child of node.children) {
                    if (child.type !== "element" || child.name !== "defs") {
                      hasDefsOnly = false;
                      break;
                    }
                  }
                  if (hasDefsOnly) {
                    return visitSkip;
                  }
                }
              }
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name === "id") {
                  const id = value;
                  if (nodeById.has(id)) {
                    delete node.attributes.id;
                  } else {
                    nodeById.set(id, node);
                  }
                } else {
                  let id = null;
                  if (referencesProps.includes(name)) {
                    const match = value.match(regReferencesUrl);
                    if (match != null) {
                      id = match[2];
                    }
                  }
                  if (name === "href" || name.endsWith(":href")) {
                    const match = value.match(regReferencesHref);
                    if (match != null) {
                      id = match[1];
                    }
                  }
                  if (name === "begin") {
                    const match = value.match(regReferencesBegin);
                    if (match != null) {
                      id = match[1];
                    }
                  }
                  if (id != null) {
                    let refs = referencesById.get(id);
                    if (refs == null) {
                      refs = [];
                      referencesById.set(id, refs);
                    }
                    refs.push({ element: node, name, value });
                  }
                }
              }
            },
          },
          root: {
            exit: () => {
              if (deoptimized) {
                return;
              }
              const isIdPreserved = (id) =>
                preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);
              let currentID = null;
              for (const [id, refs] of referencesById) {
                const node = nodeById.get(id);
                if (node != null) {
                  if (minify && isIdPreserved(id) === false) {
                    let currentIDString = null;
                    do {
                      currentID = generateID(currentID);
                      currentIDString = getIDstring(currentID, prefix);
                    } while (isIdPreserved(currentIDString));
                    node.attributes.id = currentIDString;
                    for (const { element, name, value } of refs) {
                      if (value.includes("#")) {
                        element.attributes[name] = value.replace(
                          `#${id}`,
                          `#${currentIDString}`,
                        );
                      } else {
                        element.attributes[name] = value.replace(
                          `${id}.`,
                          `${currentIDString}.`,
                        );
                      }
                    }
                  }
                  nodeById.delete(id);
                }
              }
              if (remove) {
                for (const [id, node] of nodeById) {
                  if (isIdPreserved(id) === false) {
                    delete node.attributes.id;
                  }
                }
              }
            },
          },
        };
      };
    },
    1229: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { removeLeadingZero } = __nccwpck_require__(6614);
      exports.name = "cleanupListOfValues";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "rounds list of values to the fixed precision";
      const regNumericValues =
        /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
      const regSeparator = /\s+,?\s*|,\s*/;
      const absoluteLengths = {
        cm: 96 / 2.54,
        mm: 96 / 25.4,
        in: 96,
        pt: 4 / 3,
        pc: 16,
        px: 1,
      };
      exports.fn = (_root, params) => {
        const {
          floatPrecision = 3,
          leadingZero = true,
          defaultPx = true,
          convertToPx = true,
        } = params;
        const roundValues = (lists) => {
          const roundedList = [];
          for (const elem of lists.split(regSeparator)) {
            const match = elem.match(regNumericValues);
            const matchNew = elem.match(/new/);
            if (match) {
              let num = Number(Number(match[1]).toFixed(floatPrecision));
              let matchedUnit = match[3] || "";
              let units = matchedUnit;
              if (convertToPx && units && units in absoluteLengths) {
                const pxNum = Number(
                  (absoluteLengths[units] * Number(match[1])).toFixed(
                    floatPrecision,
                  ),
                );
                if (pxNum.toString().length < match[0].length) {
                  num = pxNum;
                  units = "px";
                }
              }
              let str;
              if (leadingZero) {
                str = removeLeadingZero(num);
              } else {
                str = num.toString();
              }
              if (defaultPx && units === "px") {
                units = "";
              }
              roundedList.push(str + units);
            } else if (matchNew) {
              roundedList.push("new");
            } else if (elem) {
              roundedList.push(elem);
            }
          }
          return roundedList.join(" ");
        };
        return {
          element: {
            enter: (node) => {
              if (node.attributes.points != null) {
                node.attributes.points = roundValues(node.attributes.points);
              }
              if (node.attributes["enable-background"] != null) {
                node.attributes["enable-background"] = roundValues(
                  node.attributes["enable-background"],
                );
              }
              if (node.attributes.viewBox != null) {
                node.attributes.viewBox = roundValues(node.attributes.viewBox);
              }
              if (node.attributes["stroke-dasharray"] != null) {
                node.attributes["stroke-dasharray"] = roundValues(
                  node.attributes["stroke-dasharray"],
                );
              }
              if (node.attributes.dx != null) {
                node.attributes.dx = roundValues(node.attributes.dx);
              }
              if (node.attributes.dy != null) {
                node.attributes.dy = roundValues(node.attributes.dy);
              }
              if (node.attributes.x != null) {
                node.attributes.x = roundValues(node.attributes.x);
              }
              if (node.attributes.y != null) {
                node.attributes.y = roundValues(node.attributes.y);
              }
            },
          },
        };
      };
    },
    4362: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { removeLeadingZero } = __nccwpck_require__(6614);
      exports.name = "cleanupNumericValues";
      exports.type = "visitor";
      exports.active = true;
      exports.description =
        "rounds numeric values to the fixed precision, removes default ‘px’ units";
      const regNumericValues =
        /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
      const absoluteLengths = {
        cm: 96 / 2.54,
        mm: 96 / 25.4,
        in: 96,
        pt: 4 / 3,
        pc: 16,
        px: 1,
      };
      exports.fn = (_root, params) => {
        const {
          floatPrecision = 3,
          leadingZero = true,
          defaultPx = true,
          convertToPx = true,
        } = params;
        return {
          element: {
            enter: (node) => {
              if (node.attributes.viewBox != null) {
                const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
                node.attributes.viewBox = nums
                  .map((value) => {
                    const num = Number(value);
                    return Number.isNaN(num)
                      ? value
                      : Number(num.toFixed(floatPrecision));
                  })
                  .join(" ");
              }
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name === "version") {
                  continue;
                }
                const match = value.match(regNumericValues);
                if (match) {
                  let num = Number(Number(match[1]).toFixed(floatPrecision));
                  let matchedUnit = match[3] || "";
                  let units = matchedUnit;
                  if (convertToPx && units !== "" && units in absoluteLengths) {
                    const pxNum = Number(
                      (absoluteLengths[units] * Number(match[1])).toFixed(
                        floatPrecision,
                      ),
                    );
                    if (pxNum.toString().length < match[0].length) {
                      num = pxNum;
                      units = "px";
                    }
                  }
                  let str;
                  if (leadingZero) {
                    str = removeLeadingZero(num);
                  } else {
                    str = num.toString();
                  }
                  if (defaultPx && units === "px") {
                    units = "";
                  }
                  node.attributes[name] = str + units;
                }
              }
            },
          },
        };
      };
    },
    1354: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { inheritableAttrs, elemsGroups } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "collapseGroups";
      exports.active = true;
      exports.description = "collapses useless groups";
      const hasAnimatedAttr = (node, name) => {
        if (node.type === "element") {
          if (
            elemsGroups.animation.includes(node.name) &&
            node.attributes.attributeName === name
          ) {
            return true;
          }
          for (const child of node.children) {
            if (hasAnimatedAttr(child, name)) {
              return true;
            }
          }
        }
        return false;
      };
      exports.fn = () => ({
        element: {
          exit: (node, parentNode) => {
            if (parentNode.type === "root" || parentNode.name === "switch") {
              return;
            }
            if (node.name !== "g" || node.children.length === 0) {
              return;
            }
            if (
              Object.keys(node.attributes).length !== 0 &&
              node.children.length === 1
            ) {
              const firstChild = node.children[0];
              if (
                firstChild.type === "element" &&
                firstChild.attributes.id == null &&
                node.attributes.filter == null &&
                (node.attributes.class == null ||
                  firstChild.attributes.class == null) &&
                ((node.attributes["clip-path"] == null &&
                  node.attributes.mask == null) ||
                  (firstChild.name === "g" &&
                    node.attributes.transform == null &&
                    firstChild.attributes.transform == null))
              ) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (hasAnimatedAttr(firstChild, name)) {
                    return;
                  }
                  if (firstChild.attributes[name] == null) {
                    firstChild.attributes[name] = value;
                  } else if (name === "transform") {
                    firstChild.attributes[name] =
                      value + " " + firstChild.attributes[name];
                  } else if (firstChild.attributes[name] === "inherit") {
                    firstChild.attributes[name] = value;
                  } else if (
                    inheritableAttrs.includes(name) === false &&
                    firstChild.attributes[name] !== value
                  ) {
                    return;
                  }
                  delete node.attributes[name];
                }
              }
            }
            if (Object.keys(node.attributes).length === 0) {
              for (const child of node.children) {
                if (
                  child.type === "element" &&
                  elemsGroups.animation.includes(child.name)
                ) {
                  return;
                }
              }
              const index = parentNode.children.indexOf(node);
              parentNode.children.splice(index, 1, ...node.children);
              for (const child of node.children) {
                child.parentNode = parentNode;
              }
            }
          },
        },
      });
    },
    5676: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const collections = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "convertColors";
      exports.active = true;
      exports.description =
        "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
      const rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
      const rComma = "\\s*,\\s*";
      const regRGB = new RegExp(
        "^rgb\\(\\s*" +
          rNumber +
          rComma +
          rNumber +
          rComma +
          rNumber +
          "\\s*\\)$",
      );
      const regHEX = /^#(([a-fA-F0-9])\2){3}$/;
      const convertRgbToHex = ([r, g, b]) => {
        const hexNumber = ((((256 + r) << 8) | g) << 8) | b;
        return "#" + hexNumber.toString(16).slice(1).toUpperCase();
      };
      exports.fn = (_root, params) => {
        const {
          currentColor = false,
          names2hex = true,
          rgb2hex = true,
          shorthex = true,
          shortname = true,
        } = params;
        return {
          element: {
            enter: (node) => {
              for (const [name, value] of Object.entries(node.attributes)) {
                if (collections.colorsProps.includes(name)) {
                  let val = value;
                  if (currentColor) {
                    let matched;
                    if (typeof currentColor === "string") {
                      matched = val === currentColor;
                    } else if (currentColor instanceof RegExp) {
                      matched = currentColor.exec(val) != null;
                    } else {
                      matched = val !== "none";
                    }
                    if (matched) {
                      val = "currentColor";
                    }
                  }
                  if (names2hex) {
                    const colorName = val.toLowerCase();
                    if (collections.colorsNames[colorName] != null) {
                      val = collections.colorsNames[colorName];
                    }
                  }
                  if (rgb2hex) {
                    let match = val.match(regRGB);
                    if (match != null) {
                      let nums = match.slice(1, 4).map((m) => {
                        let n;
                        if (m.indexOf("%") > -1) {
                          n = Math.round(parseFloat(m) * 2.55);
                        } else {
                          n = Number(m);
                        }
                        return Math.max(0, Math.min(n, 255));
                      });
                      val = convertRgbToHex(nums);
                    }
                  }
                  if (shorthex) {
                    let match = val.match(regHEX);
                    if (match != null) {
                      val = "#" + match[0][1] + match[0][3] + match[0][5];
                    }
                  }
                  if (shortname) {
                    const colorName = val.toLowerCase();
                    if (collections.colorsShortNames[colorName] != null) {
                      val = collections.colorsShortNames[colorName];
                    }
                  }
                  node.attributes[name] = val;
                }
              }
            },
          },
        };
      };
    },
    4294: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "convertEllipseToCircle";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "converts non-eccentric <ellipse>s to <circle>s";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "ellipse") {
              const rx = node.attributes.rx || "0";
              const ry = node.attributes.ry || "0";
              if (rx === ry || rx === "auto" || ry === "auto") {
                node.name = "circle";
                const radius = rx === "auto" ? ry : rx;
                delete node.attributes.rx;
                delete node.attributes.ry;
                node.attributes.r = radius;
              }
            }
          },
        },
      });
    },
    1991: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { collectStylesheet, computeStyle } = __nccwpck_require__(2618);
      const { pathElems } = __nccwpck_require__(6173);
      const { path2js, js2path } = __nccwpck_require__(1624);
      const { applyTransforms } = __nccwpck_require__(8611);
      const { cleanupOutData } = __nccwpck_require__(6614);
      exports.name = "convertPathData";
      exports.type = "visitor";
      exports.active = true;
      exports.description =
        "optimizes path data: writes in shorter form, applies transformations";
      exports.params = {
        applyTransforms: true,
        applyTransformsStroked: true,
        makeArcs: { threshold: 2.5, tolerance: 0.5 },
        straightCurves: true,
        lineShorthands: true,
        curveSmoothShorthands: true,
        floatPrecision: 3,
        transformPrecision: 5,
        removeUseless: true,
        collapseRepeated: true,
        utilizeAbsolute: true,
        leadingZero: true,
        negativeExtraSpace: true,
        noSpaceAfterFlags: false,
        forceAbsolutePath: false,
      };
      let roundData;
      let precision;
      let error;
      let arcThreshold;
      let arcTolerance;
      exports.fn = (root, params) => {
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node) => {
              if (pathElems.includes(node.name) && node.attributes.d != null) {
                const computedStyle = computeStyle(stylesheet, node);
                precision = params.floatPrecision;
                error =
                  precision !== false
                    ? +Math.pow(0.1, precision).toFixed(precision)
                    : 0.01;
                roundData =
                  precision > 0 && precision < 20 ? strongRound : round;
                if (params.makeArcs) {
                  arcThreshold = params.makeArcs.threshold;
                  arcTolerance = params.makeArcs.tolerance;
                }
                const hasMarkerMid = computedStyle["marker-mid"] != null;
                const maybeHasStroke =
                  computedStyle.stroke &&
                  (computedStyle.stroke.type === "dynamic" ||
                    computedStyle.stroke.value !== "none");
                const maybeHasLinecap =
                  computedStyle["stroke-linecap"] &&
                  (computedStyle["stroke-linecap"].type === "dynamic" ||
                    computedStyle["stroke-linecap"].value !== "butt");
                const maybeHasStrokeAndLinecap =
                  maybeHasStroke && maybeHasLinecap;
                var data = path2js(node);
                if (data.length) {
                  if (params.applyTransforms) {
                    applyTransforms(node, data, params);
                  }
                  convertToRelative(data);
                  data = filters(data, params, {
                    maybeHasStrokeAndLinecap,
                    hasMarkerMid,
                  });
                  if (params.utilizeAbsolute) {
                    data = convertToMixed(data, params);
                  }
                  js2path(node, data, params);
                }
              }
            },
          },
        };
      };
      const convertToRelative = (pathData) => {
        let start = [0, 0];
        let cursor = [0, 0];
        let prevCoords = [0, 0];
        for (let i = 0; i < pathData.length; i += 1) {
          const pathItem = pathData[i];
          let { command, args } = pathItem;
          if (command === "m") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
          }
          if (command === "M") {
            if (i !== 0) {
              command = "m";
            }
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            cursor[0] += args[0];
            cursor[1] += args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
          }
          if (command === "l") {
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "L") {
            command = "l";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "h") {
            cursor[0] += args[0];
          }
          if (command === "H") {
            command = "h";
            args[0] -= cursor[0];
            cursor[0] += args[0];
          }
          if (command === "v") {
            cursor[1] += args[0];
          }
          if (command === "V") {
            command = "v";
            args[0] -= cursor[1];
            cursor[1] += args[0];
          }
          if (command === "c") {
            cursor[0] += args[4];
            cursor[1] += args[5];
          }
          if (command === "C") {
            command = "c";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            args[2] -= cursor[0];
            args[3] -= cursor[1];
            args[4] -= cursor[0];
            args[5] -= cursor[1];
            cursor[0] += args[4];
            cursor[1] += args[5];
          }
          if (command === "s") {
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "S") {
            command = "s";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            args[2] -= cursor[0];
            args[3] -= cursor[1];
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "q") {
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "Q") {
            command = "q";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            args[2] -= cursor[0];
            args[3] -= cursor[1];
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "t") {
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "T") {
            command = "t";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "a") {
            cursor[0] += args[5];
            cursor[1] += args[6];
          }
          if (command === "A") {
            command = "a";
            args[5] -= cursor[0];
            args[6] -= cursor[1];
            cursor[0] += args[5];
            cursor[1] += args[6];
          }
          if (command === "Z" || command === "z") {
            cursor[0] = start[0];
            cursor[1] = start[1];
          }
          pathItem.command = command;
          pathItem.args = args;
          pathItem.base = prevCoords;
          pathItem.coords = [cursor[0], cursor[1]];
          prevCoords = pathItem.coords;
        }
        return pathData;
      };
      function filters(
        path,
        params,
        { maybeHasStrokeAndLinecap, hasMarkerMid },
      ) {
        var stringify = data2Path.bind(null, params),
          relSubpoint = [0, 0],
          pathBase = [0, 0],
          prev = {};
        path = path.filter(function (item, index, path) {
          let command = item.command;
          let data = item.args;
          let next = path[index + 1];
          if (command !== "Z" && command !== "z") {
            var sdata = data,
              circle;
            if (command === "s") {
              sdata = [0, 0].concat(data);
              if (command === "c" || command === "s") {
                var pdata = prev.args,
                  n = pdata.length;
                sdata[0] = pdata[n - 2] - pdata[n - 4];
                sdata[1] = pdata[n - 1] - pdata[n - 3];
              }
            }
            if (
              params.makeArcs &&
              (command == "c" || command == "s") &&
              isConvex(sdata) &&
              (circle = findCircle(sdata))
            ) {
              var r = roundData([circle.radius])[0],
                angle = findArcAngle(sdata, circle),
                sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
                arc = {
                  command: "a",
                  args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
                  coords: item.coords.slice(),
                  base: item.base,
                },
                output = [arc],
                relCenter = [
                  circle.center[0] - sdata[4],
                  circle.center[1] - sdata[5],
                ],
                relCircle = { center: relCenter, radius: circle.radius },
                arcCurves = [item],
                hasPrev = 0,
                suffix = "",
                nextLonghand;
              if (
                (prev.command == "c" &&
                  isConvex(prev.args) &&
                  isArcPrev(prev.args, circle)) ||
                (prev.command == "a" &&
                  prev.sdata &&
                  isArcPrev(prev.sdata, circle))
              ) {
                arcCurves.unshift(prev);
                arc.base = prev.base;
                arc.args[5] = arc.coords[0] - arc.base[0];
                arc.args[6] = arc.coords[1] - arc.base[1];
                var prevData = prev.command == "a" ? prev.sdata : prev.args;
                var prevAngle = findArcAngle(prevData, {
                  center: [
                    prevData[4] + circle.center[0],
                    prevData[5] + circle.center[1],
                  ],
                  radius: circle.radius,
                });
                angle += prevAngle;
                if (angle > Math.PI) arc.args[3] = 1;
                hasPrev = 1;
              }
              for (
                var j = index;
                (next = path[++j]) && ~"cs".indexOf(next.command);

              ) {
                var nextData = next.args;
                if (next.command == "s") {
                  nextLonghand = makeLonghand(
                    { command: "s", args: next.args.slice() },
                    path[j - 1].args,
                  );
                  nextData = nextLonghand.args;
                  nextLonghand.args = nextData.slice(0, 2);
                  suffix = stringify([nextLonghand]);
                }
                if (isConvex(nextData) && isArc(nextData, relCircle)) {
                  angle += findArcAngle(nextData, relCircle);
                  if (angle - 2 * Math.PI > 0.001) break;
                  if (angle > Math.PI) arc.args[3] = 1;
                  arcCurves.push(next);
                  if (2 * Math.PI - angle > 0.001) {
                    arc.coords = next.coords;
                    arc.args[5] = arc.coords[0] - arc.base[0];
                    arc.args[6] = arc.coords[1] - arc.base[1];
                  } else {
                    arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
                    arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
                    arc.coords = [
                      arc.base[0] + arc.args[5],
                      arc.base[1] + arc.args[6],
                    ];
                    arc = {
                      command: "a",
                      args: [
                        r,
                        r,
                        0,
                        0,
                        sweep,
                        next.coords[0] - arc.coords[0],
                        next.coords[1] - arc.coords[1],
                      ],
                      coords: next.coords,
                      base: arc.coords,
                    };
                    output.push(arc);
                    j++;
                    break;
                  }
                  relCenter[0] -= nextData[4];
                  relCenter[1] -= nextData[5];
                } else break;
              }
              if (
                (stringify(output) + suffix).length <
                stringify(arcCurves).length
              ) {
                if (path[j] && path[j].command == "s") {
                  makeLonghand(path[j], path[j - 1].args);
                }
                if (hasPrev) {
                  var prevArc = output.shift();
                  roundData(prevArc.args);
                  relSubpoint[0] +=
                    prevArc.args[5] - prev.args[prev.args.length - 2];
                  relSubpoint[1] +=
                    prevArc.args[6] - prev.args[prev.args.length - 1];
                  prev.command = "a";
                  prev.args = prevArc.args;
                  item.base = prev.coords = prevArc.coords;
                }
                arc = output.shift();
                if (arcCurves.length == 1) {
                  item.sdata = sdata.slice();
                } else if (arcCurves.length - 1 - hasPrev > 0) {
                  path.splice.apply(
                    path,
                    [index + 1, arcCurves.length - 1 - hasPrev].concat(output),
                  );
                }
                if (!arc) return false;
                command = "a";
                data = arc.args;
                item.coords = arc.coords;
              }
            }
            if (precision !== false) {
              if (
                command === "m" ||
                command === "l" ||
                command === "t" ||
                command === "q" ||
                command === "s" ||
                command === "c"
              ) {
                for (var i = data.length; i--; ) {
                  data[i] += item.base[i % 2] - relSubpoint[i % 2];
                }
              } else if (command == "h") {
                data[0] += item.base[0] - relSubpoint[0];
              } else if (command == "v") {
                data[0] += item.base[1] - relSubpoint[1];
              } else if (command == "a") {
                data[5] += item.base[0] - relSubpoint[0];
                data[6] += item.base[1] - relSubpoint[1];
              }
              roundData(data);
              if (command == "h") relSubpoint[0] += data[0];
              else if (command == "v") relSubpoint[1] += data[0];
              else {
                relSubpoint[0] += data[data.length - 2];
                relSubpoint[1] += data[data.length - 1];
              }
              roundData(relSubpoint);
              if (command === "M" || command === "m") {
                pathBase[0] = relSubpoint[0];
                pathBase[1] = relSubpoint[1];
              }
            }
            if (params.straightCurves) {
              if (
                (command === "c" && isCurveStraightLine(data)) ||
                (command === "s" && isCurveStraightLine(sdata))
              ) {
                if (next && next.command == "s") makeLonghand(next, data);
                command = "l";
                data = data.slice(-2);
              } else if (command === "q" && isCurveStraightLine(data)) {
                if (next && next.command == "t") makeLonghand(next, data);
                command = "l";
                data = data.slice(-2);
              } else if (
                command === "t" &&
                prev.command !== "q" &&
                prev.command !== "t"
              ) {
                command = "l";
                data = data.slice(-2);
              } else if (command === "a" && (data[0] === 0 || data[1] === 0)) {
                command = "l";
                data = data.slice(-2);
              }
            }
            if (params.lineShorthands && command === "l") {
              if (data[1] === 0) {
                command = "h";
                data.pop();
              } else if (data[0] === 0) {
                command = "v";
                data.shift();
              }
            }
            if (
              params.collapseRepeated &&
              hasMarkerMid === false &&
              (command === "m" || command === "h" || command === "v") &&
              prev.command &&
              command == prev.command.toLowerCase() &&
              ((command != "h" && command != "v") ||
                prev.args[0] >= 0 == data[0] >= 0)
            ) {
              prev.args[0] += data[0];
              if (command != "h" && command != "v") {
                prev.args[1] += data[1];
              }
              prev.coords = item.coords;
              path[index] = prev;
              return false;
            }
            if (params.curveSmoothShorthands && prev.command) {
              if (command === "c") {
                if (
                  prev.command === "c" &&
                  data[0] === -(prev.args[2] - prev.args[4]) &&
                  data[1] === -(prev.args[3] - prev.args[5])
                ) {
                  command = "s";
                  data = data.slice(2);
                } else if (
                  prev.command === "s" &&
                  data[0] === -(prev.args[0] - prev.args[2]) &&
                  data[1] === -(prev.args[1] - prev.args[3])
                ) {
                  command = "s";
                  data = data.slice(2);
                } else if (
                  prev.command !== "c" &&
                  prev.command !== "s" &&
                  data[0] === 0 &&
                  data[1] === 0
                ) {
                  command = "s";
                  data = data.slice(2);
                }
              } else if (command === "q") {
                if (
                  prev.command === "q" &&
                  data[0] === prev.args[2] - prev.args[0] &&
                  data[1] === prev.args[3] - prev.args[1]
                ) {
                  command = "t";
                  data = data.slice(2);
                } else if (
                  prev.command === "t" &&
                  data[2] === prev.args[0] &&
                  data[3] === prev.args[1]
                ) {
                  command = "t";
                  data = data.slice(2);
                }
              }
            }
            if (params.removeUseless && !maybeHasStrokeAndLinecap) {
              if (
                (command === "l" ||
                  command === "h" ||
                  command === "v" ||
                  command === "q" ||
                  command === "t" ||
                  command === "c" ||
                  command === "s") &&
                data.every(function (i) {
                  return i === 0;
                })
              ) {
                path[index] = prev;
                return false;
              }
              if (command === "a" && data[5] === 0 && data[6] === 0) {
                path[index] = prev;
                return false;
              }
            }
            item.command = command;
            item.args = data;
            prev = item;
          } else {
            relSubpoint[0] = pathBase[0];
            relSubpoint[1] = pathBase[1];
            if (prev.command === "Z" || prev.command === "z") return false;
            prev = item;
          }
          return true;
        });
        return path;
      }
      function convertToMixed(path, params) {
        var prev = path[0];
        path = path.filter(function (item, index) {
          if (index == 0) return true;
          if (item.command === "Z" || item.command === "z") {
            prev = item;
            return true;
          }
          var command = item.command,
            data = item.args,
            adata = data.slice();
          if (
            command === "m" ||
            command === "l" ||
            command === "t" ||
            command === "q" ||
            command === "s" ||
            command === "c"
          ) {
            for (var i = adata.length; i--; ) {
              adata[i] += item.base[i % 2];
            }
          } else if (command == "h") {
            adata[0] += item.base[0];
          } else if (command == "v") {
            adata[0] += item.base[1];
          } else if (command == "a") {
            adata[5] += item.base[0];
            adata[6] += item.base[1];
          }
          roundData(adata);
          var absoluteDataStr = cleanupOutData(adata, params),
            relativeDataStr = cleanupOutData(data, params);
          if (
            params.forceAbsolutePath ||
            (absoluteDataStr.length < relativeDataStr.length &&
              !(
                params.negativeExtraSpace &&
                command == prev.command &&
                prev.command.charCodeAt(0) > 96 &&
                absoluteDataStr.length == relativeDataStr.length - 1 &&
                (data[0] < 0 ||
                  (/^0\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))
              ))
          ) {
            item.command = command.toUpperCase();
            item.args = adata;
          }
          prev = item;
          return true;
        });
        return path;
      }
      function isConvex(data) {
        var center = getIntersection([
          0,
          0,
          data[2],
          data[3],
          data[0],
          data[1],
          data[4],
          data[5],
        ]);
        return (
          center &&
          data[2] < center[0] == center[0] < 0 &&
          data[3] < center[1] == center[1] < 0 &&
          data[4] < center[0] == center[0] < data[0] &&
          data[5] < center[1] == center[1] < data[1]
        );
      }
      function getIntersection(coords) {
        var a1 = coords[1] - coords[3],
          b1 = coords[2] - coords[0],
          c1 = coords[0] * coords[3] - coords[2] * coords[1],
          a2 = coords[5] - coords[7],
          b2 = coords[6] - coords[4],
          c2 = coords[4] * coords[7] - coords[5] * coords[6],
          denom = a1 * b2 - a2 * b1;
        if (!denom) return;
        var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
        if (
          !isNaN(cross[0]) &&
          !isNaN(cross[1]) &&
          isFinite(cross[0]) &&
          isFinite(cross[1])
        ) {
          return cross;
        }
      }
      function strongRound(data) {
        for (var i = data.length; i-- > 0; ) {
          if (data[i].toFixed(precision) != data[i]) {
            var rounded = +data[i].toFixed(precision - 1);
            data[i] =
              +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error
                ? +data[i].toFixed(precision)
                : rounded;
          }
        }
        return data;
      }
      function round(data) {
        for (var i = data.length; i-- > 0; ) {
          data[i] = Math.round(data[i]);
        }
        return data;
      }
      function isCurveStraightLine(data) {
        var i = data.length - 2,
          a = -data[i + 1],
          b = data[i],
          d = 1 / (a * a + b * b);
        if (i <= 1 || !isFinite(d)) return false;
        while ((i -= 2) >= 0) {
          if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
            return false;
        }
        return true;
      }
      function makeLonghand(item, data) {
        switch (item.command) {
          case "s":
            item.command = "c";
            break;
          case "t":
            item.command = "q";
            break;
        }
        item.args.unshift(
          data[data.length - 2] - data[data.length - 4],
          data[data.length - 1] - data[data.length - 3],
        );
        return item;
      }
      function getDistance(point1, point2) {
        return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
      }
      function getCubicBezierPoint(curve, t) {
        var sqrT = t * t,
          cubT = sqrT * t,
          mt = 1 - t,
          sqrMt = mt * mt;
        return [
          3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
          3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],
        ];
      }
      function findCircle(curve) {
        var midPoint = getCubicBezierPoint(curve, 1 / 2),
          m1 = [midPoint[0] / 2, midPoint[1] / 2],
          m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
          center = getIntersection([
            m1[0],
            m1[1],
            m1[0] + m1[1],
            m1[1] - m1[0],
            m2[0],
            m2[1],
            m2[0] + (m2[1] - midPoint[1]),
            m2[1] - (m2[0] - midPoint[0]),
          ]),
          radius = center && getDistance([0, 0], center),
          tolerance = Math.min(
            arcThreshold * error,
            (arcTolerance * radius) / 100,
          );
        if (
          center &&
          radius < 1e15 &&
          [1 / 4, 3 / 4].every(function (point) {
            return (
              Math.abs(
                getDistance(getCubicBezierPoint(curve, point), center) - radius,
              ) <= tolerance
            );
          })
        )
          return { center, radius };
      }
      function isArc(curve, circle) {
        var tolerance = Math.min(
          arcThreshold * error,
          (arcTolerance * circle.radius) / 100,
        );
        return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {
          return (
            Math.abs(
              getDistance(getCubicBezierPoint(curve, point), circle.center) -
                circle.radius,
            ) <= tolerance
          );
        });
      }
      function isArcPrev(curve, circle) {
        return isArc(curve, {
          center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
          radius: circle.radius,
        });
      }
      function findArcAngle(curve, relCircle) {
        var x1 = -relCircle.center[0],
          y1 = -relCircle.center[1],
          x2 = curve[4] - relCircle.center[0],
          y2 = curve[5] - relCircle.center[1];
        return Math.acos(
          (x1 * x2 + y1 * y2) /
            Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)),
        );
      }
      function data2Path(params, pathData) {
        return pathData.reduce(function (pathString, item) {
          var strData = "";
          if (item.args) {
            strData = cleanupOutData(roundData(item.args.slice()), params);
          }
          return pathString + item.command + strData;
        }, "");
      }
    },
    2675: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { stringifyPathData } = __nccwpck_require__(740);
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "convertShapeToPath";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "converts basic shapes to more compact path form";
      const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
      exports.fn = (root, params) => {
        const { convertArcs = false, floatPrecision: precision } = params;
        return {
          element: {
            enter: (node, parentNode) => {
              if (
                node.name === "rect" &&
                node.attributes.width != null &&
                node.attributes.height != null &&
                node.attributes.rx == null &&
                node.attributes.ry == null
              ) {
                const x = Number(node.attributes.x || "0");
                const y = Number(node.attributes.y || "0");
                const width = Number(node.attributes.width);
                const height = Number(node.attributes.height);
                if (Number.isNaN(x - y + width - height)) return;
                const pathData = [
                  { command: "M", args: [x, y] },
                  { command: "H", args: [x + width] },
                  { command: "V", args: [y + height] },
                  { command: "H", args: [x] },
                  { command: "z", args: [] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.x;
                delete node.attributes.y;
                delete node.attributes.width;
                delete node.attributes.height;
              }
              if (node.name === "line") {
                const x1 = Number(node.attributes.x1 || "0");
                const y1 = Number(node.attributes.y1 || "0");
                const x2 = Number(node.attributes.x2 || "0");
                const y2 = Number(node.attributes.y2 || "0");
                if (Number.isNaN(x1 - y1 + x2 - y2)) return;
                const pathData = [
                  { command: "M", args: [x1, y1] },
                  { command: "L", args: [x2, y2] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.x1;
                delete node.attributes.y1;
                delete node.attributes.x2;
                delete node.attributes.y2;
              }
              if (
                (node.name === "polyline" || node.name === "polygon") &&
                node.attributes.points != null
              ) {
                const coords = (
                  node.attributes.points.match(regNumber) || []
                ).map(Number);
                if (coords.length < 4) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
                const pathData = [];
                for (let i = 0; i < coords.length; i += 2) {
                  pathData.push({
                    command: i === 0 ? "M" : "L",
                    args: coords.slice(i, i + 2),
                  });
                }
                if (node.name === "polygon") {
                  pathData.push({ command: "z", args: [] });
                }
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.points;
              }
              if (node.name === "circle" && convertArcs) {
                const cx = Number(node.attributes.cx || "0");
                const cy = Number(node.attributes.cy || "0");
                const r = Number(node.attributes.r || "0");
                if (Number.isNaN(cx - cy + r)) {
                  return;
                }
                const pathData = [
                  { command: "M", args: [cx, cy - r] },
                  { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
                  { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
                  { command: "z", args: [] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.cx;
                delete node.attributes.cy;
                delete node.attributes.r;
              }
              if (node.name === "ellipse" && convertArcs) {
                const ecx = Number(node.attributes.cx || "0");
                const ecy = Number(node.attributes.cy || "0");
                const rx = Number(node.attributes.rx || "0");
                const ry = Number(node.attributes.ry || "0");
                if (Number.isNaN(ecx - ecy + rx - ry)) {
                  return;
                }
                const pathData = [
                  { command: "M", args: [ecx, ecy - ry] },
                  { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
                  { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
                  { command: "z", args: [] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.cx;
                delete node.attributes.cy;
                delete node.attributes.rx;
                delete node.attributes.ry;
              }
            },
          },
        };
      };
    },
    3036: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      exports.name = "convertStyleToAttrs";
      exports.type = "perItem";
      exports.active = false;
      exports.description = "converts style to attributes";
      exports.params = { keepImportant: false };
      var stylingProps = __nccwpck_require__(6173).attrsGroups.presentation,
        rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)",
        rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*",
        rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)",
        rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)',
        rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$"),
        rParenthesis =
          "\\(" +
          g("[^'\"()\\\\]+", rEscape, rSingleQuotes, rQuotes) +
          "*?" +
          "\\)",
        rValue =
          "\\s*(" +
          g(
            "[^!'\"();\\\\]+?",
            rEscape,
            rSingleQuotes,
            rQuotes,
            rParenthesis,
            "[^;]*?",
          ) +
          "*?" +
          ")",
        rDeclEnd = "\\s*(?:;\\s*|$)",
        rImportant = "(\\s*!important(?![-(\\w]))?",
        regDeclarationBlock = new RegExp(
          rAttr + ":" + rValue + rImportant + rDeclEnd,
          "ig",
        ),
        regStripComments = new RegExp(
          g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
          "ig",
        );
      exports.fn = function (item, params) {
        if (item.type === "element" && item.attributes.style != null) {
          let styles = [];
          const newAttributes = {};
          const styleValue = item.attributes.style.replace(
            regStripComments,
            (match) =>
              match[0] == "/"
                ? ""
                : match[0] == "\\" && /[-g-z]/i.test(match[1])
                  ? match[1]
                  : match,
          );
          regDeclarationBlock.lastIndex = 0;
          for (var rule; (rule = regDeclarationBlock.exec(styleValue)); ) {
            if (!params.keepImportant || !rule[3]) {
              styles.push([rule[1], rule[2]]);
            }
          }
          if (styles.length) {
            styles = styles.filter(function (style) {
              if (style[0]) {
                var prop = style[0].toLowerCase(),
                  val = style[1];
                if (rQuotedString.test(val)) {
                  val = val.slice(1, -1);
                }
                if (stylingProps.includes(prop)) {
                  newAttributes[prop] = val;
                  return false;
                }
              }
              return true;
            });
            Object.assign(item.attributes, newAttributes);
            if (styles.length) {
              item.attributes.style = styles
                .map((declaration) => declaration.join(":"))
                .join(";");
            } else {
              delete item.attributes.style;
            }
          }
        }
      };
      function g() {
        return "(?:" + Array.prototype.join.call(arguments, "|") + ")";
      }
    },
    1154: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { cleanupOutData } = __nccwpck_require__(6614);
      const { transform2js, transformsMultiply, matrixToTransform } =
        __nccwpck_require__(552);
      exports.type = "visitor";
      exports.name = "convertTransform";
      exports.active = true;
      exports.description =
        "collapses multiple transformations and optimizes it";
      exports.fn = (_root, params) => {
        const {
          convertToShorts = true,
          degPrecision,
          floatPrecision = 3,
          transformPrecision = 5,
          matrixToTransform = true,
          shortTranslate = true,
          shortScale = true,
          shortRotate = true,
          removeUseless = true,
          collapseIntoOne = true,
          leadingZero = true,
          negativeExtraSpace = false,
        } = params;
        const newParams = {
          convertToShorts,
          degPrecision,
          floatPrecision,
          transformPrecision,
          matrixToTransform,
          shortTranslate,
          shortScale,
          shortRotate,
          removeUseless,
          collapseIntoOne,
          leadingZero,
          negativeExtraSpace,
        };
        return {
          element: {
            enter: (node) => {
              if (node.attributes.transform != null) {
                convertTransform(node, "transform", newParams);
              }
              if (node.attributes.gradientTransform != null) {
                convertTransform(node, "gradientTransform", newParams);
              }
              if (node.attributes.patternTransform != null) {
                convertTransform(node, "patternTransform", newParams);
              }
            },
          },
        };
      };
      const convertTransform = (item, attrName, params) => {
        let data = transform2js(item.attributes[attrName]);
        params = definePrecision(data, params);
        if (params.collapseIntoOne && data.length > 1) {
          data = [transformsMultiply(data)];
        }
        if (params.convertToShorts) {
          data = convertToShorts(data, params);
        } else {
          data.forEach((item) => roundTransform(item, params));
        }
        if (params.removeUseless) {
          data = removeUseless(data);
        }
        if (data.length) {
          item.attributes[attrName] = js2transform(data, params);
        } else {
          delete item.attributes[attrName];
        }
      };
      const definePrecision = (data, { ...newParams }) => {
        const matrixData = [];
        for (const item of data) {
          if (item.name == "matrix") {
            matrixData.push(...item.data.slice(0, 4));
          }
        }
        let significantDigits = newParams.transformPrecision;
        if (matrixData.length) {
          newParams.transformPrecision = Math.min(
            newParams.transformPrecision,
            Math.max.apply(Math, matrixData.map(floatDigits)) ||
              newParams.transformPrecision,
          );
          significantDigits = Math.max.apply(
            Math,
            matrixData.map((n) => n.toString().replace(/\D+/g, "").length),
          );
        }
        if (newParams.degPrecision == null) {
          newParams.degPrecision = Math.max(
            0,
            Math.min(newParams.floatPrecision, significantDigits - 2),
          );
        }
        return newParams;
      };
      const degRound = (data, params) => {
        if (
          params.degPrecision != null &&
          params.degPrecision >= 1 &&
          params.floatPrecision < 20
        ) {
          return smartRound(params.degPrecision, data);
        } else {
          return round(data);
        }
      };
      const floatRound = (data, params) => {
        if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
          return smartRound(params.floatPrecision, data);
        } else {
          return round(data);
        }
      };
      const transformRound = (data, params) => {
        if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
          return smartRound(params.transformPrecision, data);
        } else {
          return round(data);
        }
      };
      const floatDigits = (n) => {
        const str = n.toString();
        return str.slice(str.indexOf(".")).length - 1;
      };
      const convertToShorts = (transforms, params) => {
        for (var i = 0; i < transforms.length; i++) {
          var transform = transforms[i];
          if (params.matrixToTransform && transform.name === "matrix") {
            var decomposed = matrixToTransform(transform, params);
            if (
              js2transform(decomposed, params).length <=
              js2transform([transform], params).length
            ) {
              transforms.splice(i, 1, ...decomposed);
            }
            transform = transforms[i];
          }
          roundTransform(transform, params);
          if (
            params.shortTranslate &&
            transform.name === "translate" &&
            transform.data.length === 2 &&
            !transform.data[1]
          ) {
            transform.data.pop();
          }
          if (
            params.shortScale &&
            transform.name === "scale" &&
            transform.data.length === 2 &&
            transform.data[0] === transform.data[1]
          ) {
            transform.data.pop();
          }
          if (
            params.shortRotate &&
            transforms[i - 2] &&
            transforms[i - 2].name === "translate" &&
            transforms[i - 1].name === "rotate" &&
            transforms[i].name === "translate" &&
            transforms[i - 2].data[0] === -transforms[i].data[0] &&
            transforms[i - 2].data[1] === -transforms[i].data[1]
          ) {
            transforms.splice(i - 2, 3, {
              name: "rotate",
              data: [
                transforms[i - 1].data[0],
                transforms[i - 2].data[0],
                transforms[i - 2].data[1],
              ],
            });
            i -= 2;
          }
        }
        return transforms;
      };
      const removeUseless = (transforms) =>
        transforms.filter((transform) => {
          if (
            (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) >
              -1 &&
              (transform.data.length == 1 || transform.name == "rotate") &&
              !transform.data[0]) ||
            (transform.name == "translate" &&
              !transform.data[0] &&
              !transform.data[1]) ||
            (transform.name == "scale" &&
              transform.data[0] == 1 &&
              (transform.data.length < 2 || transform.data[1] == 1)) ||
            (transform.name == "matrix" &&
              transform.data[0] == 1 &&
              transform.data[3] == 1 &&
              !(
                transform.data[1] ||
                transform.data[2] ||
                transform.data[4] ||
                transform.data[5]
              ))
          ) {
            return false;
          }
          return true;
        });
      const js2transform = (transformJS, params) => {
        var transformString = "";
        transformJS.forEach((transform) => {
          roundTransform(transform, params);
          transformString +=
            (transformString && " ") +
            transform.name +
            "(" +
            cleanupOutData(transform.data, params) +
            ")";
        });
        return transformString;
      };
      const roundTransform = (transform, params) => {
        switch (transform.name) {
          case "translate":
            transform.data = floatRound(transform.data, params);
            break;
          case "rotate":
            transform.data = [
              ...degRound(transform.data.slice(0, 1), params),
              ...floatRound(transform.data.slice(1), params),
            ];
            break;
          case "skewX":
          case "skewY":
            transform.data = degRound(transform.data, params);
            break;
          case "scale":
            transform.data = transformRound(transform.data, params);
            break;
          case "matrix":
            transform.data = [
              ...transformRound(transform.data.slice(0, 4), params),
              ...floatRound(transform.data.slice(4), params),
            ];
            break;
        }
        return transform;
      };
      const round = (data) => data.map(Math.round);
      const smartRound = (precision, data) => {
        for (
          var i = data.length,
            tolerance = +Math.pow(0.1, precision).toFixed(precision);
          i--;

        ) {
          if (Number(data[i].toFixed(precision)) !== data[i]) {
            var rounded = +data[i].toFixed(precision - 1);
            data[i] =
              +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance
                ? +data[i].toFixed(precision)
                : rounded;
          }
        }
        return data;
      };
    },
    2197: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csstree = __nccwpck_require__(4895);
      const specificity = __nccwpck_require__(7876);
      const stable = __nccwpck_require__(5685);
      const { visitSkip, querySelectorAll, detachNodeFromParent } =
        __nccwpck_require__(143);
      exports.type = "visitor";
      exports.name = "inlineStyles";
      exports.active = true;
      exports.description = "inline styles (additional options)";
      const compareSpecificity = (a, b) => {
        for (var i = 0; i < 4; i += 1) {
          if (a[i] < b[i]) {
            return -1;
          } else if (a[i] > b[i]) {
            return 1;
          }
        }
        return 0;
      };
      exports.fn = (root, params) => {
        const {
          onlyMatchedOnce = true,
          removeMatchedSelectors = true,
          useMqs = ["", "screen"],
          usePseudos = [""],
        } = params;
        const styles = [];
        let selectors = [];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "foreignObject") {
                return visitSkip;
              }
              if (node.name !== "style" || node.children.length === 0) {
                return;
              }
              if (
                node.attributes.type != null &&
                node.attributes.type !== "" &&
                node.attributes.type !== "text/css"
              ) {
                return;
              }
              let cssText = "";
              for (const child of node.children) {
                if (child.type === "text" || child.type === "cdata") {
                  cssText += child.value;
                }
              }
              let cssAst = null;
              try {
                cssAst = csstree.parse(cssText, {
                  parseValue: false,
                  parseCustomProperty: false,
                });
              } catch {
                return;
              }
              if (cssAst.type === "StyleSheet") {
                styles.push({ node, parentNode, cssAst });
              }
              csstree.walk(cssAst, {
                visit: "Selector",
                enter(node, item) {
                  const atrule = this.atrule;
                  const rule = this.rule;
                  if (rule == null) {
                    return;
                  }
                  let mq = "";
                  if (atrule != null) {
                    mq = atrule.name;
                    if (atrule.prelude != null) {
                      mq += ` ${csstree.generate(atrule.prelude)}`;
                    }
                  }
                  if (useMqs.includes(mq) === false) {
                    return;
                  }
                  const pseudos = [];
                  if (node.type === "Selector") {
                    node.children.each((childNode, childItem, childList) => {
                      if (
                        childNode.type === "PseudoClassSelector" ||
                        childNode.type === "PseudoElementSelector"
                      ) {
                        pseudos.push({ item: childItem, list: childList });
                      }
                    });
                  }
                  const pseudoSelectors = csstree.generate({
                    type: "Selector",
                    children: new csstree.List().fromArray(
                      pseudos.map((pseudo) => pseudo.item.data),
                    ),
                  });
                  if (usePseudos.includes(pseudoSelectors) === false) {
                    return;
                  }
                  for (const pseudo of pseudos) {
                    pseudo.list.remove(pseudo.item);
                  }
                  selectors.push({ node, item, rule });
                },
              });
            },
          },
          root: {
            exit: () => {
              if (styles.length === 0) {
                return;
              }
              const sortedSelectors = stable(selectors, (a, b) => {
                const aSpecificity = specificity(a.item.data);
                const bSpecificity = specificity(b.item.data);
                return compareSpecificity(aSpecificity, bSpecificity);
              }).reverse();
              for (const selector of sortedSelectors) {
                const selectorText = csstree.generate(selector.item.data);
                const matchedElements = [];
                try {
                  for (const node of querySelectorAll(root, selectorText)) {
                    if (node.type === "element") {
                      matchedElements.push(node);
                    }
                  }
                } catch (selectError) {
                  continue;
                }
                if (matchedElements.length === 0) {
                  continue;
                }
                if (onlyMatchedOnce && matchedElements.length > 1) {
                  continue;
                }
                for (const selectedEl of matchedElements) {
                  const styleDeclarationList = csstree.parse(
                    selectedEl.attributes.style == null
                      ? ""
                      : selectedEl.attributes.style,
                    { context: "declarationList", parseValue: false },
                  );
                  if (styleDeclarationList.type !== "DeclarationList") {
                    continue;
                  }
                  const styleDeclarationItems = new Map();
                  csstree.walk(styleDeclarationList, {
                    visit: "Declaration",
                    enter(node, item) {
                      styleDeclarationItems.set(node.property, item);
                    },
                  });
                  csstree.walk(selector.rule, {
                    visit: "Declaration",
                    enter(ruleDeclaration) {
                      const matchedItem = styleDeclarationItems.get(
                        ruleDeclaration.property,
                      );
                      const ruleDeclarationItem =
                        styleDeclarationList.children.createItem(
                          ruleDeclaration,
                        );
                      if (matchedItem == null) {
                        styleDeclarationList.children.append(
                          ruleDeclarationItem,
                        );
                      } else if (
                        matchedItem.data.important !== true &&
                        ruleDeclaration.important === true
                      ) {
                        styleDeclarationList.children.replace(
                          matchedItem,
                          ruleDeclarationItem,
                        );
                        styleDeclarationItems.set(
                          ruleDeclaration.property,
                          ruleDeclarationItem,
                        );
                      }
                    },
                  });
                  selectedEl.attributes.style =
                    csstree.generate(styleDeclarationList);
                }
                if (
                  removeMatchedSelectors &&
                  matchedElements.length !== 0 &&
                  selector.rule.prelude.type === "SelectorList"
                ) {
                  selector.rule.prelude.children.remove(selector.item);
                }
                selector.matchedElements = matchedElements;
              }
              if (removeMatchedSelectors === false) {
                return;
              }
              for (const selector of sortedSelectors) {
                if (selector.matchedElements == null) {
                  continue;
                }
                if (onlyMatchedOnce && selector.matchedElements.length > 1) {
                  continue;
                }
                for (const selectedEl of selector.matchedElements) {
                  const classList = new Set(
                    selectedEl.attributes.class == null
                      ? null
                      : selectedEl.attributes.class.split(" "),
                  );
                  const firstSubSelector = selector.node.children.first();
                  if (
                    firstSubSelector != null &&
                    firstSubSelector.type === "ClassSelector"
                  ) {
                    classList.delete(firstSubSelector.name);
                  }
                  if (classList.size === 0) {
                    delete selectedEl.attributes.class;
                  } else {
                    selectedEl.attributes.class =
                      Array.from(classList).join(" ");
                  }
                  if (
                    firstSubSelector != null &&
                    firstSubSelector.type === "IdSelector"
                  ) {
                    if (selectedEl.attributes.id === firstSubSelector.name) {
                      delete selectedEl.attributes.id;
                    }
                  }
                }
              }
              for (const style of styles) {
                csstree.walk(style.cssAst, {
                  visit: "Rule",
                  enter: function (node, item, list) {
                    if (
                      node.type === "Rule" &&
                      node.prelude.type === "SelectorList" &&
                      node.prelude.children.isEmpty()
                    ) {
                      list.remove(item);
                    }
                  },
                });
                if (style.cssAst.children.isEmpty()) {
                  detachNodeFromParent(style.node, style.parentNode);
                } else {
                  const firstChild = style.node.children[0];
                  if (
                    firstChild.type === "text" ||
                    firstChild.type === "cdata"
                  ) {
                    firstChild.value = csstree.generate(style.cssAst);
                  }
                }
              }
            },
          },
        };
      };
    },
    6300: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(2618);
      const { path2js, js2path, intersects } = __nccwpck_require__(1624);
      exports.type = "visitor";
      exports.name = "mergePaths";
      exports.active = true;
      exports.description = "merges multiple paths in one if possible";
      exports.fn = (root, params) => {
        const {
          force = false,
          floatPrecision,
          noSpaceAfterFlags = false,
        } = params;
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node) => {
              let prevChild = null;
              for (const child of node.children) {
                if (
                  prevChild == null ||
                  prevChild.type !== "element" ||
                  prevChild.name !== "path" ||
                  prevChild.children.length !== 0 ||
                  prevChild.attributes.d == null
                ) {
                  prevChild = child;
                  continue;
                }
                if (
                  child.type !== "element" ||
                  child.name !== "path" ||
                  child.children.length !== 0 ||
                  child.attributes.d == null
                ) {
                  prevChild = child;
                  continue;
                }
                const computedStyle = computeStyle(stylesheet, child);
                if (
                  computedStyle["marker-start"] ||
                  computedStyle["marker-mid"] ||
                  computedStyle["marker-end"]
                ) {
                  prevChild = child;
                  continue;
                }
                const prevChildAttrs = Object.keys(prevChild.attributes);
                const childAttrs = Object.keys(child.attributes);
                let attributesAreEqual =
                  prevChildAttrs.length === childAttrs.length;
                for (const name of childAttrs) {
                  if (name !== "d") {
                    if (
                      prevChild.attributes[name] == null ||
                      prevChild.attributes[name] !== child.attributes[name]
                    ) {
                      attributesAreEqual = false;
                    }
                  }
                }
                const prevPathJS = path2js(prevChild);
                const curPathJS = path2js(child);
                if (
                  attributesAreEqual &&
                  (force || !intersects(prevPathJS, curPathJS))
                ) {
                  js2path(prevChild, prevPathJS.concat(curPathJS), {
                    floatPrecision,
                    noSpaceAfterFlags,
                  });
                  detachNodeFromParent(child, node);
                  continue;
                }
                prevChild = child;
              }
            },
          },
        };
      };
    },
    4279: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip, detachNodeFromParent } = __nccwpck_require__(143);
      const JSAPI = __nccwpck_require__(1877);
      exports.name = "mergeStyles";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "merge multiple style elements into one";
      exports.fn = () => {
        let firstStyleElement = null;
        let collectedStyles = "";
        let styleContentType = "text";
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "foreignObject") {
                return visitSkip;
              }
              if (node.name !== "style") {
                return;
              }
              if (
                node.attributes.type != null &&
                node.attributes.type !== "" &&
                node.attributes.type !== "text/css"
              ) {
                return;
              }
              let css = "";
              for (const child of node.children) {
                if (child.type === "text") {
                  css += child.value;
                }
                if (child.type === "cdata") {
                  styleContentType = "cdata";
                  css += child.value;
                }
              }
              if (css.trim().length === 0) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (node.attributes.media == null) {
                collectedStyles += css;
              } else {
                collectedStyles += `@media ${node.attributes.media}{${css}}`;
                delete node.attributes.media;
              }
              if (firstStyleElement == null) {
                firstStyleElement = node;
              } else {
                detachNodeFromParent(node, parentNode);
                firstStyleElement.children = [
                  new JSAPI(
                    { type: styleContentType, value: collectedStyles },
                    firstStyleElement,
                  ),
                ];
              }
            },
          },
        };
      };
    },
    1119: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csso = __nccwpck_require__(3027);
      exports.type = "visitor";
      exports.name = "minifyStyles";
      exports.active = true;
      exports.description =
        "minifies styles and removes unused styles based on usage data";
      exports.fn = (_root, { usage, ...params }) => {
        let enableTagsUsage = true;
        let enableIdsUsage = true;
        let enableClassesUsage = true;
        let forceUsageDeoptimized = false;
        if (typeof usage === "boolean") {
          enableTagsUsage = usage;
          enableIdsUsage = usage;
          enableClassesUsage = usage;
        } else if (usage) {
          enableTagsUsage = usage.tags == null ? true : usage.tags;
          enableIdsUsage = usage.ids == null ? true : usage.ids;
          enableClassesUsage = usage.classes == null ? true : usage.classes;
          forceUsageDeoptimized = usage.force == null ? false : usage.force;
        }
        const styleElements = [];
        const elementsWithStyleAttributes = [];
        let deoptimized = false;
        const tagsUsage = new Set();
        const idsUsage = new Set();
        const classesUsage = new Set();
        return {
          element: {
            enter: (node) => {
              if (node.name === "script") {
                deoptimized = true;
              }
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith("on")) {
                  deoptimized = true;
                }
              }
              tagsUsage.add(node.name);
              if (node.attributes.id != null) {
                idsUsage.add(node.attributes.id);
              }
              if (node.attributes.class != null) {
                for (const className of node.attributes.class.split(/\s+/)) {
                  classesUsage.add(className);
                }
              }
              if (node.name === "style" && node.children.length !== 0) {
                styleElements.push(node);
              } else if (node.attributes.style != null) {
                elementsWithStyleAttributes.push(node);
              }
            },
          },
          root: {
            exit: () => {
              const cssoUsage = {};
              if (deoptimized === false || forceUsageDeoptimized === true) {
                if (enableTagsUsage && tagsUsage.size !== 0) {
                  cssoUsage.tags = Array.from(tagsUsage);
                }
                if (enableIdsUsage && idsUsage.size !== 0) {
                  cssoUsage.ids = Array.from(idsUsage);
                }
                if (enableClassesUsage && classesUsage.size !== 0) {
                  cssoUsage.classes = Array.from(classesUsage);
                }
              }
              for (const node of styleElements) {
                if (
                  node.children[0].type === "text" ||
                  node.children[0].type === "cdata"
                ) {
                  const cssText = node.children[0].value;
                  const minified = csso.minify(cssText, {
                    ...params,
                    usage: cssoUsage,
                  }).css;
                  if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
                    node.children[0].type = "cdata";
                    node.children[0].value = minified;
                  } else {
                    node.children[0].type = "text";
                    node.children[0].value = minified;
                  }
                }
              }
              for (const node of elementsWithStyleAttributes) {
                const elemStyle = node.attributes.style;
                node.attributes.style = csso.minifyBlock(elemStyle, {
                  ...params,
                }).css;
              }
            },
          },
        };
      };
    },
    8006: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit } = __nccwpck_require__(143);
      const { inheritableAttrs, pathElems } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "moveElemsAttrsToGroup";
      exports.active = true;
      exports.description =
        "Move common attributes of group children to the group";
      exports.fn = (root) => {
        let deoptimizedWithStyles = false;
        visit(root, {
          element: {
            enter: (node) => {
              if (node.name === "style") {
                deoptimizedWithStyles = true;
              }
            },
          },
        });
        return {
          element: {
            exit: (node) => {
              if (node.name !== "g" || node.children.length <= 1) {
                return;
              }
              if (deoptimizedWithStyles) {
                return;
              }
              const commonAttributes = new Map();
              let initial = true;
              let everyChildIsPath = true;
              for (const child of node.children) {
                if (child.type === "element") {
                  if (pathElems.includes(child.name) === false) {
                    everyChildIsPath = false;
                  }
                  if (initial) {
                    initial = false;
                    for (const [name, value] of Object.entries(
                      child.attributes,
                    )) {
                      if (inheritableAttrs.includes(name)) {
                        commonAttributes.set(name, value);
                      }
                    }
                  } else {
                    for (const [name, value] of commonAttributes) {
                      if (child.attributes[name] !== value) {
                        commonAttributes.delete(name);
                      }
                    }
                  }
                }
              }
              if (
                node.attributes["clip-path"] != null ||
                node.attributes.mask != null
              ) {
                commonAttributes.delete("transform");
              }
              if (everyChildIsPath) {
                commonAttributes.delete("transform");
              }
              for (const [name, value] of commonAttributes) {
                if (name === "transform") {
                  if (node.attributes.transform != null) {
                    node.attributes.transform = `${node.attributes.transform} ${value}`;
                  } else {
                    node.attributes.transform = value;
                  }
                } else {
                  node.attributes[name] = value;
                }
              }
              for (const child of node.children) {
                if (child.type === "element") {
                  for (const [name] of commonAttributes) {
                    delete child.attributes[name];
                  }
                }
              }
            },
          },
        };
      };
    },
    9707: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { pathElems, referencesProps } = __nccwpck_require__(6173);
      exports.name = "moveGroupAttrsToElems";
      exports.type = "perItem";
      exports.active = true;
      exports.description =
        "moves some group attributes to the content elements";
      const pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
      exports.fn = function (item) {
        if (
          item.type === "element" &&
          item.name === "g" &&
          item.children.length !== 0 &&
          item.attributes.transform != null &&
          Object.entries(item.attributes).some(
            ([name, value]) =>
              referencesProps.includes(name) && value.includes("url("),
          ) === false &&
          item.children.every(
            (inner) =>
              pathElemsWithGroupsAndText.includes(inner.name) &&
              inner.attributes.id == null,
          )
        ) {
          for (const inner of item.children) {
            const value = item.attributes.transform;
            if (inner.attributes.transform != null) {
              inner.attributes.transform =
                value + " " + inner.attributes.transform;
            } else {
              inner.attributes.transform = value;
            }
          }
          delete item.attributes.transform;
        }
      };
    },
    868: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      exports["preset-default"] = __nccwpck_require__(4084);
      exports.addAttributesToSVGElement = __nccwpck_require__(3713);
      exports.addClassesToSVGElement = __nccwpck_require__(4651);
      exports.cleanupAttrs = __nccwpck_require__(9171);
      exports.cleanupEnableBackground = __nccwpck_require__(8298);
      exports.cleanupIDs = __nccwpck_require__(7156);
      exports.cleanupListOfValues = __nccwpck_require__(1229);
      exports.cleanupNumericValues = __nccwpck_require__(4362);
      exports.collapseGroups = __nccwpck_require__(1354);
      exports.convertColors = __nccwpck_require__(5676);
      exports.convertEllipseToCircle = __nccwpck_require__(4294);
      exports.convertPathData = __nccwpck_require__(1991);
      exports.convertShapeToPath = __nccwpck_require__(2675);
      exports.convertStyleToAttrs = __nccwpck_require__(3036);
      exports.convertTransform = __nccwpck_require__(1154);
      exports.mergeStyles = __nccwpck_require__(4279);
      exports.inlineStyles = __nccwpck_require__(2197);
      exports.mergePaths = __nccwpck_require__(6300);
      exports.minifyStyles = __nccwpck_require__(1119);
      exports.moveElemsAttrsToGroup = __nccwpck_require__(8006);
      exports.moveGroupAttrsToElems = __nccwpck_require__(9707);
      exports.prefixIds = __nccwpck_require__(1732);
      exports.removeAttributesBySelector = __nccwpck_require__(1858);
      exports.removeAttrs = __nccwpck_require__(8678);
      exports.removeComments = __nccwpck_require__(4085);
      exports.removeDesc = __nccwpck_require__(4126);
      exports.removeDimensions = __nccwpck_require__(2849);
      exports.removeDoctype = __nccwpck_require__(7446);
      exports.removeEditorsNSData = __nccwpck_require__(3691);
      exports.removeElementsByAttr = __nccwpck_require__(4223);
      exports.removeEmptyAttrs = __nccwpck_require__(2003);
      exports.removeEmptyContainers = __nccwpck_require__(7092);
      exports.removeEmptyText = __nccwpck_require__(5899);
      exports.removeHiddenElems = __nccwpck_require__(1171);
      exports.removeMetadata = __nccwpck_require__(1664);
      exports.removeNonInheritableGroupAttrs = __nccwpck_require__(6714);
      exports.removeOffCanvasPaths = __nccwpck_require__(1080);
      exports.removeRasterImages = __nccwpck_require__(8570);
      exports.removeScriptElement = __nccwpck_require__(6252);
      exports.removeStyleElement = __nccwpck_require__(8762);
      exports.removeTitle = __nccwpck_require__(8152);
      exports.removeUnknownsAndDefaults = __nccwpck_require__(9549);
      exports.removeUnusedNS = __nccwpck_require__(2998);
      exports.removeUselessDefs = __nccwpck_require__(4453);
      exports.removeUselessStrokeAndFill = __nccwpck_require__(3733);
      exports.removeViewBox = __nccwpck_require__(4440);
      exports.removeXMLNS = __nccwpck_require__(8737);
      exports.removeXMLProcInst = __nccwpck_require__(3127);
      exports.reusePaths = __nccwpck_require__(6299);
      exports.sortAttrs = __nccwpck_require__(1238);
      exports.sortDefsChildren = __nccwpck_require__(4604);
    },
    1732: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csstree = __nccwpck_require__(4895);
      const { referencesProps } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "prefixIds";
      exports.active = false;
      exports.description = "prefix IDs";
      const getBasename = (path) => {
        const matched = path.match(/[/\\]?([^/\\]+)$/);
        if (matched) {
          return matched[1];
        }
        return "";
      };
      const escapeIdentifierName = (str) => str.replace(/[. ]/g, "_");
      const unquote = (string) => {
        if (
          (string.startsWith('"') && string.endsWith('"')) ||
          (string.startsWith("'") && string.endsWith("'"))
        ) {
          return string.slice(1, -1);
        }
        return string;
      };
      const prefixId = (prefix, value) => {
        if (value.startsWith(prefix)) {
          return value;
        }
        return prefix + value;
      };
      const prefixReference = (prefix, value) => {
        if (value.startsWith("#")) {
          return "#" + prefixId(prefix, value.slice(1));
        }
        return null;
      };
      exports.fn = (_root, params, info) => {
        const {
          delim = "__",
          prefixIds = true,
          prefixClassNames = true,
        } = params;
        return {
          element: {
            enter: (node) => {
              let prefix = "prefix" + delim;
              if (typeof params.prefix === "function") {
                prefix = params.prefix(node, info) + delim;
              } else if (typeof params.prefix === "string") {
                prefix = params.prefix + delim;
              } else if (params.prefix === false) {
                prefix = "";
              } else if (info.path != null && info.path.length > 0) {
                prefix = escapeIdentifierName(getBasename(info.path)) + delim;
              }
              if (node.name === "style") {
                if (node.children.length === 0) {
                  return;
                }
                let cssText = "";
                if (
                  node.children[0].type === "text" ||
                  node.children[0].type === "cdata"
                ) {
                  cssText = node.children[0].value;
                }
                let cssAst = null;
                try {
                  cssAst = csstree.parse(cssText, {
                    parseValue: true,
                    parseCustomProperty: false,
                  });
                } catch {
                  return;
                }
                csstree.walk(cssAst, (node) => {
                  if (
                    (prefixIds && node.type === "IdSelector") ||
                    (prefixClassNames && node.type === "ClassSelector")
                  ) {
                    node.name = prefixId(prefix, node.name);
                    return;
                  }
                  if (
                    node.type === "Url" &&
                    node.value.value &&
                    node.value.value.length > 0
                  ) {
                    const prefixed = prefixReference(
                      prefix,
                      unquote(node.value.value),
                    );
                    if (prefixed != null) {
                      node.value.value = prefixed;
                    }
                  }
                });
                if (
                  node.children[0].type === "text" ||
                  node.children[0].type === "cdata"
                ) {
                  node.children[0].value = csstree.generate(cssAst);
                }
                return;
              }
              if (
                prefixIds &&
                node.attributes.id != null &&
                node.attributes.id.length !== 0
              ) {
                node.attributes.id = prefixId(prefix, node.attributes.id);
              }
              if (
                prefixClassNames &&
                node.attributes.class != null &&
                node.attributes.class.length !== 0
              ) {
                node.attributes.class = node.attributes.class
                  .split(/\s+/)
                  .map((name) => prefixId(prefix, name))
                  .join(" ");
              }
              for (const name of ["href", "xlink:href"]) {
                if (
                  node.attributes[name] != null &&
                  node.attributes[name].length !== 0
                ) {
                  const prefixed = prefixReference(
                    prefix,
                    node.attributes[name],
                  );
                  if (prefixed != null) {
                    node.attributes[name] = prefixed;
                  }
                }
              }
              for (const name of referencesProps) {
                if (
                  node.attributes[name] != null &&
                  node.attributes[name].length !== 0
                ) {
                  node.attributes[name] = node.attributes[name].replace(
                    /url\((.*?)\)/gi,
                    (match, url) => {
                      const prefixed = prefixReference(prefix, url);
                      if (prefixed == null) {
                        return match;
                      }
                      return `url(${prefixed})`;
                    },
                  );
                }
              }
              for (const name of ["begin", "end"]) {
                if (
                  node.attributes[name] != null &&
                  node.attributes[name].length !== 0
                ) {
                  const parts = node.attributes[name]
                    .split(/\s*;\s+/)
                    .map((val) => {
                      if (val.endsWith(".end") || val.endsWith(".start")) {
                        const [id, postfix] = val.split(".");
                        return `${prefixId(prefix, id)}.${postfix}`;
                      }
                      return val;
                    });
                  node.attributes[name] = parts.join("; ");
                }
              }
            },
          },
        };
      };
    },
    4084: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { createPreset } = __nccwpck_require__(9180);
      const removeDoctype = __nccwpck_require__(7446);
      const removeXMLProcInst = __nccwpck_require__(3127);
      const removeComments = __nccwpck_require__(4085);
      const removeMetadata = __nccwpck_require__(1664);
      const removeEditorsNSData = __nccwpck_require__(3691);
      const cleanupAttrs = __nccwpck_require__(9171);
      const mergeStyles = __nccwpck_require__(4279);
      const inlineStyles = __nccwpck_require__(2197);
      const minifyStyles = __nccwpck_require__(1119);
      const cleanupIDs = __nccwpck_require__(7156);
      const removeUselessDefs = __nccwpck_require__(4453);
      const cleanupNumericValues = __nccwpck_require__(4362);
      const convertColors = __nccwpck_require__(5676);
      const removeUnknownsAndDefaults = __nccwpck_require__(9549);
      const removeNonInheritableGroupAttrs = __nccwpck_require__(6714);
      const removeUselessStrokeAndFill = __nccwpck_require__(3733);
      const removeViewBox = __nccwpck_require__(4440);
      const cleanupEnableBackground = __nccwpck_require__(8298);
      const removeHiddenElems = __nccwpck_require__(1171);
      const removeEmptyText = __nccwpck_require__(5899);
      const convertShapeToPath = __nccwpck_require__(2675);
      const convertEllipseToCircle = __nccwpck_require__(4294);
      const moveElemsAttrsToGroup = __nccwpck_require__(8006);
      const moveGroupAttrsToElems = __nccwpck_require__(9707);
      const collapseGroups = __nccwpck_require__(1354);
      const convertPathData = __nccwpck_require__(1991);
      const convertTransform = __nccwpck_require__(1154);
      const removeEmptyAttrs = __nccwpck_require__(2003);
      const removeEmptyContainers = __nccwpck_require__(7092);
      const mergePaths = __nccwpck_require__(6300);
      const removeUnusedNS = __nccwpck_require__(2998);
      const sortDefsChildren = __nccwpck_require__(4604);
      const removeTitle = __nccwpck_require__(8152);
      const removeDesc = __nccwpck_require__(4126);
      const presetDefault = createPreset({
        name: "presetDefault",
        plugins: [
          removeDoctype,
          removeXMLProcInst,
          removeComments,
          removeMetadata,
          removeEditorsNSData,
          cleanupAttrs,
          mergeStyles,
          inlineStyles,
          minifyStyles,
          cleanupIDs,
          removeUselessDefs,
          cleanupNumericValues,
          convertColors,
          removeUnknownsAndDefaults,
          removeNonInheritableGroupAttrs,
          removeUselessStrokeAndFill,
          removeViewBox,
          cleanupEnableBackground,
          removeHiddenElems,
          removeEmptyText,
          convertShapeToPath,
          convertEllipseToCircle,
          moveElemsAttrsToGroup,
          moveGroupAttrsToElems,
          collapseGroups,
          convertPathData,
          convertTransform,
          removeEmptyAttrs,
          removeEmptyContainers,
          mergePaths,
          removeUnusedNS,
          sortDefsChildren,
          removeTitle,
          removeDesc,
        ],
      });
      module.exports = presetDefault;
    },
    1858: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { querySelectorAll } = __nccwpck_require__(143);
      exports.name = "removeAttributesBySelector";
      exports.type = "visitor";
      exports.active = false;
      exports.description =
        "removes attributes of elements that match a css selector";
      exports.fn = (root, params) => {
        const selectors = Array.isArray(params.selectors)
          ? params.selectors
          : [params];
        for (const { selector, attributes } of selectors) {
          const nodes = querySelectorAll(root, selector);
          for (const node of nodes) {
            if (node.type === "element") {
              if (Array.isArray(attributes)) {
                for (const name of attributes) {
                  delete node.attributes[name];
                }
              } else {
                delete node.attributes[attributes];
              }
            }
          }
        }
        return {};
      };
    },
    8678: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeAttrs";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "removes specified attributes";
      const DEFAULT_SEPARATOR = ":";
      const ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: "removeAttrs",\n    params: {\n      attrs: "(fill|stroke)"\n    }\n  }\n]\n`;
      exports.fn = (root, params) => {
        if (typeof params.attrs == "undefined") {
          console.warn(ENOATTRS);
          return null;
        }
        const elemSeparator =
          typeof params.elemSeparator == "string"
            ? params.elemSeparator
            : DEFAULT_SEPARATOR;
        const preserveCurrentColor =
          typeof params.preserveCurrentColor == "boolean"
            ? params.preserveCurrentColor
            : false;
        const attrs = Array.isArray(params.attrs)
          ? params.attrs
          : [params.attrs];
        return {
          element: {
            enter: (node) => {
              for (let pattern of attrs) {
                if (pattern.includes(elemSeparator) === false) {
                  pattern = [
                    ".*",
                    elemSeparator,
                    pattern,
                    elemSeparator,
                    ".*",
                  ].join("");
                } else if (pattern.split(elemSeparator).length < 3) {
                  pattern = [pattern, elemSeparator, ".*"].join("");
                }
                const list = pattern.split(elemSeparator).map((value) => {
                  if (value === "*") {
                    value = ".*";
                  }
                  return new RegExp(["^", value, "$"].join(""), "i");
                });
                if (list[0].test(node.name)) {
                  for (const [name, value] of Object.entries(node.attributes)) {
                    const isFillCurrentColor =
                      preserveCurrentColor &&
                      name == "fill" &&
                      value == "currentColor";
                    const isStrokeCurrentColor =
                      preserveCurrentColor &&
                      name == "stroke" &&
                      value == "currentColor";
                    if (
                      !isFillCurrentColor &&
                      !isStrokeCurrentColor &&
                      list[1].test(name) &&
                      list[2].test(value)
                    ) {
                      delete node.attributes[name];
                    }
                  }
                }
              }
            },
          },
        };
      };
    },
    4085: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeComments";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes comments";
      exports.fn = () => ({
        comment: {
          enter: (node, parentNode) => {
            if (node.value.charAt(0) !== "!") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    4126: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeDesc";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes <desc>";
      const standardDescs = /^(Created with|Created using)/;
      exports.fn = (root, params) => {
        const { removeAny = true } = params;
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "desc") {
                if (
                  removeAny ||
                  node.children.length === 0 ||
                  (node.children[0].type === "text" &&
                    standardDescs.test(node.children[0].value))
                ) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    2849: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeDimensions";
      exports.type = "perItem";
      exports.active = false;
      exports.description =
        "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";
      exports.fn = function (item) {
        if (item.type === "element" && item.name === "svg") {
          if (item.attributes.viewBox != null) {
            delete item.attributes.width;
            delete item.attributes.height;
          } else if (
            item.attributes.width != null &&
            item.attributes.height != null &&
            Number.isNaN(Number(item.attributes.width)) === false &&
            Number.isNaN(Number(item.attributes.height)) === false
          ) {
            const width = Number(item.attributes.width);
            const height = Number(item.attributes.height);
            item.attributes.viewBox = `0 0 ${width} ${height}`;
            delete item.attributes.width;
            delete item.attributes.height;
          }
        }
      };
    },
    7446: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeDoctype";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes doctype declaration";
      exports.fn = () => ({
        doctype: {
          enter: (node, parentNode) => {
            detachNodeFromParent(node, parentNode);
          },
        },
      });
    },
    3691: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      const { editorNamespaces } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "removeEditorsNSData";
      exports.active = true;
      exports.description =
        "removes editors namespaces, elements and attributes";
      exports.fn = (_root, params) => {
        let namespaces = editorNamespaces;
        if (Array.isArray(params.additionalNamespaces)) {
          namespaces = [...editorNamespaces, ...params.additionalNamespaces];
        }
        const prefixes = [];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg") {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (name.startsWith("xmlns:") && namespaces.includes(value)) {
                    prefixes.push(name.slice("xmlns:".length));
                    delete node.attributes[name];
                  }
                }
              }
              for (const name of Object.keys(node.attributes)) {
                if (name.includes(":")) {
                  const [prefix] = name.split(":");
                  if (prefixes.includes(prefix)) {
                    delete node.attributes[name];
                  }
                }
              }
              if (node.name.includes(":")) {
                const [prefix] = node.name.split(":");
                if (prefixes.includes(prefix)) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    4223: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeElementsByAttr";
      exports.type = "visitor";
      exports.active = false;
      exports.description =
        "removes arbitrary elements by ID or className (disabled by default)";
      exports.fn = (root, params) => {
        const ids =
          params.id == null
            ? []
            : Array.isArray(params.id)
              ? params.id
              : [params.id];
        const classes =
          params.class == null
            ? []
            : Array.isArray(params.class)
              ? params.class
              : [params.class];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.attributes.id != null && ids.length !== 0) {
                if (ids.includes(node.attributes.id)) {
                  detachNodeFromParent(node, parentNode);
                }
              }
              if (node.attributes.class && classes.length !== 0) {
                const classList = node.attributes.class.split(" ");
                for (const item of classes) {
                  if (classList.includes(item)) {
                    detachNodeFromParent(node, parentNode);
                    break;
                  }
                }
              }
            },
          },
        };
      };
    },
    2003: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { attrsGroups } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "removeEmptyAttrs";
      exports.active = true;
      exports.description = "removes empty attributes";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (
                value === "" &&
                attrsGroups.conditionalProcessing.includes(name) === false
              ) {
                delete node.attributes[name];
              }
            }
          },
        },
      });
    },
    7092: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      const { elemsGroups } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "removeEmptyContainers";
      exports.active = true;
      exports.description = "removes empty container elements";
      exports.fn = () => ({
        element: {
          exit: (node, parentNode) => {
            if (
              node.name === "svg" ||
              elemsGroups.container.includes(node.name) === false ||
              node.children.length !== 0
            ) {
              return;
            }
            if (
              node.name === "pattern" &&
              Object.keys(node.attributes).length !== 0
            ) {
              return;
            }
            if (node.name === "g" && node.attributes.filter != null) {
              return;
            }
            if (node.name === "mask" && node.attributes.id != null) {
              return;
            }
            detachNodeFromParent(node, parentNode);
          },
        },
      });
    },
    5899: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeEmptyText";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes empty <text> elements";
      exports.fn = (root, params) => {
        const { text = true, tspan = true, tref = true } = params;
        return {
          element: {
            enter: (node, parentNode) => {
              if (text && node.name === "text" && node.children.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              if (
                tspan &&
                node.name === "tspan" &&
                node.children.length === 0
              ) {
                detachNodeFromParent(node, parentNode);
              }
              if (
                tref &&
                node.name === "tref" &&
                node.attributes["xlink:href"] == null
              ) {
                detachNodeFromParent(node, parentNode);
              }
            },
          },
        };
      };
    },
    1171: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { querySelector, closestByName, detachNodeFromParent } =
        __nccwpck_require__(143);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(2618);
      const { parsePathData } = __nccwpck_require__(740);
      exports.name = "removeHiddenElems";
      exports.type = "visitor";
      exports.active = true;
      exports.description =
        "removes hidden elements (zero sized, with absent attributes)";
      exports.fn = (root, params) => {
        const {
          isHidden = true,
          displayNone = true,
          opacity0 = true,
          circleR0 = true,
          ellipseRX0 = true,
          ellipseRY0 = true,
          rectWidth0 = true,
          rectHeight0 = true,
          patternWidth0 = true,
          patternHeight0 = true,
          imageWidth0 = true,
          imageHeight0 = true,
          pathEmptyD = true,
          polylineEmptyPoints = true,
          polygonEmptyPoints = true,
        } = params;
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node, parentNode) => {
              const computedStyle = computeStyle(stylesheet, node);
              if (
                isHidden &&
                computedStyle.visibility &&
                computedStyle.visibility.type === "static" &&
                computedStyle.visibility.value === "hidden" &&
                querySelector(node, "[visibility=visible]") == null
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                displayNone &&
                computedStyle.display &&
                computedStyle.display.type === "static" &&
                computedStyle.display.value === "none" &&
                node.name !== "marker"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                opacity0 &&
                computedStyle.opacity &&
                computedStyle.opacity.type === "static" &&
                computedStyle.opacity.value === "0" &&
                closestByName(node, "clipPath") == null
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                circleR0 &&
                node.name === "circle" &&
                node.children.length === 0 &&
                node.attributes.r === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                ellipseRX0 &&
                node.name === "ellipse" &&
                node.children.length === 0 &&
                node.attributes.rx === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                ellipseRY0 &&
                node.name === "ellipse" &&
                node.children.length === 0 &&
                node.attributes.ry === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                rectWidth0 &&
                node.name === "rect" &&
                node.children.length === 0 &&
                node.attributes.width === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                rectHeight0 &&
                rectWidth0 &&
                node.name === "rect" &&
                node.children.length === 0 &&
                node.attributes.height === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                patternWidth0 &&
                node.name === "pattern" &&
                node.attributes.width === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                patternHeight0 &&
                node.name === "pattern" &&
                node.attributes.height === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                imageWidth0 &&
                node.name === "image" &&
                node.attributes.width === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                imageHeight0 &&
                node.name === "image" &&
                node.attributes.height === "0"
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (pathEmptyD && node.name === "path") {
                if (node.attributes.d == null) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
                const pathData = parsePathData(node.attributes.d);
                if (pathData.length === 0) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
                if (
                  pathData.length === 1 &&
                  computedStyle["marker-start"] == null &&
                  computedStyle["marker-end"] == null
                ) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
                return;
              }
              if (
                polylineEmptyPoints &&
                node.name === "polyline" &&
                node.attributes.points == null
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (
                polygonEmptyPoints &&
                node.name === "polygon" &&
                node.attributes.points == null
              ) {
                detachNodeFromParent(node, parentNode);
                return;
              }
            },
          },
        };
      };
    },
    1664: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeMetadata";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes <metadata>";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "metadata") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    6714: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      exports.name = "removeNonInheritableGroupAttrs";
      exports.type = "perItem";
      exports.active = true;
      exports.description =
        "removes non-inheritable group’s presentational attributes";
      const {
        inheritableAttrs,
        attrsGroups,
        presentationNonInheritableGroupAttrs,
      } = __nccwpck_require__(6173);
      exports.fn = function (item) {
        if (item.type === "element" && item.name === "g") {
          for (const name of Object.keys(item.attributes)) {
            if (
              attrsGroups.presentation.includes(name) === true &&
              inheritableAttrs.includes(name) === false &&
              presentationNonInheritableGroupAttrs.includes(name) === false
            ) {
              delete item.attributes[name];
            }
          }
        }
      };
    },
    1080: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip, detachNodeFromParent } = __nccwpck_require__(143);
      const { parsePathData } = __nccwpck_require__(740);
      const { intersects } = __nccwpck_require__(1624);
      exports.type = "visitor";
      exports.name = "removeOffCanvasPaths";
      exports.active = false;
      exports.description =
        "removes elements that are drawn outside of the viewbox (disabled by default)";
      exports.fn = () => {
        let viewBoxData = null;
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                let viewBox = "";
                if (node.attributes.viewBox != null) {
                  viewBox = node.attributes.viewBox;
                } else if (
                  node.attributes.height != null &&
                  node.attributes.width != null
                ) {
                  viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
                }
                viewBox = viewBox
                  .replace(/[,+]|px/g, " ")
                  .replace(/\s+/g, " ")
                  .replace(/^\s*|\s*$/g, "");
                const m =
                  /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
                    viewBox,
                  );
                if (m == null) {
                  return;
                }
                const left = Number.parseFloat(m[1]);
                const top = Number.parseFloat(m[2]);
                const width = Number.parseFloat(m[3]);
                const height = Number.parseFloat(m[4]);
                viewBoxData = {
                  left,
                  top,
                  right: left + width,
                  bottom: top + height,
                  width,
                  height,
                };
              }
              if (node.attributes.transform != null) {
                return visitSkip;
              }
              if (
                node.name === "path" &&
                node.attributes.d != null &&
                viewBoxData != null
              ) {
                const pathData = parsePathData(node.attributes.d);
                let visible = false;
                for (const pathDataItem of pathData) {
                  if (pathDataItem.command === "M") {
                    const [x, y] = pathDataItem.args;
                    if (
                      x >= viewBoxData.left &&
                      x <= viewBoxData.right &&
                      y >= viewBoxData.top &&
                      y <= viewBoxData.bottom
                    ) {
                      visible = true;
                    }
                  }
                }
                if (visible) {
                  return;
                }
                if (pathData.length === 2) {
                  pathData.push({ command: "z", args: [] });
                }
                const { left, top, width, height } = viewBoxData;
                const viewBoxPathData = [
                  { command: "M", args: [left, top] },
                  { command: "h", args: [width] },
                  { command: "v", args: [height] },
                  { command: "H", args: [left] },
                  { command: "z", args: [] },
                ];
                if (intersects(viewBoxPathData, pathData) === false) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    8570: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeRasterImages";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "removes raster images (disabled by default)";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (
              node.name === "image" &&
              node.attributes["xlink:href"] != null &&
              /(\.|image\/)(jpg|png|gif)/.test(node.attributes["xlink:href"])
            ) {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    6252: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeScriptElement";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "removes <script> elements (disabled by default)";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "script") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    8762: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeStyleElement";
      exports.type = "visitor";
      exports.active = false;
      exports.description = "removes <style> element (disabled by default)";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "style") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    8152: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeTitle";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes <title>";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "title") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    9549: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip, detachNodeFromParent } = __nccwpck_require__(143);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(2618);
      const {
        elems,
        attrsGroups,
        elemsGroups,
        attrsGroupsDefaults,
        presentationNonInheritableGroupAttrs,
      } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "removeUnknownsAndDefaults";
      exports.active = true;
      exports.description =
        "removes unknown elements content and attributes, removes attrs with default values";
      const allowedChildrenPerElement = new Map();
      const allowedAttributesPerElement = new Map();
      const attributesDefaultsPerElement = new Map();
      for (const [name, config] of Object.entries(elems)) {
        const allowedChildren = new Set();
        if (config.content) {
          for (const elementName of config.content) {
            allowedChildren.add(elementName);
          }
        }
        if (config.contentGroups) {
          for (const contentGroupName of config.contentGroups) {
            const elemsGroup = elemsGroups[contentGroupName];
            if (elemsGroup) {
              for (const elementName of elemsGroup) {
                allowedChildren.add(elementName);
              }
            }
          }
        }
        const allowedAttributes = new Set();
        if (config.attrs) {
          for (const attrName of config.attrs) {
            allowedAttributes.add(attrName);
          }
        }
        const attributesDefaults = new Map();
        if (config.defaults) {
          for (const [attrName, defaultValue] of Object.entries(
            config.defaults,
          )) {
            attributesDefaults.set(attrName, defaultValue);
          }
        }
        for (const attrsGroupName of config.attrsGroups) {
          const attrsGroup = attrsGroups[attrsGroupName];
          if (attrsGroup) {
            for (const attrName of attrsGroup) {
              allowedAttributes.add(attrName);
            }
          }
          const groupDefaults = attrsGroupsDefaults[attrsGroupName];
          if (groupDefaults) {
            for (const [attrName, defaultValue] of Object.entries(
              groupDefaults,
            )) {
              attributesDefaults.set(attrName, defaultValue);
            }
          }
        }
        allowedChildrenPerElement.set(name, allowedChildren);
        allowedAttributesPerElement.set(name, allowedAttributes);
        attributesDefaultsPerElement.set(name, attributesDefaults);
      }
      exports.fn = (root, params) => {
        const {
          unknownContent = true,
          unknownAttrs = true,
          defaultAttrs = true,
          uselessOverrides = true,
          keepDataAttrs = true,
          keepAriaAttrs = true,
          keepRoleAttr = false,
        } = params;
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name.includes(":")) {
                return;
              }
              if (node.name === "foreignObject") {
                return visitSkip;
              }
              if (unknownContent && parentNode.type === "element") {
                const allowedChildren = allowedChildrenPerElement.get(
                  parentNode.name,
                );
                if (allowedChildren == null || allowedChildren.size === 0) {
                  if (allowedChildrenPerElement.get(node.name) == null) {
                    detachNodeFromParent(node, parentNode);
                    return;
                  }
                } else {
                  if (allowedChildren.has(node.name) === false) {
                    detachNodeFromParent(node, parentNode);
                    return;
                  }
                }
              }
              const allowedAttributes = allowedAttributesPerElement.get(
                node.name,
              );
              const attributesDefaults = attributesDefaultsPerElement.get(
                node.name,
              );
              const computedParentStyle =
                parentNode.type === "element"
                  ? computeStyle(stylesheet, parentNode)
                  : null;
              for (const [name, value] of Object.entries(node.attributes)) {
                if (keepDataAttrs && name.startsWith("data-")) {
                  continue;
                }
                if (keepAriaAttrs && name.startsWith("aria-")) {
                  continue;
                }
                if (keepRoleAttr && name === "role") {
                  continue;
                }
                if (name === "xmlns") {
                  continue;
                }
                if (name.includes(":")) {
                  const [prefix] = name.split(":");
                  if (prefix !== "xml" && prefix !== "xlink") {
                    continue;
                  }
                }
                if (
                  unknownAttrs &&
                  allowedAttributes &&
                  allowedAttributes.has(name) === false
                ) {
                  delete node.attributes[name];
                }
                if (
                  defaultAttrs &&
                  node.attributes.id == null &&
                  attributesDefaults &&
                  attributesDefaults.get(name) === value
                ) {
                  if (
                    computedParentStyle == null ||
                    computedParentStyle[name] == null
                  ) {
                    delete node.attributes[name];
                  }
                }
                if (uselessOverrides && node.attributes.id == null) {
                  const style =
                    computedParentStyle == null
                      ? null
                      : computedParentStyle[name];
                  if (
                    presentationNonInheritableGroupAttrs.includes(name) ===
                      false &&
                    style != null &&
                    style.type === "static" &&
                    style.value === value
                  ) {
                    delete node.attributes[name];
                  }
                }
              }
            },
          },
        };
      };
    },
    2998: (__unused_webpack_module, exports) => {
      "use strict";
      exports.type = "visitor";
      exports.name = "removeUnusedNS";
      exports.active = true;
      exports.description = "removes unused namespaces declaration";
      exports.fn = () => {
        const unusedNamespaces = new Set();
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                for (const name of Object.keys(node.attributes)) {
                  if (name.startsWith("xmlns:")) {
                    const local = name.slice("xmlns:".length);
                    unusedNamespaces.add(local);
                  }
                }
              }
              if (unusedNamespaces.size !== 0) {
                if (node.name.includes(":")) {
                  const [ns] = node.name.split(":");
                  if (unusedNamespaces.has(ns)) {
                    unusedNamespaces.delete(ns);
                  }
                }
                for (const name of Object.keys(node.attributes)) {
                  if (name.includes(":")) {
                    const [ns] = name.split(":");
                    unusedNamespaces.delete(ns);
                  }
                }
              }
            },
            exit: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                for (const name of unusedNamespaces) {
                  delete node.attributes[`xmlns:${name}`];
                }
              }
            },
          },
        };
      };
    },
    4453: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      const { elemsGroups } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "removeUselessDefs";
      exports.active = true;
      exports.description = "removes elements in <defs> without id";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "defs") {
              const usefulNodes = [];
              collectUsefulNodes(node, usefulNodes);
              if (usefulNodes.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              for (const usefulNode of usefulNodes) {
                usefulNode.parentNode = node;
              }
              node.children = usefulNodes;
            } else if (
              elemsGroups.nonRendering.includes(node.name) &&
              node.attributes.id == null
            ) {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
      const collectUsefulNodes = (node, usefulNodes) => {
        for (const child of node.children) {
          if (child.type === "element") {
            if (child.attributes.id != null || child.name === "style") {
              usefulNodes.push(child);
            } else {
              collectUsefulNodes(child, usefulNodes);
            }
          }
        }
      };
    },
    3733: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit, visitSkip, detachNodeFromParent } =
        __nccwpck_require__(143);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(2618);
      const { elemsGroups } = __nccwpck_require__(6173);
      exports.type = "visitor";
      exports.name = "removeUselessStrokeAndFill";
      exports.active = true;
      exports.description = "removes useless stroke and fill attributes";
      exports.fn = (root, params) => {
        const {
          stroke: removeStroke = true,
          fill: removeFill = true,
          removeNone = false,
        } = params;
        let hasStyleOrScript = false;
        visit(root, {
          element: {
            enter: (node) => {
              if (node.name === "style" || node.name === "script") {
                hasStyleOrScript = true;
              }
            },
          },
        });
        if (hasStyleOrScript) {
          return null;
        }
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.attributes.id != null) {
                return visitSkip;
              }
              if (elemsGroups.shape.includes(node.name) == false) {
                return;
              }
              const computedStyle = computeStyle(stylesheet, node);
              const stroke = computedStyle.stroke;
              const strokeOpacity = computedStyle["stroke-opacity"];
              const strokeWidth = computedStyle["stroke-width"];
              const markerEnd = computedStyle["marker-end"];
              const fill = computedStyle.fill;
              const fillOpacity = computedStyle["fill-opacity"];
              const computedParentStyle =
                parentNode.type === "element"
                  ? computeStyle(stylesheet, parentNode)
                  : null;
              const parentStroke =
                computedParentStyle == null ? null : computedParentStyle.stroke;
              if (removeStroke) {
                if (
                  stroke == null ||
                  (stroke.type === "static" && stroke.value == "none") ||
                  (strokeOpacity != null &&
                    strokeOpacity.type === "static" &&
                    strokeOpacity.value === "0") ||
                  (strokeWidth != null &&
                    strokeWidth.type === "static" &&
                    strokeWidth.value === "0")
                ) {
                  if (
                    (strokeWidth != null &&
                      strokeWidth.type === "static" &&
                      strokeWidth.value === "0") ||
                    markerEnd == null
                  ) {
                    for (const name of Object.keys(node.attributes)) {
                      if (name.startsWith("stroke")) {
                        delete node.attributes[name];
                      }
                    }
                    if (
                      parentStroke != null &&
                      parentStroke.type === "static" &&
                      parentStroke.value !== "none"
                    ) {
                      node.attributes.stroke = "none";
                    }
                  }
                }
              }
              if (removeFill) {
                if (
                  (fill != null &&
                    fill.type === "static" &&
                    fill.value === "none") ||
                  (fillOpacity != null &&
                    fillOpacity.type === "static" &&
                    fillOpacity.value === "0")
                ) {
                  for (const name of Object.keys(node.attributes)) {
                    if (name.startsWith("fill-")) {
                      delete node.attributes[name];
                    }
                  }
                  if (
                    fill == null ||
                    (fill.type === "static" && fill.value !== "none")
                  ) {
                    node.attributes.fill = "none";
                  }
                }
              }
              if (removeNone) {
                if (
                  (stroke == null || node.attributes.stroke === "none") &&
                  ((fill != null &&
                    fill.type === "static" &&
                    fill.value === "none") ||
                    node.attributes.fill === "none")
                ) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    4440: (__unused_webpack_module, exports) => {
      "use strict";
      exports.type = "visitor";
      exports.name = "removeViewBox";
      exports.active = true;
      exports.description = "removes viewBox attribute when possible";
      const viewBoxElems = ["svg", "pattern", "symbol"];
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (
              viewBoxElems.includes(node.name) &&
              node.attributes.viewBox != null &&
              node.attributes.width != null &&
              node.attributes.height != null
            ) {
              if (node.name === "svg" && parentNode.type !== "root") {
                return;
              }
              const nums = node.attributes.viewBox.split(/[ ,]+/g);
              if (
                nums[0] === "0" &&
                nums[1] === "0" &&
                node.attributes.width.replace(/px$/, "") === nums[2] &&
                node.attributes.height.replace(/px$/, "") === nums[3]
              ) {
                delete node.attributes.viewBox;
              }
            }
          },
        },
      });
    },
    8737: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeXMLNS";
      exports.type = "perItem";
      exports.active = false;
      exports.description =
        "removes xmlns attribute (for inline svg, disabled by default)";
      exports.fn = function (item) {
        if (item.type === "element" && item.name === "svg") {
          delete item.attributes.xmlns;
          delete item.attributes["xmlns:xlink"];
        }
      };
    },
    3127: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(143);
      exports.name = "removeXMLProcInst";
      exports.type = "visitor";
      exports.active = true;
      exports.description = "removes XML processing instructions";
      exports.fn = () => ({
        instruction: {
          enter: (node, parentNode) => {
            if (node.name === "xml") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    6299: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const JSAPI = __nccwpck_require__(1877);
      exports.type = "visitor";
      exports.name = "reusePaths";
      exports.active = false;
      exports.description =
        "Finds <path> elements with the same d, fill, and " +
        "stroke, and converts them to <use> elements " +
        "referencing a single <path> def.";
      exports.fn = () => {
        const paths = new Map();
        return {
          element: {
            enter: (node) => {
              if (node.name === "path" && node.attributes.d != null) {
                const d = node.attributes.d;
                const fill = node.attributes.fill || "";
                const stroke = node.attributes.stroke || "";
                const key = d + ";s:" + stroke + ";f:" + fill;
                let list = paths.get(key);
                if (list == null) {
                  list = [];
                  paths.set(key, list);
                }
                list.push(node);
              }
            },
            exit: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                const rawDefs = {
                  type: "element",
                  name: "defs",
                  attributes: {},
                  children: [],
                };
                const defsTag = new JSAPI(rawDefs, node);
                let index = 0;
                for (const list of paths.values()) {
                  if (list.length > 1) {
                    const rawPath = {
                      type: "element",
                      name: "path",
                      attributes: { ...list[0].attributes },
                      children: [],
                    };
                    delete rawPath.attributes.transform;
                    let id;
                    if (rawPath.attributes.id == null) {
                      id = "reuse-" + index;
                      index += 1;
                      rawPath.attributes.id = id;
                    } else {
                      id = rawPath.attributes.id;
                      delete list[0].attributes.id;
                    }
                    const reusablePath = new JSAPI(rawPath, defsTag);
                    defsTag.children.push(reusablePath);
                    for (const pathNode of list) {
                      pathNode.name = "use";
                      pathNode.attributes["xlink:href"] = "#" + id;
                      delete pathNode.attributes.d;
                      delete pathNode.attributes.stroke;
                      delete pathNode.attributes.fill;
                    }
                  }
                }
                if (defsTag.children.length !== 0) {
                  if (node.attributes["xmlns:xlink"] == null) {
                    node.attributes["xmlns:xlink"] =
                      "http://www.w3.org/1999/xlink";
                  }
                  node.children.unshift(defsTag);
                }
              }
            },
          },
        };
      };
    },
    1238: (__unused_webpack_module, exports) => {
      "use strict";
      exports.type = "visitor";
      exports.name = "sortAttrs";
      exports.active = false;
      exports.description = "Sort element attributes for better compression";
      exports.fn = (_root, params) => {
        const {
          order = [
            "id",
            "width",
            "height",
            "x",
            "x1",
            "x2",
            "y",
            "y1",
            "y2",
            "cx",
            "cy",
            "r",
            "fill",
            "stroke",
            "marker",
            "d",
            "points",
          ],
          xmlnsOrder = "front",
        } = params;
        const getNsPriority = (name) => {
          if (xmlnsOrder === "front") {
            if (name === "xmlns") {
              return 3;
            }
            if (name.startsWith("xmlns:")) {
              return 2;
            }
          }
          if (name.includes(":")) {
            return 1;
          }
          return 0;
        };
        const compareAttrs = ([aName], [bName]) => {
          const aPriority = getNsPriority(aName);
          const bPriority = getNsPriority(bName);
          const priorityNs = bPriority - aPriority;
          if (priorityNs !== 0) {
            return priorityNs;
          }
          const [aPart] = aName.split("-");
          const [bPart] = bName.split("-");
          if (aPart !== bPart) {
            const aInOrderFlag = order.includes(aPart) ? 1 : 0;
            const bInOrderFlag = order.includes(bPart) ? 1 : 0;
            if (aInOrderFlag === 1 && bInOrderFlag === 1) {
              return order.indexOf(aPart) - order.indexOf(bPart);
            }
            const priorityOrder = bInOrderFlag - aInOrderFlag;
            if (priorityOrder !== 0) {
              return priorityOrder;
            }
          }
          return aName < bName ? -1 : 1;
        };
        return {
          element: {
            enter: (node) => {
              const attrs = Object.entries(node.attributes);
              attrs.sort(compareAttrs);
              const sortedAttributes = {};
              for (const [name, value] of attrs) {
                sortedAttributes[name] = value;
              }
              node.attributes = sortedAttributes;
            },
          },
        };
      };
    },
    4604: (__unused_webpack_module, exports) => {
      "use strict";
      exports.type = "visitor";
      exports.name = "sortDefsChildren";
      exports.active = true;
      exports.description = "Sorts children of <defs> to improve compression";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "defs") {
              const frequencies = new Map();
              for (const child of node.children) {
                if (child.type === "element") {
                  const frequency = frequencies.get(child.name);
                  if (frequency == null) {
                    frequencies.set(child.name, 1);
                  } else {
                    frequencies.set(child.name, frequency + 1);
                  }
                }
              }
              node.children.sort((a, b) => {
                if (a.type !== "element" || b.type !== "element") {
                  return 0;
                }
                const aFrequency = frequencies.get(a.name);
                const bFrequency = frequencies.get(b.name);
                if (aFrequency != null && bFrequency != null) {
                  const frequencyComparison = bFrequency - aFrequency;
                  if (frequencyComparison !== 0) {
                    return frequencyComparison;
                  }
                }
                const lengthComparison = b.name.length - a.name.length;
                if (lengthComparison !== 0) {
                  return lengthComparison;
                }
                if (a.name !== b.name) {
                  return a.name > b.name ? -1 : 1;
                }
                return 0;
              });
            }
          },
        },
      });
    },
    1503: (module) => {
      function webpackEmptyAsyncContext(req) {
        return Promise.resolve().then(() => {
          var e = new Error("Cannot find module '" + req + "'");
          e.code = "MODULE_NOT_FOUND";
          throw e;
        });
      }
      webpackEmptyAsyncContext.keys = () => [];
      webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
      webpackEmptyAsyncContext.id = 1503;
      module.exports = webpackEmptyAsyncContext;
    },
    3684: (module) => {
      "use strict";
      module.exports = require("./package.json");
    },
    7147: (module) => {
      "use strict";
      module.exports = require("fs");
    },
    9429: (module) => {
      "use strict";
      module.exports = require("loader-utils");
    },
    2037: (module) => {
      "use strict";
      module.exports = require("os");
    },
    1017: (module) => {
      "use strict";
      module.exports = require("path");
    },
    7310: (module) => {
      "use strict";
      module.exports = require("url");
    },
    6174: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"atrules":{"charset":{"prelude":"<string>"},"font-face":{"descriptors":{"unicode-range":{"comment":"replaces <unicode-range>, an old production name","syntax":"<urange>#"}}}},"properties":{"-moz-background-clip":{"comment":"deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip","syntax":"padding | border"},"-moz-border-radius-bottomleft":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius","syntax":"<\'border-bottom-left-radius\'>"},"-moz-border-radius-bottomright":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius","syntax":"<\'border-bottom-right-radius\'>"},"-moz-border-radius-topleft":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius","syntax":"<\'border-top-left-radius\'>"},"-moz-border-radius-topright":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius","syntax":"<\'border-bottom-right-radius\'>"},"-moz-control-character-visibility":{"comment":"firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588","syntax":"visible | hidden"},"-moz-osx-font-smoothing":{"comment":"misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth","syntax":"auto | grayscale"},"-moz-user-select":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select","syntax":"none | text | all | -moz-none"},"-ms-flex-align":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align","syntax":"start | end | center | baseline | stretch"},"-ms-flex-item-align":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align","syntax":"auto | start | end | center | baseline | stretch"},"-ms-flex-line-pack":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack","syntax":"start | end | center | justify | distribute | stretch"},"-ms-flex-negative":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-shrink\'>"},"-ms-flex-pack":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack","syntax":"start | end | center | justify | distribute"},"-ms-flex-order":{"comment":"misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx","syntax":"<integer>"},"-ms-flex-positive":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-grow\'>"},"-ms-flex-preferred-size":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-basis\'>"},"-ms-interpolation-mode":{"comment":"https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx","syntax":"nearest-neighbor | bicubic"},"-ms-grid-column-align":{"comment":"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx","syntax":"start | end | center | stretch"},"-ms-grid-row-align":{"comment":"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx","syntax":"start | end | center | stretch"},"-ms-hyphenate-limit-last":{"comment":"misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits","syntax":"none | always | column | page | spread"},"-webkit-appearance":{"comment":"webkit specific keywords","references":["http://css-infos.net/property/-webkit-appearance"],"syntax":"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"},"-webkit-background-clip":{"comment":"https://developer.mozilla.org/en/docs/Web/CSS/background-clip","syntax":"[ <box> | border | padding | content | text ]#"},"-webkit-column-break-after":{"comment":"added, http://help.dottoro.com/lcrthhhv.php","syntax":"always | auto | avoid"},"-webkit-column-break-before":{"comment":"added, http://help.dottoro.com/lcxquvkf.php","syntax":"always | auto | avoid"},"-webkit-column-break-inside":{"comment":"added, http://help.dottoro.com/lclhnthl.php","syntax":"always | auto | avoid"},"-webkit-font-smoothing":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth","syntax":"auto | none | antialiased | subpixel-antialiased"},"-webkit-mask-box-image":{"comment":"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image","syntax":"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"},"-webkit-print-color-adjust":{"comment":"missed","references":["https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"],"syntax":"economy | exact"},"-webkit-text-security":{"comment":"missed; http://help.dottoro.com/lcbkewgt.php","syntax":"none | circle | disc | square"},"-webkit-user-drag":{"comment":"missed; http://help.dottoro.com/lcbixvwm.php","syntax":"none | element | auto"},"-webkit-user-select":{"comment":"auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select","syntax":"auto | none | text | all"},"alignment-baseline":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"],"syntax":"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"},"baseline-shift":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"],"syntax":"baseline | sub | super | <svg-length>"},"behavior":{"comment":"added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx","syntax":"<url>+"},"clip-rule":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"],"syntax":"nonzero | evenodd"},"cue":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'cue-before\'> <\'cue-after\'>?"},"cue-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<url> <decibel>? | none"},"cue-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<url> <decibel>? | none"},"cursor":{"comment":"added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out","references":["https://www.sitepoint.com/css3-cursor-styles/"],"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"},"display":{"comment":"extended with -ms-flexbox","syntax":"| <-non-standard-display>"},"position":{"comment":"extended with -webkit-sticky","syntax":"| -webkit-sticky"},"dominant-baseline":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"],"syntax":"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"},"image-rendering":{"comment":"extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality","references":["https://developer.mozilla.org/en/docs/Web/CSS/image-rendering","https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"],"syntax":"| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"},"fill":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"<paint>"},"fill-opacity":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"<number-zero-one>"},"fill-rule":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"nonzero | evenodd"},"filter":{"comment":"extend with IE legacy syntaxes","syntax":"| <-ms-filter-function-list>"},"glyph-orientation-horizontal":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"],"syntax":"<angle>"},"glyph-orientation-vertical":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"],"syntax":"<angle>"},"kerning":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#KerningProperty"],"syntax":"auto | <svg-length>"},"letter-spacing":{"comment":"fix syntax <length> -> <length-percentage>","references":["https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"],"syntax":"normal | <length-percentage>"},"marker":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-end":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-mid":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-start":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"max-width":{"comment":"fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width","syntax":"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"},"width":{"comment":"per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)","syntax":"| fit-content | -moz-fit-content | -webkit-fit-content"},"min-width":{"comment":"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width","syntax":"auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"},"overflow":{"comment":"extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow","syntax":"| <-non-standard-overflow>"},"pause":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'pause-before\'> <\'pause-after\'>?"},"pause-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"pause-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"rest":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'rest-before\'> <\'rest-after\'>?"},"rest-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"rest-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"shape-rendering":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"],"syntax":"auto | optimizeSpeed | crispEdges | geometricPrecision"},"src":{"comment":"added @font-face\'s src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src","syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"},"speak":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"auto | none | normal"},"speak-as":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"},"stroke":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<paint>"},"stroke-dasharray":{"comment":"added SVG property; a list of comma and/or white space separated <length>s and <percentage>s","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"none | [ <svg-length>+ ]#"},"stroke-dashoffset":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<svg-length>"},"stroke-linecap":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"butt | round | square"},"stroke-linejoin":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"miter | round | bevel"},"stroke-miterlimit":{"comment":"added SVG property (<miterlimit> = <number-one-or-greater>) ","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<number-one-or-greater>"},"stroke-opacity":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<number-zero-one>"},"stroke-width":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<svg-length>"},"text-anchor":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"],"syntax":"start | middle | end"},"unicode-bidi":{"comment":"added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi","syntax":"| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"},"unicode-range":{"comment":"added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range","syntax":"<urange>#"},"voice-balance":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<number> | left | center | right | leftwards | rightwards"},"voice-duration":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"auto | <time>"},"voice-family":{"comment":"<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index","syntax":"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"},"voice-pitch":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"},"voice-range":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"},"voice-rate":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"},"voice-stress":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"normal | strong | moderate | none | reduced"},"voice-volume":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"},"writing-mode":{"comment":"extend with SVG keywords","syntax":"| <svg-writing-mode>"}},"syntaxes":{"-legacy-gradient":{"comment":"added collection of legacy gradient syntaxes","syntax":"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"},"-legacy-linear-gradient":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"},"-legacy-repeating-linear-gradient":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"},"-legacy-linear-gradient-arguments":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"[ <angle> | <side-or-corner> ]? , <color-stop-list>"},"-legacy-radial-gradient":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"},"-legacy-repeating-radial-gradient":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"},"-legacy-radial-gradient-arguments":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"},"-legacy-radial-gradient-size":{"comment":"before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize","syntax":"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"},"-legacy-radial-gradient-shape":{"comment":"define to double sure it doesn\'t extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape","syntax":"circle | ellipse"},"-non-standard-font":{"comment":"non standard fonts","references":["https://webkit.org/blog/3709/using-the-system-font-in-web-content/"],"syntax":"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"},"-non-standard-color":{"comment":"non standard colors","references":["http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html","https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"],"syntax":"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"},"-non-standard-image-rendering":{"comment":"non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html","syntax":"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"},"-non-standard-overflow":{"comment":"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow","syntax":"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"},"-non-standard-width":{"comment":"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width","syntax":"fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"},"-webkit-gradient()":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )","syntax":"-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"},"-webkit-gradient-color-stop":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"},"-webkit-gradient-point":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"},"-webkit-gradient-radius":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"<length> | <percentage>"},"-webkit-gradient-type":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"linear | radial"},"-webkit-mask-box-repeat":{"comment":"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image","syntax":"repeat | stretch | round"},"-webkit-mask-clip-style":{"comment":"missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working","syntax":"border | border-box | padding | padding-box | content | content-box | text"},"-ms-filter-function-list":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<-ms-filter-function>+"},"-ms-filter-function":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<-ms-filter-function-progid> | <-ms-filter-function-legacy>"},"-ms-filter-function-progid":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"\'progid:\' [ <ident-token> \'.\' ]* [ <ident-token> | <function-token> <any-value>? ) ]"},"-ms-filter-function-legacy":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<ident-token> | <function-token> <any-value>? )"},"-ms-filter":{"syntax":"<string>"},"age":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"child | young | old"},"attr-name":{"syntax":"<wq-name>"},"attr-fallback":{"syntax":"<any-value>"},"border-radius":{"comment":"missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius","syntax":"<length-percentage>{1,2}"},"bottom":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"content-list":{"comment":"missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)","syntax":"[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <\'list-style-type\'>? ) ]+"},"element()":{"comment":"https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation","syntax":"element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"},"generic-voice":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"[ <age>? <gender> <integer>? ]"},"gender":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"male | female | neutral"},"generic-family":{"comment":"added -apple-system","references":["https://webkit.org/blog/3709/using-the-system-font-in-web-content/"],"syntax":"| -apple-system"},"gradient":{"comment":"added legacy syntaxes support","syntax":"| <-legacy-gradient>"},"left":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"mask-image":{"comment":"missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image","syntax":"<mask-reference>#"},"name-repeat":{"comment":"missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat","syntax":"repeat( [ <positive-integer> | auto-fill ], <line-names>+)"},"named-color":{"comment":"added non standard color names","syntax":"| <-non-standard-color>"},"paint":{"comment":"used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint","syntax":"none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"},"page-size":{"comment":"https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size","syntax":"A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"},"ratio":{"comment":"missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio","syntax":"<integer> / <integer>"},"right":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"shape":{"comment":"missed spaces in function body and add backwards compatible syntax","syntax":"rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"},"svg-length":{"comment":"All coordinates and lengths in SVG can be specified with or without a unit identifier","references":["https://www.w3.org/TR/SVG11/coords.html#Units"],"syntax":"<percentage> | <length> | <number>"},"svg-writing-mode":{"comment":"SVG specific keywords (deprecated for CSS)","references":["https://developer.mozilla.org/en/docs/Web/CSS/writing-mode","https://www.w3.org/TR/SVG/text.html#WritingModeProperty"],"syntax":"lr-tb | rl-tb | tb-rl | lr | rl | tb"},"top":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"track-group":{"comment":"used by old grid-columns and grid-rows syntax v0","syntax":"\'(\' [ <string>* <track-minmax> <string>* ]+ \')\' [ \'[\' <positive-integer> \']\' ]? | <track-minmax>"},"track-list-v0":{"comment":"used by old grid-columns and grid-rows syntax v0","syntax":"[ <string>* <track-group> <string>* ]+ | none"},"track-minmax":{"comment":"used by old grid-columns and grid-rows syntax v0","syntax":"minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"},"x":{"comment":"missed; not sure we should add it, but no others except `cursor` is using it so it\'s ok for now; https://drafts.csswg.org/css-ui-3/#cursor","syntax":"<number>"},"y":{"comment":"missed; not sure we should add it, but no others except `cursor` is using so it\'s ok for now; https://drafts.csswg.org/css-ui-3/#cursor","syntax":"<number>"},"declaration":{"comment":"missed, restored by https://drafts.csswg.org/css-syntax","syntax":"<ident-token> : <declaration-value>? [ \'!\' important ]?"},"declaration-list":{"comment":"missed, restored by https://drafts.csswg.org/css-syntax","syntax":"[ <declaration>? \';\' ]* <declaration>?"},"url":{"comment":"https://drafts.csswg.org/css-values-4/#urls","syntax":"url( <string> <url-modifier>* ) | <url-token>"},"url-modifier":{"comment":"https://drafts.csswg.org/css-values-4/#typedef-url-modifier","syntax":"<ident> | <function-token> <any-value> )"},"number-zero-one":{"syntax":"<number [0,1]>"},"number-one-or-greater":{"syntax":"<number [1,∞]>"},"positive-integer":{"syntax":"<integer [0,∞]>"},"-non-standard-display":{"syntax":"-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"}}}',
      );
    },
    710: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}',
      );
    },
    8844: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}',
      );
    },
    3380: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}',
      );
    },
    3024: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}',
      );
    },
    378: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"@charset":{"syntax":"@charset \\"<charset>\\";","groups":["CSS Charsets"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@charset"},"@counter-style":{"syntax":"@counter-style <counter-style-name> {\\n  [ system: <counter-system>; ] ||\\n  [ symbols: <counter-symbols>; ] ||\\n  [ additive-symbols: <additive-symbols>; ] ||\\n  [ negative: <negative-symbol>; ] ||\\n  [ prefix: <prefix>; ] ||\\n  [ suffix: <suffix>; ] ||\\n  [ range: <range>; ] ||\\n  [ pad: <padding>; ] ||\\n  [ speak-as: <speak-as>; ] ||\\n  [ fallback: <counter-style-name>; ]\\n}","interfaces":["CSSCounterStyleRule"],"groups":["CSS Counter Styles"],"descriptors":{"additive-symbols":{"syntax":"[ <integer> && <symbol> ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"fallback":{"syntax":"<counter-style-name>","media":"all","initial":"decimal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"negative":{"syntax":"<symbol> <symbol>?","media":"all","initial":"\\"-\\" hyphen-minus","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"pad":{"syntax":"<integer> && <symbol>","media":"all","initial":"0 \\"\\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"prefix":{"syntax":"<symbol>","media":"all","initial":"\\"\\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"range":{"syntax":"[ [ <integer> | infinite ]{2} ]# | auto","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"speak-as":{"syntax":"auto | bullets | numbers | words | spell-out | <counter-style-name>","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"suffix":{"syntax":"<symbol>","media":"all","initial":"\\". \\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"symbols":{"syntax":"<symbol>+","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"system":{"syntax":"cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]","media":"all","initial":"symbolic","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@counter-style"},"@document":{"syntax":"@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule"],"groups":["CSS Conditional Rules"],"status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@document"},"@font-face":{"syntax":"@font-face {\\n  [ font-family: <family-name>; ] ||\\n  [ src: <src>; ] ||\\n  [ unicode-range: <unicode-range>; ] ||\\n  [ font-variant: <font-variant>; ] ||\\n  [ font-feature-settings: <font-feature-settings>; ] ||\\n  [ font-variation-settings: <font-variation-settings>; ] ||\\n  [ font-stretch: <font-stretch>; ] ||\\n  [ font-weight: <font-weight>; ] ||\\n  [ font-style: <font-style>; ]\\n}","interfaces":["CSSFontFaceRule"],"groups":["CSS Fonts"],"descriptors":{"font-display":{"syntax":"[ auto | block | swap | fallback | optional ]","media":"visual","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"font-family":{"syntax":"<family-name>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-stretch":{"syntax":"<font-stretch-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-style":{"syntax":"normal | italic | oblique <angle>{0,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-weight":{"syntax":"<font-weight-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"src":{"syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"unicode-range":{"syntax":"<unicode-range>#","media":"all","initial":"U+0-10FFFF","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-face"},"@font-feature-values":{"syntax":"@font-feature-values <family-name># {\\n  <feature-value-block-list>\\n}","interfaces":["CSSFontFeatureValuesRule"],"groups":["CSS Fonts"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"},"@import":{"syntax":"@import [ <string> | <url> ] [ <media-query-list> ]?;","groups":["Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@import"},"@keyframes":{"syntax":"@keyframes <keyframes-name> {\\n  <keyframe-block-list>\\n}","interfaces":["CSSKeyframeRule","CSSKeyframesRule"],"groups":["CSS Animations"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@keyframes"},"@media":{"syntax":"@media <media-query-list> {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSMediaRule","CSSCustomMediaRule"],"groups":["CSS Conditional Rules","Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@media"},"@namespace":{"syntax":"@namespace <namespace-prefix>? [ <string> | <url> ];","groups":["CSS Namespaces"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@namespace"},"@page":{"syntax":"@page <page-selector-list> {\\n  <page-body>\\n}","interfaces":["CSSPageRule"],"groups":["CSS Pages"],"descriptors":{"bleed":{"syntax":"auto | <length>","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"marks":{"syntax":"none | [ crop || cross ]","media":["visual","paged"],"initial":"none","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"size":{"syntax":"<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@page"},"@property":{"syntax":"@property <custom-property-name> {\\n  <declaration-list>\\n}","interfaces":["CSS","CSSPropertyRule"],"groups":["CSS Houdini"],"descriptors":{"syntax":{"syntax":"<string>","media":"all","percentages":"no","initial":"n/a (required)","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"inherits":{"syntax":"true | false","media":"all","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"initial-value":{"syntax":"<string>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"experimental"}},"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@property"},"@supports":{"syntax":"@supports <supports-condition> {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSSupportsRule"],"groups":["CSS Conditional Rules"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@supports"},"@viewport":{"syntax":"@viewport {\\n  <group-rule-body>\\n}","interfaces":["CSSViewportRule"],"groups":["CSS Device Adaptation"],"descriptors":{"height":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-height","max-height"],"percentages":["min-height","max-height"],"computed":["min-height","max-height"],"order":"orderOfAppearance","status":"standard"},"max-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"min-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"orientation":{"syntax":"auto | portrait | landscape","media":["visual","continuous"],"initial":"auto","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"user-zoom":{"syntax":"zoom | fixed","media":["visual","continuous"],"initial":"zoom","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"viewport-fit":{"syntax":"auto | contain | cover","media":["visual","continuous"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"width":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-width","max-width"],"percentages":["min-width","max-width"],"computed":["min-width","max-width"],"order":"orderOfAppearance","status":"standard"},"zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@viewport"}}',
      );
    },
    7279: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"--*":{"syntax":"<declaration-value>","media":"all","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Variables"],"initial":"seeProse","appliesto":"allElements","computed":"asSpecifiedWithVarsSubstituted","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/--*"},"-ms-accelerator":{"syntax":"false | true","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"false","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"},"-ms-block-progression":{"syntax":"tb | rl | bt | lr","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"tb","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"},"-ms-content-zoom-chaining":{"syntax":"none | chained","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"},"-ms-content-zooming":{"syntax":"none | zoom","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"zoomForTheTopLevelNoneForTheRest","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"},"-ms-content-zoom-limit":{"syntax":"<\'-ms-content-zoom-limit-min\'> <\'-ms-content-zoom-limit-max\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"},"-ms-content-zoom-limit-max":{"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"maxZoomFactor","groups":["Microsoft Extensions"],"initial":"400%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"},"-ms-content-zoom-limit-min":{"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"minZoomFactor","groups":["Microsoft Extensions"],"initial":"100%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"},"-ms-content-zoom-snap":{"syntax":"<\'-ms-content-zoom-snap-type\'> || <\'-ms-content-zoom-snap-points\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"},"-ms-content-zoom-snap-points":{"syntax":"snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0%, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"},"-ms-content-zoom-snap-type":{"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"},"-ms-filter":{"syntax":"<string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"\\"\\"","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-filter"},"-ms-flow-from":{"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"},"-ms-flow-into":{"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"iframeElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"},"-ms-grid-columns":{"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"},"-ms-grid-rows":{"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"},"-ms-high-contrast-adjust":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"},"-ms-hyphenate-limit-chars":{"syntax":"auto | <integer>{1,3}","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"},"-ms-hyphenate-limit-lines":{"syntax":"no-limit | <integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"no-limit","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"},"-ms-hyphenate-limit-zone":{"syntax":"<percentage> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToLineBoxWidth","groups":["Microsoft Extensions"],"initial":"0","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"},"-ms-ime-align":{"syntax":"auto | after","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"},"-ms-overflow-style":{"syntax":"auto | none | scrollbar | -ms-autohiding-scrollbar","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"},"-ms-scrollbar-3dlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"},"-ms-scrollbar-arrow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ButtonText","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"},"-ms-scrollbar-base-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"},"-ms-scrollbar-darkshadow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"},"-ms-scrollbar-face-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDFace","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"},"-ms-scrollbar-highlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDHighlight","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"},"-ms-scrollbar-shadow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"},"-ms-scrollbar-track-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"Scrollbar","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"},"-ms-scroll-chaining":{"syntax":"chained | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"chained","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"},"-ms-scroll-limit":{"syntax":"<\'-ms-scroll-limit-x-min\'> <\'-ms-scroll-limit-y-min\'> <\'-ms-scroll-limit-x-max\'> <\'-ms-scroll-limit-y-max\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"},"-ms-scroll-limit-x-max":{"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"},"-ms-scroll-limit-x-min":{"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"},"-ms-scroll-limit-y-max":{"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"},"-ms-scroll-limit-y-min":{"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"},"-ms-scroll-rails":{"syntax":"none | railed","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"railed","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"},"-ms-scroll-snap-points-x":{"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"},"-ms-scroll-snap-points-y":{"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"},"-ms-scroll-snap-type":{"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"},"-ms-scroll-snap-x":{"syntax":"<\'-ms-scroll-snap-type\'> <\'-ms-scroll-snap-points-x\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"},"-ms-scroll-snap-y":{"syntax":"<\'-ms-scroll-snap-type\'> <\'-ms-scroll-snap-points-y\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"},"-ms-scroll-translation":{"syntax":"none | vertical-to-horizontal","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"},"-ms-text-autospace":{"syntax":"none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"},"-ms-touch-select":{"syntax":"grippers | none","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"grippers","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"},"-ms-user-select":{"syntax":"none | element | text","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"text","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"},"-ms-wrap-flow":{"syntax":"auto | both | start | end | maximum | clear","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"},"-ms-wrap-margin":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"exclusionElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"},"-ms-wrap-through":{"syntax":"wrap | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"wrap","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"},"-moz-appearance":{"syntax":"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"-moz-binding":{"syntax":"<url> | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsExceptGeneratedContentOrPseudoElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-binding"},"-moz-border-bottom-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"},"-moz-border-left-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"},"-moz-border-right-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"},"-moz-border-top-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"},"-moz-context-properties":{"syntax":"none | [ fill | fill-opacity | stroke | stroke-opacity ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsThatCanReferenceImages","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"},"-moz-float-edge":{"syntax":"border-box | content-box | margin-box | padding-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"content-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"},"-moz-force-broken-image-icon":{"syntax":"<integer [0,1]>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"0","appliesto":"images","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"},"-moz-image-region":{"syntax":"<shape> | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"xulImageElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"},"-moz-orient":{"syntax":"inline | block | horizontal | vertical","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"inline","appliesto":"anyElementEffectOnProgressAndMeter","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-orient"},"-moz-outline-radius":{"syntax":"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?","media":"visual","inherited":false,"animationType":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"percentages":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"groups":["Mozilla Extensions"],"initial":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"appliesto":"allElements","computed":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"},"-moz-outline-radius-bottomleft":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"},"-moz-outline-radius-bottomright":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"},"-moz-outline-radius-topleft":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"},"-moz-outline-radius-topright":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"},"-moz-stack-sizing":{"syntax":"ignore | stretch-to-fit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"stretch-to-fit","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"},"-moz-text-blink":{"syntax":"none | blink","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"},"-moz-user-focus":{"syntax":"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"},"-moz-user-input":{"syntax":"auto | none | enabled | disabled","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"},"-moz-user-modify":{"syntax":"read-only | read-write | write-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"},"-moz-window-dragging":{"syntax":"drag | no-drag","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"drag","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"},"-moz-window-shadow":{"syntax":"default | menu | tooltip | sheet | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"default","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"},"-webkit-appearance":{"syntax":"none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"-webkit-border-before":{"syntax":"<\'border-width\'> || <\'border-style\'> || <\'color\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":["-webkit-border-before-width"],"groups":["WebKit Extensions"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","color"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"},"-webkit-border-before-color":{"syntax":"<\'color\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard"},"-webkit-border-before-style":{"syntax":"<\'border-style\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},"-webkit-border-before-width":{"syntax":"<\'border-width\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["WebKit Extensions"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"nonstandard"},"-webkit-box-reflect":{"syntax":"[ above | below | right | left ]? <length>? <image>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"},"-webkit-line-clamp":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["WebKit Extensions","CSS Overflow"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"},"-webkit-mask":{"syntax":"[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"appliesto":"allElements","computed":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},"-webkit-mask-attachment":{"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"},"-webkit-mask-clip":{"syntax":"[ <box> | border | padding | content | text ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"border","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},"-webkit-mask-composite":{"syntax":"<composite-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"source-over","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"},"-webkit-mask-image":{"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"absoluteURIOrNone","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},"-webkit-mask-origin":{"syntax":"[ <box> | border | padding | content ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"padding","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},"-webkit-mask-position":{"syntax":"<position>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0% 0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},"-webkit-mask-position-x":{"syntax":"[ <length-percentage> | left | center | right ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"},"-webkit-mask-position-y":{"syntax":"[ <length-percentage> | top | center | bottom ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"},"-webkit-mask-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},"-webkit-mask-repeat-x":{"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"},"-webkit-mask-repeat-y":{"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"},"-webkit-mask-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToBackgroundPositioningArea","groups":["WebKit Extensions"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},"-webkit-overflow-scrolling":{"syntax":"auto | touch","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"},"-webkit-tap-highlight-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"black","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"},"-webkit-text-fill-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"},"-webkit-text-stroke":{"syntax":"<length> || <color>","media":"visual","inherited":true,"animationType":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"appliesto":"allElements","computed":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"order":"canonicalOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"},"-webkit-text-stroke-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"},"-webkit-text-stroke-width":{"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"0","appliesto":"allElements","computed":"absoluteLength","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"},"-webkit-touch-callout":{"syntax":"default | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"default","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"},"-webkit-user-modify":{"syntax":"read-only | read-write | read-write-plaintext-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},"align-content":{"syntax":"normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-content"},"align-items":{"syntax":"normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-items"},"align-self":{"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"flexItemsGridItemsAndAbsolutelyPositionedBoxes","computed":"autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-self"},"align-tracks":{"syntax":"[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirBlockAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-tracks"},"all":{"syntax":"initial | inherit | unset | revert","media":"noPracticalMedia","inherited":false,"animationType":"eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection","percentages":"no","groups":["CSS Miscellaneous"],"initial":"noPracticalInitialValue","appliesto":"allElements","computed":"asSpecifiedAppliesToEachProperty","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/all"},"animation":{"syntax":"<single-animation>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-iteration-count","animation-direction","animation-fill-mode","animation-play-state"],"appliesto":"allElementsAndPseudos","computed":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-direction","animation-iteration-count","animation-fill-mode","animation-play-state"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation"},"animation-delay":{"syntax":"<time>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-delay"},"animation-direction":{"syntax":"<single-animation-direction>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"normal","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-direction"},"animation-duration":{"syntax":"<time>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-duration"},"animation-fill-mode":{"syntax":"<single-animation-fill-mode>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"},"animation-iteration-count":{"syntax":"<single-animation-iteration-count>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"1","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"},"animation-name":{"syntax":"[ none | <keyframes-name> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-name"},"animation-play-state":{"syntax":"<single-animation-play-state>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"running","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-play-state"},"animation-timing-function":{"syntax":"<timing-function>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"},"appearance":{"syntax":"none | auto | textfield | menulist-button | <compat-auto>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"aspect-ratio":{"syntax":"auto | <ratio>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"},"azimuth":{"syntax":"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards","media":"aural","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Speech"],"initial":"center","appliesto":"allElements","computed":"normalizedAngle","order":"orderOfAppearance","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/azimuth"},"backdrop-filter":{"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"},"backface-visibility":{"syntax":"visible | hidden","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"visible","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backface-visibility"},"background":{"syntax":"[ <bg-layer> , ]* <final-bg-layer>","media":"visual","inherited":false,"animationType":["background-color","background-image","background-clip","background-position","background-size","background-repeat","background-attachment"],"percentages":["background-position","background-size"],"groups":["CSS Backgrounds and Borders"],"initial":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"appliesto":"allElements","computed":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background"},"background-attachment":{"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-attachment"},"background-blend-mode":{"syntax":"<blend-mode>#","media":"none","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"},"background-clip":{"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"border-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-clip"},"background-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"transparent","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-color"},"background-image":{"syntax":"<bg-image>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-image"},"background-origin":{"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-origin"},"background-position":{"syntax":"<bg-position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize","groups":["CSS Backgrounds and Borders"],"initial":"0% 0%","appliesto":"allElements","computed":"listEachItemTwoKeywordsOriginOffsets","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position"},"background-position-x":{"syntax":"[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"left","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-x"},"background-position-y":{"syntax":"[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"top","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-y"},"background-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"repeat","appliesto":"allElements","computed":"listEachItemHasTwoKeywordsOnePerDimension","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-repeat"},"background-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"relativeToBackgroundPositioningArea","groups":["CSS Backgrounds and Borders"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-size"},"block-overflow":{"syntax":"clip | ellipsis | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"clip","appliesto":"blockContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"block-size":{"syntax":"<\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/block-size"},"border":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-color","border-style","border-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-width","border-style","border-color"],"appliesto":"allElements","computed":["border-width","border-style","border-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border"},"border-block":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <\'color\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block"},"border-block-color":{"syntax":"<\'border-top-color\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-color"},"border-block-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-style"},"border-block-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-width"},"border-block-end":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <\'color\'>","media":"visual","inherited":false,"animationType":["border-block-end-color","border-block-end-style","border-block-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end"},"border-block-end-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"},"border-block-end-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"},"border-block-end-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"},"border-block-start":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <\'color\'>","media":"visual","inherited":false,"animationType":["border-block-start-color","border-block-start-style","border-block-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-block-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start"},"border-block-start-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"},"border-block-start-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"},"border-block-start-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"},"border-bottom":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-bottom-color","border-bottom-style","border-bottom-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-bottom-width","border-bottom-style","border-bottom-color"],"appliesto":"allElements","computed":["border-bottom-width","border-bottom-style","border-bottom-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom"},"border-bottom-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"},"border-bottom-left-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"},"border-bottom-right-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"},"border-bottom-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"},"border-bottom-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderBottomStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"},"border-collapse":{"syntax":"collapse | separate","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"separate","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-collapse"},"border-color":{"syntax":"<color>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-color","border-right-color","border-bottom-color","border-left-color"],"appliesto":"allElements","computed":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-color"},"border-end-end-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"},"border-end-start-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"},"border-image":{"syntax":"<\'border-image-source\'> || <\'border-image-slice\'> [ / <\'border-image-width\'> | / <\'border-image-width\'>? / <\'border-image-outset\'> ]? || <\'border-image-repeat\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["border-image-slice","border-image-width"],"groups":["CSS Backgrounds and Borders"],"initial":["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],"appliesto":"allElementsExceptTableElementsWhenCollapse","computed":["border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image"},"border-image-outset":{"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-outset"},"border-image-repeat":{"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"stretch","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"},"border-image-slice":{"syntax":"<number-percentage>{1,4} && fill?","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToSizeOfBorderImage","groups":["CSS Backgrounds and Borders"],"initial":"100%","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"oneToFourPercentagesOrAbsoluteLengthsPlusFill","order":"percentagesOrLengthsFollowedByFill","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-slice"},"border-image-source":{"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"noneOrImageWithAbsoluteURI","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-source"},"border-image-width":{"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToWidthOrHeightOfBorderImageArea","groups":["CSS Backgrounds and Borders"],"initial":"1","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-width"},"border-inline":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <\'color\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline"},"border-inline-end":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <\'color\'>","media":"visual","inherited":false,"animationType":["border-inline-end-color","border-inline-end-style","border-inline-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-end-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end"},"border-inline-color":{"syntax":"<\'border-top-color\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-color"},"border-inline-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-style"},"border-inline-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-width"},"border-inline-end-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"},"border-inline-end-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"},"border-inline-end-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"},"border-inline-start":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <\'color\'>","media":"visual","inherited":false,"animationType":["border-inline-start-color","border-inline-start-style","border-inline-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start"},"border-inline-start-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"},"border-inline-start-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"},"border-inline-start-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"},"border-left":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-left-color","border-left-style","border-left-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-left-width","border-left-style","border-left-color"],"appliesto":"allElements","computed":["border-left-width","border-left-style","border-left-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left"},"border-left-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-color"},"border-left-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-style"},"border-left-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderLeftStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-width"},"border-radius":{"syntax":"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?","media":"visual","inherited":false,"animationType":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-radius"},"border-right":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-right-color","border-right-style","border-right-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-right-width","border-right-style","border-right-color"],"appliesto":"allElements","computed":["border-right-width","border-right-style","border-right-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right"},"border-right-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-color"},"border-right-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-style"},"border-right-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderRightStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-width"},"border-spacing":{"syntax":"<length> <length>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"0","appliesto":"tableElements","computed":"twoAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-spacing"},"border-start-end-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"},"border-start-start-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"},"border-style":{"syntax":"<line-style>{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-style","border-right-style","border-bottom-style","border-left-style"],"appliesto":"allElements","computed":["border-bottom-style","border-left-style","border-right-style","border-top-style"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-style"},"border-top":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-top-color","border-top-style","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top"},"border-top-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-color"},"border-top-left-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"},"border-top-right-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"},"border-top-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-style"},"border-top-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderTopStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-width"},"border-width":{"syntax":"<line-width>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-right-width","border-bottom-width","border-left-width"],"appliesto":"allElements","computed":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-width"},"bottom":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/bottom"},"box-align":{"syntax":"start | center | end | baseline | stretch","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"stretch","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-align"},"box-decoration-break":{"syntax":"slice | clone","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"slice","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"},"box-direction":{"syntax":"normal | reverse | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"normal","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-direction"},"box-flex":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"0","appliesto":"directChildrenOfElementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex"},"box-flex-group":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"inFlowChildrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex-group"},"box-lines":{"syntax":"single | multiple","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"single","appliesto":"boxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-lines"},"box-ordinal-group":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"childrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"},"box-orient":{"syntax":"horizontal | vertical | inline-axis | block-axis | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"inlineAxisHorizontalInXUL","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-orient"},"box-pack":{"syntax":"start | center | end | justify","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"start","appliesto":"elementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-pack"},"box-shadow":{"syntax":"none | <shadow>#","media":"visual","inherited":false,"animationType":"shadowList","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"absoluteLengthsSpecifiedColorAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-shadow"},"box-sizing":{"syntax":"content-box | border-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"content-box","appliesto":"allElementsAcceptingWidthOrHeight","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-sizing"},"break-after":{"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-after"},"break-before":{"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-before"},"break-inside":{"syntax":"auto | avoid | avoid-page | avoid-column | avoid-region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-inside"},"caption-side":{"syntax":"top | bottom | block-start | block-end | inline-start | inline-end","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"top","appliesto":"tableCaptionElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caption-side"},"caret-color":{"syntax":"auto | <color>","media":"interactive","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asAutoOrColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caret-color"},"clear":{"syntax":"none | left | right | both | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clear"},"clip":{"syntax":"<shape> | auto","media":"visual","inherited":false,"animationType":"rectangle","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"absolutelyPositionedElements","computed":"autoOrRectangle","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip"},"clip-path":{"syntax":"<clip-source> | [ <basic-shape> || <geometry-box> ] | none","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"referToReferenceBoxWhenSpecifiedOtherwiseBorderBox","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip-path"},"color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Color"],"initial":"variesFromBrowserToBrowser","appliesto":"allElements","computed":"translucentValuesRGBAOtherwiseRGB","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color"},"color-adjust":{"syntax":"economy | exact","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Color"],"initial":"economy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color-adjust"},"column-count":{"syntax":"<integer> | auto","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-count"},"column-fill":{"syntax":"auto | balance | balance-all","media":"visualInContinuousMediaNoEffectInOverflowColumns","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"balance","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-fill"},"column-gap":{"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},"column-rule":{"syntax":"<\'column-rule-width\'> || <\'column-rule-style\'> || <\'column-rule-color\'>","media":"visual","inherited":false,"animationType":["column-rule-color","column-rule-style","column-rule-width"],"percentages":"no","groups":["CSS Columns"],"initial":["column-rule-width","column-rule-style","column-rule-color"],"appliesto":"multicolElements","computed":["column-rule-color","column-rule-style","column-rule-width"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule"},"column-rule-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Columns"],"initial":"currentcolor","appliesto":"multicolElements","computed":"computedColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-color"},"column-rule-style":{"syntax":"<\'border-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-style"},"column-rule-width":{"syntax":"<\'border-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"medium","appliesto":"multicolElements","computed":"absoluteLength0IfColumnRuleStyleNoneOrHidden","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-width"},"column-span":{"syntax":"none | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"inFlowBlockLevelElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-span"},"column-width":{"syntax":"<length> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"absoluteLengthZeroOrLarger","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-width"},"columns":{"syntax":"<\'column-width\'> || <\'column-count\'>","media":"visual","inherited":false,"animationType":["column-width","column-count"],"percentages":"no","groups":["CSS Columns"],"initial":["column-width","column-count"],"appliesto":"blockContainersExceptTableWrappers","computed":["column-width","column-count"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/columns"},"contain":{"syntax":"none | strict | content | [ size || layout || style || paint ]","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain"},"content":{"syntax":"normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"normal","appliesto":"beforeAndAfterPseudos","computed":"normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/content"},"counter-increment":{"syntax":"[ <custom-ident> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-increment"},"counter-reset":{"syntax":"[ <custom-ident> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-reset"},"counter-set":{"syntax":"[ <custom-ident> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-set"},"cursor":{"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]","media":["visual","interactive"],"inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/cursor"},"direction":{"syntax":"ltr | rtl","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"ltr","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/direction"},"display":{"syntax":"[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Display"],"initial":"inline","appliesto":"allElements","computed":"asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/display"},"empty-cells":{"syntax":"show | hide","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"show","appliesto":"tableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/empty-cells"},"filter":{"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/filter"},"flex":{"syntax":"none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]","media":"visual","inherited":false,"animationType":["flex-grow","flex-shrink","flex-basis"],"percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-grow","flex-shrink","flex-basis"],"appliesto":"flexItemsAndInFlowPseudos","computed":["flex-grow","flex-shrink","flex-basis"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex"},"flex-basis":{"syntax":"content | <\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToFlexContainersInnerMainSize","groups":["CSS Flexible Box Layout"],"initial":"auto","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-basis"},"flex-direction":{"syntax":"row | row-reverse | column | column-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"row","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-direction"},"flex-flow":{"syntax":"<\'flex-direction\'> || <\'flex-wrap\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-direction","flex-wrap"],"appliesto":"flexContainers","computed":["flex-direction","flex-wrap"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-flow"},"flex-grow":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-grow"},"flex-shrink":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"1","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-shrink"},"flex-wrap":{"syntax":"nowrap | wrap | wrap-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"nowrap","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-wrap"},"float":{"syntax":"left | right | none | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"allElementsNoEffectIfDisplayNone","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/float"},"font":{"syntax":"[ [ <\'font-style\'> || <font-variant-css21> || <\'font-weight\'> || <\'font-stretch\'> ]? <\'font-size\'> [ / <\'line-height\'> ]? <\'font-family\'> ] | caption | icon | menu | message-box | small-caption | status-bar","media":"visual","inherited":true,"animationType":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"percentages":["font-size","line-height"],"groups":["CSS Fonts"],"initial":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"appliesto":"allElements","computed":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font"},"font-family":{"syntax":"[ <family-name> | <generic-family> ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-family"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"},"font-kerning":{"syntax":"auto | normal | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-kerning"},"font-language-override":{"syntax":"normal | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-language-override"},"font-optical-sizing":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"visual","inherited":true,"animationType":"transform","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"},"font-size":{"syntax":"<absolute-size> | <relative-size> | <length-percentage>","media":"visual","inherited":true,"animationType":"length","percentages":"referToParentElementsFontSize","groups":["CSS Fonts"],"initial":"medium","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size"},"font-size-adjust":{"syntax":"none | <number>","media":"visual","inherited":true,"animationType":"number","percentages":"no","groups":["CSS Fonts"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"},"font-smooth":{"syntax":"auto | never | always | <absolute-size> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-smooth"},"font-stretch":{"syntax":"<font-stretch-absolute>","media":"visual","inherited":true,"animationType":"fontStretch","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-stretch"},"font-style":{"syntax":"normal | italic | oblique <angle>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-style"},"font-synthesis":{"syntax":"none | [ weight || style ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"weight style","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-synthesis"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant"},"font-variant-alternates":{"syntax":"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"},"font-variant-caps":{"syntax":"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"},"font-variant-east-asian":{"syntax":"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"},"font-variant-ligatures":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"},"font-variant-numeric":{"syntax":"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"},"font-variant-position":{"syntax":"normal | sub | super","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-position"},"font-weight":{"syntax":"<font-weight-absolute> | bolder | lighter","media":"visual","inherited":true,"animationType":"fontWeight","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"keywordOrNumericalValueBolderLighterTransformedToRealValue","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-weight"},"gap":{"syntax":"<\'row-gap\'> <\'column-gap\'>?","media":"visual","inherited":false,"animationType":["row-gap","column-gap"],"percentages":"no","groups":["CSS Box Alignment"],"initial":["row-gap","column-gap"],"appliesto":"multiColumnElementsFlexContainersGridContainers","computed":["row-gap","column-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},"grid":{"syntax":"<\'grid-template\'> | <\'grid-template-rows\'> / [ auto-flow && dense? ] <\'grid-auto-columns\'>? | [ auto-flow && dense? ] <\'grid-auto-rows\'>? / <\'grid-template-columns\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-rows","grid-template-columns","grid-auto-rows","grid-auto-columns"],"groups":["CSS Grid Layout"],"initial":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"appliesto":"gridContainers","computed":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid"},"grid-area":{"syntax":"<grid-line> [ / <grid-line> ]{0,3}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-area"},"grid-auto-columns":{"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"},"grid-auto-flow":{"syntax":"[ row | column ] || dense","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"row","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"},"grid-auto-rows":{"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"},"grid-column":{"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-column-start","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-column-start","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column"},"grid-column-end":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-end"},"grid-column-gap":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},"grid-column-start":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-start"},"grid-gap":{"syntax":"<\'grid-row-gap\'> <\'grid-column-gap\'>?","media":"visual","inherited":false,"animationType":["grid-row-gap","grid-column-gap"],"percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-gap","grid-column-gap"],"appliesto":"gridContainers","computed":["grid-row-gap","grid-column-gap"],"order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},"grid-row":{"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-row-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-row-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row"},"grid-row-end":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-end"},"grid-row-gap":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},"grid-row-start":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-start"},"grid-template":{"syntax":"none | [ <\'grid-template-rows\'> / <\'grid-template-columns\'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-columns","grid-template-rows"],"groups":["CSS Grid Layout"],"initial":["grid-template-columns","grid-template-rows","grid-template-areas"],"appliesto":"gridContainers","computed":["grid-template-columns","grid-template-rows","grid-template-areas"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template"},"grid-template-areas":{"syntax":"none | <string>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"},"grid-template-columns":{"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"},"grid-template-rows":{"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"},"hanging-punctuation":{"syntax":"none | [ first || [ force-end | allow-end ] || last ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"},"height":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAutoOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/height"},"hyphens":{"syntax":"none | manual | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"manual","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hyphens"},"image-orientation":{"syntax":"from-image | <angle> | [ <angle>? flip ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"from-image","appliesto":"allElements","computed":"angleRoundedToNextQuarter","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-orientation"},"image-rendering":{"syntax":"auto | crisp-edges | pixelated","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-rendering"},"image-resolution":{"syntax":"[ from-image || <resolution> ] && snap?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"1dppx","appliesto":"allElements","computed":"asSpecifiedWithExceptionOfResolution","order":"uniqueOrder","status":"experimental"},"ime-mode":{"syntax":"auto | normal | active | inactive | disabled","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"textFields","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ime-mode"},"initial-letter":{"syntax":"normal | [ <number> <integer>? ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"normal","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter"},"initial-letter-align":{"syntax":"[ auto | alphabetic | hanging | ideographic ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"auto","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"},"inline-size":{"syntax":"<\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inline-size"},"inset":{"syntax":"<\'top\'>{1,4}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset"},"inset-block":{"syntax":"<\'top\'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block"},"inset-block-end":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-end"},"inset-block-start":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-start"},"inset-inline":{"syntax":"<\'top\'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline"},"inset-inline-end":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"},"inset-inline-start":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"},"isolation":{"syntax":"auto | isolate","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"auto","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/isolation"},"justify-content":{"syntax":"normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-content"},"justify-items":{"syntax":"normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"legacy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-items"},"justify-self":{"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-self"},"justify-tracks":{"syntax":"[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirInlineAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-tracks"},"left":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/left"},"letter-spacing":{"syntax":"normal | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumValueOfAbsoluteLengthOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/letter-spacing"},"line-break":{"syntax":"auto | loose | normal | strict | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-break"},"line-clamp":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"line-height":{"syntax":"normal | <number> | <length> | <percentage>","media":"visual","inherited":true,"animationType":"numberOrLength","percentages":"referToElementFontSize","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"absoluteLengthOrAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height"},"line-height-step":{"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"0","appliesto":"blockContainers","computed":"absoluteLength","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height-step"},"list-style":{"syntax":"<\'list-style-type\'> || <\'list-style-position\'> || <\'list-style-image\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":["list-style-type","list-style-position","list-style-image"],"appliesto":"listItems","computed":["list-style-image","list-style-position","list-style-type"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style"},"list-style-image":{"syntax":"<url> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"none","appliesto":"listItems","computed":"noneOrImageWithAbsoluteURI","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-image"},"list-style-position":{"syntax":"inside | outside","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"outside","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-position"},"list-style-type":{"syntax":"<counter-style> | <string> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"disc","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-type"},"margin":{"syntax":"[ <length> | <percentage> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["margin-bottom","margin-left","margin-right","margin-top"],"appliesto":"allElementsExceptTableDisplayTypes","computed":["margin-bottom","margin-left","margin-right","margin-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin"},"margin-block":{"syntax":"<\'margin-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block"},"margin-block-end":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-end"},"margin-block-start":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-start"},"margin-bottom":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-bottom"},"margin-inline":{"syntax":"<\'margin-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline"},"margin-inline-end":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"},"margin-inline-start":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"},"margin-left":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-left"},"margin-right":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-right"},"margin-top":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-top"},"margin-trim":{"syntax":"none | in-flow | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"none","appliesto":"blockContainersAndMultiColumnContainers","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line"],"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-trim"},"mask":{"syntax":"<mask-layer>#","media":"visual","inherited":false,"animationType":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"percentages":["mask-position"],"groups":["CSS Masking"],"initial":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"appliesto":"allElementsSVGContainerElements","computed":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},"mask-border":{"syntax":"<\'mask-border-source\'> || <\'mask-border-slice\'> [ / <\'mask-border-width\'>? [ / <\'mask-border-outset\'> ]? ]? || <\'mask-border-repeat\'> || <\'mask-border-mode\'>","media":"visual","inherited":false,"animationType":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"percentages":["mask-border-slice","mask-border-width"],"groups":["CSS Masking"],"initial":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"appliesto":"allElementsSVGContainerElements","computed":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border"},"mask-border-mode":{"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"alpha","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"},"mask-border-outset":{"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"},"mask-border-repeat":{"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"stretch","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"},"mask-border-slice":{"syntax":"<number-percentage>{1,4} fill?","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfMaskBorderImage","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"},"mask-border-source":{"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-source"},"mask-border-width":{"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToMaskBorderImageArea","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-width"},"mask-clip":{"syntax":"[ <geometry-box> | no-clip ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},"mask-composite":{"syntax":"<compositing-operator>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"add","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-composite"},"mask-image":{"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},"mask-mode":{"syntax":"<masking-mode>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"match-source","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-mode"},"mask-origin":{"syntax":"<geometry-box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},"mask-position":{"syntax":"<position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfMaskPaintingArea","groups":["CSS Masking"],"initial":"center","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoKeywordsForOriginAndOffsets","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},"mask-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"no-repeat","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoDimensionKeywords","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},"mask-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},"mask-type":{"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"luminance","appliesto":"maskElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-type"},"masonry-auto-flow":{"syntax":"[ pack | next ] || [ definite-first | ordered ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"pack","appliesto":"gridContainersWithMasonryLayout","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"},"math-style":{"syntax":"normal | compact","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["MathML"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/math-style"},"max-block-size":{"syntax":"<\'max-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-block-size"},"max-height":{"syntax":"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesNone","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-height"},"max-inline-size":{"syntax":"<\'max-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-inline-size"},"max-lines":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"max-width":{"syntax":"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-width"},"min-block-size":{"syntax":"<\'min-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-block-size"},"min-height":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentages0","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-height"},"min-inline-size":{"syntax":"<\'min-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-inline-size"},"min-width":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-width"},"mix-blend-mode":{"syntax":"<blend-mode>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"},"object-fit":{"syntax":"fill | contain | cover | none | scale-down","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"fill","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-fit"},"object-position":{"syntax":"<position>","media":"visual","inherited":true,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToWidthAndHeightOfElement","groups":["CSS Images"],"initial":"50% 50%","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-position"},"offset":{"syntax":"[ <\'offset-position\'>? [ <\'offset-path\'> [ <\'offset-distance\'> || <\'offset-rotate\'> ]? ]? ]! [ / <\'offset-anchor\'> ]?","media":"visual","inherited":false,"animationType":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"percentages":["offset-position","offset-distance","offset-anchor"],"groups":["CSS Motion Path"],"initial":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"appliesto":"transformableElements","computed":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset"},"offset-anchor":{"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"relativeToWidthAndHeight","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard"},"offset-distance":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToTotalPathLength","groups":["CSS Motion Path"],"initial":"0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-distance"},"offset-path":{"syntax":"none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-path"},"offset-position":{"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"referToSizeOfContainingBlock","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"experimental"},"offset-rotate":{"syntax":"[ auto | reverse ] || <angle>","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-rotate"},"opacity":{"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Color"],"initial":"1.0","appliesto":"allElements","computed":"specifiedValueClipped0To1","order":"uniqueOrder","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/opacity"},"order":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsGridItemsAbsolutelyPositionedContainerChildren","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/order"},"orphans":{"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/orphans"},"outline":{"syntax":"[ <\'outline-color\'> || <\'outline-style\'> || <\'outline-width\'> ]","media":["visual","interactive"],"inherited":false,"animationType":["outline-color","outline-width","outline-style"],"percentages":"no","groups":["CSS Basic User Interface"],"initial":["outline-color","outline-style","outline-width"],"appliesto":"allElements","computed":["outline-color","outline-width","outline-style"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline"},"outline-color":{"syntax":"<color> | invert","media":["visual","interactive"],"inherited":false,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"invertOrCurrentColor","appliesto":"allElements","computed":"invertForTranslucentColorRGBAOtherwiseRGB","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-color"},"outline-offset":{"syntax":"<length>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"0","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-offset"},"outline-style":{"syntax":"auto | <\'border-style\'>","media":["visual","interactive"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-style"},"outline-width":{"syntax":"<line-width>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"medium","appliesto":"allElements","computed":"absoluteLength0ForNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-width"},"overflow":{"syntax":"[ visible | hidden | clip | scroll | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":["overflow-x","overflow-y"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow"},"overflow-anchor":{"syntax":"auto | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Anchoring"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard"},"overflow-block":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},"overflow-clip-box":{"syntax":"padding-box | content-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"},"overflow-inline":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},"overflow-wrap":{"syntax":"normal | break-word | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},"overflow-x":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-x"},"overflow-y":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-y"},"overscroll-behavior":{"syntax":"[ contain | none | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"},"overscroll-behavior-block":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"},"overscroll-behavior-inline":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"},"overscroll-behavior-x":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"},"overscroll-behavior-y":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"},"padding":{"syntax":"[ <length> | <percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["padding-bottom","padding-left","padding-right","padding-top"],"appliesto":"allElementsExceptInternalTableDisplayTypes","computed":["padding-bottom","padding-left","padding-right","padding-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding"},"padding-block":{"syntax":"<\'padding-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block"},"padding-block-end":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-end"},"padding-block-start":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-start"},"padding-bottom":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-bottom"},"padding-inline":{"syntax":"<\'padding-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline"},"padding-inline-end":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"},"padding-inline-start":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"},"padding-left":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-left"},"padding-right":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-right"},"padding-top":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-top"},"page-break-after":{"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-after"},"page-break-before":{"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-before"},"page-break-inside":{"syntax":"auto | avoid","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-inside"},"paint-order":{"syntax":"normal | [ fill || stroke || markers ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/paint-order"},"perspective":{"syntax":"none | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"absoluteLengthOrNone","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective"},"perspective-origin":{"syntax":"<position>","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50%","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective-origin"},"place-content":{"syntax":"<\'align-content\'> <\'justify-content\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-content"},"place-items":{"syntax":"<\'align-items\'> <\'justify-items\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-items","justify-items"],"appliesto":"allElements","computed":["align-items","justify-items"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-items"},"place-self":{"syntax":"<\'align-self\'> <\'justify-self\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-self","justify-self"],"appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":["align-self","justify-self"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-self"},"pointer-events":{"syntax":"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Pointer Events"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/pointer-events"},"position":{"syntax":"static | relative | absolute | sticky | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"static","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/position"},"quotes":{"syntax":"none | auto | [ <string> <string> ]+","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/quotes"},"resize":{"syntax":"none | both | horizontal | vertical | block | inline","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"elementsWithOverflowNotVisibleAndReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/resize"},"right":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/right"},"rotate":{"syntax":"none | <angle> | [ x | y | z | <number>{3} ] && <angle>","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/rotate"},"row-gap":{"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},"ruby-align":{"syntax":"start | center | space-between | space-around","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"space-around","appliesto":"rubyBasesAnnotationsBaseAnnotationContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-align"},"ruby-merge":{"syntax":"separate | collapse | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"separate","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"ruby-position":{"syntax":"over | under | inter-character","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"over","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-position"},"scale":{"syntax":"none | <number>{1,3}","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scale"},"scrollbar-color":{"syntax":"auto | dark | light | <color>{2}","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"},"scrollbar-gutter":{"syntax":"auto | [ stable | always ] && both? && force?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"},"scrollbar-width":{"syntax":"auto | thin | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"},"scroll-behavior":{"syntax":"auto | smooth","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSSOM View"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"},"scroll-margin":{"syntax":"<length>{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin"},"scroll-margin-block":{"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"},"scroll-margin-block-start":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"},"scroll-margin-block-end":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"},"scroll-margin-bottom":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"},"scroll-margin-inline":{"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"},"scroll-margin-inline-start":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"},"scroll-margin-inline-end":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"},"scroll-margin-left":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"},"scroll-margin-right":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"},"scroll-margin-top":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"},"scroll-padding":{"syntax":"[ auto | <length-percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding"},"scroll-padding-block":{"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"},"scroll-padding-block-start":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"},"scroll-padding-block-end":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"},"scroll-padding-bottom":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"},"scroll-padding-inline":{"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"},"scroll-padding-inline-start":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"},"scroll-padding-inline-end":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"},"scroll-padding-left":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"},"scroll-padding-right":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"},"scroll-padding-top":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"},"scroll-snap-align":{"syntax":"[ none | start | end | center ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"},"scroll-snap-coordinate":{"syntax":"none | <position>#","media":"interactive","inherited":false,"animationType":"position","percentages":"referToBorderBox","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"},"scroll-snap-destination":{"syntax":"<position>","media":"interactive","inherited":false,"animationType":"position","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"0px 0px","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"},"scroll-snap-points-x":{"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"},"scroll-snap-points-y":{"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"},"scroll-snap-stop":{"syntax":"normal | always","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"},"scroll-snap-type":{"syntax":"none | [ x | y | block | inline | both ] [ mandatory | proximity ]?","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"},"scroll-snap-type-x":{"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"},"scroll-snap-type-y":{"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"},"shape-image-threshold":{"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Shapes"],"initial":"0.0","appliesto":"floats","computed":"specifiedValueNumberClipped0To1","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"},"shape-margin":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Shapes"],"initial":"0","appliesto":"floats","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-margin"},"shape-outside":{"syntax":"none | <shape-box> || <basic-shape> | <image>","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"no","groups":["CSS Shapes"],"initial":"none","appliesto":"floats","computed":"asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-outside"},"tab-size":{"syntax":"<integer> | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"8","appliesto":"blockContainers","computed":"specifiedIntegerOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/tab-size"},"table-layout":{"syntax":"auto | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"auto","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/table-layout"},"text-align":{"syntax":"start | end | left | right | center | justify | match-parent","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"startOrNamelessValueIfLTRRightIfRTL","appliesto":"blockContainers","computed":"asSpecifiedExceptMatchParent","order":"orderOfAppearance","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align"},"text-align-last":{"syntax":"auto | start | end | left | right | center | justify","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"blockContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align-last"},"text-combine-upright":{"syntax":"none | all | [ digits <integer>? ]","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["CSS Writing Modes"],"initial":"none","appliesto":"nonReplacedInlineElements","computed":"keywordPlusIntegerIfDigits","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"},"text-decoration":{"syntax":"<\'text-decoration-line\'> || <\'text-decoration-style\'> || <\'text-decoration-color\'> || <\'text-decoration-thickness\'>","media":"visual","inherited":false,"animationType":["text-decoration-color","text-decoration-style","text-decoration-line","text-decoration-thickness"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-decoration-color","text-decoration-style","text-decoration-line"],"appliesto":"allElements","computed":["text-decoration-line","text-decoration-style","text-decoration-color","text-decoration-thickness"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration"},"text-decoration-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"},"text-decoration-line":{"syntax":"none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"},"text-decoration-skip":{"syntax":"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"objects","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"},"text-decoration-skip-ink":{"syntax":"auto | all | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"},"text-decoration-style":{"syntax":"solid | double | dotted | dashed | wavy","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"solid","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"},"text-decoration-thickness":{"syntax":"auto | from-font | <length> | <percentage> ","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"},"text-emphasis":{"syntax":"<\'text-emphasis-style\'> || <\'text-emphasis-color\'>","media":"visual","inherited":false,"animationType":["text-emphasis-color","text-emphasis-style"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-emphasis-style","text-emphasis-color"],"appliesto":"allElements","computed":["text-emphasis-style","text-emphasis-color"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis"},"text-emphasis-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"},"text-emphasis-position":{"syntax":"[ over | under ] && [ right | left ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"over right","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"},"text-emphasis-style":{"syntax":"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"},"text-indent":{"syntax":"<length-percentage> && hanging? && each-line?","media":"visual","inherited":true,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Text"],"initial":"0","appliesto":"blockContainers","computed":"percentageOrAbsoluteLengthPlusKeywords","order":"lengthOrPercentageBeforeKeywords","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-indent"},"text-justify":{"syntax":"auto | inter-character | inter-word | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"inlineLevelAndTableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-justify"},"text-orientation":{"syntax":"mixed | upright | sideways","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"mixed","appliesto":"allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-orientation"},"text-overflow":{"syntax":"[ clip | ellipsis | <string> ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"clip","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-overflow"},"text-rendering":{"syntax":"auto | optimizeSpeed | optimizeLegibility | geometricPrecision","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Miscellaneous"],"initial":"auto","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-rendering"},"text-shadow":{"syntax":"none | <shadow-t>#","media":"visual","inherited":true,"animationType":"shadowList","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"colorPlusThreeAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-shadow"},"text-size-adjust":{"syntax":"none | auto | <percentage>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToSizeOfFont","groups":["CSS Text"],"initial":"autoForSmartphoneBrowsersSupportingInflation","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"},"text-transform":{"syntax":"none | capitalize | uppercase | lowercase | full-width | full-size-kana","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-transform"},"text-underline-offset":{"syntax":"auto | <length> | <percentage> ","media":"visual","inherited":true,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"},"text-underline-position":{"syntax":"auto | from-font | [ under || [ left | right ] ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-position"},"top":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/top"},"touch-action":{"syntax":"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Pointer Events"],"initial":"auto","appliesto":"allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/touch-action"},"transform":{"syntax":"none | <transform-list>","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform"},"transform-box":{"syntax":"content-box | border-box | fill-box | stroke-box | view-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"view-box","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-box"},"transform-origin":{"syntax":"[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50% 0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-origin"},"transform-style":{"syntax":"flat | preserve-3d","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"flat","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-style"},"transition":{"syntax":"<single-transition>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":["transition-delay","transition-duration","transition-property","transition-timing-function"],"appliesto":"allElementsAndPseudos","computed":["transition-delay","transition-duration","transition-property","transition-timing-function"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition"},"transition-delay":{"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-delay"},"transition-duration":{"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-duration"},"transition-property":{"syntax":"none | <single-transition-property>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"all","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-property"},"transition-timing-function":{"syntax":"<timing-function>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"},"translate":{"syntax":"none | <length-percentage> [ <length-percentage> <length>? ]?","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/translate"},"unicode-bidi":{"syntax":"normal | embed | isolate | bidi-override | isolate-override | plaintext","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"normal","appliesto":"allElementsSomeValuesNoEffectOnNonInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"},"user-select":{"syntax":"auto | text | none | contain | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/user-select"},"vertical-align":{"syntax":"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"referToLineHeight","groups":["CSS Table"],"initial":"baseline","appliesto":"inlineLevelAndTableCellElements","computed":"absoluteLengthOrKeyword","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/vertical-align"},"visibility":{"syntax":"visible | hidden | collapse","media":"visual","inherited":true,"animationType":"visibility","percentages":"no","groups":["CSS Box Model"],"initial":"visible","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/visibility"},"white-space":{"syntax":"normal | pre | nowrap | pre-wrap | pre-line | break-spaces","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/white-space"},"widows":{"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/widows"},"width":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAutoOrAbsoluteLength","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/width"},"will-change":{"syntax":"auto | <animateable-feature>#","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Will Change"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/will-change"},"word-break":{"syntax":"normal | break-all | keep-all | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-break"},"word-spacing":{"syntax":"normal | <length-percentage>","media":"visual","inherited":true,"animationType":"length","percentages":"referToWidthOfAffectedGlyph","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-spacing"},"word-wrap":{"syntax":"normal | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},"writing-mode":{"syntax":"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"horizontal-tb","appliesto":"allElementsExceptTableRowColumnGroupsTableRowsColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/writing-mode"},"z-index":{"syntax":"auto | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/z-index"},"zoom":{"syntax":"normal | reset | <number> | <percentage>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["Microsoft Extensions"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/zoom"}}',
      );
    },
    4448: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"absolute-size":{"syntax":"xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"},"alpha-value":{"syntax":"<number> | <percentage>"},"angle-percentage":{"syntax":"<angle> | <percentage>"},"angular-color-hint":{"syntax":"<angle-percentage>"},"angular-color-stop":{"syntax":"<color> && <color-stop-angle>?"},"angular-color-stop-list":{"syntax":"[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"},"animateable-feature":{"syntax":"scroll-position | contents | <custom-ident>"},"attachment":{"syntax":"scroll | fixed | local"},"attr()":{"syntax":"attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"},"attr-matcher":{"syntax":"[ \'~\' | \'|\' | \'^\' | \'$\' | \'*\' ]? \'=\'"},"attr-modifier":{"syntax":"i | s"},"attribute-selector":{"syntax":"\'[\' <wq-name> \']\' | \'[\' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? \']\'"},"auto-repeat":{"syntax":"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},"auto-track-list":{"syntax":"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"},"baseline-position":{"syntax":"[ first | last ]? baseline"},"basic-shape":{"syntax":"<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"},"bg-image":{"syntax":"none | <image>"},"bg-layer":{"syntax":"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},"bg-position":{"syntax":"[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"},"bg-size":{"syntax":"[ <length-percentage> | auto ]{1,2} | cover | contain"},"blur()":{"syntax":"blur( <length> )"},"blend-mode":{"syntax":"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"},"box":{"syntax":"border-box | padding-box | content-box"},"brightness()":{"syntax":"brightness( <number-percentage> )"},"calc()":{"syntax":"calc( <calc-sum> )"},"calc-sum":{"syntax":"<calc-product> [ [ \'+\' | \'-\' ] <calc-product> ]*"},"calc-product":{"syntax":"<calc-value> [ \'*\' <calc-value> | \'/\' <number> ]*"},"calc-value":{"syntax":"<number> | <dimension> | <percentage> | ( <calc-sum> )"},"cf-final-image":{"syntax":"<image> | <color>"},"cf-mixing-image":{"syntax":"<percentage>? && <image>"},"circle()":{"syntax":"circle( [ <shape-radius> ]? [ at <position> ]? )"},"clamp()":{"syntax":"clamp( <calc-sum>#{3} )"},"class-selector":{"syntax":"\'.\' <ident-token>"},"clip-source":{"syntax":"<url>"},"color":{"syntax":"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"},"color-stop":{"syntax":"<color-stop-length> | <color-stop-angle>"},"color-stop-angle":{"syntax":"<angle-percentage>{1,2}"},"color-stop-length":{"syntax":"<length-percentage>{1,2}"},"color-stop-list":{"syntax":"[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"},"combinator":{"syntax":"\'>\' | \'+\' | \'~\' | [ \'||\' ]"},"common-lig-values":{"syntax":"[ common-ligatures | no-common-ligatures ]"},"compat-auto":{"syntax":"searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"},"composite-style":{"syntax":"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"},"compositing-operator":{"syntax":"add | subtract | intersect | exclude"},"compound-selector":{"syntax":"[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"},"compound-selector-list":{"syntax":"<compound-selector>#"},"complex-selector":{"syntax":"<compound-selector> [ <combinator>? <compound-selector> ]*"},"complex-selector-list":{"syntax":"<complex-selector>#"},"conic-gradient()":{"syntax":"conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"},"contextual-alt-values":{"syntax":"[ contextual | no-contextual ]"},"content-distribution":{"syntax":"space-between | space-around | space-evenly | stretch"},"content-list":{"syntax":"[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"},"content-position":{"syntax":"center | start | end | flex-start | flex-end"},"content-replacement":{"syntax":"<image>"},"contrast()":{"syntax":"contrast( [ <number-percentage> ] )"},"counter()":{"syntax":"counter( <custom-ident>, <counter-style>? )"},"counter-style":{"syntax":"<counter-style-name> | symbols()"},"counter-style-name":{"syntax":"<custom-ident>"},"counters()":{"syntax":"counters( <custom-ident>, <string>, <counter-style>? )"},"cross-fade()":{"syntax":"cross-fade( <cf-mixing-image> , <cf-final-image>? )"},"cubic-bezier-timing-function":{"syntax":"ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"},"deprecated-system-color":{"syntax":"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"},"discretionary-lig-values":{"syntax":"[ discretionary-ligatures | no-discretionary-ligatures ]"},"display-box":{"syntax":"contents | none"},"display-inside":{"syntax":"flow | flow-root | table | flex | grid | ruby"},"display-internal":{"syntax":"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"},"display-legacy":{"syntax":"inline-block | inline-list-item | inline-table | inline-flex | inline-grid"},"display-listitem":{"syntax":"<display-outside>? && [ flow | flow-root ]? && list-item"},"display-outside":{"syntax":"block | inline | run-in"},"drop-shadow()":{"syntax":"drop-shadow( <length>{2,3} <color>? )"},"east-asian-variant-values":{"syntax":"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"},"east-asian-width-values":{"syntax":"[ full-width | proportional-width ]"},"element()":{"syntax":"element( <id-selector> )"},"ellipse()":{"syntax":"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"},"ending-shape":{"syntax":"circle | ellipse"},"env()":{"syntax":"env( <custom-ident> , <declaration-value>? )"},"explicit-track-list":{"syntax":"[ <line-names>? <track-size> ]+ <line-names>?"},"family-name":{"syntax":"<string> | <custom-ident>+"},"feature-tag-value":{"syntax":"<string> [ <integer> | on | off ]?"},"feature-type":{"syntax":"@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"},"feature-value-block":{"syntax":"<feature-type> \'{\' <feature-value-declaration-list> \'}\'"},"feature-value-block-list":{"syntax":"<feature-value-block>+"},"feature-value-declaration":{"syntax":"<custom-ident>: <integer>+;"},"feature-value-declaration-list":{"syntax":"<feature-value-declaration>"},"feature-value-name":{"syntax":"<custom-ident>"},"fill-rule":{"syntax":"nonzero | evenodd"},"filter-function":{"syntax":"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"},"filter-function-list":{"syntax":"[ <filter-function> | <url> ]+"},"final-bg-layer":{"syntax":"<\'background-color\'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},"fit-content()":{"syntax":"fit-content( [ <length> | <percentage> ] )"},"fixed-breadth":{"syntax":"<length-percentage>"},"fixed-repeat":{"syntax":"repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},"fixed-size":{"syntax":"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"},"font-stretch-absolute":{"syntax":"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"},"font-variant-css21":{"syntax":"[ normal | small-caps ]"},"font-weight-absolute":{"syntax":"normal | bold | <number [1,1000]>"},"frequency-percentage":{"syntax":"<frequency> | <percentage>"},"general-enclosed":{"syntax":"[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"},"generic-family":{"syntax":"serif | sans-serif | cursive | fantasy | monospace"},"generic-name":{"syntax":"serif | sans-serif | cursive | fantasy | monospace"},"geometry-box":{"syntax":"<shape-box> | fill-box | stroke-box | view-box"},"gradient":{"syntax":"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"},"grayscale()":{"syntax":"grayscale( <number-percentage> )"},"grid-line":{"syntax":"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"},"historical-lig-values":{"syntax":"[ historical-ligatures | no-historical-ligatures ]"},"hsl()":{"syntax":"hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"},"hsla()":{"syntax":"hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"},"hue":{"syntax":"<number> | <angle>"},"hue-rotate()":{"syntax":"hue-rotate( <angle> )"},"id-selector":{"syntax":"<hash-token>"},"image":{"syntax":"<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"},"image()":{"syntax":"image( <image-tags>? [ <image-src>? , <color>? ]! )"},"image-set()":{"syntax":"image-set( <image-set-option># )"},"image-set-option":{"syntax":"[ <image> | <string> ] <resolution>"},"image-src":{"syntax":"<url> | <string>"},"image-tags":{"syntax":"ltr | rtl"},"inflexible-breadth":{"syntax":"<length> | <percentage> | min-content | max-content | auto"},"inset()":{"syntax":"inset( <length-percentage>{1,4} [ round <\'border-radius\'> ]? )"},"invert()":{"syntax":"invert( <number-percentage> )"},"keyframes-name":{"syntax":"<custom-ident> | <string>"},"keyframe-block":{"syntax":"<keyframe-selector># {\\n  <declaration-list>\\n}"},"keyframe-block-list":{"syntax":"<keyframe-block>+"},"keyframe-selector":{"syntax":"from | to | <percentage>"},"leader()":{"syntax":"leader( <leader-type> )"},"leader-type":{"syntax":"dotted | solid | space | <string>"},"length-percentage":{"syntax":"<length> | <percentage>"},"line-names":{"syntax":"\'[\' <custom-ident>* \']\'"},"line-name-list":{"syntax":"[ <line-names> | <name-repeat> ]+"},"line-style":{"syntax":"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"},"line-width":{"syntax":"<length> | thin | medium | thick"},"linear-color-hint":{"syntax":"<length-percentage>"},"linear-color-stop":{"syntax":"<color> <color-stop-length>?"},"linear-gradient()":{"syntax":"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},"mask-layer":{"syntax":"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"},"mask-position":{"syntax":"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"},"mask-reference":{"syntax":"none | <image> | <mask-source>"},"mask-source":{"syntax":"<url>"},"masking-mode":{"syntax":"alpha | luminance | match-source"},"matrix()":{"syntax":"matrix( <number>#{6} )"},"matrix3d()":{"syntax":"matrix3d( <number>#{16} )"},"max()":{"syntax":"max( <calc-sum># )"},"media-and":{"syntax":"<media-in-parens> [ and <media-in-parens> ]+"},"media-condition":{"syntax":"<media-not> | <media-and> | <media-or> | <media-in-parens>"},"media-condition-without-or":{"syntax":"<media-not> | <media-and> | <media-in-parens>"},"media-feature":{"syntax":"( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"},"media-in-parens":{"syntax":"( <media-condition> ) | <media-feature> | <general-enclosed>"},"media-not":{"syntax":"not <media-in-parens>"},"media-or":{"syntax":"<media-in-parens> [ or <media-in-parens> ]+"},"media-query":{"syntax":"<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"},"media-query-list":{"syntax":"<media-query>#"},"media-type":{"syntax":"<ident>"},"mf-boolean":{"syntax":"<mf-name>"},"mf-name":{"syntax":"<ident>"},"mf-plain":{"syntax":"<mf-name> : <mf-value>"},"mf-range":{"syntax":"<mf-name> [ \'<\' | \'>\' ]? \'=\'? <mf-value>\\n| <mf-value> [ \'<\' | \'>\' ]? \'=\'? <mf-name>\\n| <mf-value> \'<\' \'=\'? <mf-name> \'<\' \'=\'? <mf-value>\\n| <mf-value> \'>\' \'=\'? <mf-name> \'>\' \'=\'? <mf-value>"},"mf-value":{"syntax":"<number> | <dimension> | <ident> | <ratio>"},"min()":{"syntax":"min( <calc-sum># )"},"minmax()":{"syntax":"minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"},"named-color":{"syntax":"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"},"namespace-prefix":{"syntax":"<ident>"},"ns-prefix":{"syntax":"[ <ident-token> | \'*\' ]? \'|\'"},"number-percentage":{"syntax":"<number> | <percentage>"},"numeric-figure-values":{"syntax":"[ lining-nums | oldstyle-nums ]"},"numeric-fraction-values":{"syntax":"[ diagonal-fractions | stacked-fractions ]"},"numeric-spacing-values":{"syntax":"[ proportional-nums | tabular-nums ]"},"nth":{"syntax":"<an-plus-b> | even | odd"},"opacity()":{"syntax":"opacity( [ <number-percentage> ] )"},"overflow-position":{"syntax":"unsafe | safe"},"outline-radius":{"syntax":"<length> | <percentage>"},"page-body":{"syntax":"<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"},"page-margin-box":{"syntax":"<page-margin-box-type> \'{\' <declaration-list> \'}\'"},"page-margin-box-type":{"syntax":"@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"},"page-selector-list":{"syntax":"[ <page-selector># ]?"},"page-selector":{"syntax":"<pseudo-page>+ | <ident> <pseudo-page>*"},"path()":{"syntax":"path( [ <fill-rule>, ]? <string> )"},"paint()":{"syntax":"paint( <ident>, <declaration-value>? )"},"perspective()":{"syntax":"perspective( <length> )"},"polygon()":{"syntax":"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"},"position":{"syntax":"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"},"pseudo-class-selector":{"syntax":"\':\' <ident-token> | \':\' <function-token> <any-value> \')\'"},"pseudo-element-selector":{"syntax":"\':\' <pseudo-class-selector>"},"pseudo-page":{"syntax":": [ left | right | first | blank ]"},"quote":{"syntax":"open-quote | close-quote | no-open-quote | no-close-quote"},"radial-gradient()":{"syntax":"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},"relative-selector":{"syntax":"<combinator>? <complex-selector>"},"relative-selector-list":{"syntax":"<relative-selector>#"},"relative-size":{"syntax":"larger | smaller"},"repeat-style":{"syntax":"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"},"repeating-linear-gradient()":{"syntax":"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},"repeating-radial-gradient()":{"syntax":"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},"rgb()":{"syntax":"rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"},"rgba()":{"syntax":"rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"},"rotate()":{"syntax":"rotate( [ <angle> | <zero> ] )"},"rotate3d()":{"syntax":"rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"},"rotateX()":{"syntax":"rotateX( [ <angle> | <zero> ] )"},"rotateY()":{"syntax":"rotateY( [ <angle> | <zero> ] )"},"rotateZ()":{"syntax":"rotateZ( [ <angle> | <zero> ] )"},"saturate()":{"syntax":"saturate( <number-percentage> )"},"scale()":{"syntax":"scale( <number> , <number>? )"},"scale3d()":{"syntax":"scale3d( <number> , <number> , <number> )"},"scaleX()":{"syntax":"scaleX( <number> )"},"scaleY()":{"syntax":"scaleY( <number> )"},"scaleZ()":{"syntax":"scaleZ( <number> )"},"self-position":{"syntax":"center | start | end | self-start | self-end | flex-start | flex-end"},"shape-radius":{"syntax":"<length-percentage> | closest-side | farthest-side"},"skew()":{"syntax":"skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"},"skewX()":{"syntax":"skewX( [ <angle> | <zero> ] )"},"skewY()":{"syntax":"skewY( [ <angle> | <zero> ] )"},"sepia()":{"syntax":"sepia( <number-percentage> )"},"shadow":{"syntax":"inset? && <length>{2,4} && <color>?"},"shadow-t":{"syntax":"[ <length>{2,3} && <color>? ]"},"shape":{"syntax":"rect(<top>, <right>, <bottom>, <left>)"},"shape-box":{"syntax":"<box> | margin-box"},"side-or-corner":{"syntax":"[ left | right ] || [ top | bottom ]"},"single-animation":{"syntax":"<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"},"single-animation-direction":{"syntax":"normal | reverse | alternate | alternate-reverse"},"single-animation-fill-mode":{"syntax":"none | forwards | backwards | both"},"single-animation-iteration-count":{"syntax":"infinite | <number>"},"single-animation-play-state":{"syntax":"running | paused"},"single-transition":{"syntax":"[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"},"single-transition-property":{"syntax":"all | <custom-ident>"},"size":{"syntax":"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"},"step-position":{"syntax":"jump-start | jump-end | jump-none | jump-both | start | end"},"step-timing-function":{"syntax":"step-start | step-end | steps(<integer>[, <step-position>]?)"},"subclass-selector":{"syntax":"<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"},"supports-condition":{"syntax":"not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"},"supports-in-parens":{"syntax":"( <supports-condition> ) | <supports-feature> | <general-enclosed>"},"supports-feature":{"syntax":"<supports-decl> | <supports-selector-fn>"},"supports-decl":{"syntax":"( <declaration> )"},"supports-selector-fn":{"syntax":"selector( <complex-selector> )"},"symbol":{"syntax":"<string> | <image> | <custom-ident>"},"target":{"syntax":"<target-counter()> | <target-counters()> | <target-text()>"},"target-counter()":{"syntax":"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"},"target-counters()":{"syntax":"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"},"target-text()":{"syntax":"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"},"time-percentage":{"syntax":"<time> | <percentage>"},"timing-function":{"syntax":"linear | <cubic-bezier-timing-function> | <step-timing-function>"},"track-breadth":{"syntax":"<length-percentage> | <flex> | min-content | max-content | auto"},"track-list":{"syntax":"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"},"track-repeat":{"syntax":"repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"},"track-size":{"syntax":"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"},"transform-function":{"syntax":"<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"},"transform-list":{"syntax":"<transform-function>+"},"translate()":{"syntax":"translate( <length-percentage> , <length-percentage>? )"},"translate3d()":{"syntax":"translate3d( <length-percentage> , <length-percentage> , <length> )"},"translateX()":{"syntax":"translateX( <length-percentage> )"},"translateY()":{"syntax":"translateY( <length-percentage> )"},"translateZ()":{"syntax":"translateZ( <length> )"},"type-or-unit":{"syntax":"string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"},"type-selector":{"syntax":"<wq-name> | <ns-prefix>? \'*\'"},"var()":{"syntax":"var( <custom-property-name> , <declaration-value>? )"},"viewport-length":{"syntax":"auto | <length-percentage>"},"wq-name":{"syntax":"<ns-prefix>? <ident-token>"}}',
      );
    },
  };
  var __webpack_module_cache__ = {};
  function __nccwpck_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (__webpack_module_cache__[moduleId] = { exports: {} });
    var threw = true;
    try {
      __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nccwpck_require__,
      );
      threw = false;
    } finally {
      if (threw) delete __webpack_module_cache__[moduleId];
    }
    return module.exports;
  }
  (() => {
    __nccwpck_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  var __webpack_exports__ = __nccwpck_require__(6198);
  module.exports = __webpack_exports__;
})();
