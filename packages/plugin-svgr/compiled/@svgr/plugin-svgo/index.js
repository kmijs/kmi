(() => {
  var __webpack_modules__ = {
    6945: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var svgo = __nccwpck_require__(7235);
      var cosmiconfig = __nccwpck_require__(2512);
      const explorer = cosmiconfig.cosmiconfigSync("svgo", {
        searchPlaces: [
          "package.json",
          ".svgorc",
          ".svgorc.js",
          ".svgorc.json",
          ".svgorc.yaml",
          ".svgorc.yml",
          "svgo.config.js",
          "svgo.config.cjs",
          ".svgo.yml",
        ],
        transform: (result) => result && result.config,
        cache: true,
      });
      const getSvgoConfigFromSvgrConfig = (config) => {
        const params = { overrides: {} };
        if (config.icon || config.dimensions === false) {
          params.overrides.removeViewBox = false;
        }
        if (config.native) {
          params.overrides.inlineStyles = { onlyMatchedOnce: false };
        }
        return { plugins: [{ name: "preset-default", params }, "prefixIds"] };
      };
      const getSvgoConfig = (config, state) => {
        const cwd = state.filePath || process.cwd();
        if (config.svgoConfig) return config.svgoConfig;
        if (config.runtimeConfig) {
          const userConfig = explorer.search(cwd);
          if (userConfig) return userConfig;
        }
        return getSvgoConfigFromSvgrConfig(config);
      };
      var __defProp = Object.defineProperty;
      var __defProps = Object.defineProperties;
      var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) =>
        key in obj
          ? __defProp(obj, key, {
              enumerable: true,
              configurable: true,
              writable: true,
              value,
            })
          : (obj[key] = value);
      var __spreadValues = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
          }
        return a;
      };
      var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
      const svgoPlugin = (code, config, state) => {
        if (!config.svgo) return code;
        const svgoConfig = getSvgoConfig(config, state);
        const result = svgo.optimize(
          code,
          __spreadProps(__spreadValues({}, svgoConfig), {
            path: state.filePath,
          }),
        );
        if (result.modernError) {
          throw result.modernError;
        }
        return result.data;
      };
      module.exports = svgoPlugin;
    },
    6049: (__unused_webpack_module, exports) => {
      (function (sax) {
        sax.parser = function (strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script",
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace",
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase =
            parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase
            ? "toLowerCase"
            : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities
            ? Object.create(sax.XML_ENTITIES)
            : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function (o) {
            function F() {}
            F.prototype = o;
            var newf = new F();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function (o) {
            var a = [];
            for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
            return a;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
              switch (buffers[i]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }
        function clearBuffers(parser) {
          for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function () {
            end(this);
          },
          write,
          resume: function () {
            this.error = null;
            return this;
          },
          close: function () {
            return this.write(null);
          },
          flush: function () {
            flushBuffers(this);
          },
        };
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        var nameStart =
          /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody =
          /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        var entityStart =
          /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody =
          /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "\t";
        }
        function isQuote(c) {
          return c === '"' || c === "'";
        }
        function isAttribEnd(c) {
          return c === ">" || isWhitespace(c);
        }
        function isMatch(regex, c) {
          return regex.test(c);
        }
        function notMatch(regex, c) {
          return !isMatch(regex, c);
        }
        var S = 0;
        sax.STATE = {
          BEGIN: S++,
          BEGIN_WHITESPACE: S++,
          TEXT: S++,
          TEXT_ENTITY: S++,
          OPEN_WAKA: S++,
          SGML_DECL: S++,
          SGML_DECL_QUOTED: S++,
          DOCTYPE: S++,
          DOCTYPE_QUOTED: S++,
          DOCTYPE_DTD: S++,
          DOCTYPE_DTD_QUOTED: S++,
          COMMENT_STARTING: S++,
          COMMENT: S++,
          COMMENT_ENDING: S++,
          COMMENT_ENDED: S++,
          CDATA: S++,
          CDATA_ENDING: S++,
          CDATA_ENDING_2: S++,
          PROC_INST: S++,
          PROC_INST_BODY: S++,
          PROC_INST_ENDING: S++,
          OPEN_TAG: S++,
          OPEN_TAG_SLASH: S++,
          ATTRIB: S++,
          ATTRIB_NAME: S++,
          ATTRIB_NAME_SAW_WHITE: S++,
          ATTRIB_VALUE: S++,
          ATTRIB_VALUE_QUOTED: S++,
          ATTRIB_VALUE_CLOSED: S++,
          ATTRIB_VALUE_UNQUOTED: S++,
          ATTRIB_VALUE_ENTITY_Q: S++,
          ATTRIB_VALUE_ENTITY_U: S++,
          CLOSE_TAG: S++,
          CLOSE_TAG_SAW_WHITE: S++,
          SCRIPT: S++,
          SCRIPT_ENDING: S++,
        };
        sax.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" };
        sax.ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'",
          AElig: 198,
          Aacute: 193,
          Acirc: 194,
          Agrave: 192,
          Aring: 197,
          Atilde: 195,
          Auml: 196,
          Ccedil: 199,
          ETH: 208,
          Eacute: 201,
          Ecirc: 202,
          Egrave: 200,
          Euml: 203,
          Iacute: 205,
          Icirc: 206,
          Igrave: 204,
          Iuml: 207,
          Ntilde: 209,
          Oacute: 211,
          Ocirc: 212,
          Ograve: 210,
          Oslash: 216,
          Otilde: 213,
          Ouml: 214,
          THORN: 222,
          Uacute: 218,
          Ucirc: 219,
          Ugrave: 217,
          Uuml: 220,
          Yacute: 221,
          aacute: 225,
          acirc: 226,
          aelig: 230,
          agrave: 224,
          aring: 229,
          atilde: 227,
          auml: 228,
          ccedil: 231,
          eacute: 233,
          ecirc: 234,
          egrave: 232,
          eth: 240,
          euml: 235,
          iacute: 237,
          icirc: 238,
          igrave: 236,
          iuml: 239,
          ntilde: 241,
          oacute: 243,
          ocirc: 244,
          ograve: 242,
          oslash: 248,
          otilde: 245,
          ouml: 246,
          szlig: 223,
          thorn: 254,
          uacute: 250,
          ucirc: 251,
          ugrave: 249,
          uuml: 252,
          yacute: 253,
          yuml: 255,
          copy: 169,
          reg: 174,
          nbsp: 160,
          iexcl: 161,
          cent: 162,
          pound: 163,
          curren: 164,
          yen: 165,
          brvbar: 166,
          sect: 167,
          uml: 168,
          ordf: 170,
          laquo: 171,
          not: 172,
          shy: 173,
          macr: 175,
          deg: 176,
          plusmn: 177,
          sup1: 185,
          sup2: 178,
          sup3: 179,
          acute: 180,
          micro: 181,
          para: 182,
          middot: 183,
          cedil: 184,
          ordm: 186,
          raquo: 187,
          frac14: 188,
          frac12: 189,
          frac34: 190,
          iquest: 191,
          times: 215,
          divide: 247,
          OElig: 338,
          oelig: 339,
          Scaron: 352,
          scaron: 353,
          Yuml: 376,
          fnof: 402,
          circ: 710,
          tilde: 732,
          Alpha: 913,
          Beta: 914,
          Gamma: 915,
          Delta: 916,
          Epsilon: 917,
          Zeta: 918,
          Eta: 919,
          Theta: 920,
          Iota: 921,
          Kappa: 922,
          Lambda: 923,
          Mu: 924,
          Nu: 925,
          Xi: 926,
          Omicron: 927,
          Pi: 928,
          Rho: 929,
          Sigma: 931,
          Tau: 932,
          Upsilon: 933,
          Phi: 934,
          Chi: 935,
          Psi: 936,
          Omega: 937,
          alpha: 945,
          beta: 946,
          gamma: 947,
          delta: 948,
          epsilon: 949,
          zeta: 950,
          eta: 951,
          theta: 952,
          iota: 953,
          kappa: 954,
          lambda: 955,
          mu: 956,
          nu: 957,
          xi: 958,
          omicron: 959,
          pi: 960,
          rho: 961,
          sigmaf: 962,
          sigma: 963,
          tau: 964,
          upsilon: 965,
          phi: 966,
          chi: 967,
          psi: 968,
          omega: 969,
          thetasym: 977,
          upsih: 978,
          piv: 982,
          ensp: 8194,
          emsp: 8195,
          thinsp: 8201,
          zwnj: 8204,
          zwj: 8205,
          lrm: 8206,
          rlm: 8207,
          ndash: 8211,
          mdash: 8212,
          lsquo: 8216,
          rsquo: 8217,
          sbquo: 8218,
          ldquo: 8220,
          rdquo: 8221,
          bdquo: 8222,
          dagger: 8224,
          Dagger: 8225,
          bull: 8226,
          hellip: 8230,
          permil: 8240,
          prime: 8242,
          Prime: 8243,
          lsaquo: 8249,
          rsaquo: 8250,
          oline: 8254,
          frasl: 8260,
          euro: 8364,
          image: 8465,
          weierp: 8472,
          real: 8476,
          trade: 8482,
          alefsym: 8501,
          larr: 8592,
          uarr: 8593,
          rarr: 8594,
          darr: 8595,
          harr: 8596,
          crarr: 8629,
          lArr: 8656,
          uArr: 8657,
          rArr: 8658,
          dArr: 8659,
          hArr: 8660,
          forall: 8704,
          part: 8706,
          exist: 8707,
          empty: 8709,
          nabla: 8711,
          isin: 8712,
          notin: 8713,
          ni: 8715,
          prod: 8719,
          sum: 8721,
          minus: 8722,
          lowast: 8727,
          radic: 8730,
          prop: 8733,
          infin: 8734,
          ang: 8736,
          and: 8743,
          or: 8744,
          cap: 8745,
          cup: 8746,
          int: 8747,
          there4: 8756,
          sim: 8764,
          cong: 8773,
          asymp: 8776,
          ne: 8800,
          equiv: 8801,
          le: 8804,
          ge: 8805,
          sub: 8834,
          sup: 8835,
          nsub: 8836,
          sube: 8838,
          supe: 8839,
          oplus: 8853,
          otimes: 8855,
          perp: 8869,
          sdot: 8901,
          lceil: 8968,
          rceil: 8969,
          lfloor: 8970,
          rfloor: 8971,
          lang: 9001,
          rang: 9002,
          loz: 9674,
          spades: 9824,
          clubs: 9827,
          hearts: 9829,
          diams: 9830,
        };
        Object.keys(sax.ENTITIES).forEach(function (key) {
          var e = sax.ENTITIES[key];
          var s = typeof e === "number" ? String.fromCharCode(e) : e;
          sax.ENTITIES[key] = s;
        });
        for (var s in sax.STATE) {
          sax.STATE[sax.STATE[s]] = s;
        }
        S = sax.STATE;
        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode) closeText(parser);
          emit(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode) emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text) {
          if (opt.trim) text = text.trim();
          if (opt.normalize) text = text.replace(/\s+/g, " ");
          return text;
        }
        function error(parser, reason) {
          closeText(parser);
          const message =
            reason +
            "\nLine: " +
            parser.line +
            "\nColumn: " +
            parser.column +
            "\nChar: " +
            parser.c;
          const error = new Error(message);
          error.reason = reason;
          error.line = parser.line;
          error.column = parser.column;
          parser.error = error;
          emit(parser, "onerror", error);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, "Unclosed root tag");
          if (
            parser.state !== S.BEGIN &&
            parser.state !== S.BEGIN_WHITESPACE &&
            parser.state !== S.TEXT
          ) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict)
            parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = (parser.tag = { name: parser.tagName, attributes: {} });
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }
        function qname(name, attribute) {
          var i = name.indexOf(":");
          var qualName = i < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (
            parser.attribList.indexOf(parser.attribName) !== -1 ||
            parser.tag.attributes.hasOwnProperty(parser.attribName)
          ) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(
                  parser,
                  "xml: prefix must be bound to " +
                    XML_NAMESPACE +
                    "\n" +
                    "Actual: " +
                    parser.attribValue,
                );
              } else if (
                local === "xmlns" &&
                parser.attribValue !== XMLNS_NAMESPACE
              ) {
                strictFail(
                  parser,
                  "xmlns: prefix must be bound to " +
                    XMLNS_NAMESPACE +
                    "\n" +
                    "Actual: " +
                    parser.attribValue,
                );
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue,
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(
                parser,
                "Unbound namespace prefix: " + JSON.stringify(parser.tagName),
              );
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function (p) {
                emitNode(parser, "onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p],
                });
              });
            }
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
              var nv = parser.attribList[i];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a = { name, value, prefix, local, uri };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(
                  parser,
                  "Unbound namespace prefix: " + JSON.stringify(prefix),
                );
                a.uri = prefix;
              }
              parser.tag.attributes[name] = a;
              emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S.SCRIPT;
            } else {
              parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s = parser.tags.length;
          while (s-- > t) {
            var tag = (parser.tag = parser.tags.pop());
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for (var i in tag.ns) {
              x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function (p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0) parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
          }
        }
        function charAt(chunk, i) {
          var result = "";
          if (i < chunk.length) {
            result = chunk.charAt(i);
          }
          return result;
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(
              parser,
              "Cannot write after close. Assign an onready handler.",
            );
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i = 0;
          var c = "";
          while (true) {
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === "\ufeff") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;
              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
              case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = charAt(chunk, i++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i - 1);
                }
                if (
                  c === "<" &&
                  !(parser.sawRoot && parser.closedRoot && !parser.strict)
                ) {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (
                    !isWhitespace(c) &&
                    (!parser.sawRoot || parser.closedRoot)
                  ) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;
              case S.SCRIPT:
                if (c === "<") {
                  parser.state = S.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;
              case S.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S.SCRIPT;
                }
                continue;
              case S.OPEN_WAKA:
                if (c === "!") {
                  parser.state = S.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c)) {
                } else if (isMatch(nameStart, c)) {
                  parser.state = S.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S.TEXT;
                }
                continue;
              case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if (parser.sgmlDecl + c === "--") {
                  parser.state = S.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(
                      parser,
                      "Inappropriately located doctype declaration",
                    );
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S.TEXT;
                } else if (isQuote(c)) {
                  parser.state = S.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;
              case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;
              case S.DOCTYPE:
                if (c === ">") {
                  parser.state = S.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S.DOCTYPE_DTD;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;
              case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S.DOCTYPE;
                }
                continue;
              case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === "]") {
                  parser.state = S.DOCTYPE;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                }
                continue;
              case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S.COMMENT:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;
              case S.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S.COMMENT;
                }
                continue;
              case S.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c;
                  parser.state = S.COMMENT;
                } else {
                  parser.state = S.TEXT;
                }
                continue;
              case S.CDATA:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;
              case S.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S.CDATA;
                }
                continue;
              case S.PROC_INST:
                if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else if (isWhitespace(c)) {
                  parser.state = S.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;
              case S.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;
              case S.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody,
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S.PROC_INST_BODY;
                }
                continue;
              case S.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(
                    parser,
                    "Forward-slash in opening tag not followed by >",
                  );
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.ATTRIB:
                if (isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c)) {
                  parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (isWhitespace(c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: "",
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S.ATTRIB;
                  }
                }
                continue;
              case S.ATTRIB_VALUE:
                if (isWhitespace(c)) {
                  continue;
                } else if (isQuote(c)) {
                  parser.q = c;
                  parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                  strictFail(parser, "Unquoted attribute value");
                  parser.state = S.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;
              case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;
              case S.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c)) {
                  parser.state = S.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S.ATTRIB;
                }
                continue;
              case S.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c)) {
                    continue;
                  } else if (notMatch(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = "textNode";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }
                if (c === ";") {
                  var parsedEntity = parseEntity(parser);
                  if (
                    parser.state === S.TEXT_ENTITY &&
                    !sax.ENTITIES[parser.entity] &&
                    parsedEntity !== "&" + parser.entity + ";"
                  ) {
                    chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
                  } else {
                    parser[buffer] += parsedEntity;
                  }
                  parser.entity = "";
                  parser.state = returnState;
                } else if (
                  isMatch(parser.entity.length ? entityBody : entityStart, c)
                ) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default:
                throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
      })(false ? 0 : exports);
    },
    2882: (module) => {
      module.exports = {
        trueFunc: function trueFunc() {
          return true;
        },
        falseFunc: function falseFunc() {
          return false;
        },
      };
    },
    2857: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.attributeRules = void 0;
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
      function escapeRegex(value) {
        return value.replace(reChars, "\\$&");
      }
      var caseInsensitiveAttributes = new Set([
        "accept",
        "accept-charset",
        "align",
        "alink",
        "axis",
        "bgcolor",
        "charset",
        "checked",
        "clear",
        "codetype",
        "color",
        "compact",
        "declare",
        "defer",
        "dir",
        "direction",
        "disabled",
        "enctype",
        "face",
        "frame",
        "hreflang",
        "http-equiv",
        "lang",
        "language",
        "link",
        "media",
        "method",
        "multiple",
        "nohref",
        "noresize",
        "noshade",
        "nowrap",
        "readonly",
        "rel",
        "rev",
        "rules",
        "scope",
        "scrolling",
        "selected",
        "shape",
        "target",
        "text",
        "type",
        "valign",
        "valuetype",
        "vlink",
      ]);
      function shouldIgnoreCase(selector, options) {
        return typeof selector.ignoreCase === "boolean"
          ? selector.ignoreCase
          : selector.ignoreCase === "quirks"
            ? !!options.quirksMode
            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
      }
      exports.attributeRules = {
        equals: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                attr.length === value.length &&
                attr.toLowerCase() === value &&
                next(elem)
              );
            };
          }
          return function (elem) {
            return (
              adapter.getAttributeValue(elem, name) === value && next(elem)
            );
          };
        },
        hyphen: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = value.length;
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len).toLowerCase() === value &&
                next(elem)
              );
            };
          }
          return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (
              attr != null &&
              (attr.length === len || attr.charAt(len) === "-") &&
              attr.substr(0, len) === value &&
              next(elem)
            );
          };
        },
        element: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name,
            value = data.value;
          if (/\s/.test(value)) {
            return boolbase_1.default.falseFunc;
          }
          var regex = new RegExp(
            "(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"),
            shouldIgnoreCase(data, options) ? "i" : "",
          );
          return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (
              attr != null &&
              attr.length >= value.length &&
              regex.test(attr) &&
              next(elem)
            );
          };
        },
        exists: function (next, _a, _b) {
          var name = _a.name;
          var adapter = _b.adapter;
          return function (elem) {
            return adapter.hasAttrib(elem, name) && next(elem);
          };
        },
        start: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = value.length;
          if (len === 0) {
            return boolbase_1.default.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                attr.length >= len &&
                attr.substr(0, len).toLowerCase() === value &&
                next(elem)
              );
            };
          }
          return function (elem) {
            var _a;
            return (
              !!((_a = adapter.getAttributeValue(elem, name)) === null ||
              _a === void 0
                ? void 0
                : _a.startsWith(value)) && next(elem)
            );
          };
        },
        end: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = -value.length;
          if (len === 0) {
            return boolbase_1.default.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var _a;
              return (
                ((_a = adapter.getAttributeValue(elem, name)) === null ||
                _a === void 0
                  ? void 0
                  : _a.substr(len).toLowerCase()) === value && next(elem)
              );
            };
          }
          return function (elem) {
            var _a;
            return (
              !!((_a = adapter.getAttributeValue(elem, name)) === null ||
              _a === void 0
                ? void 0
                : _a.endsWith(value)) && next(elem)
            );
          };
        },
        any: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name,
            value = data.value;
          if (value === "") {
            return boolbase_1.default.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                attr != null &&
                attr.length >= value.length &&
                regex_1.test(attr) &&
                next(elem)
              );
            };
          }
          return function (elem) {
            var _a;
            return (
              !!((_a = adapter.getAttributeValue(elem, name)) === null ||
              _a === void 0
                ? void 0
                : _a.includes(value)) && next(elem)
            );
          };
        },
        not: function (next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          if (value === "") {
            return function (elem) {
              return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
          } else if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function (elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                (attr == null ||
                  attr.length !== value.length ||
                  attr.toLowerCase() !== value) &&
                next(elem)
              );
            };
          }
          return function (elem) {
            return (
              adapter.getAttributeValue(elem, name) !== value && next(elem)
            );
          };
        },
      };
    },
    9364: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
      var css_what_1 = __nccwpck_require__(527);
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      var sort_js_1 = __importStar(__nccwpck_require__(9790));
      var general_js_1 = __nccwpck_require__(2467);
      var subselects_js_1 = __nccwpck_require__(4676);
      function compile(selector, options, context) {
        var next = compileUnsafe(selector, options, context);
        return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
      }
      exports.compile = compile;
      function compileUnsafe(selector, options, context) {
        var token =
          typeof selector === "string"
            ? (0, css_what_1.parse)(selector)
            : selector;
        return compileToken(token, options, context);
      }
      exports.compileUnsafe = compileUnsafe;
      function includesScopePseudo(t) {
        return (
          t.type === css_what_1.SelectorType.Pseudo &&
          (t.name === "scope" ||
            (Array.isArray(t.data) &&
              t.data.some(function (data) {
                return data.some(includesScopePseudo);
              })))
        );
      }
      var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
      var FLEXIBLE_DESCENDANT_TOKEN = { type: "_flexibleDescendant" };
      var SCOPE_TOKEN = {
        type: css_what_1.SelectorType.Pseudo,
        name: "scope",
        data: null,
      };
      function absolutize(token, _a, context) {
        var adapter = _a.adapter;
        var hasContext = !!(context === null || context === void 0
          ? void 0
          : context.every(function (e) {
              var parent = adapter.isTag(e) && adapter.getParent(e);
              return (
                e === subselects_js_1.PLACEHOLDER_ELEMENT ||
                (parent && adapter.isTag(parent))
              );
            }));
        for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
          var t = token_1[_i];
          if (
            t.length > 0 &&
            (0, sort_js_1.isTraversal)(t[0]) &&
            t[0].type !== css_what_1.SelectorType.Descendant
          ) {
          } else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
          } else {
            continue;
          }
          t.unshift(SCOPE_TOKEN);
        }
      }
      function compileToken(token, options, context) {
        var _a;
        token.forEach(sort_js_1.default);
        context =
          (_a = options.context) !== null && _a !== void 0 ? _a : context;
        var isArrayContext = Array.isArray(context);
        var finalContext =
          context && (Array.isArray(context) ? context : [context]);
        if (options.relativeSelector !== false) {
          absolutize(token, options, finalContext);
        } else if (
          token.some(function (t) {
            return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
          })
        ) {
          throw new Error(
            "Relative selectors are not allowed when the `relativeSelector` option is disabled",
          );
        }
        var shouldTestNextSiblings = false;
        var query = token
          .map(function (rules) {
            if (rules.length >= 2) {
              var first = rules[0],
                second = rules[1];
              if (
                first.type !== css_what_1.SelectorType.Pseudo ||
                first.name !== "scope"
              ) {
              } else if (
                isArrayContext &&
                second.type === css_what_1.SelectorType.Descendant
              ) {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
              } else if (
                second.type === css_what_1.SelectorType.Adjacent ||
                second.type === css_what_1.SelectorType.Sibling
              ) {
                shouldTestNextSiblings = true;
              }
            }
            return compileRules(rules, options, finalContext);
          })
          .reduce(reduceRules, boolbase_1.default.falseFunc);
        query.shouldTestNextSiblings = shouldTestNextSiblings;
        return query;
      }
      exports.compileToken = compileToken;
      function compileRules(rules, options, context) {
        var _a;
        return rules.reduce(
          function (previous, rule) {
            return previous === boolbase_1.default.falseFunc
              ? boolbase_1.default.falseFunc
              : (0, general_js_1.compileGeneralSelector)(
                  previous,
                  rule,
                  options,
                  context,
                  compileToken,
                );
          },
          (_a = options.rootFunc) !== null && _a !== void 0
            ? _a
            : boolbase_1.default.trueFunc,
        );
      }
      function reduceRules(a, b) {
        if (
          b === boolbase_1.default.falseFunc ||
          a === boolbase_1.default.trueFunc
        ) {
          return a;
        }
        if (
          a === boolbase_1.default.falseFunc ||
          b === boolbase_1.default.trueFunc
        ) {
          return b;
        }
        return function combine(elem) {
          return a(elem) || b(elem);
        };
      }
    },
    2467: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.compileGeneralSelector = void 0;
      var attributes_js_1 = __nccwpck_require__(2857);
      var index_js_1 = __nccwpck_require__(8183);
      var css_what_1 = __nccwpck_require__(527);
      function getElementParent(node, adapter) {
        var parent = adapter.getParent(node);
        if (parent && adapter.isTag(parent)) {
          return parent;
        }
        return null;
      }
      function compileGeneralSelector(
        next,
        selector,
        options,
        context,
        compileToken,
      ) {
        var adapter = options.adapter,
          equals = options.equals;
        switch (selector.type) {
          case css_what_1.SelectorType.PseudoElement: {
            throw new Error("Pseudo-elements are not supported by css-select");
          }
          case css_what_1.SelectorType.ColumnCombinator: {
            throw new Error(
              "Column combinators are not yet supported by css-select",
            );
          }
          case css_what_1.SelectorType.Attribute: {
            if (selector.namespace != null) {
              throw new Error(
                "Namespaced attributes are not yet supported by css-select",
              );
            }
            if (!options.xmlMode || options.lowerCaseAttributeNames) {
              selector.name = selector.name.toLowerCase();
            }
            return attributes_js_1.attributeRules[selector.action](
              next,
              selector,
              options,
            );
          }
          case css_what_1.SelectorType.Pseudo: {
            return (0, index_js_1.compilePseudoSelector)(
              next,
              selector,
              options,
              context,
              compileToken,
            );
          }
          case css_what_1.SelectorType.Tag: {
            if (selector.namespace != null) {
              throw new Error(
                "Namespaced tag names are not yet supported by css-select",
              );
            }
            var name_1 = selector.name;
            if (!options.xmlMode || options.lowerCaseTags) {
              name_1 = name_1.toLowerCase();
            }
            return function tag(elem) {
              return adapter.getName(elem) === name_1 && next(elem);
            };
          }
          case css_what_1.SelectorType.Descendant: {
            if (
              options.cacheResults === false ||
              typeof WeakSet === "undefined"
            ) {
              return function descendant(elem) {
                var current = elem;
                while ((current = getElementParent(current, adapter))) {
                  if (next(current)) {
                    return true;
                  }
                }
                return false;
              };
            }
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
              var current = elem;
              while ((current = getElementParent(current, adapter))) {
                if (!isFalseCache_1.has(current)) {
                  if (adapter.isTag(current) && next(current)) {
                    return true;
                  }
                  isFalseCache_1.add(current);
                }
              }
              return false;
            };
          }
          case "_flexibleDescendant": {
            return function flexibleDescendant(elem) {
              var current = elem;
              do {
                if (next(current)) return true;
              } while ((current = getElementParent(current, adapter)));
              return false;
            };
          }
          case css_what_1.SelectorType.Parent: {
            return function parent(elem) {
              return adapter.getChildren(elem).some(function (elem) {
                return adapter.isTag(elem) && next(elem);
              });
            };
          }
          case css_what_1.SelectorType.Child: {
            return function child(elem) {
              var parent = adapter.getParent(elem);
              return parent != null && adapter.isTag(parent) && next(parent);
            };
          }
          case css_what_1.SelectorType.Sibling: {
            return function sibling(elem) {
              var siblings = adapter.getSiblings(elem);
              for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling)) break;
                if (adapter.isTag(currentSibling) && next(currentSibling)) {
                  return true;
                }
              }
              return false;
            };
          }
          case css_what_1.SelectorType.Adjacent: {
            if (adapter.prevElementSibling) {
              return function adjacent(elem) {
                var previous = adapter.prevElementSibling(elem);
                return previous != null && next(previous);
              };
            }
            return function adjacent(elem) {
              var siblings = adapter.getSiblings(elem);
              var lastElement;
              for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling)) break;
                if (adapter.isTag(currentSibling)) {
                  lastElement = currentSibling;
                }
              }
              return !!lastElement && next(lastElement);
            };
          }
          case css_what_1.SelectorType.Universal: {
            if (selector.namespace != null && selector.namespace !== "*") {
              throw new Error(
                "Namespaced universal selectors are not yet supported by css-select",
              );
            }
            return next;
          }
        }
      }
      exports.compileGeneralSelector = compileGeneralSelector;
    },
    1275: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.aliases =
        exports.pseudos =
        exports.filters =
        exports.is =
        exports.selectOne =
        exports.selectAll =
        exports.prepareContext =
        exports._compileToken =
        exports._compileUnsafe =
        exports.compile =
          void 0;
      var DomUtils = __importStar(__nccwpck_require__(4279));
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      var compile_js_1 = __nccwpck_require__(9364);
      var subselects_js_1 = __nccwpck_require__(4676);
      var defaultEquals = function (a, b) {
        return a === b;
      };
      var defaultOptions = { adapter: DomUtils, equals: defaultEquals };
      function convertOptionFormats(options) {
        var _a, _b, _c, _d;
        var opts =
          options !== null && options !== void 0 ? options : defaultOptions;
        (_a = opts.adapter) !== null && _a !== void 0
          ? _a
          : (opts.adapter = DomUtils);
        (_b = opts.equals) !== null && _b !== void 0
          ? _b
          : (opts.equals =
              (_d =
                (_c = opts.adapter) === null || _c === void 0
                  ? void 0
                  : _c.equals) !== null && _d !== void 0
                ? _d
                : defaultEquals);
        return opts;
      }
      function wrapCompile(func) {
        return function addAdapter(selector, options, context) {
          var opts = convertOptionFormats(options);
          return func(selector, opts, context);
        };
      }
      exports.compile = wrapCompile(compile_js_1.compile);
      exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
      exports._compileToken = wrapCompile(compile_js_1.compileToken);
      function getSelectorFunc(searchFunc) {
        return function select(query, elements, options) {
          var opts = convertOptionFormats(options);
          if (typeof query !== "function") {
            query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
          }
          var filteredElements = prepareContext(
            elements,
            opts.adapter,
            query.shouldTestNextSiblings,
          );
          return searchFunc(query, filteredElements, opts);
        };
      }
      function prepareContext(elems, adapter, shouldTestNextSiblings) {
        if (shouldTestNextSiblings === void 0) {
          shouldTestNextSiblings = false;
        }
        if (shouldTestNextSiblings) {
          elems = appendNextSiblings(elems, adapter);
        }
        return Array.isArray(elems)
          ? adapter.removeSubsets(elems)
          : adapter.getChildren(elems);
      }
      exports.prepareContext = prepareContext;
      function appendNextSiblings(elem, adapter) {
        var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
        var elemsLength = elems.length;
        for (var i = 0; i < elemsLength; i++) {
          var nextSiblings = (0, subselects_js_1.getNextSiblings)(
            elems[i],
            adapter,
          );
          elems.push.apply(elems, nextSiblings);
        }
        return elems;
      }
      exports.selectAll = getSelectorFunc(function (query, elems, options) {
        return query === boolbase_1.default.falseFunc ||
          !elems ||
          elems.length === 0
          ? []
          : options.adapter.findAll(query, elems);
      });
      exports.selectOne = getSelectorFunc(function (query, elems, options) {
        return query === boolbase_1.default.falseFunc ||
          !elems ||
          elems.length === 0
          ? null
          : options.adapter.findOne(query, elems);
      });
      function is(elem, query, options) {
        var opts = convertOptionFormats(options);
        return (
          typeof query === "function"
            ? query
            : (0, compile_js_1.compile)(query, opts)
        )(elem);
      }
      exports.is = is;
      exports["default"] = exports.selectAll;
      var index_js_1 = __nccwpck_require__(8183);
      Object.defineProperty(exports, "filters", {
        enumerable: true,
        get: function () {
          return index_js_1.filters;
        },
      });
      Object.defineProperty(exports, "pseudos", {
        enumerable: true,
        get: function () {
          return index_js_1.pseudos;
        },
      });
      Object.defineProperty(exports, "aliases", {
        enumerable: true,
        get: function () {
          return index_js_1.aliases;
        },
      });
    },
    9643: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.aliases = void 0;
      exports.aliases = {
        "any-link": ":is(a, area, link)[href]",
        link: ":any-link:not(:visited)",
        disabled:
          ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
        enabled: ":not(:disabled)",
        checked:
          ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
        required: ":is(input, select, textarea)[required]",
        optional: ":is(input, select, textarea):not([required])",
        selected:
          "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
        checkbox: "[type=checkbox]",
        file: "[type=file]",
        password: "[type=password]",
        radio: "[type=radio]",
        reset: "[type=reset]",
        image: "[type=image]",
        submit: "[type=submit]",
        parent: ":not(:empty)",
        header: ":is(h1, h2, h3, h4, h5, h6)",
        button: ":is(button, input[type=button])",
        input: ":is(input, textarea, select, button)",
        text: "input:is(:not([type!='']), [type=text])",
      };
    },
    2097: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filters = void 0;
      var nth_check_1 = __importDefault(__nccwpck_require__(8452));
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      function getChildFunc(next, adapter) {
        return function (elem) {
          var parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(elem);
        };
      }
      exports.filters = {
        contains: function (next, text, _a) {
          var adapter = _a.adapter;
          return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
          };
        },
        icontains: function (next, text, _a) {
          var adapter = _a.adapter;
          var itext = text.toLowerCase();
          return function icontains(elem) {
            return (
              next(elem) && adapter.getText(elem).toLowerCase().includes(itext)
            );
          };
        },
        "nth-child": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.default.falseFunc)
            return boolbase_1.default.falseFunc;
          if (func === boolbase_1.default.trueFunc)
            return getChildFunc(next, adapter);
          return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
              if (equals(elem, siblings[i])) break;
              if (adapter.isTag(siblings[i])) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-last-child": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.default.falseFunc)
            return boolbase_1.default.falseFunc;
          if (func === boolbase_1.default.trueFunc)
            return getChildFunc(next, adapter);
          return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
              if (equals(elem, siblings[i])) break;
              if (adapter.isTag(siblings[i])) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-of-type": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.default.falseFunc)
            return boolbase_1.default.falseFunc;
          if (func === boolbase_1.default.trueFunc)
            return getChildFunc(next, adapter);
          return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling)) break;
              if (
                adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === adapter.getName(elem)
              ) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-last-of-type": function (next, rule, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.default.falseFunc)
            return boolbase_1.default.falseFunc;
          if (func === boolbase_1.default.trueFunc)
            return getChildFunc(next, adapter);
          return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling)) break;
              if (
                adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === adapter.getName(elem)
              ) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        root: function (next, _rule, _a) {
          var adapter = _a.adapter;
          return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
          };
        },
        scope: function (next, rule, options, context) {
          var equals = options.equals;
          if (!context || context.length === 0) {
            return exports.filters["root"](next, rule, options);
          }
          if (context.length === 1) {
            return function (elem) {
              return equals(context[0], elem) && next(elem);
            };
          }
          return function (elem) {
            return context.includes(elem) && next(elem);
          };
        },
        hover: dynamicStatePseudo("isHovered"),
        visited: dynamicStatePseudo("isVisited"),
        active: dynamicStatePseudo("isActive"),
      };
      function dynamicStatePseudo(name) {
        return function dynamicPseudo(next, _rule, _a) {
          var adapter = _a.adapter;
          var func = adapter[name];
          if (typeof func !== "function") {
            return boolbase_1.default.falseFunc;
          }
          return function active(elem) {
            return func(elem) && next(elem);
          };
        };
      }
    },
    8183: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.compilePseudoSelector =
        exports.aliases =
        exports.pseudos =
        exports.filters =
          void 0;
      var css_what_1 = __nccwpck_require__(527);
      var filters_js_1 = __nccwpck_require__(2097);
      Object.defineProperty(exports, "filters", {
        enumerable: true,
        get: function () {
          return filters_js_1.filters;
        },
      });
      var pseudos_js_1 = __nccwpck_require__(8989);
      Object.defineProperty(exports, "pseudos", {
        enumerable: true,
        get: function () {
          return pseudos_js_1.pseudos;
        },
      });
      var aliases_js_1 = __nccwpck_require__(9643);
      Object.defineProperty(exports, "aliases", {
        enumerable: true,
        get: function () {
          return aliases_js_1.aliases;
        },
      });
      var subselects_js_1 = __nccwpck_require__(4676);
      function compilePseudoSelector(
        next,
        selector,
        options,
        context,
        compileToken,
      ) {
        var _a;
        var name = selector.name,
          data = selector.data;
        if (Array.isArray(data)) {
          if (!(name in subselects_js_1.subselects)) {
            throw new Error(
              "Unknown pseudo-class :".concat(name, "(").concat(data, ")"),
            );
          }
          return subselects_js_1.subselects[name](
            next,
            data,
            options,
            context,
            compileToken,
          );
        }
        var userPseudo =
          (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
        var stringPseudo =
          typeof userPseudo === "string"
            ? userPseudo
            : aliases_js_1.aliases[name];
        if (typeof stringPseudo === "string") {
          if (data != null) {
            throw new Error(
              "Pseudo ".concat(name, " doesn't have any arguments"),
            );
          }
          var alias = (0, css_what_1.parse)(stringPseudo);
          return subselects_js_1.subselects["is"](
            next,
            alias,
            options,
            context,
            compileToken,
          );
        }
        if (typeof userPseudo === "function") {
          (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
          return function (elem) {
            return userPseudo(elem, data) && next(elem);
          };
        }
        if (name in filters_js_1.filters) {
          return filters_js_1.filters[name](next, data, options, context);
        }
        if (name in pseudos_js_1.pseudos) {
          var pseudo_1 = pseudos_js_1.pseudos[name];
          (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
          return function (elem) {
            return pseudo_1(elem, options, data) && next(elem);
          };
        }
        throw new Error("Unknown pseudo-class :".concat(name));
      }
      exports.compilePseudoSelector = compilePseudoSelector;
    },
    8989: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyPseudoArgs = exports.pseudos = void 0;
      exports.pseudos = {
        empty: function (elem, _a) {
          var adapter = _a.adapter;
          return !adapter.getChildren(elem).some(function (elem) {
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
          });
        },
        "first-child": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          if (adapter.prevElementSibling) {
            return adapter.prevElementSibling(elem) == null;
          }
          var firstChild = adapter.getSiblings(elem).find(function (elem) {
            return adapter.isTag(elem);
          });
          return firstChild != null && equals(elem, firstChild);
        },
        "last-child": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var siblings = adapter.getSiblings(elem);
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i])) return true;
            if (adapter.isTag(siblings[i])) break;
          }
          return false;
        },
        "first-of-type": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var siblings = adapter.getSiblings(elem);
          var elemName = adapter.getName(elem);
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling)) return true;
            if (
              adapter.isTag(currentSibling) &&
              adapter.getName(currentSibling) === elemName
            ) {
              break;
            }
          }
          return false;
        },
        "last-of-type": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var siblings = adapter.getSiblings(elem);
          var elemName = adapter.getName(elem);
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling)) return true;
            if (
              adapter.isTag(currentSibling) &&
              adapter.getName(currentSibling) === elemName
            ) {
              break;
            }
          }
          return false;
        },
        "only-of-type": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          var elemName = adapter.getName(elem);
          return adapter.getSiblings(elem).every(function (sibling) {
            return (
              equals(elem, sibling) ||
              !adapter.isTag(sibling) ||
              adapter.getName(sibling) !== elemName
            );
          });
        },
        "only-child": function (elem, _a) {
          var adapter = _a.adapter,
            equals = _a.equals;
          return adapter.getSiblings(elem).every(function (sibling) {
            return equals(elem, sibling) || !adapter.isTag(sibling);
          });
        },
      };
      function verifyPseudoArgs(func, name, subselect, argIndex) {
        if (subselect === null) {
          if (func.length > argIndex) {
            throw new Error(
              "Pseudo-class :".concat(name, " requires an argument"),
            );
          }
        } else if (func.length === argIndex) {
          throw new Error(
            "Pseudo-class :".concat(name, " doesn't have any arguments"),
          );
        }
      }
      exports.verifyPseudoArgs = verifyPseudoArgs;
    },
    4676: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __spreadArray =
        (this && this.__spreadArray) ||
        function (to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.subselects =
        exports.getNextSiblings =
        exports.ensureIsTag =
        exports.PLACEHOLDER_ELEMENT =
          void 0;
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      var sort_js_1 = __nccwpck_require__(9790);
      exports.PLACEHOLDER_ELEMENT = {};
      function ensureIsTag(next, adapter) {
        if (next === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        return function (elem) {
          return adapter.isTag(elem) && next(elem);
        };
      }
      exports.ensureIsTag = ensureIsTag;
      function getNextSiblings(elem, adapter) {
        var siblings = adapter.getSiblings(elem);
        if (siblings.length <= 1) return [];
        var elemIndex = siblings.indexOf(elem);
        if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
        return siblings.slice(elemIndex + 1).filter(adapter.isTag);
      }
      exports.getNextSiblings = getNextSiblings;
      function copyOptions(options) {
        return {
          xmlMode: !!options.xmlMode,
          lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
          lowerCaseTags: !!options.lowerCaseTags,
          quirksMode: !!options.quirksMode,
          cacheResults: !!options.cacheResults,
          pseudos: options.pseudos,
          adapter: options.adapter,
          equals: options.equals,
        };
      }
      var is = function (next, token, options, context, compileToken) {
        var func = compileToken(token, copyOptions(options), context);
        return func === boolbase_1.default.trueFunc
          ? next
          : func === boolbase_1.default.falseFunc
            ? boolbase_1.default.falseFunc
            : function (elem) {
                return func(elem) && next(elem);
              };
      };
      exports.subselects = {
        is,
        matches: is,
        where: is,
        not: function (next, token, options, context, compileToken) {
          var func = compileToken(token, copyOptions(options), context);
          return func === boolbase_1.default.falseFunc
            ? next
            : func === boolbase_1.default.trueFunc
              ? boolbase_1.default.falseFunc
              : function (elem) {
                  return !func(elem) && next(elem);
                };
        },
        has: function (next, subselect, options, _context, compileToken) {
          var adapter = options.adapter;
          var opts = copyOptions(options);
          opts.relativeSelector = true;
          var context = subselect.some(function (s) {
            return s.some(sort_js_1.isTraversal);
          })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
          var compiled = compileToken(subselect, opts, context);
          if (compiled === boolbase_1.default.falseFunc)
            return boolbase_1.default.falseFunc;
          var hasElement = ensureIsTag(compiled, adapter);
          if (context && compiled !== boolbase_1.default.trueFunc) {
            var _a = compiled.shouldTestNextSiblings,
              shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
            return function (elem) {
              if (!next(elem)) return false;
              context[0] = elem;
              var childs = adapter.getChildren(elem);
              var nextElements = shouldTestNextSiblings_1
                ? __spreadArray(
                    __spreadArray([], childs, true),
                    getNextSiblings(elem, adapter),
                    true,
                  )
                : childs;
              return adapter.existsOne(hasElement, nextElements);
            };
          }
          return function (elem) {
            return (
              next(elem) &&
              adapter.existsOne(hasElement, adapter.getChildren(elem))
            );
          };
        },
      };
    },
    9790: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isTraversal = void 0;
      var css_what_1 = __nccwpck_require__(527);
      var procedure = new Map([
        [css_what_1.SelectorType.Universal, 50],
        [css_what_1.SelectorType.Tag, 30],
        [css_what_1.SelectorType.Attribute, 1],
        [css_what_1.SelectorType.Pseudo, 0],
      ]);
      function isTraversal(token) {
        return !procedure.has(token.type);
      }
      exports.isTraversal = isTraversal;
      var attributes = new Map([
        [css_what_1.AttributeAction.Exists, 10],
        [css_what_1.AttributeAction.Equals, 8],
        [css_what_1.AttributeAction.Not, 7],
        [css_what_1.AttributeAction.Start, 6],
        [css_what_1.AttributeAction.End, 6],
        [css_what_1.AttributeAction.Any, 5],
      ]);
      function sortByProcedure(arr) {
        var procs = arr.map(getProcedure);
        for (var i = 1; i < arr.length; i++) {
          var procNew = procs[i];
          if (procNew < 0) continue;
          for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
          }
        }
      }
      exports["default"] = sortByProcedure;
      function getProcedure(token) {
        var _a, _b;
        var proc =
          (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
        if (token.type === css_what_1.SelectorType.Attribute) {
          proc =
            (_b = attributes.get(token.action)) !== null && _b !== void 0
              ? _b
              : 4;
          if (
            token.action === css_what_1.AttributeAction.Equals &&
            token.name === "id"
          ) {
            proc = 9;
          }
          if (token.ignoreCase) {
            proc >>= 1;
          }
        } else if (token.type === css_what_1.SelectorType.Pseudo) {
          if (!token.data) {
            proc = 3;
          } else if (token.name === "has" || token.name === "contains") {
            proc = 0;
          } else if (Array.isArray(token.data)) {
            proc = Math.min.apply(
              Math,
              token.data.map(function (d) {
                return Math.min.apply(Math, d.map(getProcedure));
              }),
            );
            if (proc < 0) {
              proc = 0;
            }
          } else {
            proc = 2;
          }
        }
        return proc;
      }
    },
    527: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringify = exports.parse = exports.isTraversal = void 0;
      __exportStar(__nccwpck_require__(5834), exports);
      var parse_1 = __nccwpck_require__(5103);
      Object.defineProperty(exports, "isTraversal", {
        enumerable: true,
        get: function () {
          return parse_1.isTraversal;
        },
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function () {
          return parse_1.parse;
        },
      });
      var stringify_1 = __nccwpck_require__(4243);
      Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function () {
          return stringify_1.stringify;
        },
      });
    },
    5103: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = exports.isTraversal = void 0;
      var types_1 = __nccwpck_require__(5834);
      var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
      var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
      var actionTypes = new Map([
        [126, types_1.AttributeAction.Element],
        [94, types_1.AttributeAction.Start],
        [36, types_1.AttributeAction.End],
        [42, types_1.AttributeAction.Any],
        [33, types_1.AttributeAction.Not],
        [124, types_1.AttributeAction.Hyphen],
      ]);
      var unpackPseudos = new Set([
        "has",
        "not",
        "matches",
        "is",
        "where",
        "host",
        "host-context",
      ]);
      function isTraversal(selector) {
        switch (selector.type) {
          case types_1.SelectorType.Adjacent:
          case types_1.SelectorType.Child:
          case types_1.SelectorType.Descendant:
          case types_1.SelectorType.Parent:
          case types_1.SelectorType.Sibling:
          case types_1.SelectorType.ColumnCombinator:
            return true;
          default:
            return false;
        }
      }
      exports.isTraversal = isTraversal;
      var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
      function funescape(_, escaped, escapedWhitespace) {
        var high = parseInt(escaped, 16) - 65536;
        return high !== high || escapedWhitespace
          ? escaped
          : high < 0
            ? String.fromCharCode(high + 65536)
            : String.fromCharCode((high >> 10) | 55296, (high & 1023) | 56320);
      }
      function unescapeCSS(str) {
        return str.replace(reEscape, funescape);
      }
      function isQuote(c) {
        return c === 39 || c === 34;
      }
      function isWhitespace(c) {
        return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
      }
      function parse(selector) {
        var subselects = [];
        var endIndex = parseSelector(subselects, "".concat(selector), 0);
        if (endIndex < selector.length) {
          throw new Error(
            "Unmatched selector: ".concat(selector.slice(endIndex)),
          );
        }
        return subselects;
      }
      exports.parse = parse;
      function parseSelector(subselects, selector, selectorIndex) {
        var tokens = [];
        function getName(offset) {
          var match = selector.slice(selectorIndex + offset).match(reName);
          if (!match) {
            throw new Error(
              "Expected name, found ".concat(selector.slice(selectorIndex)),
            );
          }
          var name = match[0];
          selectorIndex += offset + name.length;
          return unescapeCSS(name);
        }
        function stripWhitespace(offset) {
          selectorIndex += offset;
          while (
            selectorIndex < selector.length &&
            isWhitespace(selector.charCodeAt(selectorIndex))
          ) {
            selectorIndex++;
          }
        }
        function readValueWithParenthesis() {
          selectorIndex += 1;
          var start = selectorIndex;
          var counter = 1;
          for (
            ;
            counter > 0 && selectorIndex < selector.length;
            selectorIndex++
          ) {
            if (
              selector.charCodeAt(selectorIndex) === 40 &&
              !isEscaped(selectorIndex)
            ) {
              counter++;
            } else if (
              selector.charCodeAt(selectorIndex) === 41 &&
              !isEscaped(selectorIndex)
            ) {
              counter--;
            }
          }
          if (counter) {
            throw new Error("Parenthesis not matched");
          }
          return unescapeCSS(selector.slice(start, selectorIndex - 1));
        }
        function isEscaped(pos) {
          var slashCount = 0;
          while (selector.charCodeAt(--pos) === 92) slashCount++;
          return (slashCount & 1) === 1;
        }
        function ensureNotTraversal() {
          if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
          }
        }
        function addTraversal(type) {
          if (
            tokens.length > 0 &&
            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant
          ) {
            tokens[tokens.length - 1].type = type;
            return;
          }
          ensureNotTraversal();
          tokens.push({ type });
        }
        function addSpecialAttribute(name, action) {
          tokens.push({
            type: types_1.SelectorType.Attribute,
            name,
            action,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks",
          });
        }
        function finalizeSubselector() {
          if (
            tokens.length &&
            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant
          ) {
            tokens.pop();
          }
          if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
          }
          subselects.push(tokens);
        }
        stripWhitespace(0);
        if (selector.length === selectorIndex) {
          return selectorIndex;
        }
        loop: while (selectorIndex < selector.length) {
          var firstChar = selector.charCodeAt(selectorIndex);
          switch (firstChar) {
            case 32:
            case 9:
            case 10:
            case 12:
            case 13: {
              if (
                tokens.length === 0 ||
                tokens[0].type !== types_1.SelectorType.Descendant
              ) {
                ensureNotTraversal();
                tokens.push({ type: types_1.SelectorType.Descendant });
              }
              stripWhitespace(1);
              break;
            }
            case 62: {
              addTraversal(types_1.SelectorType.Child);
              stripWhitespace(1);
              break;
            }
            case 60: {
              addTraversal(types_1.SelectorType.Parent);
              stripWhitespace(1);
              break;
            }
            case 126: {
              addTraversal(types_1.SelectorType.Sibling);
              stripWhitespace(1);
              break;
            }
            case 43: {
              addTraversal(types_1.SelectorType.Adjacent);
              stripWhitespace(1);
              break;
            }
            case 46: {
              addSpecialAttribute("class", types_1.AttributeAction.Element);
              break;
            }
            case 35: {
              addSpecialAttribute("id", types_1.AttributeAction.Equals);
              break;
            }
            case 91: {
              stripWhitespace(1);
              var name_1 = void 0;
              var namespace = null;
              if (selector.charCodeAt(selectorIndex) === 124) {
                name_1 = getName(1);
              } else if (selector.startsWith("*|", selectorIndex)) {
                namespace = "*";
                name_1 = getName(2);
              } else {
                name_1 = getName(0);
                if (
                  selector.charCodeAt(selectorIndex) === 124 &&
                  selector.charCodeAt(selectorIndex + 1) !== 61
                ) {
                  namespace = name_1;
                  name_1 = getName(1);
                }
              }
              stripWhitespace(0);
              var action = types_1.AttributeAction.Exists;
              var possibleAction = actionTypes.get(
                selector.charCodeAt(selectorIndex),
              );
              if (possibleAction) {
                action = possibleAction;
                if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                  throw new Error("Expected `=`");
                }
                stripWhitespace(2);
              } else if (selector.charCodeAt(selectorIndex) === 61) {
                action = types_1.AttributeAction.Equals;
                stripWhitespace(1);
              }
              var value = "";
              var ignoreCase = null;
              if (action !== "exists") {
                if (isQuote(selector.charCodeAt(selectorIndex))) {
                  var quote = selector.charCodeAt(selectorIndex);
                  var sectionEnd = selectorIndex + 1;
                  while (
                    sectionEnd < selector.length &&
                    (selector.charCodeAt(sectionEnd) !== quote ||
                      isEscaped(sectionEnd))
                  ) {
                    sectionEnd += 1;
                  }
                  if (selector.charCodeAt(sectionEnd) !== quote) {
                    throw new Error("Attribute value didn't end");
                  }
                  value = unescapeCSS(
                    selector.slice(selectorIndex + 1, sectionEnd),
                  );
                  selectorIndex = sectionEnd + 1;
                } else {
                  var valueStart = selectorIndex;
                  while (
                    selectorIndex < selector.length &&
                    ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                      selector.charCodeAt(selectorIndex) !== 93) ||
                      isEscaped(selectorIndex))
                  ) {
                    selectorIndex += 1;
                  }
                  value = unescapeCSS(
                    selector.slice(valueStart, selectorIndex),
                  );
                }
                stripWhitespace(0);
                var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
                if (forceIgnore === 115) {
                  ignoreCase = false;
                  stripWhitespace(1);
                } else if (forceIgnore === 105) {
                  ignoreCase = true;
                  stripWhitespace(1);
                }
              }
              if (selector.charCodeAt(selectorIndex) !== 93) {
                throw new Error("Attribute selector didn't terminate");
              }
              selectorIndex += 1;
              var attributeSelector = {
                type: types_1.SelectorType.Attribute,
                name: name_1,
                action,
                value,
                namespace,
                ignoreCase,
              };
              tokens.push(attributeSelector);
              break;
            }
            case 58: {
              if (selector.charCodeAt(selectorIndex + 1) === 58) {
                tokens.push({
                  type: types_1.SelectorType.PseudoElement,
                  name: getName(2).toLowerCase(),
                  data:
                    selector.charCodeAt(selectorIndex) === 40
                      ? readValueWithParenthesis()
                      : null,
                });
                continue;
              }
              var name_2 = getName(1).toLowerCase();
              var data = null;
              if (selector.charCodeAt(selectorIndex) === 40) {
                if (unpackPseudos.has(name_2)) {
                  if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                    throw new Error(
                      "Pseudo-selector ".concat(name_2, " cannot be quoted"),
                    );
                  }
                  data = [];
                  selectorIndex = parseSelector(
                    data,
                    selector,
                    selectorIndex + 1,
                  );
                  if (selector.charCodeAt(selectorIndex) !== 41) {
                    throw new Error(
                      "Missing closing parenthesis in :"
                        .concat(name_2, " (")
                        .concat(selector, ")"),
                    );
                  }
                  selectorIndex += 1;
                } else {
                  data = readValueWithParenthesis();
                  if (stripQuotesFromPseudos.has(name_2)) {
                    var quot = data.charCodeAt(0);
                    if (
                      quot === data.charCodeAt(data.length - 1) &&
                      isQuote(quot)
                    ) {
                      data = data.slice(1, -1);
                    }
                  }
                  data = unescapeCSS(data);
                }
              }
              tokens.push({
                type: types_1.SelectorType.Pseudo,
                name: name_2,
                data,
              });
              break;
            }
            case 44: {
              finalizeSubselector();
              tokens = [];
              stripWhitespace(1);
              break;
            }
            default: {
              if (selector.startsWith("/*", selectorIndex)) {
                var endIndex = selector.indexOf("*/", selectorIndex + 2);
                if (endIndex < 0) {
                  throw new Error("Comment was not terminated");
                }
                selectorIndex = endIndex + 2;
                if (tokens.length === 0) {
                  stripWhitespace(0);
                }
                break;
              }
              var namespace = null;
              var name_3 = void 0;
              if (firstChar === 42) {
                selectorIndex += 1;
                name_3 = "*";
              } else if (firstChar === 124) {
                name_3 = "";
                if (selector.charCodeAt(selectorIndex + 1) === 124) {
                  addTraversal(types_1.SelectorType.ColumnCombinator);
                  stripWhitespace(2);
                  break;
                }
              } else if (reName.test(selector.slice(selectorIndex))) {
                name_3 = getName(0);
              } else {
                break loop;
              }
              if (
                selector.charCodeAt(selectorIndex) === 124 &&
                selector.charCodeAt(selectorIndex + 1) !== 124
              ) {
                namespace = name_3;
                if (selector.charCodeAt(selectorIndex + 1) === 42) {
                  name_3 = "*";
                  selectorIndex += 2;
                } else {
                  name_3 = getName(1);
                }
              }
              tokens.push(
                name_3 === "*"
                  ? { type: types_1.SelectorType.Universal, namespace }
                  : { type: types_1.SelectorType.Tag, name: name_3, namespace },
              );
            }
          }
        }
        finalizeSubselector();
        return selectorIndex;
      }
    },
    4243: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __spreadArray =
        (this && this.__spreadArray) ||
        function (to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringify = void 0;
      var types_1 = __nccwpck_require__(5834);
      var attribValChars = ["\\", '"'];
      var pseudoValChars = __spreadArray(
        __spreadArray([], attribValChars, true),
        ["(", ")"],
        false,
      );
      var charsToEscapeInAttributeValue = new Set(
        attribValChars.map(function (c) {
          return c.charCodeAt(0);
        }),
      );
      var charsToEscapeInPseudoValue = new Set(
        pseudoValChars.map(function (c) {
          return c.charCodeAt(0);
        }),
      );
      var charsToEscapeInName = new Set(
        __spreadArray(
          __spreadArray([], pseudoValChars, true),
          ["~", "^", "$", "*", "+", "!", "|", ":", "[", "]", " ", "."],
          false,
        ).map(function (c) {
          return c.charCodeAt(0);
        }),
      );
      function stringify(selector) {
        return selector
          .map(function (token) {
            return token.map(stringifyToken).join("");
          })
          .join(", ");
      }
      exports.stringify = stringify;
      function stringifyToken(token, index, arr) {
        switch (token.type) {
          case types_1.SelectorType.Child:
            return index === 0 ? "> " : " > ";
          case types_1.SelectorType.Parent:
            return index === 0 ? "< " : " < ";
          case types_1.SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
          case types_1.SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
          case types_1.SelectorType.Descendant:
            return " ";
          case types_1.SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
          case types_1.SelectorType.Universal:
            return token.namespace === "*" &&
              index + 1 < arr.length &&
              "name" in arr[index + 1]
              ? ""
              : "".concat(getNamespace(token.namespace), "*");
          case types_1.SelectorType.Tag:
            return getNamespacedName(token);
          case types_1.SelectorType.PseudoElement:
            return "::"
              .concat(escapeName(token.name, charsToEscapeInName))
              .concat(
                token.data === null
                  ? ""
                  : "(".concat(
                      escapeName(token.data, charsToEscapeInPseudoValue),
                      ")",
                    ),
              );
          case types_1.SelectorType.Pseudo:
            return ":"
              .concat(escapeName(token.name, charsToEscapeInName))
              .concat(
                token.data === null
                  ? ""
                  : "(".concat(
                      typeof token.data === "string"
                        ? escapeName(token.data, charsToEscapeInPseudoValue)
                        : stringify(token.data),
                      ")",
                    ),
              );
          case types_1.SelectorType.Attribute: {
            if (
              token.name === "id" &&
              token.action === types_1.AttributeAction.Equals &&
              token.ignoreCase === "quirks" &&
              !token.namespace
            ) {
              return "#".concat(escapeName(token.value, charsToEscapeInName));
            }
            if (
              token.name === "class" &&
              token.action === types_1.AttributeAction.Element &&
              token.ignoreCase === "quirks" &&
              !token.namespace
            ) {
              return ".".concat(escapeName(token.value, charsToEscapeInName));
            }
            var name_1 = getNamespacedName(token);
            if (token.action === types_1.AttributeAction.Exists) {
              return "[".concat(name_1, "]");
            }
            return "["
              .concat(name_1)
              .concat(getActionValue(token.action), '="')
              .concat(
                escapeName(token.value, charsToEscapeInAttributeValue),
                '"',
              )
              .concat(
                token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s",
                "]",
              );
          }
        }
      }
      function getActionValue(action) {
        switch (action) {
          case types_1.AttributeAction.Equals:
            return "";
          case types_1.AttributeAction.Element:
            return "~";
          case types_1.AttributeAction.Start:
            return "^";
          case types_1.AttributeAction.End:
            return "$";
          case types_1.AttributeAction.Any:
            return "*";
          case types_1.AttributeAction.Not:
            return "!";
          case types_1.AttributeAction.Hyphen:
            return "|";
          case types_1.AttributeAction.Exists:
            throw new Error("Shouldn't be here");
        }
      }
      function getNamespacedName(token) {
        return ""
          .concat(getNamespace(token.namespace))
          .concat(escapeName(token.name, charsToEscapeInName));
      }
      function getNamespace(namespace) {
        return namespace !== null
          ? "".concat(
              namespace === "*"
                ? "*"
                : escapeName(namespace, charsToEscapeInName),
              "|",
            )
          : "";
      }
      function escapeName(str, charsToEscape) {
        var lastIdx = 0;
        var ret = "";
        for (var i = 0; i < str.length; i++) {
          if (charsToEscape.has(str.charCodeAt(i))) {
            ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
            lastIdx = i + 1;
          }
        }
        return ret.length > 0 ? ret + str.slice(lastIdx) : str;
      }
    },
    5834: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AttributeAction =
        exports.IgnoreCaseMode =
        exports.SelectorType =
          void 0;
      var SelectorType;
      (function (SelectorType) {
        SelectorType["Attribute"] = "attribute";
        SelectorType["Pseudo"] = "pseudo";
        SelectorType["PseudoElement"] = "pseudo-element";
        SelectorType["Tag"] = "tag";
        SelectorType["Universal"] = "universal";
        SelectorType["Adjacent"] = "adjacent";
        SelectorType["Child"] = "child";
        SelectorType["Descendant"] = "descendant";
        SelectorType["Parent"] = "parent";
        SelectorType["Sibling"] = "sibling";
        SelectorType["ColumnCombinator"] = "column-combinator";
      })((SelectorType = exports.SelectorType || (exports.SelectorType = {})));
      exports.IgnoreCaseMode = {
        Unknown: null,
        QuirksMode: "quirks",
        IgnoreCase: true,
        CaseSensitive: false,
      };
      var AttributeAction;
      (function (AttributeAction) {
        AttributeAction["Any"] = "any";
        AttributeAction["Element"] = "element";
        AttributeAction["End"] = "end";
        AttributeAction["Equals"] = "equals";
        AttributeAction["Exists"] = "exists";
        AttributeAction["Hyphen"] = "hyphen";
        AttributeAction["Not"] = "not";
        AttributeAction["Start"] = "start";
      })(
        (AttributeAction =
          exports.AttributeAction || (exports.AttributeAction = {})),
      );
    },
    7114: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.attributeNames = exports.elementNames = void 0;
      exports.elementNames = new Map(
        [
          "altGlyph",
          "altGlyphDef",
          "altGlyphItem",
          "animateColor",
          "animateMotion",
          "animateTransform",
          "clipPath",
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDistantLight",
          "feDropShadow",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "fePointLight",
          "feSpecularLighting",
          "feSpotLight",
          "feTile",
          "feTurbulence",
          "foreignObject",
          "glyphRef",
          "linearGradient",
          "radialGradient",
          "textPath",
        ].map(function (val) {
          return [val.toLowerCase(), val];
        }),
      );
      exports.attributeNames = new Map(
        [
          "definitionURL",
          "attributeName",
          "attributeType",
          "baseFrequency",
          "baseProfile",
          "calcMode",
          "clipPathUnits",
          "diffuseConstant",
          "edgeMode",
          "filterUnits",
          "glyphRef",
          "gradientTransform",
          "gradientUnits",
          "kernelMatrix",
          "kernelUnitLength",
          "keyPoints",
          "keySplines",
          "keyTimes",
          "lengthAdjust",
          "limitingConeAngle",
          "markerHeight",
          "markerUnits",
          "markerWidth",
          "maskContentUnits",
          "maskUnits",
          "numOctaves",
          "pathLength",
          "patternContentUnits",
          "patternTransform",
          "patternUnits",
          "pointsAtX",
          "pointsAtY",
          "pointsAtZ",
          "preserveAlpha",
          "preserveAspectRatio",
          "primitiveUnits",
          "refX",
          "refY",
          "repeatCount",
          "repeatDur",
          "requiredExtensions",
          "requiredFeatures",
          "specularConstant",
          "specularExponent",
          "spreadMethod",
          "startOffset",
          "stdDeviation",
          "stitchTiles",
          "surfaceScale",
          "systemLanguage",
          "tableValues",
          "targetX",
          "targetY",
          "textLength",
          "viewBox",
          "viewTarget",
          "xChannelSelector",
          "yChannelSelector",
          "zoomAndPan",
        ].map(function (val) {
          return [val.toLowerCase(), val];
        }),
      );
    },
    18: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __assign =
        (this && this.__assign) ||
        function () {
          __assign =
            Object.assign ||
            function (t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
            };
          return __assign.apply(this, arguments);
        };
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.render = void 0;
      var ElementType = __importStar(__nccwpck_require__(1810));
      var entities_1 = __nccwpck_require__(4194);
      var foreignNames_js_1 = __nccwpck_require__(7114);
      var unencodedElements = new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript",
      ]);
      function replaceQuotes(value) {
        return value.replace(/"/g, "&quot;");
      }
      function formatAttributes(attributes, opts) {
        var _a;
        if (!attributes) return;
        var encode =
          ((_a = opts.encodeEntities) !== null && _a !== void 0
            ? _a
            : opts.decodeEntities) === false
            ? replaceQuotes
            : opts.xmlMode || opts.encodeEntities !== "utf8"
              ? entities_1.encodeXML
              : entities_1.escapeAttribute;
        return Object.keys(attributes)
          .map(function (key) {
            var _a, _b;
            var value =
              (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
              key =
                (_b = foreignNames_js_1.attributeNames.get(key)) !== null &&
                _b !== void 0
                  ? _b
                  : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
              return key;
            }
            return "".concat(key, '="').concat(encode(value), '"');
          })
          .join(" ");
      }
      var singleTag = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
      ]);
      function render(node, options) {
        if (options === void 0) {
          options = {};
        }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i = 0; i < nodes.length; i++) {
          output += renderNode(nodes[i], options);
        }
        return output;
      }
      exports.render = render;
      exports["default"] = render;
      function renderNode(node, options) {
        switch (node.type) {
          case ElementType.Root:
            return render(node.children, options);
          case ElementType.Doctype:
          case ElementType.Directive:
            return renderDirective(node);
          case ElementType.Comment:
            return renderComment(node);
          case ElementType.CDATA:
            return renderCdata(node);
          case ElementType.Script:
          case ElementType.Style:
          case ElementType.Tag:
            return renderTag(node, options);
          case ElementType.Text:
            return renderText(node, options);
        }
      }
      var foreignModeIntegrationPoints = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
      ]);
      var foreignElements = new Set(["svg", "math"]);
      function renderTag(elem, opts) {
        var _a;
        if (opts.xmlMode === "foreign") {
          elem.name =
            (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null &&
            _a !== void 0
              ? _a
              : elem.name;
          if (
            elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)
          ) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
          }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<".concat(elem.name);
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
          tag += " ".concat(attribs);
        }
        if (
          elem.children.length === 0 &&
          (opts.xmlMode
            ? opts.selfClosingTags !== false
            : opts.selfClosingTags && singleTag.has(elem.name))
        ) {
          if (!opts.xmlMode) tag += " ";
          tag += "/>";
        } else {
          tag += ">";
          if (elem.children.length > 0) {
            tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</".concat(elem.name, ">");
          }
        }
        return tag;
      }
      function renderDirective(elem) {
        return "<".concat(elem.data, ">");
      }
      function renderText(elem, opts) {
        var _a;
        var data = elem.data || "";
        if (
          ((_a = opts.encodeEntities) !== null && _a !== void 0
            ? _a
            : opts.decodeEntities) !== false &&
          !(
            !opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name)
          )
        ) {
          data =
            opts.xmlMode || opts.encodeEntities !== "utf8"
              ? (0, entities_1.encodeXML)(data)
              : (0, entities_1.escapeText)(data);
        }
        return data;
      }
      function renderCdata(elem) {
        return "<![CDATA[".concat(elem.children[0].data, "]]>");
      }
      function renderComment(elem) {
        return "\x3c!--".concat(elem.data, "--\x3e");
      }
    },
    1810: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Doctype =
        exports.CDATA =
        exports.Tag =
        exports.Style =
        exports.Script =
        exports.Comment =
        exports.Directive =
        exports.Text =
        exports.Root =
        exports.isTag =
        exports.ElementType =
          void 0;
      var ElementType;
      (function (ElementType) {
        ElementType["Root"] = "root";
        ElementType["Text"] = "text";
        ElementType["Directive"] = "directive";
        ElementType["Comment"] = "comment";
        ElementType["Script"] = "script";
        ElementType["Style"] = "style";
        ElementType["Tag"] = "tag";
        ElementType["CDATA"] = "cdata";
        ElementType["Doctype"] = "doctype";
      })((ElementType = exports.ElementType || (exports.ElementType = {})));
      function isTag(elem) {
        return (
          elem.type === ElementType.Tag ||
          elem.type === ElementType.Script ||
          elem.type === ElementType.Style
        );
      }
      exports.isTag = isTag;
      exports.Root = ElementType.Root;
      exports.Text = ElementType.Text;
      exports.Directive = ElementType.Directive;
      exports.Comment = ElementType.Comment;
      exports.Script = ElementType.Script;
      exports.Style = ElementType.Style;
      exports.Tag = ElementType.Tag;
      exports.CDATA = ElementType.CDATA;
      exports.Doctype = ElementType.Doctype;
    },
    3123: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DomHandler = void 0;
      var domelementtype_1 = __nccwpck_require__(1810);
      var node_js_1 = __nccwpck_require__(8337);
      __exportStar(__nccwpck_require__(8337), exports);
      var defaultOpts = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false,
      };
      var DomHandler = (function () {
        function DomHandler(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = undefined;
          }
          this.callback =
            callback !== null && callback !== void 0 ? callback : null;
          this.options =
            options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB =
            elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler.prototype.onparserinit = function (parser) {
          this.parser = parser;
        };
        DomHandler.prototype.onreset = function () {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler.prototype.onend = function () {
          if (this.done) return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler.prototype.onerror = function (error) {
          this.handleCallback(error);
        };
        DomHandler.prototype.onclosetag = function () {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB) this.elementCB(elem);
        };
        DomHandler.prototype.onopentag = function (name, attribs) {
          var type = this.options.xmlMode
            ? domelementtype_1.ElementType.Tag
            : undefined;
          var element = new node_js_1.Element(name, attribs, undefined, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler.prototype.ontext = function (data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler.prototype.oncomment = function (data) {
          if (
            this.lastNode &&
            this.lastNode.type === domelementtype_1.ElementType.Comment
          ) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler.prototype.oncommentend = function () {
          this.lastNode = null;
        };
        DomHandler.prototype.oncdatastart = function () {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler.prototype.oncdataend = function () {
          this.lastNode = null;
        };
        DomHandler.prototype.onprocessinginstruction = function (name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler.prototype.handleCallback = function (error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler.prototype.addNode = function (node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler;
      })();
      exports.DomHandler = DomHandler;
      exports["default"] = DomHandler;
    },
    8337: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __extends =
        (this && this.__extends) ||
        (function () {
          var extendStatics = function (d, b) {
            extendStatics =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (d, b) {
                  d.__proto__ = b;
                }) ||
              function (d, b) {
                for (var p in b)
                  if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
              };
            return extendStatics(d, b);
          };
          return function (d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError(
                "Class extends value " +
                  String(b) +
                  " is not a constructor or null",
              );
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype =
              b === null
                ? Object.create(b)
                : ((__.prototype = b.prototype), new __());
          };
        })();
      var __assign =
        (this && this.__assign) ||
        function () {
          __assign =
            Object.assign ||
            function (t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
            };
          return __assign.apply(this, arguments);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.cloneNode =
        exports.hasChildren =
        exports.isDocument =
        exports.isDirective =
        exports.isComment =
        exports.isText =
        exports.isCDATA =
        exports.isTag =
        exports.Element =
        exports.Document =
        exports.CDATA =
        exports.NodeWithChildren =
        exports.ProcessingInstruction =
        exports.Comment =
        exports.Text =
        exports.DataNode =
        exports.Node =
          void 0;
      var domelementtype_1 = __nccwpck_require__(1810);
      var Node = (function () {
        function Node() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node.prototype, "parentNode", {
          get: function () {
            return this.parent;
          },
          set: function (parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node.prototype, "previousSibling", {
          get: function () {
            return this.prev;
          },
          set: function (prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node.prototype, "nextSibling", {
          get: function () {
            return this.next;
          },
          set: function (next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true,
        });
        Node.prototype.cloneNode = function (recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node;
      })();
      exports.Node = Node;
      var DataNode = (function (_super) {
        __extends(DataNode, _super);
        function DataNode(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode.prototype, "nodeValue", {
          get: function () {
            return this.data;
          },
          set: function (data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true,
        });
        return DataNode;
      })(Node);
      exports.DataNode = DataNode;
      var Text = (function (_super) {
        __extends(Text, _super);
        function Text() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text.prototype, "nodeType", {
          get: function () {
            return 3;
          },
          enumerable: false,
          configurable: true,
        });
        return Text;
      })(DataNode);
      exports.Text = Text;
      var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment.prototype, "nodeType", {
          get: function () {
            return 8;
          },
          enumerable: false,
          configurable: true,
        });
        return Comment;
      })(DataNode);
      exports.Comment = Comment;
      var ProcessingInstruction = (function (_super) {
        __extends(ProcessingInstruction, _super);
        function ProcessingInstruction(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
          get: function () {
            return 1;
          },
          enumerable: false,
          configurable: true,
        });
        return ProcessingInstruction;
      })(DataNode);
      exports.ProcessingInstruction = ProcessingInstruction;
      var NodeWithChildren = (function (_super) {
        __extends(NodeWithChildren, _super);
        function NodeWithChildren(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
          get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0
              ? _a
              : null;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
          get: function () {
            return this.children.length > 0
              ? this.children[this.children.length - 1]
              : null;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
          get: function () {
            return this.children;
          },
          set: function (children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true,
        });
        return NodeWithChildren;
      })(Node);
      exports.NodeWithChildren = NodeWithChildren;
      var CDATA = (function (_super) {
        __extends(CDATA, _super);
        function CDATA() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA.prototype, "nodeType", {
          get: function () {
            return 4;
          },
          enumerable: false,
          configurable: true,
        });
        return CDATA;
      })(NodeWithChildren);
      exports.CDATA = CDATA;
      var Document = (function (_super) {
        __extends(Document, _super);
        function Document() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document.prototype, "nodeType", {
          get: function () {
            return 9;
          },
          enumerable: false,
          configurable: true,
        });
        return Document;
      })(NodeWithChildren);
      exports.Document = Document;
      var Element = (function (_super) {
        __extends(Element, _super);
        function Element(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type =
              name === "script"
                ? domelementtype_1.ElementType.Script
                : name === "style"
                  ? domelementtype_1.ElementType.Style
                  : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element.prototype, "nodeType", {
          get: function () {
            return 1;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Element.prototype, "tagName", {
          get: function () {
            return this.name;
          },
          set: function (name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Element.prototype, "attributes", {
          get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace:
                  (_a = _this["x-attribsNamespace"]) === null || _a === void 0
                    ? void 0
                    : _a[name],
                prefix:
                  (_b = _this["x-attribsPrefix"]) === null || _b === void 0
                    ? void 0
                    : _b[name],
              };
            });
          },
          enumerable: false,
          configurable: true,
        });
        return Element;
      })(NodeWithChildren);
      exports.Element = Element;
      function isTag(node) {
        return (0, domelementtype_1.isTag)(node);
      }
      exports.isTag = isTag;
      function isCDATA(node) {
        return node.type === domelementtype_1.ElementType.CDATA;
      }
      exports.isCDATA = isCDATA;
      function isText(node) {
        return node.type === domelementtype_1.ElementType.Text;
      }
      exports.isText = isText;
      function isComment(node) {
        return node.type === domelementtype_1.ElementType.Comment;
      }
      exports.isComment = isComment;
      function isDirective(node) {
        return node.type === domelementtype_1.ElementType.Directive;
      }
      exports.isDirective = isDirective;
      function isDocument(node) {
        return node.type === domelementtype_1.ElementType.Root;
      }
      exports.isDocument = isDocument;
      function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
      }
      exports.hasChildren = hasChildren;
      function cloneNode(node, recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        var result;
        if (isText(node)) {
          result = new Text(node.data);
        } else if (isComment(node)) {
          result = new Comment(node.data);
        } else if (isTag(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_1 = new Element(
            node.name,
            __assign({}, node.attribs),
            children,
          );
          children.forEach(function (child) {
            return (child.parent = clone_1);
          });
          if (node.namespace != null) {
            clone_1.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign(
              {},
              node["x-attribsNamespace"],
            );
          }
          if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
          }
          result = clone_1;
        } else if (isCDATA(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_2 = new CDATA(children);
          children.forEach(function (child) {
            return (child.parent = clone_2);
          });
          result = clone_2;
        } else if (isDocument(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_3 = new Document(children);
          children.forEach(function (child) {
            return (child.parent = clone_3);
          });
          if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
          }
          result = clone_3;
        } else if (isDirective(node)) {
          var instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
        } else {
          throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
      }
      exports.cloneNode = cloneNode;
      function cloneChildren(childs) {
        var children = childs.map(function (child) {
          return cloneNode(child, true);
        });
        for (var i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
        }
        return children;
      }
    },
    8106: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFeed = getFeed;
      var stringify_js_1 = __nccwpck_require__(6047);
      var legacy_js_1 = __nccwpck_require__(3856);
      function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot
          ? null
          : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
      }
      function getAtomFeed(feedRoot) {
        var _a;
        var childs = feedRoot.children;
        var feed = {
          type: "atom",
          items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(
            function (item) {
              var _a;
              var children = item.children;
              var entry = { media: getMediaElements(children) };
              addConditionally(entry, "id", "id", children);
              addConditionally(entry, "title", "title", children);
              var href =
                (_a = getOneElement("link", children)) === null || _a === void 0
                  ? void 0
                  : _a.attribs["href"];
              if (href) {
                entry.link = href;
              }
              var description =
                fetch("summary", children) || fetch("content", children);
              if (description) {
                entry.description = description;
              }
              var pubDate = fetch("updated", children);
              if (pubDate) {
                entry.pubDate = new Date(pubDate);
              }
              return entry;
            },
          ),
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href =
          (_a = getOneElement("link", childs)) === null || _a === void 0
            ? void 0
            : _a.attribs["href"];
        if (href) {
          feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch("updated", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
      }
      function getRssFeed(feedRoot) {
        var _a, _b;
        var childs =
          (_b =
            (_a = getOneElement("channel", feedRoot.children)) === null ||
            _a === void 0
              ? void 0
              : _a.children) !== null && _b !== void 0
            ? _b
            : [];
        var feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: (0, legacy_js_1.getElementsByTagName)(
            "item",
            feedRoot.children,
          ).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate =
              fetch("pubDate", children) || fetch("dc:date", children);
            if (pubDate) entry.pubDate = new Date(pubDate);
            return entry;
          }),
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch("lastBuildDate", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
      }
      var MEDIA_KEYS_STRING = ["url", "type", "lang"];
      var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width",
      ];
      function getMediaElements(where) {
        return (0, legacy_js_1.getElementsByTagName)(
          "media:content",
          where,
        ).map(function (elem) {
          var attribs = elem.attribs;
          var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"],
          };
          for (
            var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;
            _i < MEDIA_KEYS_STRING_1.length;
            _i++
          ) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
              media[attrib] = attribs[attrib];
            }
          }
          for (
            var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;
            _a < MEDIA_KEYS_INT_1.length;
            _a++
          ) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
              media[attrib] = parseInt(attribs[attrib], 10);
            }
          }
          if (attribs["expression"]) {
            media.expression = attribs["expression"];
          }
          return media;
        });
      }
      function getOneElement(tagName, node) {
        return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
      }
      function fetch(tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        return (0, stringify_js_1.textContent)(
          (0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1),
        ).trim();
      }
      function addConditionally(obj, prop, tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        var val = fetch(tagName, where, recurse);
        if (val) obj[prop] = val;
      }
      function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
      }
    },
    9154: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentPosition = void 0;
      exports.removeSubsets = removeSubsets;
      exports.compareDocumentPosition = compareDocumentPosition;
      exports.uniqueSort = uniqueSort;
      var domhandler_1 = __nccwpck_require__(3123);
      function removeSubsets(nodes) {
        var idx = nodes.length;
        while (--idx >= 0) {
          var node = nodes[idx];
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
          }
          for (
            var ancestor = node.parent;
            ancestor;
            ancestor = ancestor.parent
          ) {
            if (nodes.includes(ancestor)) {
              nodes.splice(idx, 1);
              break;
            }
          }
        }
        return nodes;
      }
      var DocumentPosition;
      (function (DocumentPosition) {
        DocumentPosition[(DocumentPosition["DISCONNECTED"] = 1)] =
          "DISCONNECTED";
        DocumentPosition[(DocumentPosition["PRECEDING"] = 2)] = "PRECEDING";
        DocumentPosition[(DocumentPosition["FOLLOWING"] = 4)] = "FOLLOWING";
        DocumentPosition[(DocumentPosition["CONTAINS"] = 8)] = "CONTAINS";
        DocumentPosition[(DocumentPosition["CONTAINED_BY"] = 16)] =
          "CONTAINED_BY";
      })(
        DocumentPosition || (exports.DocumentPosition = DocumentPosition = {}),
      );
      function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
          return 0;
        }
        var current = (0, domhandler_1.hasChildren)(nodeA)
          ? nodeA
          : nodeA.parent;
        while (current) {
          aParents.unshift(current);
          current = current.parent;
        }
        current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
          bParents.unshift(current);
          current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
        }
        if (idx === 0) {
          return DocumentPosition.DISCONNECTED;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
          }
          return DocumentPosition.FOLLOWING;
        }
        if (sharedParent === nodeA) {
          return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
        }
        return DocumentPosition.PRECEDING;
      }
      function uniqueSort(nodes) {
        nodes = nodes.filter(function (node, i, arr) {
          return !arr.includes(node, i + 1);
        });
        nodes.sort(function (a, b) {
          var relative = compareDocumentPosition(a, b);
          if (relative & DocumentPosition.PRECEDING) {
            return -1;
          } else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
          }
          return 0;
        });
        return nodes;
      }
    },
    4279: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasChildren =
        exports.isDocument =
        exports.isComment =
        exports.isText =
        exports.isCDATA =
        exports.isTag =
          void 0;
      __exportStar(__nccwpck_require__(6047), exports);
      __exportStar(__nccwpck_require__(2154), exports);
      __exportStar(__nccwpck_require__(2252), exports);
      __exportStar(__nccwpck_require__(126), exports);
      __exportStar(__nccwpck_require__(3856), exports);
      __exportStar(__nccwpck_require__(9154), exports);
      __exportStar(__nccwpck_require__(8106), exports);
      var domhandler_1 = __nccwpck_require__(3123);
      Object.defineProperty(exports, "isTag", {
        enumerable: true,
        get: function () {
          return domhandler_1.isTag;
        },
      });
      Object.defineProperty(exports, "isCDATA", {
        enumerable: true,
        get: function () {
          return domhandler_1.isCDATA;
        },
      });
      Object.defineProperty(exports, "isText", {
        enumerable: true,
        get: function () {
          return domhandler_1.isText;
        },
      });
      Object.defineProperty(exports, "isComment", {
        enumerable: true,
        get: function () {
          return domhandler_1.isComment;
        },
      });
      Object.defineProperty(exports, "isDocument", {
        enumerable: true,
        get: function () {
          return domhandler_1.isDocument;
        },
      });
      Object.defineProperty(exports, "hasChildren", {
        enumerable: true,
        get: function () {
          return domhandler_1.hasChildren;
        },
      });
    },
    3856: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.testElement = testElement;
      exports.getElements = getElements;
      exports.getElementById = getElementById;
      exports.getElementsByTagName = getElementsByTagName;
      exports.getElementsByClassName = getElementsByClassName;
      exports.getElementsByTagType = getElementsByTagType;
      var domhandler_1 = __nccwpck_require__(3123);
      var querying_js_1 = __nccwpck_require__(126);
      var Checks = {
        tag_name: function (name) {
          if (typeof name === "function") {
            return function (elem) {
              return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
          } else if (name === "*") {
            return domhandler_1.isTag;
          }
          return function (elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
          };
        },
        tag_type: function (type) {
          if (typeof type === "function") {
            return function (elem) {
              return type(elem.type);
            };
          }
          return function (elem) {
            return elem.type === type;
          };
        },
        tag_contains: function (data) {
          if (typeof data === "function") {
            return function (elem) {
              return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
          }
          return function (elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
          };
        },
      };
      function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
          return function (elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
          };
        }
        return function (elem) {
          return (
            (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value
          );
        };
      }
      function combineFuncs(a, b) {
        return function (elem) {
          return a(elem) || b(elem);
        };
      }
      function compileTest(options) {
        var funcs = Object.keys(options).map(function (key) {
          var value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
      }
      function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
      }
      function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) {
          limit = Infinity;
        }
        var test = compileTest(options);
        return test
          ? (0, querying_js_1.filter)(test, nodes, recurse, limit)
          : [];
      }
      function getElementById(id, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (!Array.isArray(nodes)) nodes = [nodes];
        return (0, querying_js_1.findOne)(
          getAttribCheck("id", id),
          nodes,
          recurse,
        );
      }
      function getElementsByTagName(tagName, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(
          Checks["tag_name"](tagName),
          nodes,
          recurse,
          limit,
        );
      }
      function getElementsByClassName(className, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(
          getAttribCheck("class", className),
          nodes,
          recurse,
          limit,
        );
      }
      function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(
          Checks["tag_type"](type),
          nodes,
          recurse,
          limit,
        );
      }
    },
    2252: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.removeElement = removeElement;
      exports.replaceElement = replaceElement;
      exports.appendChild = appendChild;
      exports.append = append;
      exports.prependChild = prependChild;
      exports.prepend = prepend;
      function removeElement(elem) {
        if (elem.prev) elem.prev.next = elem.next;
        if (elem.next) elem.next.prev = elem.prev;
        if (elem.parent) {
          var childs = elem.parent.children;
          var childsIndex = childs.lastIndexOf(elem);
          if (childsIndex >= 0) {
            childs.splice(childsIndex, 1);
          }
        }
        elem.next = null;
        elem.prev = null;
        elem.parent = null;
      }
      function replaceElement(elem, replacement) {
        var prev = (replacement.prev = elem.prev);
        if (prev) {
          prev.next = replacement;
        }
        var next = (replacement.next = elem.next);
        if (next) {
          next.prev = replacement;
        }
        var parent = (replacement.parent = elem.parent);
        if (parent) {
          var childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
          elem.parent = null;
        }
      }
      function appendChild(parent, child) {
        removeElement(child);
        child.next = null;
        child.parent = parent;
        if (parent.children.push(child) > 1) {
          var sibling = parent.children[parent.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
        } else {
          child.prev = null;
        }
      }
      function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
          currNext.prev = next;
          if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
        } else if (parent) {
          parent.children.push(next);
        }
      }
      function prependChild(parent, child) {
        removeElement(child);
        child.parent = parent;
        child.prev = null;
        if (parent.children.unshift(child) !== 1) {
          var sibling = parent.children[1];
          sibling.prev = child;
          child.next = sibling;
        } else {
          child.next = null;
        }
      }
      function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
          elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
      }
    },
    126: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filter = filter;
      exports.find = find;
      exports.findOneChild = findOneChild;
      exports.findOne = findOne;
      exports.existsOne = existsOne;
      exports.findAll = findAll;
      var domhandler_1 = __nccwpck_require__(3123);
      function filter(test, node, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return find(test, Array.isArray(node) ? node : [node], recurse, limit);
      }
      function find(test, nodes, recurse, limit) {
        var result = [];
        var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
        var indexStack = [0];
        for (;;) {
          if (indexStack[0] >= nodeStack[0].length) {
            if (indexStack.length === 1) {
              return result;
            }
            nodeStack.shift();
            indexStack.shift();
            continue;
          }
          var elem = nodeStack[0][indexStack[0]++];
          if (test(elem)) {
            result.push(elem);
            if (--limit <= 0) return result;
          }
          if (
            recurse &&
            (0, domhandler_1.hasChildren)(elem) &&
            elem.children.length > 0
          ) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
          }
        }
      }
      function findOneChild(test, nodes) {
        return nodes.find(test);
      }
      function findOne(test, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
        for (var i = 0; i < searchedNodes.length; i++) {
          var node = searchedNodes[i];
          if ((0, domhandler_1.isTag)(node) && test(node)) {
            return node;
          }
          if (
            recurse &&
            (0, domhandler_1.hasChildren)(node) &&
            node.children.length > 0
          ) {
            var found = findOne(test, node.children, true);
            if (found) return found;
          }
        }
        return null;
      }
      function existsOne(test, nodes) {
        return (Array.isArray(nodes) ? nodes : [nodes]).some(function (node) {
          return (
            ((0, domhandler_1.isTag)(node) && test(node)) ||
            ((0, domhandler_1.hasChildren)(node) &&
              existsOne(test, node.children))
          );
        });
      }
      function findAll(test, nodes) {
        var result = [];
        var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
        var indexStack = [0];
        for (;;) {
          if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
              return result;
            }
            nodeStack.shift();
            indexStack.shift();
            continue;
          }
          var elem = nodeStack[0][indexStack[0]++];
          if ((0, domhandler_1.isTag)(elem) && test(elem)) result.push(elem);
          if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
          }
        }
      }
    },
    6047: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOuterHTML = getOuterHTML;
      exports.getInnerHTML = getInnerHTML;
      exports.getText = getText;
      exports.textContent = textContent;
      exports.innerText = innerText;
      var domhandler_1 = __nccwpck_require__(3123);
      var dom_serializer_1 = __importDefault(__nccwpck_require__(18));
      var domelementtype_1 = __nccwpck_require__(1810);
      function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
      }
      function getInnerHTML(node, options) {
        return (0, domhandler_1.hasChildren)(node)
          ? node.children
              .map(function (node) {
                return getOuterHTML(node, options);
              })
              .join("")
          : "";
      }
      function getText(node) {
        if (Array.isArray(node)) return node.map(getText).join("");
        if ((0, domhandler_1.isTag)(node))
          return node.name === "br" ? "\n" : getText(node.children);
        if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
        if ((0, domhandler_1.isText)(node)) return node.data;
        return "";
      }
      function textContent(node) {
        if (Array.isArray(node)) return node.map(textContent).join("");
        if (
          (0, domhandler_1.hasChildren)(node) &&
          !(0, domhandler_1.isComment)(node)
        ) {
          return textContent(node.children);
        }
        if ((0, domhandler_1.isText)(node)) return node.data;
        return "";
      }
      function innerText(node) {
        if (Array.isArray(node)) return node.map(innerText).join("");
        if (
          (0, domhandler_1.hasChildren)(node) &&
          (node.type === domelementtype_1.ElementType.Tag ||
            (0, domhandler_1.isCDATA)(node))
        ) {
          return innerText(node.children);
        }
        if ((0, domhandler_1.isText)(node)) return node.data;
        return "";
      }
    },
    2154: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getChildren = getChildren;
      exports.getParent = getParent;
      exports.getSiblings = getSiblings;
      exports.getAttributeValue = getAttributeValue;
      exports.hasAttrib = hasAttrib;
      exports.getName = getName;
      exports.nextElementSibling = nextElementSibling;
      exports.prevElementSibling = prevElementSibling;
      var domhandler_1 = __nccwpck_require__(3123);
      function getChildren(elem) {
        return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
      }
      function getParent(elem) {
        return elem.parent || null;
      }
      function getSiblings(elem) {
        var _a, _b;
        var parent = getParent(elem);
        if (parent != null) return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev,
          next = elem.next;
        while (prev != null) {
          siblings.unshift(prev);
          (_a = prev), (prev = _a.prev);
        }
        while (next != null) {
          siblings.push(next);
          (_b = next), (next = _b.next);
        }
        return siblings;
      }
      function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0
          ? void 0
          : _a[name];
      }
      function hasAttrib(elem, name) {
        return (
          elem.attribs != null &&
          Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
          elem.attribs[name] != null
        );
      }
      function getName(elem) {
        return elem.name;
      }
      function nextElementSibling(elem) {
        var _a;
        var next = elem.next;
        while (next !== null && !(0, domhandler_1.isTag)(next))
          (_a = next), (next = _a.next);
        return next;
      }
      function prevElementSibling(elem) {
        var _a;
        var prev = elem.prev;
        while (prev !== null && !(0, domhandler_1.isTag)(prev))
          (_a = prev), (prev = _a.prev);
        return prev;
      }
    },
    3925: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decodeXML =
        exports.decodeHTMLStrict =
        exports.decodeHTMLAttribute =
        exports.decodeHTML =
        exports.determineBranch =
        exports.EntityDecoder =
        exports.DecodingMode =
        exports.BinTrieFlags =
        exports.fromCodePoint =
        exports.replaceCodePoint =
        exports.decodeCodePoint =
        exports.xmlDecodeTree =
        exports.htmlDecodeTree =
          void 0;
      var decode_data_html_js_1 = __importDefault(__nccwpck_require__(1644));
      exports.htmlDecodeTree = decode_data_html_js_1.default;
      var decode_data_xml_js_1 = __importDefault(__nccwpck_require__(4006));
      exports.xmlDecodeTree = decode_data_xml_js_1.default;
      var decode_codepoint_js_1 = __importStar(__nccwpck_require__(128));
      exports.decodeCodePoint = decode_codepoint_js_1.default;
      var decode_codepoint_js_2 = __nccwpck_require__(128);
      Object.defineProperty(exports, "replaceCodePoint", {
        enumerable: true,
        get: function () {
          return decode_codepoint_js_2.replaceCodePoint;
        },
      });
      Object.defineProperty(exports, "fromCodePoint", {
        enumerable: true,
        get: function () {
          return decode_codepoint_js_2.fromCodePoint;
        },
      });
      var CharCodes;
      (function (CharCodes) {
        CharCodes[(CharCodes["NUM"] = 35)] = "NUM";
        CharCodes[(CharCodes["SEMI"] = 59)] = "SEMI";
        CharCodes[(CharCodes["EQUALS"] = 61)] = "EQUALS";
        CharCodes[(CharCodes["ZERO"] = 48)] = "ZERO";
        CharCodes[(CharCodes["NINE"] = 57)] = "NINE";
        CharCodes[(CharCodes["LOWER_A"] = 97)] = "LOWER_A";
        CharCodes[(CharCodes["LOWER_F"] = 102)] = "LOWER_F";
        CharCodes[(CharCodes["LOWER_X"] = 120)] = "LOWER_X";
        CharCodes[(CharCodes["LOWER_Z"] = 122)] = "LOWER_Z";
        CharCodes[(CharCodes["UPPER_A"] = 65)] = "UPPER_A";
        CharCodes[(CharCodes["UPPER_F"] = 70)] = "UPPER_F";
        CharCodes[(CharCodes["UPPER_Z"] = 90)] = "UPPER_Z";
      })(CharCodes || (CharCodes = {}));
      var TO_LOWER_BIT = 32;
      var BinTrieFlags;
      (function (BinTrieFlags) {
        BinTrieFlags[(BinTrieFlags["VALUE_LENGTH"] = 49152)] = "VALUE_LENGTH";
        BinTrieFlags[(BinTrieFlags["BRANCH_LENGTH"] = 16256)] = "BRANCH_LENGTH";
        BinTrieFlags[(BinTrieFlags["JUMP_TABLE"] = 127)] = "JUMP_TABLE";
      })((BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {})));
      function isNumber(code) {
        return code >= CharCodes.ZERO && code <= CharCodes.NINE;
      }
      function isHexadecimalCharacter(code) {
        return (
          (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
          (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)
        );
      }
      function isAsciiAlphaNumeric(code) {
        return (
          (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
          (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
          isNumber(code)
        );
      }
      function isEntityInAttributeInvalidEnd(code) {
        return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
      }
      var EntityDecoderState;
      (function (EntityDecoderState) {
        EntityDecoderState[(EntityDecoderState["EntityStart"] = 0)] =
          "EntityStart";
        EntityDecoderState[(EntityDecoderState["NumericStart"] = 1)] =
          "NumericStart";
        EntityDecoderState[(EntityDecoderState["NumericDecimal"] = 2)] =
          "NumericDecimal";
        EntityDecoderState[(EntityDecoderState["NumericHex"] = 3)] =
          "NumericHex";
        EntityDecoderState[(EntityDecoderState["NamedEntity"] = 4)] =
          "NamedEntity";
      })(EntityDecoderState || (EntityDecoderState = {}));
      var DecodingMode;
      (function (DecodingMode) {
        DecodingMode[(DecodingMode["Legacy"] = 0)] = "Legacy";
        DecodingMode[(DecodingMode["Strict"] = 1)] = "Strict";
        DecodingMode[(DecodingMode["Attribute"] = 2)] = "Attribute";
      })((DecodingMode = exports.DecodingMode || (exports.DecodingMode = {})));
      var EntityDecoder = (function () {
        function EntityDecoder(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder.prototype.startEntity = function (decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder.prototype.write = function (str, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder.prototype.stateNumericStart = function (str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder.prototype.addToNumericResult = function (
          str,
          start,
          end,
          base,
        ) {
          if (start !== end) {
            var digitCount = end - start;
            this.result =
              this.result * Math.pow(base, digitCount) +
              parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder.prototype.stateNumericHex = function (str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder.prototype.emitNumericEntity = function (
          lastCp,
          expectedLength,
        ) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0
              ? void 0
              : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint(
            (0, decode_codepoint_js_1.replaceCodePoint)(this.result),
            this.consumed,
          );
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder.prototype.stateNamedEntity = function (str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(
              decodeTree,
              current,
              this.treeIndex + Math.max(1, valueLength),
              char,
            );
            if (this.treeIndex < 0) {
              return this.result === 0 ||
                (this.decodeMode === DecodingMode.Attribute &&
                  (valueLength === 0 || isEntityInAttributeInvalidEnd(char)))
                ? 0
                : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(
                  this.treeIndex,
                  valueLength,
                  this.consumed + this.excess,
                );
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {
          var _a;
          var _b = this,
            result = _b.result,
            decodeTree = _b.decodeTree;
          var valueLength =
            (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0
            ? void 0
            : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder.prototype.emitNamedEntityData = function (
          result,
          valueLength,
          consumed,
        ) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(
            valueLength === 1
              ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
              : decodeTree[result + 1],
            consumed,
          );
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder.prototype.end = function () {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 &&
                (this.decodeMode !== DecodingMode.Attribute ||
                  this.result === this.treeIndex)
                ? this.emitNotTerminatedNamedEntity()
                : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0
                ? void 0
                : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder;
      })();
      exports.EntityDecoder = EntityDecoder;
      function getDecoder(decodeTree) {
        var ret = "";
        var decoder = new EntityDecoder(decodeTree, function (str) {
          return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str));
        });
        return function decodeWithTrie(str, decodeMode) {
          var lastIndex = 0;
          var offset = 0;
          while ((offset = str.indexOf("&", offset)) >= 0) {
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            var len = decoder.write(str, offset + 1);
            if (len < 0) {
              lastIndex = offset + decoder.end();
              break;
            }
            lastIndex = offset + len;
            offset = len === 0 ? lastIndex + 1 : lastIndex;
          }
          var result = ret + str.slice(lastIndex);
          ret = "";
          return result;
        };
      }
      function determineBranch(decodeTree, current, nodeIdx, char) {
        var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        if (jumpOffset) {
          var value = char - jumpOffset;
          return value < 0 || value >= branchCount
            ? -1
            : decodeTree[nodeIdx + value] - 1;
        }
        var lo = nodeIdx;
        var hi = lo + branchCount - 1;
        while (lo <= hi) {
          var mid = (lo + hi) >>> 1;
          var midVal = decodeTree[mid];
          if (midVal < char) {
            lo = mid + 1;
          } else if (midVal > char) {
            hi = mid - 1;
          } else {
            return decodeTree[mid + branchCount];
          }
        }
        return -1;
      }
      exports.determineBranch = determineBranch;
      var htmlDecoder = getDecoder(decode_data_html_js_1.default);
      var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
      function decodeHTML(str, mode) {
        if (mode === void 0) {
          mode = DecodingMode.Legacy;
        }
        return htmlDecoder(str, mode);
      }
      exports.decodeHTML = decodeHTML;
      function decodeHTMLAttribute(str) {
        return htmlDecoder(str, DecodingMode.Attribute);
      }
      exports.decodeHTMLAttribute = decodeHTMLAttribute;
      function decodeHTMLStrict(str) {
        return htmlDecoder(str, DecodingMode.Strict);
      }
      exports.decodeHTMLStrict = decodeHTMLStrict;
      function decodeXML(str) {
        return xmlDecoder(str, DecodingMode.Strict);
      }
      exports.decodeXML = decodeXML;
    },
    128: (__unused_webpack_module, exports) => {
      "use strict";
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.replaceCodePoint = exports.fromCodePoint = void 0;
      var decodeMap = new Map([
        [0, 65533],
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
      ]);
      exports.fromCodePoint =
        (_a = String.fromCodePoint) !== null && _a !== void 0
          ? _a
          : function (codePoint) {
              var output = "";
              if (codePoint > 65535) {
                codePoint -= 65536;
                output += String.fromCharCode(
                  ((codePoint >>> 10) & 1023) | 55296,
                );
                codePoint = 56320 | (codePoint & 1023);
              }
              output += String.fromCharCode(codePoint);
              return output;
            };
      function replaceCodePoint(codePoint) {
        var _a;
        if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
          return 65533;
        }
        return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0
          ? _a
          : codePoint;
      }
      exports.replaceCodePoint = replaceCodePoint;
      function decodeCodePoint(codePoint) {
        return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
      }
      exports["default"] = decodeCodePoint;
    },
    6844: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
      var encode_html_js_1 = __importDefault(__nccwpck_require__(4675));
      var escape_js_1 = __nccwpck_require__(4055);
      var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
      function encodeHTML(data) {
        return encodeHTMLTrieRe(htmlReplacer, data);
      }
      exports.encodeHTML = encodeHTML;
      function encodeNonAsciiHTML(data) {
        return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
      }
      exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
      function encodeHTMLTrieRe(regExp, str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = regExp.exec(str)) !== null) {
          var i = match.index;
          ret += str.substring(lastIdx, i);
          var char = str.charCodeAt(i);
          var next = encode_html_js_1.default.get(char);
          if (typeof next === "object") {
            if (i + 1 < str.length) {
              var nextChar = str.charCodeAt(i + 1);
              var value =
                typeof next.n === "number"
                  ? next.n === nextChar
                    ? next.o
                    : undefined
                  : next.n.get(nextChar);
              if (value !== undefined) {
                ret += value;
                lastIdx = regExp.lastIndex += 1;
                continue;
              }
            }
            next = next.v;
          }
          if (next !== undefined) {
            ret += next;
            lastIdx = i + 1;
          } else {
            var cp = (0, escape_js_1.getCodePoint)(str, i);
            ret += "&#x".concat(cp.toString(16), ";");
            lastIdx = regExp.lastIndex += Number(cp !== char);
          }
        }
        return ret + str.substr(lastIdx);
      }
    },
    4055: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.escapeText =
        exports.escapeAttribute =
        exports.escapeUTF8 =
        exports.escape =
        exports.encodeXML =
        exports.getCodePoint =
        exports.xmlReplacer =
          void 0;
      exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
      var xmlCodeMap = new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"],
      ]);
      exports.getCodePoint =
        String.prototype.codePointAt != null
          ? function (str, index) {
              return str.codePointAt(index);
            }
          : function (c, index) {
              return (c.charCodeAt(index) & 64512) === 55296
                ? (c.charCodeAt(index) - 55296) * 1024 +
                    c.charCodeAt(index + 1) -
                    56320 +
                    65536
                : c.charCodeAt(index);
            };
      function encodeXML(str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = exports.xmlReplacer.exec(str)) !== null) {
          var i = match.index;
          var char = str.charCodeAt(i);
          var next = xmlCodeMap.get(char);
          if (next !== undefined) {
            ret += str.substring(lastIdx, i) + next;
            lastIdx = i + 1;
          } else {
            ret += ""
              .concat(str.substring(lastIdx, i), "&#x")
              .concat((0, exports.getCodePoint)(str, i).toString(16), ";");
            lastIdx = exports.xmlReplacer.lastIndex += Number(
              (char & 64512) === 55296,
            );
          }
        }
        return ret + str.substr(lastIdx);
      }
      exports.encodeXML = encodeXML;
      exports.escape = encodeXML;
      function getEscaper(regex, map) {
        return function escape(data) {
          var match;
          var lastIdx = 0;
          var result = "";
          while ((match = regex.exec(data))) {
            if (lastIdx !== match.index) {
              result += data.substring(lastIdx, match.index);
            }
            result += map.get(match[0].charCodeAt(0));
            lastIdx = match.index + 1;
          }
          return result + data.substring(lastIdx);
        };
      }
      exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
      exports.escapeAttribute = getEscaper(
        /["&\u00A0]/g,
        new Map([
          [34, "&quot;"],
          [38, "&amp;"],
          [160, "&nbsp;"],
        ]),
      );
      exports.escapeText = getEscaper(
        /[&<>\u00A0]/g,
        new Map([
          [38, "&amp;"],
          [60, "&lt;"],
          [62, "&gt;"],
          [160, "&nbsp;"],
        ]),
      );
    },
    1644: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports["default"] = new Uint16Array(
        'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'
          .split("")
          .map(function (c) {
            return c.charCodeAt(0);
          }),
      );
    },
    4006: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports["default"] = new Uint16Array(
        "Ȁaglq\tɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map(function (c) {
          return c.charCodeAt(0);
        }),
      );
    },
    4675: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function restoreDiff(arr) {
        for (var i = 1; i < arr.length; i++) {
          arr[i][0] += arr[i - 1][0] + 1;
        }
        return arr;
      }
      exports["default"] = new Map(
        restoreDiff([
          [9, "&Tab;"],
          [0, "&NewLine;"],
          [22, "&excl;"],
          [0, "&quot;"],
          [0, "&num;"],
          [0, "&dollar;"],
          [0, "&percnt;"],
          [0, "&amp;"],
          [0, "&apos;"],
          [0, "&lpar;"],
          [0, "&rpar;"],
          [0, "&ast;"],
          [0, "&plus;"],
          [0, "&comma;"],
          [1, "&period;"],
          [0, "&sol;"],
          [10, "&colon;"],
          [0, "&semi;"],
          [0, { v: "&lt;", n: 8402, o: "&nvlt;" }],
          [0, { v: "&equals;", n: 8421, o: "&bne;" }],
          [0, { v: "&gt;", n: 8402, o: "&nvgt;" }],
          [0, "&quest;"],
          [0, "&commat;"],
          [26, "&lbrack;"],
          [0, "&bsol;"],
          [0, "&rbrack;"],
          [0, "&Hat;"],
          [0, "&lowbar;"],
          [0, "&DiacriticalGrave;"],
          [5, { n: 106, o: "&fjlig;" }],
          [20, "&lbrace;"],
          [0, "&verbar;"],
          [0, "&rbrace;"],
          [34, "&nbsp;"],
          [0, "&iexcl;"],
          [0, "&cent;"],
          [0, "&pound;"],
          [0, "&curren;"],
          [0, "&yen;"],
          [0, "&brvbar;"],
          [0, "&sect;"],
          [0, "&die;"],
          [0, "&copy;"],
          [0, "&ordf;"],
          [0, "&laquo;"],
          [0, "&not;"],
          [0, "&shy;"],
          [0, "&circledR;"],
          [0, "&macr;"],
          [0, "&deg;"],
          [0, "&PlusMinus;"],
          [0, "&sup2;"],
          [0, "&sup3;"],
          [0, "&acute;"],
          [0, "&micro;"],
          [0, "&para;"],
          [0, "&centerdot;"],
          [0, "&cedil;"],
          [0, "&sup1;"],
          [0, "&ordm;"],
          [0, "&raquo;"],
          [0, "&frac14;"],
          [0, "&frac12;"],
          [0, "&frac34;"],
          [0, "&iquest;"],
          [0, "&Agrave;"],
          [0, "&Aacute;"],
          [0, "&Acirc;"],
          [0, "&Atilde;"],
          [0, "&Auml;"],
          [0, "&angst;"],
          [0, "&AElig;"],
          [0, "&Ccedil;"],
          [0, "&Egrave;"],
          [0, "&Eacute;"],
          [0, "&Ecirc;"],
          [0, "&Euml;"],
          [0, "&Igrave;"],
          [0, "&Iacute;"],
          [0, "&Icirc;"],
          [0, "&Iuml;"],
          [0, "&ETH;"],
          [0, "&Ntilde;"],
          [0, "&Ograve;"],
          [0, "&Oacute;"],
          [0, "&Ocirc;"],
          [0, "&Otilde;"],
          [0, "&Ouml;"],
          [0, "&times;"],
          [0, "&Oslash;"],
          [0, "&Ugrave;"],
          [0, "&Uacute;"],
          [0, "&Ucirc;"],
          [0, "&Uuml;"],
          [0, "&Yacute;"],
          [0, "&THORN;"],
          [0, "&szlig;"],
          [0, "&agrave;"],
          [0, "&aacute;"],
          [0, "&acirc;"],
          [0, "&atilde;"],
          [0, "&auml;"],
          [0, "&aring;"],
          [0, "&aelig;"],
          [0, "&ccedil;"],
          [0, "&egrave;"],
          [0, "&eacute;"],
          [0, "&ecirc;"],
          [0, "&euml;"],
          [0, "&igrave;"],
          [0, "&iacute;"],
          [0, "&icirc;"],
          [0, "&iuml;"],
          [0, "&eth;"],
          [0, "&ntilde;"],
          [0, "&ograve;"],
          [0, "&oacute;"],
          [0, "&ocirc;"],
          [0, "&otilde;"],
          [0, "&ouml;"],
          [0, "&div;"],
          [0, "&oslash;"],
          [0, "&ugrave;"],
          [0, "&uacute;"],
          [0, "&ucirc;"],
          [0, "&uuml;"],
          [0, "&yacute;"],
          [0, "&thorn;"],
          [0, "&yuml;"],
          [0, "&Amacr;"],
          [0, "&amacr;"],
          [0, "&Abreve;"],
          [0, "&abreve;"],
          [0, "&Aogon;"],
          [0, "&aogon;"],
          [0, "&Cacute;"],
          [0, "&cacute;"],
          [0, "&Ccirc;"],
          [0, "&ccirc;"],
          [0, "&Cdot;"],
          [0, "&cdot;"],
          [0, "&Ccaron;"],
          [0, "&ccaron;"],
          [0, "&Dcaron;"],
          [0, "&dcaron;"],
          [0, "&Dstrok;"],
          [0, "&dstrok;"],
          [0, "&Emacr;"],
          [0, "&emacr;"],
          [2, "&Edot;"],
          [0, "&edot;"],
          [0, "&Eogon;"],
          [0, "&eogon;"],
          [0, "&Ecaron;"],
          [0, "&ecaron;"],
          [0, "&Gcirc;"],
          [0, "&gcirc;"],
          [0, "&Gbreve;"],
          [0, "&gbreve;"],
          [0, "&Gdot;"],
          [0, "&gdot;"],
          [0, "&Gcedil;"],
          [1, "&Hcirc;"],
          [0, "&hcirc;"],
          [0, "&Hstrok;"],
          [0, "&hstrok;"],
          [0, "&Itilde;"],
          [0, "&itilde;"],
          [0, "&Imacr;"],
          [0, "&imacr;"],
          [2, "&Iogon;"],
          [0, "&iogon;"],
          [0, "&Idot;"],
          [0, "&imath;"],
          [0, "&IJlig;"],
          [0, "&ijlig;"],
          [0, "&Jcirc;"],
          [0, "&jcirc;"],
          [0, "&Kcedil;"],
          [0, "&kcedil;"],
          [0, "&kgreen;"],
          [0, "&Lacute;"],
          [0, "&lacute;"],
          [0, "&Lcedil;"],
          [0, "&lcedil;"],
          [0, "&Lcaron;"],
          [0, "&lcaron;"],
          [0, "&Lmidot;"],
          [0, "&lmidot;"],
          [0, "&Lstrok;"],
          [0, "&lstrok;"],
          [0, "&Nacute;"],
          [0, "&nacute;"],
          [0, "&Ncedil;"],
          [0, "&ncedil;"],
          [0, "&Ncaron;"],
          [0, "&ncaron;"],
          [0, "&napos;"],
          [0, "&ENG;"],
          [0, "&eng;"],
          [0, "&Omacr;"],
          [0, "&omacr;"],
          [2, "&Odblac;"],
          [0, "&odblac;"],
          [0, "&OElig;"],
          [0, "&oelig;"],
          [0, "&Racute;"],
          [0, "&racute;"],
          [0, "&Rcedil;"],
          [0, "&rcedil;"],
          [0, "&Rcaron;"],
          [0, "&rcaron;"],
          [0, "&Sacute;"],
          [0, "&sacute;"],
          [0, "&Scirc;"],
          [0, "&scirc;"],
          [0, "&Scedil;"],
          [0, "&scedil;"],
          [0, "&Scaron;"],
          [0, "&scaron;"],
          [0, "&Tcedil;"],
          [0, "&tcedil;"],
          [0, "&Tcaron;"],
          [0, "&tcaron;"],
          [0, "&Tstrok;"],
          [0, "&tstrok;"],
          [0, "&Utilde;"],
          [0, "&utilde;"],
          [0, "&Umacr;"],
          [0, "&umacr;"],
          [0, "&Ubreve;"],
          [0, "&ubreve;"],
          [0, "&Uring;"],
          [0, "&uring;"],
          [0, "&Udblac;"],
          [0, "&udblac;"],
          [0, "&Uogon;"],
          [0, "&uogon;"],
          [0, "&Wcirc;"],
          [0, "&wcirc;"],
          [0, "&Ycirc;"],
          [0, "&ycirc;"],
          [0, "&Yuml;"],
          [0, "&Zacute;"],
          [0, "&zacute;"],
          [0, "&Zdot;"],
          [0, "&zdot;"],
          [0, "&Zcaron;"],
          [0, "&zcaron;"],
          [19, "&fnof;"],
          [34, "&imped;"],
          [63, "&gacute;"],
          [65, "&jmath;"],
          [142, "&circ;"],
          [0, "&caron;"],
          [16, "&breve;"],
          [0, "&DiacriticalDot;"],
          [0, "&ring;"],
          [0, "&ogon;"],
          [0, "&DiacriticalTilde;"],
          [0, "&dblac;"],
          [51, "&DownBreve;"],
          [127, "&Alpha;"],
          [0, "&Beta;"],
          [0, "&Gamma;"],
          [0, "&Delta;"],
          [0, "&Epsilon;"],
          [0, "&Zeta;"],
          [0, "&Eta;"],
          [0, "&Theta;"],
          [0, "&Iota;"],
          [0, "&Kappa;"],
          [0, "&Lambda;"],
          [0, "&Mu;"],
          [0, "&Nu;"],
          [0, "&Xi;"],
          [0, "&Omicron;"],
          [0, "&Pi;"],
          [0, "&Rho;"],
          [1, "&Sigma;"],
          [0, "&Tau;"],
          [0, "&Upsilon;"],
          [0, "&Phi;"],
          [0, "&Chi;"],
          [0, "&Psi;"],
          [0, "&ohm;"],
          [7, "&alpha;"],
          [0, "&beta;"],
          [0, "&gamma;"],
          [0, "&delta;"],
          [0, "&epsi;"],
          [0, "&zeta;"],
          [0, "&eta;"],
          [0, "&theta;"],
          [0, "&iota;"],
          [0, "&kappa;"],
          [0, "&lambda;"],
          [0, "&mu;"],
          [0, "&nu;"],
          [0, "&xi;"],
          [0, "&omicron;"],
          [0, "&pi;"],
          [0, "&rho;"],
          [0, "&sigmaf;"],
          [0, "&sigma;"],
          [0, "&tau;"],
          [0, "&upsi;"],
          [0, "&phi;"],
          [0, "&chi;"],
          [0, "&psi;"],
          [0, "&omega;"],
          [7, "&thetasym;"],
          [0, "&Upsi;"],
          [2, "&phiv;"],
          [0, "&piv;"],
          [5, "&Gammad;"],
          [0, "&digamma;"],
          [18, "&kappav;"],
          [0, "&rhov;"],
          [3, "&epsiv;"],
          [0, "&backepsilon;"],
          [10, "&IOcy;"],
          [0, "&DJcy;"],
          [0, "&GJcy;"],
          [0, "&Jukcy;"],
          [0, "&DScy;"],
          [0, "&Iukcy;"],
          [0, "&YIcy;"],
          [0, "&Jsercy;"],
          [0, "&LJcy;"],
          [0, "&NJcy;"],
          [0, "&TSHcy;"],
          [0, "&KJcy;"],
          [1, "&Ubrcy;"],
          [0, "&DZcy;"],
          [0, "&Acy;"],
          [0, "&Bcy;"],
          [0, "&Vcy;"],
          [0, "&Gcy;"],
          [0, "&Dcy;"],
          [0, "&IEcy;"],
          [0, "&ZHcy;"],
          [0, "&Zcy;"],
          [0, "&Icy;"],
          [0, "&Jcy;"],
          [0, "&Kcy;"],
          [0, "&Lcy;"],
          [0, "&Mcy;"],
          [0, "&Ncy;"],
          [0, "&Ocy;"],
          [0, "&Pcy;"],
          [0, "&Rcy;"],
          [0, "&Scy;"],
          [0, "&Tcy;"],
          [0, "&Ucy;"],
          [0, "&Fcy;"],
          [0, "&KHcy;"],
          [0, "&TScy;"],
          [0, "&CHcy;"],
          [0, "&SHcy;"],
          [0, "&SHCHcy;"],
          [0, "&HARDcy;"],
          [0, "&Ycy;"],
          [0, "&SOFTcy;"],
          [0, "&Ecy;"],
          [0, "&YUcy;"],
          [0, "&YAcy;"],
          [0, "&acy;"],
          [0, "&bcy;"],
          [0, "&vcy;"],
          [0, "&gcy;"],
          [0, "&dcy;"],
          [0, "&iecy;"],
          [0, "&zhcy;"],
          [0, "&zcy;"],
          [0, "&icy;"],
          [0, "&jcy;"],
          [0, "&kcy;"],
          [0, "&lcy;"],
          [0, "&mcy;"],
          [0, "&ncy;"],
          [0, "&ocy;"],
          [0, "&pcy;"],
          [0, "&rcy;"],
          [0, "&scy;"],
          [0, "&tcy;"],
          [0, "&ucy;"],
          [0, "&fcy;"],
          [0, "&khcy;"],
          [0, "&tscy;"],
          [0, "&chcy;"],
          [0, "&shcy;"],
          [0, "&shchcy;"],
          [0, "&hardcy;"],
          [0, "&ycy;"],
          [0, "&softcy;"],
          [0, "&ecy;"],
          [0, "&yucy;"],
          [0, "&yacy;"],
          [1, "&iocy;"],
          [0, "&djcy;"],
          [0, "&gjcy;"],
          [0, "&jukcy;"],
          [0, "&dscy;"],
          [0, "&iukcy;"],
          [0, "&yicy;"],
          [0, "&jsercy;"],
          [0, "&ljcy;"],
          [0, "&njcy;"],
          [0, "&tshcy;"],
          [0, "&kjcy;"],
          [1, "&ubrcy;"],
          [0, "&dzcy;"],
          [7074, "&ensp;"],
          [0, "&emsp;"],
          [0, "&emsp13;"],
          [0, "&emsp14;"],
          [1, "&numsp;"],
          [0, "&puncsp;"],
          [0, "&ThinSpace;"],
          [0, "&hairsp;"],
          [0, "&NegativeMediumSpace;"],
          [0, "&zwnj;"],
          [0, "&zwj;"],
          [0, "&lrm;"],
          [0, "&rlm;"],
          [0, "&dash;"],
          [2, "&ndash;"],
          [0, "&mdash;"],
          [0, "&horbar;"],
          [0, "&Verbar;"],
          [1, "&lsquo;"],
          [0, "&CloseCurlyQuote;"],
          [0, "&lsquor;"],
          [1, "&ldquo;"],
          [0, "&CloseCurlyDoubleQuote;"],
          [0, "&bdquo;"],
          [1, "&dagger;"],
          [0, "&Dagger;"],
          [0, "&bull;"],
          [2, "&nldr;"],
          [0, "&hellip;"],
          [9, "&permil;"],
          [0, "&pertenk;"],
          [0, "&prime;"],
          [0, "&Prime;"],
          [0, "&tprime;"],
          [0, "&backprime;"],
          [3, "&lsaquo;"],
          [0, "&rsaquo;"],
          [3, "&oline;"],
          [2, "&caret;"],
          [1, "&hybull;"],
          [0, "&frasl;"],
          [10, "&bsemi;"],
          [7, "&qprime;"],
          [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }],
          [0, "&NoBreak;"],
          [0, "&af;"],
          [0, "&InvisibleTimes;"],
          [0, "&ic;"],
          [72, "&euro;"],
          [46, "&tdot;"],
          [0, "&DotDot;"],
          [37, "&complexes;"],
          [2, "&incare;"],
          [4, "&gscr;"],
          [0, "&hamilt;"],
          [0, "&Hfr;"],
          [0, "&Hopf;"],
          [0, "&planckh;"],
          [0, "&hbar;"],
          [0, "&imagline;"],
          [0, "&Ifr;"],
          [0, "&lagran;"],
          [0, "&ell;"],
          [1, "&naturals;"],
          [0, "&numero;"],
          [0, "&copysr;"],
          [0, "&weierp;"],
          [0, "&Popf;"],
          [0, "&Qopf;"],
          [0, "&realine;"],
          [0, "&real;"],
          [0, "&reals;"],
          [0, "&rx;"],
          [3, "&trade;"],
          [1, "&integers;"],
          [2, "&mho;"],
          [0, "&zeetrf;"],
          [0, "&iiota;"],
          [2, "&bernou;"],
          [0, "&Cayleys;"],
          [1, "&escr;"],
          [0, "&Escr;"],
          [0, "&Fouriertrf;"],
          [1, "&Mellintrf;"],
          [0, "&order;"],
          [0, "&alefsym;"],
          [0, "&beth;"],
          [0, "&gimel;"],
          [0, "&daleth;"],
          [12, "&CapitalDifferentialD;"],
          [0, "&dd;"],
          [0, "&ee;"],
          [0, "&ii;"],
          [10, "&frac13;"],
          [0, "&frac23;"],
          [0, "&frac15;"],
          [0, "&frac25;"],
          [0, "&frac35;"],
          [0, "&frac45;"],
          [0, "&frac16;"],
          [0, "&frac56;"],
          [0, "&frac18;"],
          [0, "&frac38;"],
          [0, "&frac58;"],
          [0, "&frac78;"],
          [49, "&larr;"],
          [0, "&ShortUpArrow;"],
          [0, "&rarr;"],
          [0, "&darr;"],
          [0, "&harr;"],
          [0, "&updownarrow;"],
          [0, "&nwarr;"],
          [0, "&nearr;"],
          [0, "&LowerRightArrow;"],
          [0, "&LowerLeftArrow;"],
          [0, "&nlarr;"],
          [0, "&nrarr;"],
          [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }],
          [0, "&Larr;"],
          [0, "&Uarr;"],
          [0, "&Rarr;"],
          [0, "&Darr;"],
          [0, "&larrtl;"],
          [0, "&rarrtl;"],
          [0, "&LeftTeeArrow;"],
          [0, "&mapstoup;"],
          [0, "&map;"],
          [0, "&DownTeeArrow;"],
          [1, "&hookleftarrow;"],
          [0, "&hookrightarrow;"],
          [0, "&larrlp;"],
          [0, "&looparrowright;"],
          [0, "&harrw;"],
          [0, "&nharr;"],
          [1, "&lsh;"],
          [0, "&rsh;"],
          [0, "&ldsh;"],
          [0, "&rdsh;"],
          [1, "&crarr;"],
          [0, "&cularr;"],
          [0, "&curarr;"],
          [2, "&circlearrowleft;"],
          [0, "&circlearrowright;"],
          [0, "&leftharpoonup;"],
          [0, "&DownLeftVector;"],
          [0, "&RightUpVector;"],
          [0, "&LeftUpVector;"],
          [0, "&rharu;"],
          [0, "&DownRightVector;"],
          [0, "&dharr;"],
          [0, "&dharl;"],
          [0, "&RightArrowLeftArrow;"],
          [0, "&udarr;"],
          [0, "&LeftArrowRightArrow;"],
          [0, "&leftleftarrows;"],
          [0, "&upuparrows;"],
          [0, "&rightrightarrows;"],
          [0, "&ddarr;"],
          [0, "&leftrightharpoons;"],
          [0, "&Equilibrium;"],
          [0, "&nlArr;"],
          [0, "&nhArr;"],
          [0, "&nrArr;"],
          [0, "&DoubleLeftArrow;"],
          [0, "&DoubleUpArrow;"],
          [0, "&DoubleRightArrow;"],
          [0, "&dArr;"],
          [0, "&DoubleLeftRightArrow;"],
          [0, "&DoubleUpDownArrow;"],
          [0, "&nwArr;"],
          [0, "&neArr;"],
          [0, "&seArr;"],
          [0, "&swArr;"],
          [0, "&lAarr;"],
          [0, "&rAarr;"],
          [1, "&zigrarr;"],
          [6, "&larrb;"],
          [0, "&rarrb;"],
          [15, "&DownArrowUpArrow;"],
          [7, "&loarr;"],
          [0, "&roarr;"],
          [0, "&hoarr;"],
          [0, "&forall;"],
          [0, "&comp;"],
          [0, { v: "&part;", n: 824, o: "&npart;" }],
          [0, "&exist;"],
          [0, "&nexist;"],
          [0, "&empty;"],
          [1, "&Del;"],
          [0, "&Element;"],
          [0, "&NotElement;"],
          [1, "&ni;"],
          [0, "&notni;"],
          [2, "&prod;"],
          [0, "&coprod;"],
          [0, "&sum;"],
          [0, "&minus;"],
          [0, "&MinusPlus;"],
          [0, "&dotplus;"],
          [1, "&Backslash;"],
          [0, "&lowast;"],
          [0, "&compfn;"],
          [1, "&radic;"],
          [2, "&prop;"],
          [0, "&infin;"],
          [0, "&angrt;"],
          [0, { v: "&ang;", n: 8402, o: "&nang;" }],
          [0, "&angmsd;"],
          [0, "&angsph;"],
          [0, "&mid;"],
          [0, "&nmid;"],
          [0, "&DoubleVerticalBar;"],
          [0, "&NotDoubleVerticalBar;"],
          [0, "&and;"],
          [0, "&or;"],
          [0, { v: "&cap;", n: 65024, o: "&caps;" }],
          [0, { v: "&cup;", n: 65024, o: "&cups;" }],
          [0, "&int;"],
          [0, "&Int;"],
          [0, "&iiint;"],
          [0, "&conint;"],
          [0, "&Conint;"],
          [0, "&Cconint;"],
          [0, "&cwint;"],
          [0, "&ClockwiseContourIntegral;"],
          [0, "&awconint;"],
          [0, "&there4;"],
          [0, "&becaus;"],
          [0, "&ratio;"],
          [0, "&Colon;"],
          [0, "&dotminus;"],
          [1, "&mDDot;"],
          [0, "&homtht;"],
          [0, { v: "&sim;", n: 8402, o: "&nvsim;" }],
          [0, { v: "&backsim;", n: 817, o: "&race;" }],
          [0, { v: "&ac;", n: 819, o: "&acE;" }],
          [0, "&acd;"],
          [0, "&VerticalTilde;"],
          [0, "&NotTilde;"],
          [0, { v: "&eqsim;", n: 824, o: "&nesim;" }],
          [0, "&sime;"],
          [0, "&NotTildeEqual;"],
          [0, "&cong;"],
          [0, "&simne;"],
          [0, "&ncong;"],
          [0, "&ap;"],
          [0, "&nap;"],
          [0, "&ape;"],
          [0, { v: "&apid;", n: 824, o: "&napid;" }],
          [0, "&backcong;"],
          [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }],
          [0, { v: "&bump;", n: 824, o: "&nbump;" }],
          [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }],
          [0, { v: "&doteq;", n: 824, o: "&nedot;" }],
          [0, "&doteqdot;"],
          [0, "&efDot;"],
          [0, "&erDot;"],
          [0, "&Assign;"],
          [0, "&ecolon;"],
          [0, "&ecir;"],
          [0, "&circeq;"],
          [1, "&wedgeq;"],
          [0, "&veeeq;"],
          [1, "&triangleq;"],
          [2, "&equest;"],
          [0, "&ne;"],
          [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }],
          [0, "&nequiv;"],
          [1, { v: "&le;", n: 8402, o: "&nvle;" }],
          [0, { v: "&ge;", n: 8402, o: "&nvge;" }],
          [0, { v: "&lE;", n: 824, o: "&nlE;" }],
          [0, { v: "&gE;", n: 824, o: "&ngE;" }],
          [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }],
          [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }],
          [
            0,
            {
              v: "&ll;",
              n: new Map(
                restoreDiff([
                  [824, "&nLtv;"],
                  [7577, "&nLt;"],
                ]),
              ),
            },
          ],
          [
            0,
            {
              v: "&gg;",
              n: new Map(
                restoreDiff([
                  [824, "&nGtv;"],
                  [7577, "&nGt;"],
                ]),
              ),
            },
          ],
          [0, "&between;"],
          [0, "&NotCupCap;"],
          [0, "&nless;"],
          [0, "&ngt;"],
          [0, "&nle;"],
          [0, "&nge;"],
          [0, "&lesssim;"],
          [0, "&GreaterTilde;"],
          [0, "&nlsim;"],
          [0, "&ngsim;"],
          [0, "&LessGreater;"],
          [0, "&gl;"],
          [0, "&NotLessGreater;"],
          [0, "&NotGreaterLess;"],
          [0, "&pr;"],
          [0, "&sc;"],
          [0, "&prcue;"],
          [0, "&sccue;"],
          [0, "&PrecedesTilde;"],
          [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }],
          [0, "&NotPrecedes;"],
          [0, "&NotSucceeds;"],
          [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }],
          [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }],
          [0, "&nsub;"],
          [0, "&nsup;"],
          [0, "&sube;"],
          [0, "&supe;"],
          [0, "&NotSubsetEqual;"],
          [0, "&NotSupersetEqual;"],
          [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }],
          [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }],
          [1, "&cupdot;"],
          [0, "&UnionPlus;"],
          [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }],
          [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }],
          [0, "&sqsube;"],
          [0, "&sqsupe;"],
          [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }],
          [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }],
          [0, "&CirclePlus;"],
          [0, "&CircleMinus;"],
          [0, "&CircleTimes;"],
          [0, "&osol;"],
          [0, "&CircleDot;"],
          [0, "&circledcirc;"],
          [0, "&circledast;"],
          [1, "&circleddash;"],
          [0, "&boxplus;"],
          [0, "&boxminus;"],
          [0, "&boxtimes;"],
          [0, "&dotsquare;"],
          [0, "&RightTee;"],
          [0, "&dashv;"],
          [0, "&DownTee;"],
          [0, "&bot;"],
          [1, "&models;"],
          [0, "&DoubleRightTee;"],
          [0, "&Vdash;"],
          [0, "&Vvdash;"],
          [0, "&VDash;"],
          [0, "&nvdash;"],
          [0, "&nvDash;"],
          [0, "&nVdash;"],
          [0, "&nVDash;"],
          [0, "&prurel;"],
          [1, "&LeftTriangle;"],
          [0, "&RightTriangle;"],
          [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }],
          [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }],
          [0, "&origof;"],
          [0, "&imof;"],
          [0, "&multimap;"],
          [0, "&hercon;"],
          [0, "&intcal;"],
          [0, "&veebar;"],
          [1, "&barvee;"],
          [0, "&angrtvb;"],
          [0, "&lrtri;"],
          [0, "&bigwedge;"],
          [0, "&bigvee;"],
          [0, "&bigcap;"],
          [0, "&bigcup;"],
          [0, "&diam;"],
          [0, "&sdot;"],
          [0, "&sstarf;"],
          [0, "&divideontimes;"],
          [0, "&bowtie;"],
          [0, "&ltimes;"],
          [0, "&rtimes;"],
          [0, "&leftthreetimes;"],
          [0, "&rightthreetimes;"],
          [0, "&backsimeq;"],
          [0, "&curlyvee;"],
          [0, "&curlywedge;"],
          [0, "&Sub;"],
          [0, "&Sup;"],
          [0, "&Cap;"],
          [0, "&Cup;"],
          [0, "&fork;"],
          [0, "&epar;"],
          [0, "&lessdot;"],
          [0, "&gtdot;"],
          [0, { v: "&Ll;", n: 824, o: "&nLl;" }],
          [0, { v: "&Gg;", n: 824, o: "&nGg;" }],
          [0, { v: "&leg;", n: 65024, o: "&lesg;" }],
          [0, { v: "&gel;", n: 65024, o: "&gesl;" }],
          [2, "&cuepr;"],
          [0, "&cuesc;"],
          [0, "&NotPrecedesSlantEqual;"],
          [0, "&NotSucceedsSlantEqual;"],
          [0, "&NotSquareSubsetEqual;"],
          [0, "&NotSquareSupersetEqual;"],
          [2, "&lnsim;"],
          [0, "&gnsim;"],
          [0, "&precnsim;"],
          [0, "&scnsim;"],
          [0, "&nltri;"],
          [0, "&NotRightTriangle;"],
          [0, "&nltrie;"],
          [0, "&NotRightTriangleEqual;"],
          [0, "&vellip;"],
          [0, "&ctdot;"],
          [0, "&utdot;"],
          [0, "&dtdot;"],
          [0, "&disin;"],
          [0, "&isinsv;"],
          [0, "&isins;"],
          [0, { v: "&isindot;", n: 824, o: "&notindot;" }],
          [0, "&notinvc;"],
          [0, "&notinvb;"],
          [1, { v: "&isinE;", n: 824, o: "&notinE;" }],
          [0, "&nisd;"],
          [0, "&xnis;"],
          [0, "&nis;"],
          [0, "&notnivc;"],
          [0, "&notnivb;"],
          [6, "&barwed;"],
          [0, "&Barwed;"],
          [1, "&lceil;"],
          [0, "&rceil;"],
          [0, "&LeftFloor;"],
          [0, "&rfloor;"],
          [0, "&drcrop;"],
          [0, "&dlcrop;"],
          [0, "&urcrop;"],
          [0, "&ulcrop;"],
          [0, "&bnot;"],
          [1, "&profline;"],
          [0, "&profsurf;"],
          [1, "&telrec;"],
          [0, "&target;"],
          [5, "&ulcorn;"],
          [0, "&urcorn;"],
          [0, "&dlcorn;"],
          [0, "&drcorn;"],
          [2, "&frown;"],
          [0, "&smile;"],
          [9, "&cylcty;"],
          [0, "&profalar;"],
          [7, "&topbot;"],
          [6, "&ovbar;"],
          [1, "&solbar;"],
          [60, "&angzarr;"],
          [51, "&lmoustache;"],
          [0, "&rmoustache;"],
          [2, "&OverBracket;"],
          [0, "&bbrk;"],
          [0, "&bbrktbrk;"],
          [37, "&OverParenthesis;"],
          [0, "&UnderParenthesis;"],
          [0, "&OverBrace;"],
          [0, "&UnderBrace;"],
          [2, "&trpezium;"],
          [4, "&elinters;"],
          [59, "&blank;"],
          [164, "&circledS;"],
          [55, "&boxh;"],
          [1, "&boxv;"],
          [9, "&boxdr;"],
          [3, "&boxdl;"],
          [3, "&boxur;"],
          [3, "&boxul;"],
          [3, "&boxvr;"],
          [7, "&boxvl;"],
          [7, "&boxhd;"],
          [7, "&boxhu;"],
          [7, "&boxvh;"],
          [19, "&boxH;"],
          [0, "&boxV;"],
          [0, "&boxdR;"],
          [0, "&boxDr;"],
          [0, "&boxDR;"],
          [0, "&boxdL;"],
          [0, "&boxDl;"],
          [0, "&boxDL;"],
          [0, "&boxuR;"],
          [0, "&boxUr;"],
          [0, "&boxUR;"],
          [0, "&boxuL;"],
          [0, "&boxUl;"],
          [0, "&boxUL;"],
          [0, "&boxvR;"],
          [0, "&boxVr;"],
          [0, "&boxVR;"],
          [0, "&boxvL;"],
          [0, "&boxVl;"],
          [0, "&boxVL;"],
          [0, "&boxHd;"],
          [0, "&boxhD;"],
          [0, "&boxHD;"],
          [0, "&boxHu;"],
          [0, "&boxhU;"],
          [0, "&boxHU;"],
          [0, "&boxvH;"],
          [0, "&boxVh;"],
          [0, "&boxVH;"],
          [19, "&uhblk;"],
          [3, "&lhblk;"],
          [3, "&block;"],
          [8, "&blk14;"],
          [0, "&blk12;"],
          [0, "&blk34;"],
          [13, "&square;"],
          [8, "&blacksquare;"],
          [0, "&EmptyVerySmallSquare;"],
          [1, "&rect;"],
          [0, "&marker;"],
          [2, "&fltns;"],
          [1, "&bigtriangleup;"],
          [0, "&blacktriangle;"],
          [0, "&triangle;"],
          [2, "&blacktriangleright;"],
          [0, "&rtri;"],
          [3, "&bigtriangledown;"],
          [0, "&blacktriangledown;"],
          [0, "&dtri;"],
          [2, "&blacktriangleleft;"],
          [0, "&ltri;"],
          [6, "&loz;"],
          [0, "&cir;"],
          [32, "&tridot;"],
          [2, "&bigcirc;"],
          [8, "&ultri;"],
          [0, "&urtri;"],
          [0, "&lltri;"],
          [0, "&EmptySmallSquare;"],
          [0, "&FilledSmallSquare;"],
          [8, "&bigstar;"],
          [0, "&star;"],
          [7, "&phone;"],
          [49, "&female;"],
          [1, "&male;"],
          [29, "&spades;"],
          [2, "&clubs;"],
          [1, "&hearts;"],
          [0, "&diamondsuit;"],
          [3, "&sung;"],
          [2, "&flat;"],
          [0, "&natural;"],
          [0, "&sharp;"],
          [163, "&check;"],
          [3, "&cross;"],
          [8, "&malt;"],
          [21, "&sext;"],
          [33, "&VerticalSeparator;"],
          [25, "&lbbrk;"],
          [0, "&rbbrk;"],
          [84, "&bsolhsub;"],
          [0, "&suphsol;"],
          [28, "&LeftDoubleBracket;"],
          [0, "&RightDoubleBracket;"],
          [0, "&lang;"],
          [0, "&rang;"],
          [0, "&Lang;"],
          [0, "&Rang;"],
          [0, "&loang;"],
          [0, "&roang;"],
          [7, "&longleftarrow;"],
          [0, "&longrightarrow;"],
          [0, "&longleftrightarrow;"],
          [0, "&DoubleLongLeftArrow;"],
          [0, "&DoubleLongRightArrow;"],
          [0, "&DoubleLongLeftRightArrow;"],
          [1, "&longmapsto;"],
          [2, "&dzigrarr;"],
          [258, "&nvlArr;"],
          [0, "&nvrArr;"],
          [0, "&nvHarr;"],
          [0, "&Map;"],
          [6, "&lbarr;"],
          [0, "&bkarow;"],
          [0, "&lBarr;"],
          [0, "&dbkarow;"],
          [0, "&drbkarow;"],
          [0, "&DDotrahd;"],
          [0, "&UpArrowBar;"],
          [0, "&DownArrowBar;"],
          [2, "&Rarrtl;"],
          [2, "&latail;"],
          [0, "&ratail;"],
          [0, "&lAtail;"],
          [0, "&rAtail;"],
          [0, "&larrfs;"],
          [0, "&rarrfs;"],
          [0, "&larrbfs;"],
          [0, "&rarrbfs;"],
          [2, "&nwarhk;"],
          [0, "&nearhk;"],
          [0, "&hksearow;"],
          [0, "&hkswarow;"],
          [0, "&nwnear;"],
          [0, "&nesear;"],
          [0, "&seswar;"],
          [0, "&swnwar;"],
          [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }],
          [1, "&cudarrr;"],
          [0, "&ldca;"],
          [0, "&rdca;"],
          [0, "&cudarrl;"],
          [0, "&larrpl;"],
          [2, "&curarrm;"],
          [0, "&cularrp;"],
          [7, "&rarrpl;"],
          [2, "&harrcir;"],
          [0, "&Uarrocir;"],
          [0, "&lurdshar;"],
          [0, "&ldrushar;"],
          [2, "&LeftRightVector;"],
          [0, "&RightUpDownVector;"],
          [0, "&DownLeftRightVector;"],
          [0, "&LeftUpDownVector;"],
          [0, "&LeftVectorBar;"],
          [0, "&RightVectorBar;"],
          [0, "&RightUpVectorBar;"],
          [0, "&RightDownVectorBar;"],
          [0, "&DownLeftVectorBar;"],
          [0, "&DownRightVectorBar;"],
          [0, "&LeftUpVectorBar;"],
          [0, "&LeftDownVectorBar;"],
          [0, "&LeftTeeVector;"],
          [0, "&RightTeeVector;"],
          [0, "&RightUpTeeVector;"],
          [0, "&RightDownTeeVector;"],
          [0, "&DownLeftTeeVector;"],
          [0, "&DownRightTeeVector;"],
          [0, "&LeftUpTeeVector;"],
          [0, "&LeftDownTeeVector;"],
          [0, "&lHar;"],
          [0, "&uHar;"],
          [0, "&rHar;"],
          [0, "&dHar;"],
          [0, "&luruhar;"],
          [0, "&ldrdhar;"],
          [0, "&ruluhar;"],
          [0, "&rdldhar;"],
          [0, "&lharul;"],
          [0, "&llhard;"],
          [0, "&rharul;"],
          [0, "&lrhard;"],
          [0, "&udhar;"],
          [0, "&duhar;"],
          [0, "&RoundImplies;"],
          [0, "&erarr;"],
          [0, "&simrarr;"],
          [0, "&larrsim;"],
          [0, "&rarrsim;"],
          [0, "&rarrap;"],
          [0, "&ltlarr;"],
          [1, "&gtrarr;"],
          [0, "&subrarr;"],
          [1, "&suplarr;"],
          [0, "&lfisht;"],
          [0, "&rfisht;"],
          [0, "&ufisht;"],
          [0, "&dfisht;"],
          [5, "&lopar;"],
          [0, "&ropar;"],
          [4, "&lbrke;"],
          [0, "&rbrke;"],
          [0, "&lbrkslu;"],
          [0, "&rbrksld;"],
          [0, "&lbrksld;"],
          [0, "&rbrkslu;"],
          [0, "&langd;"],
          [0, "&rangd;"],
          [0, "&lparlt;"],
          [0, "&rpargt;"],
          [0, "&gtlPar;"],
          [0, "&ltrPar;"],
          [3, "&vzigzag;"],
          [1, "&vangrt;"],
          [0, "&angrtvbd;"],
          [6, "&ange;"],
          [0, "&range;"],
          [0, "&dwangle;"],
          [0, "&uwangle;"],
          [0, "&angmsdaa;"],
          [0, "&angmsdab;"],
          [0, "&angmsdac;"],
          [0, "&angmsdad;"],
          [0, "&angmsdae;"],
          [0, "&angmsdaf;"],
          [0, "&angmsdag;"],
          [0, "&angmsdah;"],
          [0, "&bemptyv;"],
          [0, "&demptyv;"],
          [0, "&cemptyv;"],
          [0, "&raemptyv;"],
          [0, "&laemptyv;"],
          [0, "&ohbar;"],
          [0, "&omid;"],
          [0, "&opar;"],
          [1, "&operp;"],
          [1, "&olcross;"],
          [0, "&odsold;"],
          [1, "&olcir;"],
          [0, "&ofcir;"],
          [0, "&olt;"],
          [0, "&ogt;"],
          [0, "&cirscir;"],
          [0, "&cirE;"],
          [0, "&solb;"],
          [0, "&bsolb;"],
          [3, "&boxbox;"],
          [3, "&trisb;"],
          [0, "&rtriltri;"],
          [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }],
          [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }],
          [11, "&iinfin;"],
          [0, "&infintie;"],
          [0, "&nvinfin;"],
          [4, "&eparsl;"],
          [0, "&smeparsl;"],
          [0, "&eqvparsl;"],
          [5, "&blacklozenge;"],
          [8, "&RuleDelayed;"],
          [1, "&dsol;"],
          [9, "&bigodot;"],
          [0, "&bigoplus;"],
          [0, "&bigotimes;"],
          [1, "&biguplus;"],
          [1, "&bigsqcup;"],
          [5, "&iiiint;"],
          [0, "&fpartint;"],
          [2, "&cirfnint;"],
          [0, "&awint;"],
          [0, "&rppolint;"],
          [0, "&scpolint;"],
          [0, "&npolint;"],
          [0, "&pointint;"],
          [0, "&quatint;"],
          [0, "&intlarhk;"],
          [10, "&pluscir;"],
          [0, "&plusacir;"],
          [0, "&simplus;"],
          [0, "&plusdu;"],
          [0, "&plussim;"],
          [0, "&plustwo;"],
          [1, "&mcomma;"],
          [0, "&minusdu;"],
          [2, "&loplus;"],
          [0, "&roplus;"],
          [0, "&Cross;"],
          [0, "&timesd;"],
          [0, "&timesbar;"],
          [1, "&smashp;"],
          [0, "&lotimes;"],
          [0, "&rotimes;"],
          [0, "&otimesas;"],
          [0, "&Otimes;"],
          [0, "&odiv;"],
          [0, "&triplus;"],
          [0, "&triminus;"],
          [0, "&tritime;"],
          [0, "&intprod;"],
          [2, "&amalg;"],
          [0, "&capdot;"],
          [1, "&ncup;"],
          [0, "&ncap;"],
          [0, "&capand;"],
          [0, "&cupor;"],
          [0, "&cupcap;"],
          [0, "&capcup;"],
          [0, "&cupbrcap;"],
          [0, "&capbrcup;"],
          [0, "&cupcup;"],
          [0, "&capcap;"],
          [0, "&ccups;"],
          [0, "&ccaps;"],
          [2, "&ccupssm;"],
          [2, "&And;"],
          [0, "&Or;"],
          [0, "&andand;"],
          [0, "&oror;"],
          [0, "&orslope;"],
          [0, "&andslope;"],
          [1, "&andv;"],
          [0, "&orv;"],
          [0, "&andd;"],
          [0, "&ord;"],
          [1, "&wedbar;"],
          [6, "&sdote;"],
          [3, "&simdot;"],
          [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }],
          [0, "&easter;"],
          [0, "&apacir;"],
          [0, { v: "&apE;", n: 824, o: "&napE;" }],
          [0, "&eplus;"],
          [0, "&pluse;"],
          [0, "&Esim;"],
          [0, "&Colone;"],
          [0, "&Equal;"],
          [1, "&ddotseq;"],
          [0, "&equivDD;"],
          [0, "&ltcir;"],
          [0, "&gtcir;"],
          [0, "&ltquest;"],
          [0, "&gtquest;"],
          [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }],
          [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }],
          [0, "&lesdot;"],
          [0, "&gesdot;"],
          [0, "&lesdoto;"],
          [0, "&gesdoto;"],
          [0, "&lesdotor;"],
          [0, "&gesdotol;"],
          [0, "&lap;"],
          [0, "&gap;"],
          [0, "&lne;"],
          [0, "&gne;"],
          [0, "&lnap;"],
          [0, "&gnap;"],
          [0, "&lEg;"],
          [0, "&gEl;"],
          [0, "&lsime;"],
          [0, "&gsime;"],
          [0, "&lsimg;"],
          [0, "&gsiml;"],
          [0, "&lgE;"],
          [0, "&glE;"],
          [0, "&lesges;"],
          [0, "&gesles;"],
          [0, "&els;"],
          [0, "&egs;"],
          [0, "&elsdot;"],
          [0, "&egsdot;"],
          [0, "&el;"],
          [0, "&eg;"],
          [2, "&siml;"],
          [0, "&simg;"],
          [0, "&simlE;"],
          [0, "&simgE;"],
          [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }],
          [
            0,
            { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" },
          ],
          [1, "&glj;"],
          [0, "&gla;"],
          [0, "&ltcc;"],
          [0, "&gtcc;"],
          [0, "&lescc;"],
          [0, "&gescc;"],
          [0, "&smt;"],
          [0, "&lat;"],
          [0, { v: "&smte;", n: 65024, o: "&smtes;" }],
          [0, { v: "&late;", n: 65024, o: "&lates;" }],
          [0, "&bumpE;"],
          [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }],
          [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }],
          [2, "&prE;"],
          [0, "&scE;"],
          [0, "&precneqq;"],
          [0, "&scnE;"],
          [0, "&prap;"],
          [0, "&scap;"],
          [0, "&precnapprox;"],
          [0, "&scnap;"],
          [0, "&Pr;"],
          [0, "&Sc;"],
          [0, "&subdot;"],
          [0, "&supdot;"],
          [0, "&subplus;"],
          [0, "&supplus;"],
          [0, "&submult;"],
          [0, "&supmult;"],
          [0, "&subedot;"],
          [0, "&supedot;"],
          [0, { v: "&subE;", n: 824, o: "&nsubE;" }],
          [0, { v: "&supE;", n: 824, o: "&nsupE;" }],
          [0, "&subsim;"],
          [0, "&supsim;"],
          [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }],
          [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }],
          [2, "&csub;"],
          [0, "&csup;"],
          [0, "&csube;"],
          [0, "&csupe;"],
          [0, "&subsup;"],
          [0, "&supsub;"],
          [0, "&subsub;"],
          [0, "&supsup;"],
          [0, "&suphsub;"],
          [0, "&supdsub;"],
          [0, "&forkv;"],
          [0, "&topfork;"],
          [0, "&mlcp;"],
          [8, "&Dashv;"],
          [1, "&Vdashl;"],
          [0, "&Barv;"],
          [0, "&vBar;"],
          [0, "&vBarv;"],
          [1, "&Vbar;"],
          [0, "&Not;"],
          [0, "&bNot;"],
          [0, "&rnmid;"],
          [0, "&cirmid;"],
          [0, "&midcir;"],
          [0, "&topcir;"],
          [0, "&nhpar;"],
          [0, "&parsim;"],
          [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }],
          [
            44343,
            {
              n: new Map(
                restoreDiff([
                  [56476, "&Ascr;"],
                  [1, "&Cscr;"],
                  [0, "&Dscr;"],
                  [2, "&Gscr;"],
                  [2, "&Jscr;"],
                  [0, "&Kscr;"],
                  [2, "&Nscr;"],
                  [0, "&Oscr;"],
                  [0, "&Pscr;"],
                  [0, "&Qscr;"],
                  [1, "&Sscr;"],
                  [0, "&Tscr;"],
                  [0, "&Uscr;"],
                  [0, "&Vscr;"],
                  [0, "&Wscr;"],
                  [0, "&Xscr;"],
                  [0, "&Yscr;"],
                  [0, "&Zscr;"],
                  [0, "&ascr;"],
                  [0, "&bscr;"],
                  [0, "&cscr;"],
                  [0, "&dscr;"],
                  [1, "&fscr;"],
                  [1, "&hscr;"],
                  [0, "&iscr;"],
                  [0, "&jscr;"],
                  [0, "&kscr;"],
                  [0, "&lscr;"],
                  [0, "&mscr;"],
                  [0, "&nscr;"],
                  [1, "&pscr;"],
                  [0, "&qscr;"],
                  [0, "&rscr;"],
                  [0, "&sscr;"],
                  [0, "&tscr;"],
                  [0, "&uscr;"],
                  [0, "&vscr;"],
                  [0, "&wscr;"],
                  [0, "&xscr;"],
                  [0, "&yscr;"],
                  [0, "&zscr;"],
                  [52, "&Afr;"],
                  [0, "&Bfr;"],
                  [1, "&Dfr;"],
                  [0, "&Efr;"],
                  [0, "&Ffr;"],
                  [0, "&Gfr;"],
                  [2, "&Jfr;"],
                  [0, "&Kfr;"],
                  [0, "&Lfr;"],
                  [0, "&Mfr;"],
                  [0, "&Nfr;"],
                  [0, "&Ofr;"],
                  [0, "&Pfr;"],
                  [0, "&Qfr;"],
                  [1, "&Sfr;"],
                  [0, "&Tfr;"],
                  [0, "&Ufr;"],
                  [0, "&Vfr;"],
                  [0, "&Wfr;"],
                  [0, "&Xfr;"],
                  [0, "&Yfr;"],
                  [1, "&afr;"],
                  [0, "&bfr;"],
                  [0, "&cfr;"],
                  [0, "&dfr;"],
                  [0, "&efr;"],
                  [0, "&ffr;"],
                  [0, "&gfr;"],
                  [0, "&hfr;"],
                  [0, "&ifr;"],
                  [0, "&jfr;"],
                  [0, "&kfr;"],
                  [0, "&lfr;"],
                  [0, "&mfr;"],
                  [0, "&nfr;"],
                  [0, "&ofr;"],
                  [0, "&pfr;"],
                  [0, "&qfr;"],
                  [0, "&rfr;"],
                  [0, "&sfr;"],
                  [0, "&tfr;"],
                  [0, "&ufr;"],
                  [0, "&vfr;"],
                  [0, "&wfr;"],
                  [0, "&xfr;"],
                  [0, "&yfr;"],
                  [0, "&zfr;"],
                  [0, "&Aopf;"],
                  [0, "&Bopf;"],
                  [1, "&Dopf;"],
                  [0, "&Eopf;"],
                  [0, "&Fopf;"],
                  [0, "&Gopf;"],
                  [1, "&Iopf;"],
                  [0, "&Jopf;"],
                  [0, "&Kopf;"],
                  [0, "&Lopf;"],
                  [0, "&Mopf;"],
                  [1, "&Oopf;"],
                  [3, "&Sopf;"],
                  [0, "&Topf;"],
                  [0, "&Uopf;"],
                  [0, "&Vopf;"],
                  [0, "&Wopf;"],
                  [0, "&Xopf;"],
                  [0, "&Yopf;"],
                  [1, "&aopf;"],
                  [0, "&bopf;"],
                  [0, "&copf;"],
                  [0, "&dopf;"],
                  [0, "&eopf;"],
                  [0, "&fopf;"],
                  [0, "&gopf;"],
                  [0, "&hopf;"],
                  [0, "&iopf;"],
                  [0, "&jopf;"],
                  [0, "&kopf;"],
                  [0, "&lopf;"],
                  [0, "&mopf;"],
                  [0, "&nopf;"],
                  [0, "&oopf;"],
                  [0, "&popf;"],
                  [0, "&qopf;"],
                  [0, "&ropf;"],
                  [0, "&sopf;"],
                  [0, "&topf;"],
                  [0, "&uopf;"],
                  [0, "&vopf;"],
                  [0, "&wopf;"],
                  [0, "&xopf;"],
                  [0, "&yopf;"],
                  [0, "&zopf;"],
                ]),
              ),
            },
          ],
          [8906, "&fflig;"],
          [0, "&filig;"],
          [0, "&fllig;"],
          [0, "&ffilig;"],
          [0, "&ffllig;"],
        ]),
      );
    },
    4194: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.decodeXMLStrict =
        exports.decodeHTML5Strict =
        exports.decodeHTML4Strict =
        exports.decodeHTML5 =
        exports.decodeHTML4 =
        exports.decodeHTMLAttribute =
        exports.decodeHTMLStrict =
        exports.decodeHTML =
        exports.decodeXML =
        exports.DecodingMode =
        exports.EntityDecoder =
        exports.encodeHTML5 =
        exports.encodeHTML4 =
        exports.encodeNonAsciiHTML =
        exports.encodeHTML =
        exports.escapeText =
        exports.escapeAttribute =
        exports.escapeUTF8 =
        exports.escape =
        exports.encodeXML =
        exports.encode =
        exports.decodeStrict =
        exports.decode =
        exports.EncodingMode =
        exports.EntityLevel =
          void 0;
      var decode_js_1 = __nccwpck_require__(3925);
      var encode_js_1 = __nccwpck_require__(6844);
      var escape_js_1 = __nccwpck_require__(4055);
      var EntityLevel;
      (function (EntityLevel) {
        EntityLevel[(EntityLevel["XML"] = 0)] = "XML";
        EntityLevel[(EntityLevel["HTML"] = 1)] = "HTML";
      })((EntityLevel = exports.EntityLevel || (exports.EntityLevel = {})));
      var EncodingMode;
      (function (EncodingMode) {
        EncodingMode[(EncodingMode["UTF8"] = 0)] = "UTF8";
        EncodingMode[(EncodingMode["ASCII"] = 1)] = "ASCII";
        EncodingMode[(EncodingMode["Extensive"] = 2)] = "Extensive";
        EncodingMode[(EncodingMode["Attribute"] = 3)] = "Attribute";
        EncodingMode[(EncodingMode["Text"] = 4)] = "Text";
      })((EncodingMode = exports.EncodingMode || (exports.EncodingMode = {})));
      function decode(data, options) {
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var level = typeof options === "number" ? options : options.level;
        if (level === EntityLevel.HTML) {
          var mode = typeof options === "object" ? options.mode : undefined;
          return (0, decode_js_1.decodeHTML)(data, mode);
        }
        return (0, decode_js_1.decodeXML)(data);
      }
      exports.decode = decode;
      function decodeStrict(data, options) {
        var _a;
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var opts = typeof options === "number" ? { level: options } : options;
        (_a = opts.mode) !== null && _a !== void 0
          ? _a
          : (opts.mode = decode_js_1.DecodingMode.Strict);
        return decode(data, opts);
      }
      exports.decodeStrict = decodeStrict;
      function encode(data, options) {
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var opts = typeof options === "number" ? { level: options } : options;
        if (opts.mode === EncodingMode.UTF8)
          return (0, escape_js_1.escapeUTF8)(data);
        if (opts.mode === EncodingMode.Attribute)
          return (0, escape_js_1.escapeAttribute)(data);
        if (opts.mode === EncodingMode.Text)
          return (0, escape_js_1.escapeText)(data);
        if (opts.level === EntityLevel.HTML) {
          if (opts.mode === EncodingMode.ASCII) {
            return (0, encode_js_1.encodeNonAsciiHTML)(data);
          }
          return (0, encode_js_1.encodeHTML)(data);
        }
        return (0, escape_js_1.encodeXML)(data);
      }
      exports.encode = encode;
      var escape_js_2 = __nccwpck_require__(4055);
      Object.defineProperty(exports, "encodeXML", {
        enumerable: true,
        get: function () {
          return escape_js_2.encodeXML;
        },
      });
      Object.defineProperty(exports, "escape", {
        enumerable: true,
        get: function () {
          return escape_js_2.escape;
        },
      });
      Object.defineProperty(exports, "escapeUTF8", {
        enumerable: true,
        get: function () {
          return escape_js_2.escapeUTF8;
        },
      });
      Object.defineProperty(exports, "escapeAttribute", {
        enumerable: true,
        get: function () {
          return escape_js_2.escapeAttribute;
        },
      });
      Object.defineProperty(exports, "escapeText", {
        enumerable: true,
        get: function () {
          return escape_js_2.escapeText;
        },
      });
      var encode_js_2 = __nccwpck_require__(6844);
      Object.defineProperty(exports, "encodeHTML", {
        enumerable: true,
        get: function () {
          return encode_js_2.encodeHTML;
        },
      });
      Object.defineProperty(exports, "encodeNonAsciiHTML", {
        enumerable: true,
        get: function () {
          return encode_js_2.encodeNonAsciiHTML;
        },
      });
      Object.defineProperty(exports, "encodeHTML4", {
        enumerable: true,
        get: function () {
          return encode_js_2.encodeHTML;
        },
      });
      Object.defineProperty(exports, "encodeHTML5", {
        enumerable: true,
        get: function () {
          return encode_js_2.encodeHTML;
        },
      });
      var decode_js_2 = __nccwpck_require__(3925);
      Object.defineProperty(exports, "EntityDecoder", {
        enumerable: true,
        get: function () {
          return decode_js_2.EntityDecoder;
        },
      });
      Object.defineProperty(exports, "DecodingMode", {
        enumerable: true,
        get: function () {
          return decode_js_2.DecodingMode;
        },
      });
      Object.defineProperty(exports, "decodeXML", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeXML;
        },
      });
      Object.defineProperty(exports, "decodeHTML", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTML;
        },
      });
      Object.defineProperty(exports, "decodeHTMLStrict", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTMLStrict;
        },
      });
      Object.defineProperty(exports, "decodeHTMLAttribute", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTMLAttribute;
        },
      });
      Object.defineProperty(exports, "decodeHTML4", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTML;
        },
      });
      Object.defineProperty(exports, "decodeHTML5", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTML;
        },
      });
      Object.defineProperty(exports, "decodeHTML4Strict", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTMLStrict;
        },
      });
      Object.defineProperty(exports, "decodeHTML5Strict", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeHTMLStrict;
        },
      });
      Object.defineProperty(exports, "decodeXMLStrict", {
        enumerable: true,
        get: function () {
          return decode_js_2.decodeXML;
        },
      });
    },
    2901: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generate = exports.compile = void 0;
      var boolbase_1 = __importDefault(__nccwpck_require__(2882));
      function compile(parsed) {
        var a = parsed[0];
        var b = parsed[1] - 1;
        if (b < 0 && a <= 0) return boolbase_1.default.falseFunc;
        if (a === -1)
          return function (index) {
            return index <= b;
          };
        if (a === 0)
          return function (index) {
            return index === b;
          };
        if (a === 1)
          return b < 0
            ? boolbase_1.default.trueFunc
            : function (index) {
                return index >= b;
              };
        var absA = Math.abs(a);
        var bMod = ((b % absA) + absA) % absA;
        return a > 1
          ? function (index) {
              return index >= b && index % absA === bMod;
            }
          : function (index) {
              return index <= b && index % absA === bMod;
            };
      }
      exports.compile = compile;
      function generate(parsed) {
        var a = parsed[0];
        var b = parsed[1] - 1;
        var n = 0;
        if (a < 0) {
          var aPos_1 = -a;
          var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
          return function () {
            var val = minValue_1 + aPos_1 * n++;
            return val > b ? null : val;
          };
        }
        if (a === 0)
          return b < 0
            ? function () {
                return null;
              }
            : function () {
                return n++ === 0 ? b : null;
              };
        if (b < 0) {
          b += a * Math.ceil(-b / a);
        }
        return function () {
          return a * n++ + b;
        };
      }
      exports.generate = generate;
    },
    8452: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequence =
        exports.generate =
        exports.compile =
        exports.parse =
          void 0;
      var parse_js_1 = __nccwpck_require__(3056);
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function () {
          return parse_js_1.parse;
        },
      });
      var compile_js_1 = __nccwpck_require__(2901);
      Object.defineProperty(exports, "compile", {
        enumerable: true,
        get: function () {
          return compile_js_1.compile;
        },
      });
      Object.defineProperty(exports, "generate", {
        enumerable: true,
        get: function () {
          return compile_js_1.generate;
        },
      });
      function nthCheck(formula) {
        return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
      }
      exports["default"] = nthCheck;
      function sequence(formula) {
        return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
      }
      exports.sequence = sequence;
    },
    3056: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = void 0;
      var whitespace = new Set([9, 10, 12, 13, 32]);
      var ZERO = "0".charCodeAt(0);
      var NINE = "9".charCodeAt(0);
      function parse(formula) {
        formula = formula.trim().toLowerCase();
        if (formula === "even") {
          return [2, 0];
        } else if (formula === "odd") {
          return [2, 1];
        }
        var idx = 0;
        var a = 0;
        var sign = readSign();
        var number = readNumber();
        if (idx < formula.length && formula.charAt(idx) === "n") {
          idx++;
          a = sign * (number !== null && number !== void 0 ? number : 1);
          skipWhitespace();
          if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
          } else {
            sign = number = 0;
          }
        }
        if (number === null || idx < formula.length) {
          throw new Error(
            "n-th rule couldn't be parsed ('".concat(formula, "')"),
          );
        }
        return [a, sign * number];
        function readSign() {
          if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
          }
          if (formula.charAt(idx) === "+") {
            idx++;
          }
          return 1;
        }
        function readNumber() {
          var start = idx;
          var value = 0;
          while (
            idx < formula.length &&
            formula.charCodeAt(idx) >= ZERO &&
            formula.charCodeAt(idx) <= NINE
          ) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
          }
          return idx === start ? null : value;
        }
        function skipWhitespace() {
          while (
            idx < formula.length &&
            whitespace.has(formula.charCodeAt(idx))
          ) {
            idx++;
          }
        }
      }
      exports.parse = parse;
    },
    9090: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var util = __nccwpck_require__(4704);
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? new Map() : Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(
        aArray,
        aAllowDuplicates,
      ) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap
          ? this._set.size
          : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap
          ? this.has(aStr)
          : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.I = ArraySet;
    },
    5331: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var base64 = __nccwpck_require__(5017);
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    },
    5017: (__unused_webpack_module, exports) => {
      var intToCharMap =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
          "",
        );
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function (charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    },
    9180: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var util = __nccwpck_require__(4704);
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return (
          lineB > lineA ||
          (lineB == lineA && columnB >= columnA) ||
          util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
        );
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(
        aCallback,
        aThisArg,
      ) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.H = MappingList;
    },
    4209: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var base64VLQ = __nccwpck_require__(5331);
      var util = __nccwpck_require__(4704);
      var ArraySet = __nccwpck_require__(9090).I;
      var MappingList = __nccwpck_require__(9180).H;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._ignoreInvalidMapping = util.getArg(
          aArgs,
          "ignoreInvalidMapping",
          false,
        );
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(
          aSourceMapConsumer,
          generatorOps,
        ) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator(
            Object.assign(generatorOps || {}, {
              file: aSourceMapConsumer.file,
              sourceRoot,
            }),
          );
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn,
              },
            };
            if (mapping.source != null) {
              newMapping.source = mapping.source;
              if (sourceRoot != null) {
                newMapping.source = util.relative(
                  sourceRoot,
                  newMapping.source,
                );
              }
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn,
              };
              if (mapping.name != null) {
                newMapping.name = mapping.name;
              }
            }
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var sourceRelative = sourceFile;
            if (sourceRoot !== null) {
              sourceRelative = util.relative(sourceRoot, sourceFile);
            }
            if (!generator._sources.has(sourceRelative)) {
              generator._sources.add(sourceRelative);
            }
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, "generated");
          var original = util.getArg(aArgs, "original", null);
          var source = util.getArg(aArgs, "source", null);
          var name = util.getArg(aArgs, "name", null);
          if (!this._skipValidation) {
            if (
              this._validateMapping(generated, original, source, name) === false
            ) {
              return;
            }
          }
          if (source != null) {
            source = String(source);
            if (!this._sources.has(source)) {
              this._sources.add(source);
            }
          }
          if (name != null) {
            name = String(name);
            if (!this._names.has(name)) {
              this._names.add(name);
            }
          }
          this._mappings.add({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source,
            name,
          });
        };
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(
          aSourceFile,
          aSourceContent,
        ) {
          var source = aSourceFile;
          if (this._sourceRoot != null) {
            source = util.relative(this._sourceRoot, source);
          }
          if (aSourceContent != null) {
            if (!this._sourcesContents) {
              this._sourcesContents = Object.create(null);
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else if (this._sourcesContents) {
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(
          aSourceMapConsumer,
          aSourceFile,
          aSourceMapPath,
        ) {
          var sourceFile = aSourceFile;
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null) {
              throw new Error(
                "SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
                  'or the source map\'s "file" property. Both were omitted.',
              );
            }
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          var newSources = new ArraySet();
          var newNames = new ArraySet();
          this._mappings.unsortedForEach(function (mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn,
              });
              if (original.source != null) {
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                  mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                  mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                  mapping.name = original.name;
                }
              }
            }
            var source = mapping.source;
            if (source != null && !newSources.has(source)) {
              newSources.add(source);
            }
            var name = mapping.name;
            if (name != null && !newNames.has(name)) {
              newNames.add(name);
            }
          }, this);
          this._sources = newSources;
          this._names = newNames;
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content != null) {
              if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
              }
              if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(
          aGenerated,
          aOriginal,
          aSource,
          aName,
        ) {
          if (
            aOriginal &&
            typeof aOriginal.line !== "number" &&
            typeof aOriginal.column !== "number"
          ) {
            var message =
              "original.line and original.column are not numbers -- you probably meant to omit " +
              "the original mapping entirely and only map the generated position. If so, pass " +
              "null for the original mapping instead of an object with empty or null values.";
            if (this._ignoreInvalidMapping) {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(message);
              }
              return false;
            } else {
              throw new Error(message);
            }
          }
          if (
            aGenerated &&
            "line" in aGenerated &&
            "column" in aGenerated &&
            aGenerated.line > 0 &&
            aGenerated.column >= 0 &&
            !aOriginal &&
            !aSource &&
            !aName
          ) {
            return;
          } else if (
            aGenerated &&
            "line" in aGenerated &&
            "column" in aGenerated &&
            aOriginal &&
            "line" in aOriginal &&
            "column" in aOriginal &&
            aGenerated.line > 0 &&
            aGenerated.column >= 0 &&
            aOriginal.line > 0 &&
            aOriginal.column >= 0 &&
            aSource
          ) {
            return;
          } else {
            var message =
              "Invalid mapping: " +
              JSON.stringify({
                generated: aGenerated,
                source: aSource,
                original: aOriginal,
                name: aName,
              });
            if (this._ignoreInvalidMapping) {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(message);
              }
              return false;
            } else {
              throw new Error(message);
            }
          }
        };
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = "";
          var next;
          var mapping;
          var nameIdx;
          var sourceIdx;
          var mappings = this._mappings.toArray();
          for (var i = 0, len = mappings.length; i < len; i++) {
            mapping = mappings[i];
            next = "";
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                next += ";";
                previousGeneratedLine++;
              }
            } else {
              if (i > 0) {
                if (
                  !util.compareByGeneratedPositionsInflated(
                    mapping,
                    mappings[i - 1],
                  )
                ) {
                  continue;
                }
                next += ",";
              }
            }
            next += base64VLQ.encode(
              mapping.generatedColumn - previousGeneratedColumn,
            );
            previousGeneratedColumn = mapping.generatedColumn;
            if (mapping.source != null) {
              sourceIdx = this._sources.indexOf(mapping.source);
              next += base64VLQ.encode(sourceIdx - previousSource);
              previousSource = sourceIdx;
              next += base64VLQ.encode(
                mapping.originalLine - 1 - previousOriginalLine,
              );
              previousOriginalLine = mapping.originalLine - 1;
              next += base64VLQ.encode(
                mapping.originalColumn - previousOriginalColumn,
              );
              previousOriginalColumn = mapping.originalColumn;
              if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
              }
            }
            result += next;
          }
          return result;
        };
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(
          aSources,
          aSourceRoot,
        ) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot != null) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(
              this._sourcesContents,
              key,
            )
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings(),
          };
          if (this._file != null) {
            map.file = this._file;
          }
          if (this._sourceRoot != null) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(
              map.sources,
              map.sourceRoot,
            );
          }
          return map;
        };
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this.toJSON());
        };
      exports.SourceMapGenerator = SourceMapGenerator;
    },
    4704: (__unused_webpack_module, exports) => {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp =
        /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5],
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      var MAX_CACHED_INPUTS = 32;
      function lruMemoize(f) {
        var cache = [];
        return function (input) {
          for (var i = 0; i < cache.length; i++) {
            if (cache[i].input === input) {
              var temp = cache[0];
              cache[0] = cache[i];
              cache[i] = temp;
              return cache[0].result;
            }
          }
          var result = f(input);
          cache.unshift({ input, result });
          if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
          }
          return result;
        };
      }
      var normalize = lruMemoize(function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = [];
        var start = 0;
        var i = 0;
        while (true) {
          start = i;
          i = path.indexOf("/", start);
          if (i === -1) {
            parts.push(path.slice(start));
            break;
          } else {
            parts.push(path.slice(start, i));
            while (i < path.length && path[i] === "/") {
              i++;
            }
          }
        }
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      });
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined =
          aPath.charAt(0) === "/"
            ? aPath
            : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = (function () {
        var obj = Object.create(null);
        return !("__proto__" in obj);
      })();
      function identity(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (
          s.charCodeAt(length - 1) !== 95 ||
          s.charCodeAt(length - 2) !== 95 ||
          s.charCodeAt(length - 3) !== 111 ||
          s.charCodeAt(length - 4) !== 116 ||
          s.charCodeAt(length - 5) !== 111 ||
          s.charCodeAt(length - 6) !== 114 ||
          s.charCodeAt(length - 7) !== 112 ||
          s.charCodeAt(length - 8) !== 95 ||
          s.charCodeAt(length - 9) !== 95
        ) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(
        mappingA,
        mappingB,
        onlyCompareOriginal,
      ) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByOriginalPositionsNoSource(
        mappingA,
        mappingB,
        onlyCompareOriginal,
      ) {
        var cmp;
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositionsNoSource =
        compareByOriginalPositionsNoSource;
      function compareByGeneratedPositionsDeflated(
        mappingA,
        mappingB,
        onlyCompareGenerated,
      ) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated =
        compareByGeneratedPositionsDeflated;
      function compareByGeneratedPositionsDeflatedNoLine(
        mappingA,
        mappingB,
        onlyCompareGenerated,
      ) {
        var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflatedNoLine =
        compareByGeneratedPositionsDeflatedNoLine;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated =
        compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (
            sourceRoot[sourceRoot.length - 1] !== "/" &&
            sourceURL[0] !== "/"
          ) {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    },
    3350: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      exports.builtin = [
        __nccwpck_require__(4174),
        __nccwpck_require__(7871),
        __nccwpck_require__(5698),
        __nccwpck_require__(3188),
        __nccwpck_require__(2938),
        __nccwpck_require__(7719),
        __nccwpck_require__(5005),
        __nccwpck_require__(6260),
        __nccwpck_require__(5793),
        __nccwpck_require__(8352),
        __nccwpck_require__(1083),
        __nccwpck_require__(6640),
        __nccwpck_require__(4106),
        __nccwpck_require__(834),
        __nccwpck_require__(9601),
        __nccwpck_require__(7016),
        __nccwpck_require__(2325),
        __nccwpck_require__(7996),
        __nccwpck_require__(9061),
        __nccwpck_require__(5346),
        __nccwpck_require__(9843),
        __nccwpck_require__(8005),
        __nccwpck_require__(7366),
        __nccwpck_require__(7874),
        __nccwpck_require__(7096),
        __nccwpck_require__(954),
        __nccwpck_require__(5147),
        __nccwpck_require__(6760),
        __nccwpck_require__(8219),
        __nccwpck_require__(2502),
        __nccwpck_require__(4009),
        __nccwpck_require__(1273),
        __nccwpck_require__(8402),
        __nccwpck_require__(2804),
        __nccwpck_require__(9542),
        __nccwpck_require__(2391),
        __nccwpck_require__(4398),
        __nccwpck_require__(6086),
        __nccwpck_require__(2166),
        __nccwpck_require__(4064),
        __nccwpck_require__(5843),
        __nccwpck_require__(906),
        __nccwpck_require__(5718),
        __nccwpck_require__(4256),
        __nccwpck_require__(3467),
        __nccwpck_require__(8627),
        __nccwpck_require__(6766),
        __nccwpck_require__(7425),
        __nccwpck_require__(7110),
        __nccwpck_require__(5927),
        __nccwpck_require__(4727),
        __nccwpck_require__(8175),
        __nccwpck_require__(21),
      ];
    },
    6723: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const SAX = __nccwpck_require__(6049);
      const { textElems } = __nccwpck_require__(4298);
      class SvgoParserError extends Error {
        constructor(message, line, column, source, file) {
          super(message);
          this.name = "SvgoParserError";
          this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
          this.reason = message;
          this.line = line;
          this.column = column;
          this.source = source;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, SvgoParserError);
          }
        }
        toString() {
          const lines = this.source.split(/\r?\n/);
          const startLine = Math.max(this.line - 3, 0);
          const endLine = Math.min(this.line + 2, lines.length);
          const lineNumberWidth = String(endLine).length;
          const startColumn = Math.max(this.column - 54, 0);
          const endColumn = Math.max(this.column + 20, 80);
          const code = lines
            .slice(startLine, endLine)
            .map((line, index) => {
              const lineSlice = line.slice(startColumn, endColumn);
              let ellipsisPrefix = "";
              let ellipsisSuffix = "";
              if (startColumn !== 0) {
                ellipsisPrefix = startColumn > line.length - 1 ? " " : "…";
              }
              if (endColumn < line.length - 1) {
                ellipsisSuffix = "…";
              }
              const number = startLine + 1 + index;
              const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
              if (number === this.line) {
                const gutterSpacing = gutter.replace(/[^|]/g, " ");
                const lineSpacing = (
                  ellipsisPrefix + line.slice(startColumn, this.column - 1)
                ).replace(/[^\t]/g, " ");
                const spacing = gutterSpacing + lineSpacing;
                return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\n ${spacing}^`;
              }
              return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
            })
            .join("\n");
          return `${this.name}: ${this.message}\n\n${code}\n`;
        }
      }
      const entityDeclaration =
        /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
      const config = {
        strict: true,
        trim: false,
        normalize: false,
        lowercase: true,
        xmlns: true,
        position: true,
      };
      const parseSvg = (data, from) => {
        const sax = SAX.parser(config.strict, config);
        const root = { type: "root", children: [] };
        let current = root;
        const stack = [root];
        const pushToContent = (node) => {
          Object.defineProperty(node, "parentNode", {
            writable: true,
            value: current,
          });
          current.children.push(node);
        };
        sax.ondoctype = (doctype) => {
          const node = { type: "doctype", name: "svg", data: { doctype } };
          pushToContent(node);
          const subsetStart = doctype.indexOf("[");
          if (subsetStart >= 0) {
            entityDeclaration.lastIndex = subsetStart;
            let entityMatch = entityDeclaration.exec(data);
            while (entityMatch != null) {
              sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
              entityMatch = entityDeclaration.exec(data);
            }
          }
        };
        sax.onprocessinginstruction = (data) => {
          const node = {
            type: "instruction",
            name: data.name,
            value: data.body,
          };
          pushToContent(node);
        };
        sax.oncomment = (comment) => {
          const node = { type: "comment", value: comment.trim() };
          pushToContent(node);
        };
        sax.oncdata = (cdata) => {
          const node = { type: "cdata", value: cdata };
          pushToContent(node);
        };
        sax.onopentag = (data) => {
          let element = {
            type: "element",
            name: data.name,
            attributes: {},
            children: [],
          };
          for (const [name, attr] of Object.entries(data.attributes)) {
            element.attributes[name] = attr.value;
          }
          pushToContent(element);
          current = element;
          stack.push(element);
        };
        sax.ontext = (text) => {
          if (current.type === "element") {
            if (textElems.has(current.name)) {
              const node = { type: "text", value: text };
              pushToContent(node);
            } else if (/\S/.test(text)) {
              const node = { type: "text", value: text.trim() };
              pushToContent(node);
            }
          }
        };
        sax.onclosetag = () => {
          stack.pop();
          current = stack[stack.length - 1];
        };
        sax.onerror = (e) => {
          const error = new SvgoParserError(
            e.reason,
            e.line + 1,
            e.column,
            data,
            from,
          );
          if (e.message.indexOf("Unexpected end") === -1) {
            throw error;
          }
        };
        sax.write(data).close();
        return root;
      };
      exports.parseSvg = parseSvg;
    },
    2162: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { removeLeadingZero, toFixed } = __nccwpck_require__(5916);
      const argsCountPerCommand = {
        M: 2,
        m: 2,
        Z: 0,
        z: 0,
        L: 2,
        l: 2,
        H: 1,
        h: 1,
        V: 1,
        v: 1,
        C: 6,
        c: 6,
        S: 4,
        s: 4,
        Q: 4,
        q: 4,
        T: 2,
        t: 2,
        A: 7,
        a: 7,
      };
      const isCommand = (c) => c in argsCountPerCommand;
      const isWsp = (c) => {
        const codePoint = c.codePointAt(0);
        return (
          codePoint === 32 ||
          codePoint === 9 ||
          codePoint === 13 ||
          codePoint === 10
        );
      };
      const isDigit = (c) => {
        const codePoint = c.codePointAt(0);
        if (codePoint == null) {
          return false;
        }
        return 48 <= codePoint && codePoint <= 57;
      };
      const readNumber = (string, cursor) => {
        let i = cursor;
        let value = "";
        let state = "none";
        for (; i < string.length; i += 1) {
          const c = string[i];
          if (c === "+" || c === "-") {
            if (state === "none") {
              state = "sign";
              value += c;
              continue;
            }
            if (state === "e") {
              state = "exponent_sign";
              value += c;
              continue;
            }
          }
          if (isDigit(c)) {
            if (state === "none" || state === "sign" || state === "whole") {
              state = "whole";
              value += c;
              continue;
            }
            if (state === "decimal_point" || state === "decimal") {
              state = "decimal";
              value += c;
              continue;
            }
            if (
              state === "e" ||
              state === "exponent_sign" ||
              state === "exponent"
            ) {
              state = "exponent";
              value += c;
              continue;
            }
          }
          if (c === ".") {
            if (state === "none" || state === "sign" || state === "whole") {
              state = "decimal_point";
              value += c;
              continue;
            }
          }
          if (c === "E" || c == "e") {
            if (
              state === "whole" ||
              state === "decimal_point" ||
              state === "decimal"
            ) {
              state = "e";
              value += c;
              continue;
            }
          }
          break;
        }
        const number = Number.parseFloat(value);
        if (Number.isNaN(number)) {
          return [cursor, null];
        } else {
          return [i - 1, number];
        }
      };
      const parsePathData = (string) => {
        const pathData = [];
        let command = null;
        let args = [];
        let argsCount = 0;
        let canHaveComma = false;
        let hadComma = false;
        for (let i = 0; i < string.length; i += 1) {
          const c = string.charAt(i);
          if (isWsp(c)) {
            continue;
          }
          if (canHaveComma && c === ",") {
            if (hadComma) {
              break;
            }
            hadComma = true;
            continue;
          }
          if (isCommand(c)) {
            if (hadComma) {
              return pathData;
            }
            if (command == null) {
              if (c !== "M" && c !== "m") {
                return pathData;
              }
            } else {
              if (args.length !== 0) {
                return pathData;
              }
            }
            command = c;
            args = [];
            argsCount = argsCountPerCommand[command];
            canHaveComma = false;
            if (argsCount === 0) {
              pathData.push({ command, args });
            }
            continue;
          }
          if (command == null) {
            return pathData;
          }
          let newCursor = i;
          let number = null;
          if (command === "A" || command === "a") {
            const position = args.length;
            if (position === 0 || position === 1) {
              if (c !== "+" && c !== "-") {
                [newCursor, number] = readNumber(string, i);
              }
            }
            if (position === 2 || position === 5 || position === 6) {
              [newCursor, number] = readNumber(string, i);
            }
            if (position === 3 || position === 4) {
              if (c === "0") {
                number = 0;
              }
              if (c === "1") {
                number = 1;
              }
            }
          } else {
            [newCursor, number] = readNumber(string, i);
          }
          if (number == null) {
            return pathData;
          }
          args.push(number);
          canHaveComma = true;
          hadComma = false;
          i = newCursor;
          if (args.length === argsCount) {
            pathData.push({ command, args });
            if (command === "M") {
              command = "L";
            }
            if (command === "m") {
              command = "l";
            }
            args = [];
          }
        }
        return pathData;
      };
      exports.parsePathData = parsePathData;
      const roundAndStringify = (number, precision) => {
        if (precision != null) {
          number = toFixed(number, precision);
        }
        return { roundedStr: removeLeadingZero(number), rounded: number };
      };
      const stringifyArgs = (
        command,
        args,
        precision,
        disableSpaceAfterFlags,
      ) => {
        let result = "";
        let previous;
        for (let i = 0; i < args.length; i++) {
          const { roundedStr, rounded } = roundAndStringify(args[i], precision);
          if (
            disableSpaceAfterFlags &&
            (command === "A" || command === "a") &&
            (i % 7 === 4 || i % 7 === 5)
          ) {
            result += roundedStr;
          } else if (i === 0 || rounded < 0) {
            result += roundedStr;
          } else if (
            !Number.isInteger(previous) &&
            rounded != 0 &&
            rounded < 1 &&
            rounded > -1
          ) {
            result += roundedStr;
          } else {
            result += ` ${roundedStr}`;
          }
          previous = rounded;
        }
        return result;
      };
      const stringifyPathData = ({
        pathData,
        precision,
        disableSpaceAfterFlags,
      }) => {
        if (pathData.length === 1) {
          const { command, args } = pathData[0];
          return (
            command +
            stringifyArgs(command, args, precision, disableSpaceAfterFlags)
          );
        }
        let result = "";
        let prev = { ...pathData[0] };
        if (pathData[1].command === "L") {
          prev.command = "M";
        } else if (pathData[1].command === "l") {
          prev.command = "m";
        }
        for (let i = 1; i < pathData.length; i++) {
          const { command, args } = pathData[i];
          if (
            (prev.command === command &&
              prev.command !== "M" &&
              prev.command !== "m") ||
            (prev.command === "M" && command === "L") ||
            (prev.command === "m" && command === "l")
          ) {
            prev.args = [...prev.args, ...args];
            if (i === pathData.length - 1) {
              result +=
                prev.command +
                stringifyArgs(
                  prev.command,
                  prev.args,
                  precision,
                  disableSpaceAfterFlags,
                );
            }
          } else {
            result +=
              prev.command +
              stringifyArgs(
                prev.command,
                prev.args,
                precision,
                disableSpaceAfterFlags,
              );
            if (i === pathData.length - 1) {
              result +=
                command +
                stringifyArgs(command, args, precision, disableSpaceAfterFlags);
            } else {
              prev = { command, args };
            }
          }
        }
        return result;
      };
      exports.stringifyPathData = stringifyPathData;
    },
    1289: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { textElems } = __nccwpck_require__(4298);
      const encodeEntity = (char) => entities[char];
      const defaults = {
        doctypeStart: "<!DOCTYPE",
        doctypeEnd: ">",
        procInstStart: "<?",
        procInstEnd: "?>",
        tagOpenStart: "<",
        tagOpenEnd: ">",
        tagCloseStart: "</",
        tagCloseEnd: ">",
        tagShortStart: "<",
        tagShortEnd: "/>",
        attrStart: '="',
        attrEnd: '"',
        commentStart: "\x3c!--",
        commentEnd: "--\x3e",
        cdataStart: "<![CDATA[",
        cdataEnd: "]]>",
        textStart: "",
        textEnd: "",
        indent: 4,
        regEntities: /[&'"<>]/g,
        regValEntities: /[&"<>]/g,
        encodeEntity,
        pretty: false,
        useShortTags: true,
        eol: "lf",
        finalNewline: false,
      };
      const entities = {
        "&": "&amp;",
        "'": "&apos;",
        '"': "&quot;",
        ">": "&gt;",
        "<": "&lt;",
      };
      const stringifySvg = (data, userOptions = {}) => {
        const config = { ...defaults, ...userOptions };
        const indent = config.indent;
        let newIndent = "    ";
        if (typeof indent === "number" && Number.isNaN(indent) === false) {
          newIndent = indent < 0 ? "\t" : " ".repeat(indent);
        } else if (typeof indent === "string") {
          newIndent = indent;
        }
        const state = { indent: newIndent, textContext: null, indentLevel: 0 };
        const eol = config.eol === "crlf" ? "\r\n" : "\n";
        if (config.pretty) {
          config.doctypeEnd += eol;
          config.procInstEnd += eol;
          config.commentEnd += eol;
          config.cdataEnd += eol;
          config.tagShortEnd += eol;
          config.tagOpenEnd += eol;
          config.tagCloseEnd += eol;
          config.textEnd += eol;
        }
        let svg = stringifyNode(data, config, state);
        if (config.finalNewline && svg.length > 0 && !svg.endsWith("\n")) {
          svg += eol;
        }
        return svg;
      };
      exports.stringifySvg = stringifySvg;
      const stringifyNode = (data, config, state) => {
        let svg = "";
        state.indentLevel += 1;
        for (const item of data.children) {
          if (item.type === "element") {
            svg += stringifyElement(item, config, state);
          }
          if (item.type === "text") {
            svg += stringifyText(item, config, state);
          }
          if (item.type === "doctype") {
            svg += stringifyDoctype(item, config);
          }
          if (item.type === "instruction") {
            svg += stringifyInstruction(item, config);
          }
          if (item.type === "comment") {
            svg += stringifyComment(item, config);
          }
          if (item.type === "cdata") {
            svg += stringifyCdata(item, config, state);
          }
        }
        state.indentLevel -= 1;
        return svg;
      };
      const createIndent = (config, state) => {
        let indent = "";
        if (config.pretty && state.textContext == null) {
          indent = state.indent.repeat(state.indentLevel - 1);
        }
        return indent;
      };
      const stringifyDoctype = (node, config) =>
        config.doctypeStart + node.data.doctype + config.doctypeEnd;
      const stringifyInstruction = (node, config) =>
        config.procInstStart +
        node.name +
        " " +
        node.value +
        config.procInstEnd;
      const stringifyComment = (node, config) =>
        config.commentStart + node.value + config.commentEnd;
      const stringifyCdata = (node, config, state) =>
        createIndent(config, state) +
        config.cdataStart +
        node.value +
        config.cdataEnd;
      const stringifyElement = (node, config, state) => {
        if (node.children.length === 0) {
          if (config.useShortTags) {
            return (
              createIndent(config, state) +
              config.tagShortStart +
              node.name +
              stringifyAttributes(node, config) +
              config.tagShortEnd
            );
          } else {
            return (
              createIndent(config, state) +
              config.tagShortStart +
              node.name +
              stringifyAttributes(node, config) +
              config.tagOpenEnd +
              config.tagCloseStart +
              node.name +
              config.tagCloseEnd
            );
          }
        } else {
          let tagOpenStart = config.tagOpenStart;
          let tagOpenEnd = config.tagOpenEnd;
          let tagCloseStart = config.tagCloseStart;
          let tagCloseEnd = config.tagCloseEnd;
          let openIndent = createIndent(config, state);
          let closeIndent = createIndent(config, state);
          if (state.textContext) {
            tagOpenStart = defaults.tagOpenStart;
            tagOpenEnd = defaults.tagOpenEnd;
            tagCloseStart = defaults.tagCloseStart;
            tagCloseEnd = defaults.tagCloseEnd;
            openIndent = "";
          } else if (textElems.has(node.name)) {
            tagOpenEnd = defaults.tagOpenEnd;
            tagCloseStart = defaults.tagCloseStart;
            closeIndent = "";
            state.textContext = node;
          }
          const children = stringifyNode(node, config, state);
          if (state.textContext === node) {
            state.textContext = null;
          }
          return (
            openIndent +
            tagOpenStart +
            node.name +
            stringifyAttributes(node, config) +
            tagOpenEnd +
            children +
            closeIndent +
            tagCloseStart +
            node.name +
            tagCloseEnd
          );
        }
      };
      const stringifyAttributes = (node, config) => {
        let attrs = "";
        for (const [name, value] of Object.entries(node.attributes)) {
          if (value !== undefined) {
            const encodedValue = value
              .toString()
              .replace(config.regValEntities, config.encodeEntity);
            attrs +=
              " " + name + config.attrStart + encodedValue + config.attrEnd;
          } else {
            attrs += " " + name;
          }
        }
        return attrs;
      };
      const stringifyText = (node, config, state) =>
        createIndent(config, state) +
        config.textStart +
        node.value.replace(config.regEntities, config.encodeEntity) +
        (state.textContext ? "" : config.textEnd);
    },
    3630: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csstree = __nccwpck_require__(203);
      const csswhat = __nccwpck_require__(527);
      const {
        syntax: { specificity },
      } = __nccwpck_require__(6846);
      const { visit, matches } = __nccwpck_require__(4315);
      const {
        attrsGroups,
        inheritableAttrs,
        presentationNonInheritableGroupAttrs,
      } = __nccwpck_require__(4298);
      const csstreeWalkSkip = csstree.walk.skip;
      const parseRule = (ruleNode, dynamic) => {
        const declarations = [];
        ruleNode.block.children.forEach((cssNode) => {
          if (cssNode.type === "Declaration") {
            declarations.push({
              name: cssNode.property,
              value: csstree.generate(cssNode.value),
              important: cssNode.important === true,
            });
          }
        });
        const rules = [];
        csstree.walk(ruleNode.prelude, (node) => {
          if (node.type === "Selector") {
            const newNode = csstree.clone(node);
            let hasPseudoClasses = false;
            csstree.walk(newNode, (pseudoClassNode, item, list) => {
              if (pseudoClassNode.type === "PseudoClassSelector") {
                hasPseudoClasses = true;
                list.remove(item);
              }
            });
            rules.push({
              specificity: specificity(node),
              dynamic: hasPseudoClasses || dynamic,
              selector: csstree.generate(newNode),
              declarations,
            });
          }
        });
        return rules;
      };
      const parseStylesheet = (css, dynamic) => {
        const rules = [];
        const ast = csstree.parse(css, {
          parseValue: false,
          parseAtrulePrelude: false,
        });
        csstree.walk(ast, (cssNode) => {
          if (cssNode.type === "Rule") {
            rules.push(...parseRule(cssNode, dynamic || false));
            return csstreeWalkSkip;
          }
          if (cssNode.type === "Atrule") {
            if (
              cssNode.name === "keyframes" ||
              cssNode.name === "-webkit-keyframes"
            ) {
              return csstreeWalkSkip;
            }
            csstree.walk(cssNode, (ruleNode) => {
              if (ruleNode.type === "Rule") {
                rules.push(...parseRule(ruleNode, dynamic || true));
                return csstreeWalkSkip;
              }
            });
            return csstreeWalkSkip;
          }
        });
        return rules;
      };
      const parseStyleDeclarations = (css) => {
        const declarations = [];
        const ast = csstree.parse(css, {
          context: "declarationList",
          parseValue: false,
        });
        csstree.walk(ast, (cssNode) => {
          if (cssNode.type === "Declaration") {
            declarations.push({
              name: cssNode.property,
              value: csstree.generate(cssNode.value),
              important: cssNode.important === true,
            });
          }
        });
        return declarations;
      };
      const computeOwnStyle = (stylesheet, node) => {
        const computedStyle = {};
        const importantStyles = new Map();
        for (const [name, value] of Object.entries(node.attributes)) {
          if (attrsGroups.presentation.has(name)) {
            computedStyle[name] = { type: "static", inherited: false, value };
            importantStyles.set(name, false);
          }
        }
        for (const { selector, declarations, dynamic } of stylesheet.rules) {
          if (matches(node, selector)) {
            for (const { name, value, important } of declarations) {
              const computed = computedStyle[name];
              if (computed && computed.type === "dynamic") {
                continue;
              }
              if (dynamic) {
                computedStyle[name] = { type: "dynamic", inherited: false };
                continue;
              }
              if (
                computed == null ||
                important === true ||
                importantStyles.get(name) === false
              ) {
                computedStyle[name] = {
                  type: "static",
                  inherited: false,
                  value,
                };
                importantStyles.set(name, important);
              }
            }
          }
        }
        const styleDeclarations =
          node.attributes.style == null
            ? []
            : parseStyleDeclarations(node.attributes.style);
        for (const { name, value, important } of styleDeclarations) {
          const computed = computedStyle[name];
          if (computed && computed.type === "dynamic") {
            continue;
          }
          if (
            computed == null ||
            important === true ||
            importantStyles.get(name) === false
          ) {
            computedStyle[name] = { type: "static", inherited: false, value };
            importantStyles.set(name, important);
          }
        }
        return computedStyle;
      };
      const compareSpecificity = (a, b) => {
        for (let i = 0; i < 4; i += 1) {
          if (a[i] < b[i]) {
            return -1;
          } else if (a[i] > b[i]) {
            return 1;
          }
        }
        return 0;
      };
      exports.compareSpecificity = compareSpecificity;
      const collectStylesheet = (root) => {
        const rules = [];
        const parents = new Map();
        visit(root, {
          element: {
            enter: (node, parentNode) => {
              parents.set(node, parentNode);
              if (node.name !== "style") {
                return;
              }
              if (
                node.attributes.type == null ||
                node.attributes.type === "" ||
                node.attributes.type === "text/css"
              ) {
                const dynamic =
                  node.attributes.media != null &&
                  node.attributes.media !== "all";
                for (const child of node.children) {
                  if (child.type === "text" || child.type === "cdata") {
                    rules.push(...parseStylesheet(child.value, dynamic));
                  }
                }
              }
            },
          },
        });
        rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));
        return { rules, parents };
      };
      exports.collectStylesheet = collectStylesheet;
      const computeStyle = (stylesheet, node) => {
        const { parents } = stylesheet;
        const computedStyles = computeOwnStyle(stylesheet, node);
        let parent = parents.get(node);
        while (parent != null && parent.type !== "root") {
          const inheritedStyles = computeOwnStyle(stylesheet, parent);
          for (const [name, computed] of Object.entries(inheritedStyles)) {
            if (
              computedStyles[name] == null &&
              inheritableAttrs.has(name) &&
              !presentationNonInheritableGroupAttrs.has(name)
            ) {
              computedStyles[name] = { ...computed, inherited: true };
            }
          }
          parent = parents.get(parent);
        }
        return computedStyles;
      };
      exports.computeStyle = computeStyle;
      const includesAttrSelector = (
        selector,
        name,
        value = null,
        traversed = false,
      ) => {
        const selectors =
          typeof selector === "string"
            ? csswhat.parse(selector)
            : csswhat.parse(csstree.generate(selector.data));
        for (const subselector of selectors) {
          const hasAttrSelector = subselector.some((segment, index) => {
            if (traversed) {
              if (index === subselector.length - 1) {
                return false;
              }
              const isNextTraversal = csswhat.isTraversal(
                subselector[index + 1],
              );
              if (!isNextTraversal) {
                return false;
              }
            }
            if (segment.type !== "attribute" || segment.name !== name) {
              return false;
            }
            return value == null ? true : segment.value === value;
          });
          if (hasAttrSelector) {
            return true;
          }
        }
        return false;
      };
      exports.includesAttrSelector = includesAttrSelector;
    },
    7235: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const os = __nccwpck_require__(2037);
      const fs = __nccwpck_require__(7147);
      const { pathToFileURL } = __nccwpck_require__(7310);
      const path = __nccwpck_require__(1017);
      const { optimize: optimizeAgnostic } = __nccwpck_require__(3037);
      const importConfig = async (configFile) => {
        let config;
        if (configFile.endsWith(".cjs")) {
          config = require(configFile);
        } else {
          const { default: imported } = await __nccwpck_require__(4609)(
            pathToFileURL(configFile),
          );
          config = imported;
        }
        if (
          config == null ||
          typeof config !== "object" ||
          Array.isArray(config)
        ) {
          throw Error(`Invalid config file "${configFile}"`);
        }
        return config;
      };
      const isFile = async (file) => {
        try {
          const stats = await fs.promises.stat(file);
          return stats.isFile();
        } catch {
          return false;
        }
      };
      const loadConfig = async (configFile, cwd = process.cwd()) => {
        if (configFile != null) {
          if (path.isAbsolute(configFile)) {
            return await importConfig(configFile);
          } else {
            return await importConfig(path.join(cwd, configFile));
          }
        }
        let dir = cwd;
        while (true) {
          const js = path.join(dir, "svgo.config.js");
          if (await isFile(js)) {
            return await importConfig(js);
          }
          const mjs = path.join(dir, "svgo.config.mjs");
          if (await isFile(mjs)) {
            return await importConfig(mjs);
          }
          const cjs = path.join(dir, "svgo.config.cjs");
          if (await isFile(cjs)) {
            return await importConfig(cjs);
          }
          const parent = path.dirname(dir);
          if (dir === parent) {
            return null;
          }
          dir = parent;
        }
      };
      exports.loadConfig = loadConfig;
      const optimize = (input, config) => {
        if (config == null) {
          config = {};
        }
        if (typeof config !== "object") {
          throw Error("Config should be an object");
        }
        return optimizeAgnostic(input, {
          ...config,
          js2svg: { eol: os.EOL === "\r\n" ? "crlf" : "lf", ...config.js2svg },
        });
      };
      exports.optimize = optimize;
    },
    3037: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { parseSvg } = __nccwpck_require__(6723);
      const { stringifySvg } = __nccwpck_require__(1289);
      const { builtin } = __nccwpck_require__(3350);
      const { invokePlugins } = __nccwpck_require__(973);
      const { encodeSVGDatauri } = __nccwpck_require__(5916);
      const pluginsMap = {};
      for (const plugin of builtin) {
        pluginsMap[plugin.name] = plugin;
      }
      const resolvePluginConfig = (plugin) => {
        if (typeof plugin === "string") {
          const builtinPlugin = pluginsMap[plugin];
          if (builtinPlugin == null) {
            throw Error(`Unknown builtin plugin "${plugin}" specified.`);
          }
          return { name: plugin, params: {}, fn: builtinPlugin.fn };
        }
        if (typeof plugin === "object" && plugin != null) {
          if (plugin.name == null) {
            throw Error(`Plugin name should be specified`);
          }
          let fn = plugin.fn;
          if (fn == null) {
            const builtinPlugin = pluginsMap[plugin.name];
            if (builtinPlugin == null) {
              throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
            }
            fn = builtinPlugin.fn;
          }
          return { name: plugin.name, params: plugin.params, fn };
        }
        return null;
      };
      const optimize = (input, config) => {
        if (config == null) {
          config = {};
        }
        if (typeof config !== "object") {
          throw Error("Config should be an object");
        }
        const maxPassCount = config.multipass ? 10 : 1;
        let prevResultSize = Number.POSITIVE_INFINITY;
        let output = "";
        const info = {};
        if (config.path != null) {
          info.path = config.path;
        }
        for (let i = 0; i < maxPassCount; i += 1) {
          info.multipassCount = i;
          const ast = parseSvg(input, config.path);
          const plugins = config.plugins || ["preset-default"];
          if (!Array.isArray(plugins)) {
            throw Error(
              "malformed config, `plugins` property must be an array.\nSee more info here: https://github.com/svg/svgo#configuration",
            );
          }
          const resolvedPlugins = plugins
            .filter((plugin) => plugin != null)
            .map(resolvePluginConfig);
          if (resolvedPlugins.length < plugins.length) {
            console.warn(
              "Warning: plugins list includes null or undefined elements, these will be ignored.",
            );
          }
          const globalOverrides = {};
          if (config.floatPrecision != null) {
            globalOverrides.floatPrecision = config.floatPrecision;
          }
          invokePlugins(ast, info, resolvedPlugins, null, globalOverrides);
          output = stringifySvg(ast, config.js2svg);
          if (output.length < prevResultSize) {
            input = output;
            prevResultSize = output.length;
          } else {
            break;
          }
        }
        if (config.datauri) {
          output = encodeSVGDatauri(output, config.datauri);
        }
        return { data: output };
      };
      exports.optimize = optimize;
    },
    7024: (module) => {
      "use strict";
      const isTag = (node) => node.type === "element";
      const existsOne = (test, elems) =>
        elems.some((elem) => {
          if (isTag(elem)) {
            return test(elem) || existsOne(test, getChildren(elem));
          } else {
            return false;
          }
        });
      const getAttributeValue = (elem, name) => elem.attributes[name];
      const getChildren = (node) => node.children || [];
      const getName = (elemAst) => elemAst.name;
      const getParent = (node) => node.parentNode || null;
      const getSiblings = (elem) => {
        var parent = getParent(elem);
        return parent ? getChildren(parent) : [];
      };
      const getText = (node) => {
        if (
          node.children[0].type === "text" &&
          node.children[0].type === "cdata"
        ) {
          return node.children[0].value;
        }
        return "";
      };
      const hasAttrib = (elem, name) => elem.attributes[name] !== undefined;
      const removeSubsets = (nodes) => {
        let idx = nodes.length;
        let node;
        let ancestor;
        let replace;
        while (--idx > -1) {
          node = ancestor = nodes[idx];
          nodes[idx] = null;
          replace = true;
          while (ancestor) {
            if (nodes.includes(ancestor)) {
              replace = false;
              nodes.splice(idx, 1);
              break;
            }
            ancestor = getParent(ancestor);
          }
          if (replace) {
            nodes[idx] = node;
          }
        }
        return nodes;
      };
      const findAll = (test, elems) => {
        const result = [];
        for (const elem of elems) {
          if (isTag(elem)) {
            if (test(elem)) {
              result.push(elem);
            }
            result.push(...findAll(test, getChildren(elem)));
          }
        }
        return result;
      };
      const findOne = (test, elems) => {
        for (const elem of elems) {
          if (isTag(elem)) {
            if (test(elem)) {
              return elem;
            }
            const result = findOne(test, getChildren(elem));
            if (result) {
              return result;
            }
          }
        }
        return null;
      };
      const svgoCssSelectAdapter = {
        isTag,
        existsOne,
        getAttributeValue,
        getChildren,
        getName,
        getParent,
        getSiblings,
        getText,
        hasAttrib,
        removeSubsets,
        findAll,
        findOne,
      };
      module.exports = svgoCssSelectAdapter;
    },
    973: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit } = __nccwpck_require__(4315);
      const invokePlugins = (
        ast,
        info,
        plugins,
        overrides,
        globalOverrides,
      ) => {
        for (const plugin of plugins) {
          const override = overrides?.[plugin.name];
          if (override === false) {
            continue;
          }
          const params = { ...plugin.params, ...globalOverrides, ...override };
          const visitor = plugin.fn(ast, params, info);
          if (visitor != null) {
            visit(ast, visitor);
          }
        }
      };
      exports.invokePlugins = invokePlugins;
      const createPreset = ({ name, plugins }) => ({
        name,
        fn: (ast, params, info) => {
          const { floatPrecision, overrides } = params;
          const globalOverrides = {};
          if (floatPrecision != null) {
            globalOverrides.floatPrecision = floatPrecision;
          }
          if (overrides) {
            const pluginNames = plugins.map(({ name }) => name);
            for (const pluginName of Object.keys(overrides)) {
              if (!pluginNames.includes(pluginName)) {
                console.warn(
                  `You are trying to configure ${pluginName} which is not part of ${name}.\n` +
                    `Try to put it before or after, for example\n\n` +
                    `plugins: [\n` +
                    `  {\n` +
                    `    name: '${name}',\n` +
                    `  },\n` +
                    `  '${pluginName}'\n` +
                    `]\n`,
                );
              }
            }
          }
          invokePlugins(ast, info, plugins, overrides, globalOverrides);
        },
      });
      exports.createPreset = createPreset;
    },
    5916: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { attrsGroups, referencesProps } = __nccwpck_require__(4298);
      const regReferencesUrl = /\burl\((["'])?#(.+?)\1\)/g;
      const regReferencesHref = /^#(.+?)$/;
      const regReferencesBegin = /(\w+)\.[a-zA-Z]/;
      exports.encodeSVGDatauri = (str, type) => {
        var prefix = "data:image/svg+xml";
        if (!type || type === "base64") {
          prefix += ";base64,";
          str = prefix + Buffer.from(str).toString("base64");
        } else if (type === "enc") {
          str = prefix + "," + encodeURIComponent(str);
        } else if (type === "unenc") {
          str = prefix + "," + str;
        }
        return str;
      };
      exports.decodeSVGDatauri = (str) => {
        var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
        var match = regexp.exec(str);
        if (!match) return str;
        var data = match[3];
        if (match[2]) {
          str = Buffer.from(data, "base64").toString("utf8");
        } else if (data.charAt(0) === "%") {
          str = decodeURIComponent(data);
        } else if (data.charAt(0) === "<") {
          str = data;
        }
        return str;
      };
      exports.cleanupOutData = (data, params, command) => {
        let str = "";
        let delimiter;
        let prev;
        data.forEach((item, i) => {
          delimiter = " ";
          if (i == 0) delimiter = "";
          if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
            var pos = i % 7;
            if (pos == 4 || pos == 5) delimiter = "";
          }
          const itemStr = params.leadingZero
            ? removeLeadingZero(item)
            : item.toString();
          if (
            params.negativeExtraSpace &&
            delimiter != "" &&
            (item < 0 || (itemStr.charAt(0) === "." && prev % 1 !== 0))
          ) {
            delimiter = "";
          }
          prev = item;
          str += delimiter + itemStr;
        });
        return str;
      };
      const removeLeadingZero = (value) => {
        const strValue = value.toString();
        if (0 < value && value < 1 && strValue.startsWith("0")) {
          return strValue.slice(1);
        }
        if (-1 < value && value < 0 && strValue[1] === "0") {
          return strValue[0] + strValue.slice(2);
        }
        return strValue;
      };
      exports.removeLeadingZero = removeLeadingZero;
      const hasScripts = (node) => {
        if (node.name === "script" && node.children.length !== 0) {
          return true;
        }
        if (node.name === "a") {
          const hasJsLinks = Object.entries(node.attributes).some(
            ([attrKey, attrValue]) =>
              (attrKey === "href" || attrKey.endsWith(":href")) &&
              attrValue != null &&
              attrValue.trimStart().startsWith("javascript:"),
          );
          if (hasJsLinks) {
            return true;
          }
        }
        const eventAttrs = [
          ...attrsGroups.animationEvent,
          ...attrsGroups.documentEvent,
          ...attrsGroups.documentElementEvent,
          ...attrsGroups.globalEvent,
          ...attrsGroups.graphicalEvent,
        ];
        return eventAttrs.some((attr) => node.attributes[attr] != null);
      };
      exports.hasScripts = hasScripts;
      const includesUrlReference = (body) =>
        new RegExp(regReferencesUrl).test(body);
      exports.includesUrlReference = includesUrlReference;
      const findReferences = (attribute, value) => {
        const results = [];
        if (referencesProps.has(attribute)) {
          const matches = value.matchAll(regReferencesUrl);
          for (const match of matches) {
            results.push(match[2]);
          }
        }
        if (attribute === "href" || attribute.endsWith(":href")) {
          const match = regReferencesHref.exec(value);
          if (match != null) {
            results.push(match[1]);
          }
        }
        if (attribute === "begin") {
          const match = regReferencesBegin.exec(value);
          if (match != null) {
            results.push(match[1]);
          }
        }
        return results.map((body) => decodeURI(body));
      };
      exports.findReferences = findReferences;
      const toFixed = (num, precision) => {
        const pow = 10 ** precision;
        return Math.round(num * pow) / pow;
      };
      exports.toFixed = toFixed;
    },
    4315: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { selectAll, selectOne, is } = __nccwpck_require__(1275);
      const xastAdaptor = __nccwpck_require__(7024);
      const cssSelectOptions = { xmlMode: true, adapter: xastAdaptor };
      const querySelectorAll = (node, selector) =>
        selectAll(selector, node, cssSelectOptions);
      exports.querySelectorAll = querySelectorAll;
      const querySelector = (node, selector) =>
        selectOne(selector, node, cssSelectOptions);
      exports.querySelector = querySelector;
      const matches = (node, selector) => is(node, selector, cssSelectOptions);
      exports.matches = matches;
      const visitSkip = Symbol();
      exports.visitSkip = visitSkip;
      const visit = (node, visitor, parentNode) => {
        const callbacks = visitor[node.type];
        if (callbacks && callbacks.enter) {
          const symbol = callbacks.enter(node, parentNode);
          if (symbol === visitSkip) {
            return;
          }
        }
        if (node.type === "root") {
          for (const child of node.children) {
            visit(child, visitor, node);
          }
        }
        if (node.type === "element") {
          if (parentNode.children.includes(node)) {
            for (const child of node.children) {
              visit(child, visitor, node);
            }
          }
        }
        if (callbacks && callbacks.exit) {
          callbacks.exit(node, parentNode);
        }
      };
      exports.visit = visit;
      const detachNodeFromParent = (node, parentNode) => {
        parentNode.children = parentNode.children.filter(
          (child) => child !== node,
        );
      };
      exports.detachNodeFromParent = detachNodeFromParent;
    },
    4298: (__unused_webpack_module, exports) => {
      "use strict";
      exports.elemsGroups = {
        animation: new Set([
          "animate",
          "animateColor",
          "animateMotion",
          "animateTransform",
          "set",
        ]),
        descriptive: new Set(["desc", "metadata", "title"]),
        shape: new Set([
          "circle",
          "ellipse",
          "line",
          "path",
          "polygon",
          "polyline",
          "rect",
        ]),
        structural: new Set(["defs", "g", "svg", "symbol", "use"]),
        paintServer: new Set([
          "hatch",
          "linearGradient",
          "meshGradient",
          "pattern",
          "radialGradient",
          "solidColor",
        ]),
        nonRendering: new Set([
          "clipPath",
          "filter",
          "linearGradient",
          "marker",
          "mask",
          "pattern",
          "radialGradient",
          "solidColor",
          "symbol",
        ]),
        container: new Set([
          "a",
          "defs",
          "foreignObject",
          "g",
          "marker",
          "mask",
          "missing-glyph",
          "pattern",
          "svg",
          "switch",
          "symbol",
        ]),
        textContent: new Set([
          "altGlyph",
          "altGlyphDef",
          "altGlyphItem",
          "glyph",
          "glyphRef",
          "text",
          "textPath",
          "tref",
          "tspan",
        ]),
        textContentChild: new Set(["altGlyph", "textPath", "tref", "tspan"]),
        lightSource: new Set([
          "feDiffuseLighting",
          "feDistantLight",
          "fePointLight",
          "feSpecularLighting",
          "feSpotLight",
        ]),
        filterPrimitive: new Set([
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDropShadow",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "feSpecularLighting",
          "feTile",
          "feTurbulence",
        ]),
      };
      exports.textElems = new Set([
        ...exports.elemsGroups.textContent,
        "pre",
        "title",
      ]);
      exports.pathElems = new Set(["glyph", "missing-glyph", "path"]);
      exports.attrsGroups = {
        animationAddition: new Set(["additive", "accumulate"]),
        animationAttributeTarget: new Set(["attributeType", "attributeName"]),
        animationEvent: new Set(["onbegin", "onend", "onrepeat", "onload"]),
        animationTiming: new Set([
          "begin",
          "dur",
          "end",
          "fill",
          "max",
          "min",
          "repeatCount",
          "repeatDur",
          "restart",
        ]),
        animationValue: new Set([
          "by",
          "calcMode",
          "from",
          "keySplines",
          "keyTimes",
          "to",
          "values",
        ]),
        conditionalProcessing: new Set([
          "requiredExtensions",
          "requiredFeatures",
          "systemLanguage",
        ]),
        core: new Set(["id", "tabindex", "xml:base", "xml:lang", "xml:space"]),
        graphicalEvent: new Set([
          "onactivate",
          "onclick",
          "onfocusin",
          "onfocusout",
          "onload",
          "onmousedown",
          "onmousemove",
          "onmouseout",
          "onmouseover",
          "onmouseup",
        ]),
        presentation: new Set([
          "alignment-baseline",
          "baseline-shift",
          "clip-path",
          "clip-rule",
          "clip",
          "color-interpolation-filters",
          "color-interpolation",
          "color-profile",
          "color-rendering",
          "color",
          "cursor",
          "direction",
          "display",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "fill",
          "filter",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size-adjust",
          "font-size",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "mask",
          "opacity",
          "overflow",
          "paint-order",
          "pointer-events",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "stroke",
          "text-anchor",
          "text-decoration",
          "text-overflow",
          "text-rendering",
          "transform-origin",
          "transform",
          "unicode-bidi",
          "vector-effect",
          "visibility",
          "word-spacing",
          "writing-mode",
        ]),
        xlink: new Set([
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:href",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type",
        ]),
        documentEvent: new Set([
          "onabort",
          "onerror",
          "onresize",
          "onscroll",
          "onunload",
          "onzoom",
        ]),
        documentElementEvent: new Set(["oncopy", "oncut", "onpaste"]),
        globalEvent: new Set([
          "oncancel",
          "oncanplay",
          "oncanplaythrough",
          "onchange",
          "onclick",
          "onclose",
          "oncuechange",
          "ondblclick",
          "ondrag",
          "ondragend",
          "ondragenter",
          "ondragleave",
          "ondragover",
          "ondragstart",
          "ondrop",
          "ondurationchange",
          "onemptied",
          "onended",
          "onerror",
          "onfocus",
          "oninput",
          "oninvalid",
          "onkeydown",
          "onkeypress",
          "onkeyup",
          "onload",
          "onloadeddata",
          "onloadedmetadata",
          "onloadstart",
          "onmousedown",
          "onmouseenter",
          "onmouseleave",
          "onmousemove",
          "onmouseout",
          "onmouseover",
          "onmouseup",
          "onmousewheel",
          "onpause",
          "onplay",
          "onplaying",
          "onprogress",
          "onratechange",
          "onreset",
          "onresize",
          "onscroll",
          "onseeked",
          "onseeking",
          "onselect",
          "onshow",
          "onstalled",
          "onsubmit",
          "onsuspend",
          "ontimeupdate",
          "ontoggle",
          "onvolumechange",
          "onwaiting",
        ]),
        filterPrimitive: new Set(["x", "y", "width", "height", "result"]),
        transferFunction: new Set([
          "amplitude",
          "exponent",
          "intercept",
          "offset",
          "slope",
          "tableValues",
          "type",
        ]),
      };
      exports.attrsGroupsDefaults = {
        core: { "xml:space": "default" },
        presentation: {
          clip: "auto",
          "clip-path": "none",
          "clip-rule": "nonzero",
          mask: "none",
          opacity: "1",
          "stop-color": "#000",
          "stop-opacity": "1",
          "fill-opacity": "1",
          "fill-rule": "nonzero",
          fill: "#000",
          stroke: "none",
          "stroke-width": "1",
          "stroke-linecap": "butt",
          "stroke-linejoin": "miter",
          "stroke-miterlimit": "4",
          "stroke-dasharray": "none",
          "stroke-dashoffset": "0",
          "stroke-opacity": "1",
          "paint-order": "normal",
          "vector-effect": "none",
          display: "inline",
          visibility: "visible",
          "marker-start": "none",
          "marker-mid": "none",
          "marker-end": "none",
          "color-interpolation": "sRGB",
          "color-interpolation-filters": "linearRGB",
          "color-rendering": "auto",
          "shape-rendering": "auto",
          "text-rendering": "auto",
          "image-rendering": "auto",
          "font-style": "normal",
          "font-variant": "normal",
          "font-weight": "normal",
          "font-stretch": "normal",
          "font-size": "medium",
          "font-size-adjust": "none",
          kerning: "auto",
          "letter-spacing": "normal",
          "word-spacing": "normal",
          "text-decoration": "none",
          "text-anchor": "start",
          "text-overflow": "clip",
          "writing-mode": "lr-tb",
          "glyph-orientation-vertical": "auto",
          "glyph-orientation-horizontal": "0deg",
          direction: "ltr",
          "unicode-bidi": "normal",
          "dominant-baseline": "auto",
          "alignment-baseline": "baseline",
          "baseline-shift": "baseline",
        },
        transferFunction: {
          slope: "1",
          intercept: "0",
          amplitude: "1",
          exponent: "1",
          offset: "0",
        },
      };
      exports.elems = {
        a: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "style",
            "target",
            "transform",
          ]),
          defaults: { target: "_self" },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
            "tspan",
          ]),
        },
        altGlyph: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "dx",
            "dy",
            "externalResourcesRequired",
            "format",
            "glyphRef",
            "rotate",
            "style",
            "x",
            "y",
          ]),
        },
        altGlyphDef: {
          attrsGroups: new Set(["core"]),
          content: new Set(["glyphRef"]),
        },
        altGlyphItem: {
          attrsGroups: new Set(["core"]),
          content: new Set(["glyphRef", "altGlyphItem"]),
        },
        animate: {
          attrsGroups: new Set([
            "animationAddition",
            "animationAttributeTarget",
            "animationEvent",
            "animationTiming",
            "animationValue",
            "conditionalProcessing",
            "core",
            "presentation",
            "xlink",
          ]),
          attrs: new Set(["externalResourcesRequired"]),
          contentGroups: new Set(["descriptive"]),
        },
        animateColor: {
          attrsGroups: new Set([
            "animationAddition",
            "animationAttributeTarget",
            "animationEvent",
            "animationTiming",
            "animationValue",
            "conditionalProcessing",
            "core",
            "presentation",
            "xlink",
          ]),
          attrs: new Set(["externalResourcesRequired"]),
          contentGroups: new Set(["descriptive"]),
        },
        animateMotion: {
          attrsGroups: new Set([
            "animationAddition",
            "animationEvent",
            "animationTiming",
            "animationValue",
            "conditionalProcessing",
            "core",
            "xlink",
          ]),
          attrs: new Set([
            "externalResourcesRequired",
            "keyPoints",
            "origin",
            "path",
            "rotate",
          ]),
          defaults: { rotate: "0" },
          contentGroups: new Set(["descriptive"]),
          content: new Set(["mpath"]),
        },
        animateTransform: {
          attrsGroups: new Set([
            "animationAddition",
            "animationAttributeTarget",
            "animationEvent",
            "animationTiming",
            "animationValue",
            "conditionalProcessing",
            "core",
            "xlink",
          ]),
          attrs: new Set(["externalResourcesRequired", "type"]),
          contentGroups: new Set(["descriptive"]),
        },
        circle: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "cx",
            "cy",
            "externalResourcesRequired",
            "r",
            "style",
            "transform",
          ]),
          defaults: { cx: "0", cy: "0" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        clipPath: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "clipPathUnits",
            "externalResourcesRequired",
            "style",
            "transform",
          ]),
          defaults: { clipPathUnits: "userSpaceOnUse" },
          contentGroups: new Set(["animation", "descriptive", "shape"]),
          content: new Set(["text", "use"]),
        },
        "color-profile": {
          attrsGroups: new Set(["core", "xlink"]),
          attrs: new Set(["local", "name", "rendering-intent"]),
          defaults: { name: "sRGB", "rendering-intent": "auto" },
          contentGroups: new Set(["descriptive"]),
        },
        cursor: {
          attrsGroups: new Set(["core", "conditionalProcessing", "xlink"]),
          attrs: new Set(["externalResourcesRequired", "x", "y"]),
          defaults: { x: "0", y: "0" },
          contentGroups: new Set(["descriptive"]),
        },
        defs: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "style",
            "transform",
          ]),
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        desc: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["class", "style"]),
        },
        ellipse: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "cx",
            "cy",
            "externalResourcesRequired",
            "rx",
            "ry",
            "style",
            "transform",
          ]),
          defaults: { cx: "0", cy: "0" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        feBlend: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in", "in2", "mode"]),
          defaults: { mode: "normal" },
          content: new Set(["animate", "set"]),
        },
        feColorMatrix: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in", "type", "values"]),
          defaults: { type: "matrix" },
          content: new Set(["animate", "set"]),
        },
        feComponentTransfer: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in"]),
          content: new Set(["feFuncA", "feFuncB", "feFuncG", "feFuncR"]),
        },
        feComposite: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set([
            "class",
            "in",
            "in2",
            "k1",
            "k2",
            "k3",
            "k4",
            "operator",
            "style",
          ]),
          defaults: { operator: "over", k1: "0", k2: "0", k3: "0", k4: "0" },
          content: new Set(["animate", "set"]),
        },
        feConvolveMatrix: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set([
            "class",
            "in",
            "kernelMatrix",
            "order",
            "style",
            "bias",
            "divisor",
            "edgeMode",
            "targetX",
            "targetY",
            "kernelUnitLength",
            "preserveAlpha",
          ]),
          defaults: {
            order: "3",
            bias: "0",
            edgeMode: "duplicate",
            preserveAlpha: "false",
          },
          content: new Set(["animate", "set"]),
        },
        feDiffuseLighting: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set([
            "class",
            "diffuseConstant",
            "in",
            "kernelUnitLength",
            "style",
            "surfaceScale",
          ]),
          defaults: { surfaceScale: "1", diffuseConstant: "1" },
          contentGroups: new Set(["descriptive"]),
          content: new Set(["feDistantLight", "fePointLight", "feSpotLight"]),
        },
        feDisplacementMap: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set([
            "class",
            "in",
            "in2",
            "scale",
            "style",
            "xChannelSelector",
            "yChannelSelector",
          ]),
          defaults: {
            scale: "0",
            xChannelSelector: "A",
            yChannelSelector: "A",
          },
          content: new Set(["animate", "set"]),
        },
        feDistantLight: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["azimuth", "elevation"]),
          defaults: { azimuth: "0", elevation: "0" },
          content: new Set(["animate", "set"]),
        },
        feFlood: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style"]),
          content: new Set(["animate", "animateColor", "set"]),
        },
        feFuncA: {
          attrsGroups: new Set(["core", "transferFunction"]),
          content: new Set(["set", "animate"]),
        },
        feFuncB: {
          attrsGroups: new Set(["core", "transferFunction"]),
          content: new Set(["set", "animate"]),
        },
        feFuncG: {
          attrsGroups: new Set(["core", "transferFunction"]),
          content: new Set(["set", "animate"]),
        },
        feFuncR: {
          attrsGroups: new Set(["core", "transferFunction"]),
          content: new Set(["set", "animate"]),
        },
        feGaussianBlur: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in", "stdDeviation"]),
          defaults: { stdDeviation: "0" },
          content: new Set(["set", "animate"]),
        },
        feImage: {
          attrsGroups: new Set([
            "core",
            "presentation",
            "filterPrimitive",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "href",
            "preserveAspectRatio",
            "style",
            "xlink:href",
          ]),
          defaults: { preserveAspectRatio: "xMidYMid meet" },
          content: new Set(["animate", "animateTransform", "set"]),
        },
        feMerge: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style"]),
          content: new Set(["feMergeNode"]),
        },
        feMergeNode: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["in"]),
          content: new Set(["animate", "set"]),
        },
        feMorphology: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in", "operator", "radius"]),
          defaults: { operator: "erode", radius: "0" },
          content: new Set(["animate", "set"]),
        },
        feOffset: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in", "dx", "dy"]),
          defaults: { dx: "0", dy: "0" },
          content: new Set(["animate", "set"]),
        },
        fePointLight: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["x", "y", "z"]),
          defaults: { x: "0", y: "0", z: "0" },
          content: new Set(["animate", "set"]),
        },
        feSpecularLighting: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set([
            "class",
            "in",
            "kernelUnitLength",
            "specularConstant",
            "specularExponent",
            "style",
            "surfaceScale",
          ]),
          defaults: {
            surfaceScale: "1",
            specularConstant: "1",
            specularExponent: "1",
          },
          contentGroups: new Set(["descriptive", "lightSource"]),
        },
        feSpotLight: {
          attrsGroups: new Set(["core"]),
          attrs: new Set([
            "limitingConeAngle",
            "pointsAtX",
            "pointsAtY",
            "pointsAtZ",
            "specularExponent",
            "x",
            "y",
            "z",
          ]),
          defaults: {
            x: "0",
            y: "0",
            z: "0",
            pointsAtX: "0",
            pointsAtY: "0",
            pointsAtZ: "0",
            specularExponent: "1",
          },
          content: new Set(["animate", "set"]),
        },
        feTile: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set(["class", "style", "in"]),
          content: new Set(["animate", "set"]),
        },
        feTurbulence: {
          attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
          attrs: new Set([
            "baseFrequency",
            "class",
            "numOctaves",
            "seed",
            "stitchTiles",
            "style",
            "type",
          ]),
          defaults: {
            baseFrequency: "0",
            numOctaves: "1",
            seed: "0",
            stitchTiles: "noStitch",
            type: "turbulence",
          },
          content: new Set(["animate", "set"]),
        },
        filter: {
          attrsGroups: new Set(["core", "presentation", "xlink"]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "filterRes",
            "filterUnits",
            "height",
            "href",
            "primitiveUnits",
            "style",
            "width",
            "x",
            "xlink:href",
            "y",
          ]),
          defaults: {
            primitiveUnits: "userSpaceOnUse",
            x: "-10%",
            y: "-10%",
            width: "120%",
            height: "120%",
          },
          contentGroups: new Set(["descriptive", "filterPrimitive"]),
          content: new Set(["animate", "set"]),
        },
        font: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "horiz-adv-x",
            "horiz-origin-x",
            "horiz-origin-y",
            "style",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
          ]),
          defaults: { "horiz-origin-x": "0", "horiz-origin-y": "0" },
          contentGroups: new Set(["descriptive"]),
          content: new Set([
            "font-face",
            "glyph",
            "hkern",
            "missing-glyph",
            "vkern",
          ]),
        },
        "font-face": {
          attrsGroups: new Set(["core"]),
          attrs: new Set([
            "font-family",
            "font-style",
            "font-variant",
            "font-weight",
            "font-stretch",
            "font-size",
            "unicode-range",
            "units-per-em",
            "panose-1",
            "stemv",
            "stemh",
            "slope",
            "cap-height",
            "x-height",
            "accent-height",
            "ascent",
            "descent",
            "widths",
            "bbox",
            "ideographic",
            "alphabetic",
            "mathematical",
            "hanging",
            "v-ideographic",
            "v-alphabetic",
            "v-mathematical",
            "v-hanging",
            "underline-position",
            "underline-thickness",
            "strikethrough-position",
            "strikethrough-thickness",
            "overline-position",
            "overline-thickness",
          ]),
          defaults: {
            "font-style": "all",
            "font-variant": "normal",
            "font-weight": "all",
            "font-stretch": "normal",
            "unicode-range": "U+0-10FFFF",
            "units-per-em": "1000",
            "panose-1": "0 0 0 0 0 0 0 0 0 0",
            slope: "0",
          },
          contentGroups: new Set(["descriptive"]),
          content: new Set(["font-face-src"]),
        },
        "font-face-format": {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["string"]),
        },
        "font-face-name": {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["name"]),
        },
        "font-face-src": {
          attrsGroups: new Set(["core"]),
          content: new Set(["font-face-name", "font-face-uri"]),
        },
        "font-face-uri": {
          attrsGroups: new Set(["core", "xlink"]),
          attrs: new Set(["href", "xlink:href"]),
          content: new Set(["font-face-format"]),
        },
        foreignObject: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "height",
            "style",
            "transform",
            "width",
            "x",
            "y",
          ]),
          defaults: { x: "0", y: "0" },
        },
        g: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "style",
            "transform",
          ]),
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        glyph: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set([
            "arabic-form",
            "class",
            "d",
            "glyph-name",
            "horiz-adv-x",
            "lang",
            "orientation",
            "style",
            "unicode",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
          ]),
          defaults: { "arabic-form": "initial" },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        glyphRef: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set([
            "class",
            "d",
            "horiz-adv-x",
            "style",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
          ]),
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        hatch: {
          attrsGroups: new Set(["core", "presentation", "xlink"]),
          attrs: new Set([
            "class",
            "hatchContentUnits",
            "hatchUnits",
            "pitch",
            "rotate",
            "style",
            "transform",
            "x",
            "y",
          ]),
          defaults: {
            hatchUnits: "objectBoundingBox",
            hatchContentUnits: "userSpaceOnUse",
            x: "0",
            y: "0",
            pitch: "0",
            rotate: "0",
          },
          contentGroups: new Set(["animation", "descriptive"]),
          content: new Set(["hatchPath"]),
        },
        hatchPath: {
          attrsGroups: new Set(["core", "presentation", "xlink"]),
          attrs: new Set(["class", "style", "d", "offset"]),
          defaults: { offset: "0" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        hkern: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["u1", "g1", "u2", "g2", "k"]),
        },
        image: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "height",
            "href",
            "preserveAspectRatio",
            "style",
            "transform",
            "width",
            "x",
            "xlink:href",
            "y",
          ]),
          defaults: { x: "0", y: "0", preserveAspectRatio: "xMidYMid meet" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        line: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "style",
            "transform",
            "x1",
            "x2",
            "y1",
            "y2",
          ]),
          defaults: { x1: "0", y1: "0", x2: "0", y2: "0" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        linearGradient: {
          attrsGroups: new Set(["core", "presentation", "xlink"]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "gradientTransform",
            "gradientUnits",
            "href",
            "spreadMethod",
            "style",
            "x1",
            "x2",
            "xlink:href",
            "y1",
            "y2",
          ]),
          defaults: {
            x1: "0",
            y1: "0",
            x2: "100%",
            y2: "0",
            spreadMethod: "pad",
          },
          contentGroups: new Set(["descriptive"]),
          content: new Set(["animate", "animateTransform", "set", "stop"]),
        },
        marker: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "markerHeight",
            "markerUnits",
            "markerWidth",
            "orient",
            "preserveAspectRatio",
            "refX",
            "refY",
            "style",
            "viewBox",
          ]),
          defaults: {
            markerUnits: "strokeWidth",
            refX: "0",
            refY: "0",
            markerWidth: "3",
            markerHeight: "3",
          },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        mask: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "height",
            "mask-type",
            "maskContentUnits",
            "maskUnits",
            "style",
            "width",
            "x",
            "y",
          ]),
          defaults: {
            maskUnits: "objectBoundingBox",
            maskContentUnits: "userSpaceOnUse",
            x: "-10%",
            y: "-10%",
            width: "120%",
            height: "120%",
          },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        metadata: { attrsGroups: new Set(["core"]) },
        "missing-glyph": {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set([
            "class",
            "d",
            "horiz-adv-x",
            "style",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
          ]),
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        mpath: {
          attrsGroups: new Set(["core", "xlink"]),
          attrs: new Set(["externalResourcesRequired", "href", "xlink:href"]),
          contentGroups: new Set(["descriptive"]),
        },
        path: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "d",
            "externalResourcesRequired",
            "pathLength",
            "style",
            "transform",
          ]),
          contentGroups: new Set(["animation", "descriptive"]),
        },
        pattern: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "height",
            "href",
            "patternContentUnits",
            "patternTransform",
            "patternUnits",
            "preserveAspectRatio",
            "style",
            "viewBox",
            "width",
            "x",
            "xlink:href",
            "y",
          ]),
          defaults: {
            patternUnits: "objectBoundingBox",
            patternContentUnits: "userSpaceOnUse",
            x: "0",
            y: "0",
            width: "0",
            height: "0",
            preserveAspectRatio: "xMidYMid meet",
          },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        polygon: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "points",
            "style",
            "transform",
          ]),
          contentGroups: new Set(["animation", "descriptive"]),
        },
        polyline: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "points",
            "style",
            "transform",
          ]),
          contentGroups: new Set(["animation", "descriptive"]),
        },
        radialGradient: {
          attrsGroups: new Set(["core", "presentation", "xlink"]),
          attrs: new Set([
            "class",
            "cx",
            "cy",
            "externalResourcesRequired",
            "fr",
            "fx",
            "fy",
            "gradientTransform",
            "gradientUnits",
            "href",
            "r",
            "spreadMethod",
            "style",
            "xlink:href",
          ]),
          defaults: {
            gradientUnits: "objectBoundingBox",
            cx: "50%",
            cy: "50%",
            r: "50%",
          },
          contentGroups: new Set(["descriptive"]),
          content: new Set(["animate", "animateTransform", "set", "stop"]),
        },
        meshGradient: {
          attrsGroups: new Set(["core", "presentation", "xlink"]),
          attrs: new Set([
            "class",
            "style",
            "x",
            "y",
            "gradientUnits",
            "transform",
          ]),
          contentGroups: new Set(["descriptive", "paintServer", "animation"]),
          content: new Set(["meshRow"]),
        },
        meshRow: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set(["class", "style"]),
          contentGroups: new Set(["descriptive"]),
          content: new Set(["meshPatch"]),
        },
        meshPatch: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set(["class", "style"]),
          contentGroups: new Set(["descriptive"]),
          content: new Set(["stop"]),
        },
        rect: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "height",
            "rx",
            "ry",
            "style",
            "transform",
            "width",
            "x",
            "y",
          ]),
          defaults: { x: "0", y: "0" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        script: {
          attrsGroups: new Set(["core", "xlink"]),
          attrs: new Set([
            "externalResourcesRequired",
            "type",
            "href",
            "xlink:href",
          ]),
        },
        set: {
          attrsGroups: new Set([
            "animation",
            "animationAttributeTarget",
            "animationTiming",
            "conditionalProcessing",
            "core",
            "xlink",
          ]),
          attrs: new Set(["externalResourcesRequired", "to"]),
          contentGroups: new Set(["descriptive"]),
        },
        solidColor: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set(["class", "style"]),
          contentGroups: new Set(["paintServer"]),
        },
        stop: {
          attrsGroups: new Set(["core", "presentation"]),
          attrs: new Set(["class", "style", "offset", "path"]),
          content: new Set(["animate", "animateColor", "set"]),
        },
        style: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["type", "media", "title"]),
          defaults: { type: "text/css" },
        },
        svg: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "documentEvent",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "baseProfile",
            "class",
            "contentScriptType",
            "contentStyleType",
            "height",
            "preserveAspectRatio",
            "style",
            "version",
            "viewBox",
            "width",
            "x",
            "y",
            "zoomAndPan",
          ]),
          defaults: {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            preserveAspectRatio: "xMidYMid meet",
            zoomAndPan: "magnify",
            version: "1.1",
            baseProfile: "none",
            contentScriptType: "application/ecmascript",
            contentStyleType: "text/css",
          },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        switch: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "style",
            "transform",
          ]),
          contentGroups: new Set(["animation", "descriptive", "shape"]),
          content: new Set([
            "a",
            "foreignObject",
            "g",
            "image",
            "svg",
            "switch",
            "text",
            "use",
          ]),
        },
        symbol: {
          attrsGroups: new Set(["core", "graphicalEvent", "presentation"]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "preserveAspectRatio",
            "refX",
            "refY",
            "style",
            "viewBox",
          ]),
          defaults: { refX: "0", refY: "0" },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "paintServer",
            "shape",
            "structural",
          ]),
          content: new Set([
            "a",
            "altGlyphDef",
            "clipPath",
            "color-profile",
            "cursor",
            "filter",
            "font-face",
            "font",
            "foreignObject",
            "image",
            "marker",
            "mask",
            "pattern",
            "script",
            "style",
            "switch",
            "text",
            "view",
          ]),
        },
        text: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "dx",
            "dy",
            "externalResourcesRequired",
            "lengthAdjust",
            "rotate",
            "style",
            "textLength",
            "transform",
            "x",
            "y",
          ]),
          defaults: { x: "0", y: "0", lengthAdjust: "spacing" },
          contentGroups: new Set([
            "animation",
            "descriptive",
            "textContentChild",
          ]),
          content: new Set(["a"]),
        },
        textPath: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "d",
            "externalResourcesRequired",
            "href",
            "method",
            "spacing",
            "startOffset",
            "style",
            "xlink:href",
          ]),
          defaults: { startOffset: "0", method: "align", spacing: "exact" },
          contentGroups: new Set(["descriptive"]),
          content: new Set([
            "a",
            "altGlyph",
            "animate",
            "animateColor",
            "set",
            "tref",
            "tspan",
          ]),
        },
        title: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["class", "style"]),
        },
        tref: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "href",
            "style",
            "xlink:href",
          ]),
          contentGroups: new Set(["descriptive"]),
          content: new Set(["animate", "animateColor", "set"]),
        },
        tspan: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
          ]),
          attrs: new Set([
            "class",
            "dx",
            "dy",
            "externalResourcesRequired",
            "lengthAdjust",
            "rotate",
            "style",
            "textLength",
            "x",
            "y",
          ]),
          contentGroups: new Set(["descriptive"]),
          content: new Set([
            "a",
            "altGlyph",
            "animate",
            "animateColor",
            "set",
            "tref",
            "tspan",
          ]),
        },
        use: {
          attrsGroups: new Set([
            "conditionalProcessing",
            "core",
            "graphicalEvent",
            "presentation",
            "xlink",
          ]),
          attrs: new Set([
            "class",
            "externalResourcesRequired",
            "height",
            "href",
            "style",
            "transform",
            "width",
            "x",
            "xlink:href",
            "y",
          ]),
          defaults: { x: "0", y: "0" },
          contentGroups: new Set(["animation", "descriptive"]),
        },
        view: {
          attrsGroups: new Set(["core"]),
          attrs: new Set([
            "externalResourcesRequired",
            "preserveAspectRatio",
            "viewBox",
            "viewTarget",
            "zoomAndPan",
          ]),
          contentGroups: new Set(["descriptive"]),
        },
        vkern: {
          attrsGroups: new Set(["core"]),
          attrs: new Set(["u1", "g1", "u2", "g2", "k"]),
        },
      };
      exports.editorNamespaces = new Set([
        "http://creativecommons.org/ns#",
        "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
        "http://ns.adobe.com/AdobeIllustrator/10.0/",
        "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
        "http://ns.adobe.com/Extensibility/1.0/",
        "http://ns.adobe.com/Flows/1.0/",
        "http://ns.adobe.com/GenericCustomNamespace/1.0/",
        "http://ns.adobe.com/Graphs/1.0/",
        "http://ns.adobe.com/ImageReplacement/1.0/",
        "http://ns.adobe.com/SaveForWeb/1.0/",
        "http://ns.adobe.com/Variables/1.0/",
        "http://ns.adobe.com/XPath/1.0/",
        "http://purl.org/dc/elements/1.1/",
        "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
        "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
        "http://taptrix.com/vectorillustrator/svg_extensions",
        "http://www.bohemiancoding.com/sketch/ns",
        "http://www.figma.com/figma/ns",
        "http://www.inkscape.org/namespaces/inkscape",
        "http://www.serif.com/",
        "http://www.vector.evaxdesign.sk",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      ]);
      exports.referencesProps = new Set([
        "clip-path",
        "color-profile",
        "fill",
        "filter",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "stroke",
        "style",
      ]);
      exports.inheritableAttrs = new Set([
        "clip-rule",
        "color-interpolation-filters",
        "color-interpolation",
        "color-profile",
        "color-rendering",
        "color",
        "cursor",
        "direction",
        "dominant-baseline",
        "fill-opacity",
        "fill-rule",
        "fill",
        "font-family",
        "font-size-adjust",
        "font-size",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "font",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "marker-end",
        "marker-mid",
        "marker-start",
        "marker",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "stroke",
        "text-anchor",
        "text-rendering",
        "transform",
        "visibility",
        "word-spacing",
        "writing-mode",
      ]);
      exports.presentationNonInheritableGroupAttrs = new Set([
        "clip-path",
        "display",
        "filter",
        "mask",
        "opacity",
        "text-decoration",
        "transform",
        "unicode-bidi",
      ]);
      exports.colorsNames = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#0ff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000",
        blanchedalmond: "#ffebcd",
        blue: "#00f",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#0ff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#f0f",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#789",
        lightslategrey: "#789",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#0f0",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#f0f",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#639",
        red: "#f00",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#fff",
        whitesmoke: "#f5f5f5",
        yellow: "#ff0",
        yellowgreen: "#9acd32",
      };
      exports.colorsShortNames = {
        "#f0ffff": "azure",
        "#f5f5dc": "beige",
        "#ffe4c4": "bisque",
        "#a52a2a": "brown",
        "#ff7f50": "coral",
        "#ffd700": "gold",
        "#808080": "gray",
        "#008000": "green",
        "#4b0082": "indigo",
        "#fffff0": "ivory",
        "#f0e68c": "khaki",
        "#faf0e6": "linen",
        "#800000": "maroon",
        "#000080": "navy",
        "#808000": "olive",
        "#ffa500": "orange",
        "#da70d6": "orchid",
        "#cd853f": "peru",
        "#ffc0cb": "pink",
        "#dda0dd": "plum",
        "#800080": "purple",
        "#f00": "red",
        "#ff0000": "red",
        "#fa8072": "salmon",
        "#a0522d": "sienna",
        "#c0c0c0": "silver",
        "#fffafa": "snow",
        "#d2b48c": "tan",
        "#008080": "teal",
        "#ff6347": "tomato",
        "#ee82ee": "violet",
        "#f5deb3": "wheat",
      };
      exports.colorsProps = new Set([
        "color",
        "fill",
        "flood-color",
        "lighting-color",
        "stop-color",
        "stroke",
      ]);
      exports.pseudoClasses = {
        displayState: new Set(["fullscreen", "modal", "picture-in-picture"]),
        input: new Set([
          "autofill",
          "blank",
          "checked",
          "default",
          "disabled",
          "enabled",
          "in-range",
          "indetermined",
          "invalid",
          "optional",
          "out-of-range",
          "placeholder-shown",
          "read-only",
          "read-write",
          "required",
          "user-invalid",
          "valid",
        ]),
        linguistic: new Set(["dir", "lang"]),
        location: new Set([
          "any-link",
          "link",
          "local-link",
          "scope",
          "target-within",
          "target",
          "visited",
        ]),
        resourceState: new Set(["playing", "paused"]),
        timeDimensional: new Set(["current", "past", "future"]),
        treeStructural: new Set([
          "empty",
          "first-child",
          "first-of-type",
          "last-child",
          "last-of-type",
          "nth-child",
          "nth-last-child",
          "nth-last-of-type",
          "nth-of-type",
          "only-child",
          "only-of-type",
          "root",
        ]),
        userAction: new Set([
          "active",
          "focus-visible",
          "focus-within",
          "focus",
          "hover",
        ]),
        functional: new Set(["is", "not", "where", "has"]),
      };
    },
    515: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { parsePathData, stringifyPathData } = __nccwpck_require__(2162);
      var prevCtrlPoint;
      const path2js = (path) => {
        if (path.pathJS) return path.pathJS;
        const pathData = [];
        const newPathData = parsePathData(path.attributes.d);
        for (const { command, args } of newPathData) {
          pathData.push({ command, args });
        }
        if (pathData.length && pathData[0].command == "m") {
          pathData[0].command = "M";
        }
        path.pathJS = pathData;
        return pathData;
      };
      exports.path2js = path2js;
      const convertRelativeToAbsolute = (data) => {
        const newData = [];
        let start = [0, 0];
        let cursor = [0, 0];
        for (let { command, args } of data) {
          args = args.slice();
          if (command === "m") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            command = "M";
          }
          if (command === "M") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
          }
          if (command === "h") {
            args[0] += cursor[0];
            command = "H";
          }
          if (command === "H") {
            cursor[0] = args[0];
          }
          if (command === "v") {
            args[0] += cursor[1];
            command = "V";
          }
          if (command === "V") {
            cursor[1] = args[0];
          }
          if (command === "l") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            command = "L";
          }
          if (command === "L") {
            cursor[0] = args[0];
            cursor[1] = args[1];
          }
          if (command === "c") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            args[2] += cursor[0];
            args[3] += cursor[1];
            args[4] += cursor[0];
            args[5] += cursor[1];
            command = "C";
          }
          if (command === "C") {
            cursor[0] = args[4];
            cursor[1] = args[5];
          }
          if (command === "s") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            args[2] += cursor[0];
            args[3] += cursor[1];
            command = "S";
          }
          if (command === "S") {
            cursor[0] = args[2];
            cursor[1] = args[3];
          }
          if (command === "q") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            args[2] += cursor[0];
            args[3] += cursor[1];
            command = "Q";
          }
          if (command === "Q") {
            cursor[0] = args[2];
            cursor[1] = args[3];
          }
          if (command === "t") {
            args[0] += cursor[0];
            args[1] += cursor[1];
            command = "T";
          }
          if (command === "T") {
            cursor[0] = args[0];
            cursor[1] = args[1];
          }
          if (command === "a") {
            args[5] += cursor[0];
            args[6] += cursor[1];
            command = "A";
          }
          if (command === "A") {
            cursor[0] = args[5];
            cursor[1] = args[6];
          }
          if (command === "z" || command === "Z") {
            cursor[0] = start[0];
            cursor[1] = start[1];
            command = "z";
          }
          newData.push({ command, args });
        }
        return newData;
      };
      exports.js2path = function (path, data, params) {
        path.pathJS = data;
        const pathData = [];
        for (const item of data) {
          if (
            pathData.length !== 0 &&
            (item.command === "M" || item.command === "m")
          ) {
            const last = pathData[pathData.length - 1];
            if (last.command === "M" || last.command === "m") {
              pathData.pop();
            }
          }
          pathData.push({ command: item.command, args: item.args });
        }
        path.attributes.d = stringifyPathData({
          pathData,
          precision: params.floatPrecision,
          disableSpaceAfterFlags: params.noSpaceAfterFlags,
        });
      };
      function set(dest, source) {
        dest[0] = source[source.length - 2];
        dest[1] = source[source.length - 1];
        return dest;
      }
      exports.intersects = function (path1, path2) {
        const points1 = gatherPoints(convertRelativeToAbsolute(path1));
        const points2 = gatherPoints(convertRelativeToAbsolute(path2));
        if (
          points1.maxX <= points2.minX ||
          points2.maxX <= points1.minX ||
          points1.maxY <= points2.minY ||
          points2.maxY <= points1.minY ||
          points1.list.every((set1) =>
            points2.list.every(
              (set2) =>
                set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||
                set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||
                set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||
                set2.list[set2.maxY][1] <= set1.list[set1.minY][1],
            ),
          )
        )
          return false;
        const hullNest1 = points1.list.map(convexHull);
        const hullNest2 = points2.list.map(convexHull);
        return hullNest1.some(function (hull1) {
          if (hull1.list.length < 3) return false;
          return hullNest2.some(function (hull2) {
            if (hull2.list.length < 3) return false;
            var simplex = [getSupport(hull1, hull2, [1, 0])],
              direction = minus(simplex[0]);
            var iterations = 1e4;
            while (true) {
              if (iterations-- == 0) {
                console.error(
                  "Error: infinite loop while processing mergePaths plugin.",
                );
                return true;
              }
              simplex.push(getSupport(hull1, hull2, direction));
              if (dot(direction, simplex[simplex.length - 1]) <= 0)
                return false;
              if (processSimplex(simplex, direction)) return true;
            }
          });
        });
        function getSupport(a, b, direction) {
          return sub(
            supportPoint(a, direction),
            supportPoint(b, minus(direction)),
          );
        }
        function supportPoint(polygon, direction) {
          var index =
              direction[1] >= 0
                ? direction[0] < 0
                  ? polygon.maxY
                  : polygon.maxX
                : direction[0] < 0
                  ? polygon.minX
                  : polygon.minY,
            max = -Infinity,
            value;
          while ((value = dot(polygon.list[index], direction)) > max) {
            max = value;
            index = ++index % polygon.list.length;
          }
          return polygon.list[(index || polygon.list.length) - 1];
        }
      };
      function processSimplex(simplex, direction) {
        if (simplex.length == 2) {
          let a = simplex[1],
            b = simplex[0],
            AO = minus(simplex[1]),
            AB = sub(b, a);
          if (dot(AO, AB) > 0) {
            set(direction, orth(AB, a));
          } else {
            set(direction, AO);
            simplex.shift();
          }
        } else {
          let a = simplex[2],
            b = simplex[1],
            c = simplex[0],
            AB = sub(b, a),
            AC = sub(c, a),
            AO = minus(a),
            ACB = orth(AB, AC),
            ABC = orth(AC, AB);
          if (dot(ACB, AO) > 0) {
            if (dot(AB, AO) > 0) {
              set(direction, ACB);
              simplex.shift();
            } else {
              set(direction, AO);
              simplex.splice(0, 2);
            }
          } else if (dot(ABC, AO) > 0) {
            if (dot(AC, AO) > 0) {
              set(direction, ABC);
              simplex.splice(1, 1);
            } else {
              set(direction, AO);
              simplex.splice(0, 2);
            }
          } else return true;
        }
        return false;
      }
      function minus(v) {
        return [-v[0], -v[1]];
      }
      function sub(v1, v2) {
        return [v1[0] - v2[0], v1[1] - v2[1]];
      }
      function dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      }
      function orth(v, from) {
        var o = [-v[1], v[0]];
        return dot(o, minus(from)) < 0 ? minus(o) : o;
      }
      function gatherPoints(pathData) {
        const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
        const addPoint = (path, point) => {
          if (!path.list.length || point[1] > path.list[path.maxY][1]) {
            path.maxY = path.list.length;
            points.maxY = points.list.length
              ? Math.max(point[1], points.maxY)
              : point[1];
          }
          if (!path.list.length || point[0] > path.list[path.maxX][0]) {
            path.maxX = path.list.length;
            points.maxX = points.list.length
              ? Math.max(point[0], points.maxX)
              : point[0];
          }
          if (!path.list.length || point[1] < path.list[path.minY][1]) {
            path.minY = path.list.length;
            points.minY = points.list.length
              ? Math.min(point[1], points.minY)
              : point[1];
          }
          if (!path.list.length || point[0] < path.list[path.minX][0]) {
            path.minX = path.list.length;
            points.minX = points.list.length
              ? Math.min(point[0], points.minX)
              : point[0];
          }
          path.list.push(point);
        };
        for (let i = 0; i < pathData.length; i += 1) {
          const pathDataItem = pathData[i];
          let subPath =
            points.list.length === 0
              ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }
              : points.list[points.list.length - 1];
          let prev = i === 0 ? null : pathData[i - 1];
          let basePoint =
            subPath.list.length === 0
              ? null
              : subPath.list[subPath.list.length - 1];
          let data = pathDataItem.args;
          let ctrlPoint = basePoint;
          const toAbsolute = (n, i) =>
            n + (basePoint == null ? 0 : basePoint[i % 2]);
          switch (pathDataItem.command) {
            case "M":
              subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
              points.list.push(subPath);
              break;
            case "H":
              if (basePoint != null) {
                addPoint(subPath, [data[0], basePoint[1]]);
              }
              break;
            case "V":
              if (basePoint != null) {
                addPoint(subPath, [basePoint[0], data[0]]);
              }
              break;
            case "Q":
              addPoint(subPath, data.slice(0, 2));
              prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
              break;
            case "T":
              if (
                basePoint != null &&
                prev != null &&
                (prev.command == "Q" || prev.command == "T")
              ) {
                ctrlPoint = [
                  basePoint[0] + prevCtrlPoint[0],
                  basePoint[1] + prevCtrlPoint[1],
                ];
                addPoint(subPath, ctrlPoint);
                prevCtrlPoint = [
                  data[0] - ctrlPoint[0],
                  data[1] - ctrlPoint[1],
                ];
              }
              break;
            case "C":
              if (basePoint != null) {
                addPoint(subPath, [
                  0.5 * (basePoint[0] + data[0]),
                  0.5 * (basePoint[1] + data[1]),
                ]);
              }
              addPoint(subPath, [
                0.5 * (data[0] + data[2]),
                0.5 * (data[1] + data[3]),
              ]);
              addPoint(subPath, [
                0.5 * (data[2] + data[4]),
                0.5 * (data[3] + data[5]),
              ]);
              prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
              break;
            case "S":
              if (
                basePoint != null &&
                prev != null &&
                (prev.command == "C" || prev.command == "S")
              ) {
                addPoint(subPath, [
                  basePoint[0] + 0.5 * prevCtrlPoint[0],
                  basePoint[1] + 0.5 * prevCtrlPoint[1],
                ]);
                ctrlPoint = [
                  basePoint[0] + prevCtrlPoint[0],
                  basePoint[1] + prevCtrlPoint[1],
                ];
              }
              if (ctrlPoint != null) {
                addPoint(subPath, [
                  0.5 * (ctrlPoint[0] + data[0]),
                  0.5 * (ctrlPoint[1] + data[1]),
                ]);
              }
              addPoint(subPath, [
                0.5 * (data[0] + data[2]),
                0.5 * (data[1] + data[3]),
              ]);
              prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
              break;
            case "A":
              if (basePoint != null) {
                var curves = a2c.apply(0, basePoint.concat(data));
                for (
                  var cData;
                  (cData = curves.splice(0, 6).map(toAbsolute)).length;

                ) {
                  if (basePoint != null) {
                    addPoint(subPath, [
                      0.5 * (basePoint[0] + cData[0]),
                      0.5 * (basePoint[1] + cData[1]),
                    ]);
                  }
                  addPoint(subPath, [
                    0.5 * (cData[0] + cData[2]),
                    0.5 * (cData[1] + cData[3]),
                  ]);
                  addPoint(subPath, [
                    0.5 * (cData[2] + cData[4]),
                    0.5 * (cData[3] + cData[5]),
                  ]);
                  if (curves.length)
                    addPoint(subPath, (basePoint = cData.slice(-2)));
                }
              }
              break;
          }
          if (data.length >= 2) addPoint(subPath, data.slice(-2));
        }
        return points;
      }
      function convexHull(points) {
        points.list.sort(function (a, b) {
          return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
        });
        var lower = [],
          minY = 0,
          bottom = 0;
        for (let i = 0; i < points.list.length; i++) {
          while (
            lower.length >= 2 &&
            cross(
              lower[lower.length - 2],
              lower[lower.length - 1],
              points.list[i],
            ) <= 0
          ) {
            lower.pop();
          }
          if (points.list[i][1] < points.list[minY][1]) {
            minY = i;
            bottom = lower.length;
          }
          lower.push(points.list[i]);
        }
        var upper = [],
          maxY = points.list.length - 1,
          top = 0;
        for (let i = points.list.length; i--; ) {
          while (
            upper.length >= 2 &&
            cross(
              upper[upper.length - 2],
              upper[upper.length - 1],
              points.list[i],
            ) <= 0
          ) {
            upper.pop();
          }
          if (points.list[i][1] > points.list[maxY][1]) {
            maxY = i;
            top = upper.length;
          }
          upper.push(points.list[i]);
        }
        upper.pop();
        lower.pop();
        const hullList = lower.concat(upper);
        const hull = {
          list: hullList,
          minX: 0,
          maxX: lower.length,
          minY: bottom,
          maxY: (lower.length + top) % hullList.length,
        };
        return hull;
      }
      function cross(o, a, b) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
      const a2c = (
        x1,
        y1,
        rx,
        ry,
        angle,
        large_arc_flag,
        sweep_flag,
        x2,
        y2,
        recursive,
      ) => {
        const _120 = (Math.PI * 120) / 180;
        const rad = (Math.PI / 180) * (+angle || 0);
        let res = [];
        const rotateX = (x, y, rad) => x * Math.cos(rad) - y * Math.sin(rad);
        const rotateY = (x, y, rad) => x * Math.sin(rad) + y * Math.cos(rad);
        if (!recursive) {
          x1 = rotateX(x1, y1, -rad);
          y1 = rotateY(x1, y1, -rad);
          x2 = rotateX(x2, y2, -rad);
          y2 = rotateY(x2, y2, -rad);
          var x = (x1 - x2) / 2,
            y = (y1 - y2) / 2;
          var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
          if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
          }
          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k =
            (large_arc_flag == sweep_flag ? -1 : 1) *
            Math.sqrt(
              Math.abs(
                (rx2 * ry2 - rx2 * y * y - ry2 * x * x) /
                  (rx2 * y * y + ry2 * x * x),
              ),
            );
          var cx = (k * rx * y) / ry + (x1 + x2) / 2;
          var cy = (k * -ry * x) / rx + (y1 + y2) / 2;
          var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
          var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x2 < cx ? Math.PI - f2 : f2;
          f1 < 0 && (f1 = Math.PI * 2 + f1);
          f2 < 0 && (f2 = Math.PI * 2 + f2);
          if (sweep_flag && f1 > f2) {
            f1 = f1 - Math.PI * 2;
          }
          if (!sweep_flag && f2 > f1) {
            f2 = f2 - Math.PI * 2;
          }
        } else {
          f1 = recursive[0];
          f2 = recursive[1];
          cx = recursive[2];
          cy = recursive[3];
        }
        var df = f2 - f1;
        if (Math.abs(df) > _120) {
          var f2old = f2,
            x2old = x2,
            y2old = y2;
          f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
            f2,
            f2old,
            cx,
            cy,
          ]);
        }
        df = f2 - f1;
        var c1 = Math.cos(f1),
          s1 = Math.sin(f1),
          c2 = Math.cos(f2),
          s2 = Math.sin(f2),
          t = Math.tan(df / 4),
          hx = (4 / 3) * rx * t,
          hy = (4 / 3) * ry * t,
          m = [
            -hx * s1,
            hy * c1,
            x2 + hx * s2 - x1,
            y2 - hy * c2 - y1,
            x2 - x1,
            y2 - y1,
          ];
        if (recursive) {
          return m.concat(res);
        } else {
          res = m.concat(res);
          var newres = [];
          for (var i = 0, n = res.length; i < n; i++) {
            newres[i] =
              i % 2
                ? rotateY(res[i - 1], res[i], rad)
                : rotateX(res[i], res[i + 1], rad);
          }
          return newres;
        }
      };
    },
    5203: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { toFixed } = __nccwpck_require__(5916);
      const transformTypes = new Set([
        "matrix",
        "rotate",
        "scale",
        "skewX",
        "skewY",
        "translate",
      ]);
      const regTransformSplit =
        /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
      const regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
      exports.transform2js = (transformString) => {
        const transforms = [];
        let currentTransform = null;
        for (const item of transformString.split(regTransformSplit)) {
          if (!item) {
            continue;
          }
          if (transformTypes.has(item)) {
            currentTransform = { name: item, data: [] };
            transforms.push(currentTransform);
          } else {
            let num;
            while ((num = regNumericValues.exec(item))) {
              num = Number(num);
              if (currentTransform != null) {
                currentTransform.data.push(num);
              }
            }
          }
        }
        return currentTransform == null || currentTransform.data.length == 0
          ? []
          : transforms;
      };
      exports.transformsMultiply = (transforms) => {
        const matrixData = transforms.map((transform) => {
          if (transform.name === "matrix") {
            return transform.data;
          }
          return transformToMatrix(transform);
        });
        const matrixTransform = {
          name: "matrix",
          data:
            matrixData.length > 0
              ? matrixData.reduce(multiplyTransformMatrices)
              : [],
        };
        return matrixTransform;
      };
      const mth = {
        rad: (deg) => (deg * Math.PI) / 180,
        deg: (rad) => (rad * 180) / Math.PI,
        cos: (deg) => Math.cos(mth.rad(deg)),
        acos: (val, floatPrecision) =>
          toFixed(mth.deg(Math.acos(val)), floatPrecision),
        sin: (deg) => Math.sin(mth.rad(deg)),
        asin: (val, floatPrecision) =>
          toFixed(mth.deg(Math.asin(val)), floatPrecision),
        tan: (deg) => Math.tan(mth.rad(deg)),
        atan: (val, floatPrecision) =>
          toFixed(mth.deg(Math.atan(val)), floatPrecision),
      };
      exports.matrixToTransform = (transform, params) => {
        const floatPrecision = params.floatPrecision;
        const data = transform.data;
        const transforms = [];
        if (data[4] || data[5]) {
          transforms.push({
            name: "translate",
            data: data.slice(4, data[5] ? 6 : 5),
          });
        }
        let sx = toFixed(
          Math.hypot(data[0], data[1]),
          params.transformPrecision,
        );
        let sy = toFixed(
          (data[0] * data[3] - data[1] * data[2]) / sx,
          params.transformPrecision,
        );
        const colsSum = data[0] * data[2] + data[1] * data[3];
        const rowsSum = data[0] * data[1] + data[2] * data[3];
        const scaleBefore = rowsSum !== 0 || sx === sy;
        if (!data[1] && data[2]) {
          transforms.push({
            name: "skewX",
            data: [mth.atan(data[2] / sy, floatPrecision)],
          });
        } else if (data[1] && !data[2]) {
          transforms.push({
            name: "skewY",
            data: [mth.atan(data[1] / data[0], floatPrecision)],
          });
          sx = data[0];
          sy = data[3];
        } else if (!colsSum || (sx === 1 && sy === 1) || !scaleBefore) {
          if (!scaleBefore) {
            sx = Math.hypot(data[0], data[2]);
            sy = Math.hypot(data[1], data[3]);
            if (toFixed(data[0], params.transformPrecision) < 0) {
              sx = -sx;
            }
            if (
              data[3] < 0 ||
              (Math.sign(data[1]) === Math.sign(data[2]) &&
                toFixed(data[3], params.transformPrecision) === 0)
            ) {
              sy = -sy;
            }
            transforms.push({ name: "scale", data: [sx, sy] });
          }
          const angle = Math.min(Math.max(-1, data[0] / sx), 1);
          const rotate = [
            mth.acos(angle, floatPrecision) *
              ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),
          ];
          if (rotate[0]) {
            transforms.push({ name: "rotate", data: rotate });
          }
          if (rowsSum && colsSum)
            transforms.push({
              name: "skewX",
              data: [mth.atan(colsSum / (sx * sx), floatPrecision)],
            });
          if (rotate[0] && (data[4] || data[5])) {
            transforms.shift();
            const oneOverCos = 1 - data[0] / sx;
            const sin = data[1] / (scaleBefore ? sx : sy);
            const x = data[4] * (scaleBefore ? 1 : sy);
            const y = data[5] * (scaleBefore ? 1 : sx);
            const denom =
              (oneOverCos ** 2 + sin ** 2) * (scaleBefore ? 1 : sx * sy);
            rotate.push(
              (oneOverCos * x - sin * y) / denom,
              (oneOverCos * y + sin * x) / denom,
            );
          }
        } else if (data[1] || data[2]) {
          return [transform];
        }
        if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length) {
          transforms.push({ name: "scale", data: sx == sy ? [sx] : [sx, sy] });
        }
        return transforms;
      };
      const transformToMatrix = (transform) => {
        if (transform.name === "matrix") {
          return transform.data;
        }
        switch (transform.name) {
          case "translate":
            return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
          case "scale":
            return [
              transform.data[0],
              0,
              0,
              transform.data[1] || transform.data[0],
              0,
              0,
            ];
          case "rotate":
            var cos = mth.cos(transform.data[0]),
              sin = mth.sin(transform.data[0]),
              cx = transform.data[1] || 0,
              cy = transform.data[2] || 0;
            return [
              cos,
              sin,
              -sin,
              cos,
              (1 - cos) * cx + sin * cy,
              (1 - cos) * cy - sin * cx,
            ];
          case "skewX":
            return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
          case "skewY":
            return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
          default:
            throw Error(`Unknown transform ${transform.name}`);
        }
      };
      exports.transformArc = (cursor, arc, transform) => {
        const x = arc[5] - cursor[0];
        const y = arc[6] - cursor[1];
        let a = arc[0];
        let b = arc[1];
        const rot = (arc[2] * Math.PI) / 180;
        const cos = Math.cos(rot);
        const sin = Math.sin(rot);
        if (a > 0 && b > 0) {
          let h =
            Math.pow(x * cos + y * sin, 2) / (4 * a * a) +
            Math.pow(y * cos - x * sin, 2) / (4 * b * b);
          if (h > 1) {
            h = Math.sqrt(h);
            a *= h;
            b *= h;
          }
        }
        const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
        const m = multiplyTransformMatrices(transform, ellipse);
        const lastCol = m[2] * m[2] + m[3] * m[3];
        const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
        const root =
          Math.hypot(m[0] - m[3], m[1] + m[2]) *
          Math.hypot(m[0] + m[3], m[1] - m[2]);
        if (!root) {
          arc[0] = arc[1] = Math.sqrt(squareSum / 2);
          arc[2] = 0;
        } else {
          const majorAxisSqr = (squareSum + root) / 2;
          const minorAxisSqr = (squareSum - root) / 2;
          const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
          const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
          const rowsSum = m[0] * m[2] + m[1] * m[3];
          const term1 = m[0] * sub + m[2] * rowsSum;
          const term2 = m[1] * sub + m[3] * rowsSum;
          arc[0] = Math.sqrt(majorAxisSqr);
          arc[1] = Math.sqrt(minorAxisSqr);
          arc[2] =
            (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
              Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *
              180) /
            Math.PI;
        }
        if (transform[0] < 0 !== transform[3] < 0) {
          arc[4] = 1 - arc[4];
        }
        return arc;
      };
      const multiplyTransformMatrices = (a, b) => [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5],
      ];
    },
    7871: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "addAttributesToSVGElement";
      exports.description = "adds attributes to an outer <svg> element";
      var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.\nIt should have a list of "attributes" or one "attribute".\nConfig example:\n\nplugins: [\n  {\n    name: 'addAttributesToSVGElement',\n    params: {\n      attribute: "mySvg"\n    }\n  }\n]\n\nplugins: [\n  {\n    name: 'addAttributesToSVGElement',\n    params: {\n      attributes: ["mySvg", "size-big"]\n    }\n  }\n]\n\nplugins: [\n  {\n    name: 'addAttributesToSVGElement',\n    params: {\n      attributes: [\n        {\n          focusable: false\n        },\n        {\n          'data-image': icon\n        }\n      ]\n    }\n  }\n]\n`;
      exports.fn = (root, params) => {
        if (!Array.isArray(params.attributes) && !params.attribute) {
          console.error(ENOCLS);
          return null;
        }
        const attributes = params.attributes || [params.attribute];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                for (const attribute of attributes) {
                  if (typeof attribute === "string") {
                    if (node.attributes[attribute] == null) {
                      node.attributes[attribute] = undefined;
                    }
                  }
                  if (typeof attribute === "object") {
                    for (const key of Object.keys(attribute)) {
                      if (node.attributes[key] == null) {
                        node.attributes[key] = attribute[key];
                      }
                    }
                  }
                }
              }
            },
          },
        };
      };
    },
    5698: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "addClassesToSVGElement";
      exports.description = "adds classnames to an outer <svg> element";
      var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.\nIt should have a list of classes in "classNames" or one "className".\nConfig example:\n\nplugins: [\n  {\n    name: "addClassesToSVGElement",\n    params: {\n      className: "mySvg"\n    }\n  }\n]\n\nplugins: [\n  {\n    name: "addClassesToSVGElement",\n    params: {\n      classNames: ["mySvg", "size-big"]\n    }\n  }\n]\n`;
      exports.fn = (root, params) => {
        if (
          !(
            Array.isArray(params.classNames) && params.classNames.some(String)
          ) &&
          !params.className
        ) {
          console.error(ENOCLS);
          return null;
        }
        const classNames = params.classNames || [params.className];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                const classList = new Set(
                  node.attributes.class == null
                    ? null
                    : node.attributes.class.split(" "),
                );
                for (const className of classNames) {
                  if (className != null) {
                    classList.add(className);
                  }
                }
                node.attributes.class = Array.from(classList).join(" ");
              }
            },
          },
        };
      };
    },
    1046: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { collectStylesheet, computeStyle } = __nccwpck_require__(3630);
      const { transformsMultiply, transform2js, transformArc } =
        __nccwpck_require__(5203);
      const { path2js } = __nccwpck_require__(515);
      const { removeLeadingZero, includesUrlReference } =
        __nccwpck_require__(5916);
      const { referencesProps, attrsGroupsDefaults } =
        __nccwpck_require__(4298);
      const regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
      const applyTransforms = (root, params) => {
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node) => {
              if (node.attributes.d == null) {
                return;
              }
              if (node.attributes.id != null) {
                return;
              }
              if (
                node.attributes.transform == null ||
                node.attributes.transform === "" ||
                node.attributes.style != null ||
                Object.entries(node.attributes).some(
                  ([name, value]) =>
                    referencesProps.has(name) && includesUrlReference(value),
                )
              ) {
                return;
              }
              const computedStyle = computeStyle(stylesheet, node);
              const transformStyle = computedStyle.transform;
              if (
                transformStyle.type === "static" &&
                transformStyle.value !== node.attributes.transform
              ) {
                return;
              }
              const matrix = transformsMultiply(
                transform2js(node.attributes.transform),
              );
              const stroke =
                computedStyle.stroke?.type === "static"
                  ? computedStyle.stroke.value
                  : null;
              const strokeWidth =
                computedStyle["stroke-width"]?.type === "static"
                  ? computedStyle["stroke-width"].value
                  : null;
              const transformPrecision = params.transformPrecision;
              if (
                computedStyle.stroke?.type === "dynamic" ||
                computedStyle["stroke-width"]?.type === "dynamic"
              ) {
                return;
              }
              const scale = Number(
                Math.sqrt(
                  matrix.data[0] * matrix.data[0] +
                    matrix.data[1] * matrix.data[1],
                ).toFixed(transformPrecision),
              );
              if (stroke && stroke != "none") {
                if (!params.applyTransformsStroked) {
                  return;
                }
                if (
                  (matrix.data[0] !== matrix.data[3] ||
                    matrix.data[1] !== -matrix.data[2]) &&
                  (matrix.data[0] !== -matrix.data[3] ||
                    matrix.data[1] !== matrix.data[2])
                ) {
                  return;
                }
                if (scale !== 1) {
                  if (
                    node.attributes["vector-effect"] !== "non-scaling-stroke"
                  ) {
                    node.attributes["stroke-width"] = (
                      strokeWidth ||
                      attrsGroupsDefaults.presentation["stroke-width"]
                    )
                      .trim()
                      .replace(regNumericValues, (num) =>
                        removeLeadingZero(Number(num) * scale),
                      );
                    if (node.attributes["stroke-dashoffset"] != null) {
                      node.attributes["stroke-dashoffset"] = node.attributes[
                        "stroke-dashoffset"
                      ]
                        .trim()
                        .replace(regNumericValues, (num) =>
                          removeLeadingZero(Number(num) * scale),
                        );
                    }
                    if (node.attributes["stroke-dasharray"] != null) {
                      node.attributes["stroke-dasharray"] = node.attributes[
                        "stroke-dasharray"
                      ]
                        .trim()
                        .replace(regNumericValues, (num) =>
                          removeLeadingZero(Number(num) * scale),
                        );
                    }
                  }
                }
              }
              const pathData = path2js(node);
              applyMatrixToPathData(pathData, matrix.data);
              delete node.attributes.transform;
            },
          },
        };
      };
      exports.applyTransforms = applyTransforms;
      const transformAbsolutePoint = (matrix, x, y) => {
        const newX = matrix[0] * x + matrix[2] * y + matrix[4];
        const newY = matrix[1] * x + matrix[3] * y + matrix[5];
        return [newX, newY];
      };
      const transformRelativePoint = (matrix, x, y) => {
        const newX = matrix[0] * x + matrix[2] * y;
        const newY = matrix[1] * x + matrix[3] * y;
        return [newX, newY];
      };
      const applyMatrixToPathData = (pathData, matrix) => {
        const start = [0, 0];
        const cursor = [0, 0];
        for (const pathItem of pathData) {
          let { command, args } = pathItem;
          if (command === "M") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
            const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "m") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
            const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "H") {
            command = "L";
            args = [args[0], cursor[1]];
          }
          if (command === "h") {
            command = "l";
            args = [args[0], 0];
          }
          if (command === "V") {
            command = "L";
            args = [cursor[0], args[0]];
          }
          if (command === "v") {
            command = "l";
            args = [0, args[0]];
          }
          if (command === "L") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "l") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "C") {
            cursor[0] = args[4];
            cursor[1] = args[5];
            const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
            const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
            const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x2;
            args[3] = y2;
            args[4] = x;
            args[5] = y;
          }
          if (command === "c") {
            cursor[0] += args[4];
            cursor[1] += args[5];
            const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
            const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
            const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x2;
            args[3] = y2;
            args[4] = x;
            args[5] = y;
          }
          if (command === "S") {
            cursor[0] = args[2];
            cursor[1] = args[3];
            const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
            const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
            args[0] = x2;
            args[1] = y2;
            args[2] = x;
            args[3] = y;
          }
          if (command === "s") {
            cursor[0] += args[2];
            cursor[1] += args[3];
            const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
            const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
            args[0] = x2;
            args[1] = y2;
            args[2] = x;
            args[3] = y;
          }
          if (command === "Q") {
            cursor[0] = args[2];
            cursor[1] = args[3];
            const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
            const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x;
            args[3] = y;
          }
          if (command === "q") {
            cursor[0] += args[2];
            cursor[1] += args[3];
            const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
            const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
            args[0] = x1;
            args[1] = y1;
            args[2] = x;
            args[3] = y;
          }
          if (command === "T") {
            cursor[0] = args[0];
            cursor[1] = args[1];
            const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "t") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
            args[0] = x;
            args[1] = y;
          }
          if (command === "A") {
            transformArc(cursor, args, matrix);
            cursor[0] = args[5];
            cursor[1] = args[6];
            if (Math.abs(args[2]) > 80) {
              const a = args[0];
              const rotation = args[2];
              args[0] = args[1];
              args[1] = a;
              args[2] = rotation + (rotation > 0 ? -90 : 90);
            }
            const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
            args[5] = x;
            args[6] = y;
          }
          if (command === "a") {
            transformArc([0, 0], args, matrix);
            cursor[0] += args[5];
            cursor[1] += args[6];
            if (Math.abs(args[2]) > 80) {
              const a = args[0];
              const rotation = args[2];
              args[0] = args[1];
              args[1] = a;
              args[2] = rotation + (rotation > 0 ? -90 : 90);
            }
            const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
            args[5] = x;
            args[6] = y;
          }
          if (command === "z" || command === "Z") {
            cursor[0] = start[0];
            cursor[1] = start[1];
          }
          pathItem.command = command;
          pathItem.args = args;
        }
      };
    },
    3188: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "cleanupAttrs";
      exports.description =
        "cleanups attributes from newlines, trailing and repeating spaces";
      const regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
      const regNewlines = /\r?\n/g;
      const regSpaces = /\s{2,}/g;
      exports.fn = (root, params) => {
        const { newlines = true, trim = true, spaces = true } = params;
        return {
          element: {
            enter: (node) => {
              for (const name of Object.keys(node.attributes)) {
                if (newlines) {
                  node.attributes[name] = node.attributes[name].replace(
                    regNewlinesNeedSpace,
                    (match, p1, p2) => p1 + " " + p2,
                  );
                  node.attributes[name] = node.attributes[name].replace(
                    regNewlines,
                    "",
                  );
                }
                if (trim) {
                  node.attributes[name] = node.attributes[name].trim();
                }
                if (spaces) {
                  node.attributes[name] = node.attributes[name].replace(
                    regSpaces,
                    " ",
                  );
                }
              }
            },
          },
        };
      };
    },
    2938: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csstree = __nccwpck_require__(203);
      const { visit } = __nccwpck_require__(4315);
      exports.name = "cleanupEnableBackground";
      exports.description =
        "remove or cleanup enable-background attribute when possible";
      const regEnableBackground =
        /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
      exports.fn = (root) => {
        let hasFilter = false;
        visit(root, {
          element: {
            enter: (node) => {
              if (node.name === "filter") {
                hasFilter = true;
              }
            },
          },
        });
        return {
          element: {
            enter: (node) => {
              let newStyle = null;
              let enableBackgroundDeclaration = null;
              if (node.attributes.style != null) {
                newStyle = csstree.parse(node.attributes.style, {
                  context: "declarationList",
                });
                if (newStyle.type === "DeclarationList") {
                  const enableBackgroundDeclarations = [];
                  csstree.walk(newStyle, (node, nodeItem) => {
                    if (
                      node.type === "Declaration" &&
                      node.property === "enable-background"
                    ) {
                      enableBackgroundDeclarations.push(nodeItem);
                      enableBackgroundDeclaration = nodeItem;
                    }
                  });
                  for (
                    let i = 0;
                    i < enableBackgroundDeclarations.length - 1;
                    i++
                  ) {
                    newStyle.children.remove(enableBackgroundDeclarations[i]);
                  }
                }
              }
              if (!hasFilter) {
                delete node.attributes["enable-background"];
                if (newStyle?.type === "DeclarationList") {
                  if (enableBackgroundDeclaration) {
                    newStyle.children.remove(enableBackgroundDeclaration);
                  }
                  if (newStyle.children.isEmpty) {
                    delete node.attributes.style;
                  } else {
                    node.attributes.style = csstree.generate(newStyle);
                  }
                }
                return;
              }
              const hasDimensions =
                node.attributes.width != null && node.attributes.height != null;
              if (
                (node.name === "svg" ||
                  node.name === "mask" ||
                  node.name === "pattern") &&
                hasDimensions
              ) {
                const attrValue = node.attributes["enable-background"];
                const attrCleaned = cleanupValue(
                  attrValue,
                  node.name,
                  node.attributes.width,
                  node.attributes.height,
                );
                if (attrCleaned) {
                  node.attributes["enable-background"] = attrCleaned;
                } else {
                  delete node.attributes["enable-background"];
                }
                if (
                  newStyle?.type === "DeclarationList" &&
                  enableBackgroundDeclaration
                ) {
                  const styleValue = csstree.generate(
                    enableBackgroundDeclaration.data.value,
                  );
                  const styleCleaned = cleanupValue(
                    styleValue,
                    node.name,
                    node.attributes.width,
                    node.attributes.height,
                  );
                  if (styleCleaned) {
                    enableBackgroundDeclaration.data.value = {
                      type: "Raw",
                      value: styleCleaned,
                    };
                  } else {
                    newStyle.children.remove(enableBackgroundDeclaration);
                  }
                }
              }
              if (newStyle?.type === "DeclarationList") {
                if (newStyle.children.isEmpty) {
                  delete node.attributes.style;
                } else {
                  node.attributes.style = csstree.generate(newStyle);
                }
              }
            },
          },
        };
      };
      const cleanupValue = (value, nodeName, width, height) => {
        const match = regEnableBackground.exec(value);
        if (match != null && width === match[1] && height === match[3]) {
          return nodeName === "svg" ? undefined : "new";
        }
        return value;
      };
    },
    7719: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip } = __nccwpck_require__(4315);
      const { hasScripts, findReferences } = __nccwpck_require__(5916);
      exports.name = "cleanupIds";
      exports.description = "removes unused IDs and minifies used";
      const generateIdChars = [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
      ];
      const maxIdIndex = generateIdChars.length - 1;
      const hasStringPrefix = (string, prefixes) => {
        for (const prefix of prefixes) {
          if (string.startsWith(prefix)) {
            return true;
          }
        }
        return false;
      };
      const generateId = (currentId) => {
        if (currentId == null) {
          return [0];
        }
        currentId[currentId.length - 1] += 1;
        for (let i = currentId.length - 1; i > 0; i--) {
          if (currentId[i] > maxIdIndex) {
            currentId[i] = 0;
            if (currentId[i - 1] !== undefined) {
              currentId[i - 1]++;
            }
          }
        }
        if (currentId[0] > maxIdIndex) {
          currentId[0] = 0;
          currentId.unshift(0);
        }
        return currentId;
      };
      const getIdString = (arr) => arr.map((i) => generateIdChars[i]).join("");
      exports.fn = (_root, params) => {
        const {
          remove = true,
          minify = true,
          preserve = [],
          preservePrefixes = [],
          force = false,
        } = params;
        const preserveIds = new Set(
          Array.isArray(preserve) ? preserve : preserve ? [preserve] : [],
        );
        const preserveIdPrefixes = Array.isArray(preservePrefixes)
          ? preservePrefixes
          : preservePrefixes
            ? [preservePrefixes]
            : [];
        const nodeById = new Map();
        const referencesById = new Map();
        let deoptimized = false;
        return {
          element: {
            enter: (node) => {
              if (!force) {
                if (
                  (node.name === "style" && node.children.length !== 0) ||
                  hasScripts(node)
                ) {
                  deoptimized = true;
                  return;
                }
                if (node.name === "svg") {
                  let hasDefsOnly = true;
                  for (const child of node.children) {
                    if (child.type !== "element" || child.name !== "defs") {
                      hasDefsOnly = false;
                      break;
                    }
                  }
                  if (hasDefsOnly) {
                    return visitSkip;
                  }
                }
              }
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name === "id") {
                  const id = value;
                  if (nodeById.has(id)) {
                    delete node.attributes.id;
                  } else {
                    nodeById.set(id, node);
                  }
                } else {
                  const ids = findReferences(name, value);
                  for (const id of ids) {
                    let refs = referencesById.get(id);
                    if (refs == null) {
                      refs = [];
                      referencesById.set(id, refs);
                    }
                    refs.push({ element: node, name });
                  }
                }
              }
            },
          },
          root: {
            exit: () => {
              if (deoptimized) {
                return;
              }
              const isIdPreserved = (id) =>
                preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);
              let currentId = null;
              for (const [id, refs] of referencesById) {
                const node = nodeById.get(id);
                if (node != null) {
                  if (minify && isIdPreserved(id) === false) {
                    let currentIdString = null;
                    do {
                      currentId = generateId(currentId);
                      currentIdString = getIdString(currentId);
                    } while (
                      isIdPreserved(currentIdString) ||
                      (referencesById.has(currentIdString) &&
                        nodeById.get(currentIdString) == null)
                    );
                    node.attributes.id = currentIdString;
                    for (const { element, name } of refs) {
                      const value = element.attributes[name];
                      if (value.includes("#")) {
                        element.attributes[name] = value.replace(
                          `#${encodeURI(id)}`,
                          `#${currentIdString}`,
                        );
                      } else {
                        element.attributes[name] = value.replace(
                          `${id}.`,
                          `${currentIdString}.`,
                        );
                      }
                    }
                  }
                  nodeById.delete(id);
                }
              }
              if (remove) {
                for (const [id, node] of nodeById) {
                  if (isIdPreserved(id) === false) {
                    delete node.attributes.id;
                  }
                }
              }
            },
          },
        };
      };
    },
    5005: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { removeLeadingZero } = __nccwpck_require__(5916);
      exports.name = "cleanupListOfValues";
      exports.description = "rounds list of values to the fixed precision";
      const regNumericValues =
        /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
      const regSeparator = /\s+,?\s*|,\s*/;
      const absoluteLengths = {
        cm: 96 / 2.54,
        mm: 96 / 25.4,
        in: 96,
        pt: 4 / 3,
        pc: 16,
        px: 1,
      };
      exports.fn = (_root, params) => {
        const {
          floatPrecision = 3,
          leadingZero = true,
          defaultPx = true,
          convertToPx = true,
        } = params;
        const roundValues = (lists) => {
          const roundedList = [];
          for (const elem of lists.split(regSeparator)) {
            const match = elem.match(regNumericValues);
            const matchNew = elem.match(/new/);
            if (match) {
              let num = Number(Number(match[1]).toFixed(floatPrecision));
              let matchedUnit = match[3] || "";
              let units = matchedUnit;
              if (convertToPx && units && units in absoluteLengths) {
                const pxNum = Number(
                  (absoluteLengths[units] * Number(match[1])).toFixed(
                    floatPrecision,
                  ),
                );
                if (pxNum.toString().length < match[0].length) {
                  num = pxNum;
                  units = "px";
                }
              }
              let str;
              if (leadingZero) {
                str = removeLeadingZero(num);
              } else {
                str = num.toString();
              }
              if (defaultPx && units === "px") {
                units = "";
              }
              roundedList.push(str + units);
            } else if (matchNew) {
              roundedList.push("new");
            } else if (elem) {
              roundedList.push(elem);
            }
          }
          return roundedList.join(" ");
        };
        return {
          element: {
            enter: (node) => {
              if (node.attributes.points != null) {
                node.attributes.points = roundValues(node.attributes.points);
              }
              if (node.attributes["enable-background"] != null) {
                node.attributes["enable-background"] = roundValues(
                  node.attributes["enable-background"],
                );
              }
              if (node.attributes.viewBox != null) {
                node.attributes.viewBox = roundValues(node.attributes.viewBox);
              }
              if (node.attributes["stroke-dasharray"] != null) {
                node.attributes["stroke-dasharray"] = roundValues(
                  node.attributes["stroke-dasharray"],
                );
              }
              if (node.attributes.dx != null) {
                node.attributes.dx = roundValues(node.attributes.dx);
              }
              if (node.attributes.dy != null) {
                node.attributes.dy = roundValues(node.attributes.dy);
              }
              if (node.attributes.x != null) {
                node.attributes.x = roundValues(node.attributes.x);
              }
              if (node.attributes.y != null) {
                node.attributes.y = roundValues(node.attributes.y);
              }
            },
          },
        };
      };
    },
    6260: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { removeLeadingZero } = __nccwpck_require__(5916);
      exports.name = "cleanupNumericValues";
      exports.description =
        "rounds numeric values to the fixed precision, removes default ‘px’ units";
      const regNumericValues =
        /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
      const absoluteLengths = {
        cm: 96 / 2.54,
        mm: 96 / 25.4,
        in: 96,
        pt: 4 / 3,
        pc: 16,
        px: 1,
      };
      exports.fn = (_root, params) => {
        const {
          floatPrecision = 3,
          leadingZero = true,
          defaultPx = true,
          convertToPx = true,
        } = params;
        return {
          element: {
            enter: (node) => {
              if (node.attributes.viewBox != null) {
                const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
                node.attributes.viewBox = nums
                  .map((value) => {
                    const num = Number(value);
                    return Number.isNaN(num)
                      ? value
                      : Number(num.toFixed(floatPrecision));
                  })
                  .join(" ");
              }
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name === "version") {
                  continue;
                }
                const match = value.match(regNumericValues);
                if (match) {
                  let num = Number(Number(match[1]).toFixed(floatPrecision));
                  let matchedUnit = match[3] || "";
                  let units = matchedUnit;
                  if (convertToPx && units !== "" && units in absoluteLengths) {
                    const pxNum = Number(
                      (absoluteLengths[units] * Number(match[1])).toFixed(
                        floatPrecision,
                      ),
                    );
                    if (pxNum.toString().length < match[0].length) {
                      num = pxNum;
                      units = "px";
                    }
                  }
                  let str;
                  if (leadingZero) {
                    str = removeLeadingZero(num);
                  } else {
                    str = num.toString();
                  }
                  if (defaultPx && units === "px") {
                    units = "";
                  }
                  node.attributes[name] = str + units;
                }
              }
            },
          },
        };
      };
    },
    5793: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { inheritableAttrs, elemsGroups } = __nccwpck_require__(4298);
      exports.name = "collapseGroups";
      exports.description = "collapses useless groups";
      const hasAnimatedAttr = (node, name) => {
        if (node.type === "element") {
          if (
            elemsGroups.animation.has(node.name) &&
            node.attributes.attributeName === name
          ) {
            return true;
          }
          for (const child of node.children) {
            if (hasAnimatedAttr(child, name)) {
              return true;
            }
          }
        }
        return false;
      };
      exports.fn = () => ({
        element: {
          exit: (node, parentNode) => {
            if (parentNode.type === "root" || parentNode.name === "switch") {
              return;
            }
            if (node.name !== "g" || node.children.length === 0) {
              return;
            }
            if (
              Object.keys(node.attributes).length !== 0 &&
              node.children.length === 1
            ) {
              const firstChild = node.children[0];
              if (
                firstChild.type === "element" &&
                firstChild.attributes.id == null &&
                node.attributes.filter == null &&
                (node.attributes.class == null ||
                  firstChild.attributes.class == null) &&
                ((node.attributes["clip-path"] == null &&
                  node.attributes.mask == null) ||
                  (firstChild.name === "g" &&
                    node.attributes.transform == null &&
                    firstChild.attributes.transform == null))
              ) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (hasAnimatedAttr(firstChild, name)) {
                    return;
                  }
                  if (firstChild.attributes[name] == null) {
                    firstChild.attributes[name] = value;
                  } else if (name === "transform") {
                    firstChild.attributes[name] =
                      value + " " + firstChild.attributes[name];
                  } else if (firstChild.attributes[name] === "inherit") {
                    firstChild.attributes[name] = value;
                  } else if (
                    inheritableAttrs.has(name) === false &&
                    firstChild.attributes[name] !== value
                  ) {
                    return;
                  }
                  delete node.attributes[name];
                }
              }
            }
            if (Object.keys(node.attributes).length === 0) {
              for (const child of node.children) {
                if (
                  child.type === "element" &&
                  elemsGroups.animation.has(child.name)
                ) {
                  return;
                }
              }
              const index = parentNode.children.indexOf(node);
              parentNode.children.splice(index, 1, ...node.children);
              for (const child of node.children) {
                Object.defineProperty(child, "parentNode", {
                  writable: true,
                  value: parentNode,
                });
              }
            }
          },
        },
      });
    },
    8352: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const collections = __nccwpck_require__(4298);
      exports.name = "convertColors";
      exports.description =
        "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
      const rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
      const rComma = "\\s*,\\s*";
      const regRGB = new RegExp(
        "^rgb\\(\\s*" +
          rNumber +
          rComma +
          rNumber +
          rComma +
          rNumber +
          "\\s*\\)$",
      );
      const regHEX = /^#(([a-fA-F0-9])\2){3}$/;
      const convertRgbToHex = ([r, g, b]) => {
        const hexNumber = ((((256 + r) << 8) | g) << 8) | b;
        return "#" + hexNumber.toString(16).slice(1).toUpperCase();
      };
      exports.fn = (_root, params) => {
        const {
          currentColor = false,
          names2hex = true,
          rgb2hex = true,
          shorthex = true,
          shortname = true,
        } = params;
        return {
          element: {
            enter: (node) => {
              for (const [name, value] of Object.entries(node.attributes)) {
                if (collections.colorsProps.has(name)) {
                  let val = value;
                  if (currentColor) {
                    let matched;
                    if (typeof currentColor === "string") {
                      matched = val === currentColor;
                    } else if (currentColor instanceof RegExp) {
                      matched = currentColor.exec(val) != null;
                    } else {
                      matched = val !== "none";
                    }
                    if (matched) {
                      val = "currentColor";
                    }
                  }
                  if (names2hex) {
                    const colorName = val.toLowerCase();
                    if (collections.colorsNames[colorName] != null) {
                      val = collections.colorsNames[colorName];
                    }
                  }
                  if (rgb2hex) {
                    let match = val.match(regRGB);
                    if (match != null) {
                      let nums = match.slice(1, 4).map((m) => {
                        let n;
                        if (m.indexOf("%") > -1) {
                          n = Math.round(parseFloat(m) * 2.55);
                        } else {
                          n = Number(m);
                        }
                        return Math.max(0, Math.min(n, 255));
                      });
                      val = convertRgbToHex(nums);
                    }
                  }
                  if (shorthex) {
                    let match = val.match(regHEX);
                    if (match != null) {
                      val = "#" + match[0][1] + match[0][3] + match[0][5];
                    }
                  }
                  if (shortname) {
                    const colorName = val.toLowerCase();
                    if (collections.colorsShortNames[colorName] != null) {
                      val = collections.colorsShortNames[colorName];
                    }
                  }
                  node.attributes[name] = val;
                }
              }
            },
          },
        };
      };
    },
    1083: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "convertEllipseToCircle";
      exports.description = "converts non-eccentric <ellipse>s to <circle>s";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "ellipse") {
              const rx = node.attributes.rx || "0";
              const ry = node.attributes.ry || "0";
              if (rx === ry || rx === "auto" || ry === "auto") {
                node.name = "circle";
                const radius = rx === "auto" ? ry : rx;
                delete node.attributes.rx;
                delete node.attributes.ry;
                node.attributes.r = radius;
              }
            }
          },
        },
      });
    },
    6640: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { attrsGroupsDefaults, colorsProps } = __nccwpck_require__(4298);
      const { detachNodeFromParent, querySelectorAll, querySelector } =
        __nccwpck_require__(4315);
      const { computeStyle, collectStylesheet } = __nccwpck_require__(3630);
      exports.name = "convertOneStopGradients";
      exports.description =
        "converts one-stop (single color) gradients to a plain color";
      exports.fn = (root) => {
        const stylesheet = collectStylesheet(root);
        const effectedDefs = new Set();
        const allDefs = new Map();
        const gradientsToDetach = new Map();
        let xlinkHrefCount = 0;
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.attributes["xlink:href"] != null) {
                xlinkHrefCount++;
              }
              if (node.name === "defs") {
                allDefs.set(node, parentNode);
                return;
              }
              if (
                node.name !== "linearGradient" &&
                node.name !== "radialGradient"
              ) {
                return;
              }
              const stops = node.children.filter(
                (child) => child.type === "element" && child.name === "stop",
              );
              const href =
                node.attributes["xlink:href"] || node.attributes["href"];
              let effectiveNode =
                stops.length === 0 && href != null && href.startsWith("#")
                  ? querySelector(root, href)
                  : node;
              if (effectiveNode == null || effectiveNode.type !== "element") {
                gradientsToDetach.set(node, parentNode);
                return;
              }
              const effectiveStops = effectiveNode.children.filter(
                (child) => child.type === "element" && child.name === "stop",
              );
              if (
                effectiveStops.length !== 1 ||
                effectiveStops[0].type !== "element"
              ) {
                return;
              }
              if (parentNode.type === "element" && parentNode.name === "defs") {
                effectedDefs.add(parentNode);
              }
              gradientsToDetach.set(node, parentNode);
              let color;
              const style = computeStyle(stylesheet, effectiveStops[0])[
                "stop-color"
              ];
              if (style != null && style.type === "static") {
                color = style.value;
              }
              const selectorVal = `url(#${node.attributes.id})`;
              const selector = [...colorsProps]
                .map((attr) => `[${attr}="${selectorVal}"]`)
                .join(",");
              const elements = querySelectorAll(root, selector);
              for (const element of elements) {
                if (element.type !== "element") {
                  continue;
                }
                for (const attr of colorsProps) {
                  if (element.attributes[attr] !== selectorVal) {
                    continue;
                  }
                  if (color != null) {
                    element.attributes[attr] = color;
                  } else {
                    delete element.attributes[attr];
                  }
                }
              }
              const styledElements = querySelectorAll(
                root,
                `[style*=${selectorVal}]`,
              );
              for (const element of styledElements) {
                if (element.type !== "element") {
                  continue;
                }
                element.attributes.style = element.attributes.style.replace(
                  selectorVal,
                  color || attrsGroupsDefaults.presentation["stop-color"],
                );
              }
            },
            exit: (node) => {
              if (node.name === "svg") {
                for (const [gradient, parent] of gradientsToDetach.entries()) {
                  if (gradient.attributes["xlink:href"] != null) {
                    xlinkHrefCount--;
                  }
                  detachNodeFromParent(gradient, parent);
                }
                if (xlinkHrefCount === 0) {
                  delete node.attributes["xmlns:xlink"];
                }
                for (const [defs, parent] of allDefs.entries()) {
                  if (effectedDefs.has(defs) && defs.children.length === 0) {
                    detachNodeFromParent(defs, parent);
                  }
                }
              }
            },
          },
        };
      };
    },
    4106: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { collectStylesheet, computeStyle } = __nccwpck_require__(3630);
      const { visit } = __nccwpck_require__(4315);
      const { pathElems } = __nccwpck_require__(4298);
      const { path2js, js2path } = __nccwpck_require__(515);
      const { applyTransforms } = __nccwpck_require__(1046);
      const { cleanupOutData, toFixed } = __nccwpck_require__(5916);
      exports.name = "convertPathData";
      exports.description =
        "optimizes path data: writes in shorter form, applies transformations";
      let roundData;
      let precision;
      let error;
      let arcThreshold;
      let arcTolerance;
      exports.fn = (root, params) => {
        const {
          applyTransforms: _applyTransforms = true,
          applyTransformsStroked = true,
          makeArcs = { threshold: 2.5, tolerance: 0.5 },
          straightCurves = true,
          convertToQ = true,
          lineShorthands = true,
          convertToZ = true,
          curveSmoothShorthands = true,
          floatPrecision = 3,
          transformPrecision = 5,
          smartArcRounding = true,
          removeUseless = true,
          collapseRepeated = true,
          utilizeAbsolute = true,
          leadingZero = true,
          negativeExtraSpace = true,
          noSpaceAfterFlags = false,
          forceAbsolutePath = false,
        } = params;
        const newParams = {
          applyTransforms: _applyTransforms,
          applyTransformsStroked,
          makeArcs,
          straightCurves,
          convertToQ,
          lineShorthands,
          convertToZ,
          curveSmoothShorthands,
          floatPrecision,
          transformPrecision,
          smartArcRounding,
          removeUseless,
          collapseRepeated,
          utilizeAbsolute,
          leadingZero,
          negativeExtraSpace,
          noSpaceAfterFlags,
          forceAbsolutePath,
        };
        if (_applyTransforms) {
          visit(
            root,
            applyTransforms(root, {
              transformPrecision,
              applyTransformsStroked,
            }),
          );
        }
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node) => {
              if (pathElems.has(node.name) && node.attributes.d != null) {
                const computedStyle = computeStyle(stylesheet, node);
                precision = floatPrecision;
                error =
                  precision !== false
                    ? +Math.pow(0.1, precision).toFixed(precision)
                    : 0.01;
                roundData =
                  precision && precision > 0 && precision < 20
                    ? strongRound
                    : round;
                if (makeArcs) {
                  arcThreshold = makeArcs.threshold;
                  arcTolerance = makeArcs.tolerance;
                }
                const hasMarkerMid = computedStyle["marker-mid"] != null;
                const maybeHasStroke =
                  computedStyle.stroke &&
                  (computedStyle.stroke.type === "dynamic" ||
                    computedStyle.stroke.value !== "none");
                const maybeHasLinecap =
                  computedStyle["stroke-linecap"] &&
                  (computedStyle["stroke-linecap"].type === "dynamic" ||
                    computedStyle["stroke-linecap"].value !== "butt");
                const maybeHasStrokeAndLinecap =
                  maybeHasStroke && maybeHasLinecap;
                const isSafeToUseZ = maybeHasStroke
                  ? computedStyle["stroke-linecap"]?.type === "static" &&
                    computedStyle["stroke-linecap"].value === "round" &&
                    computedStyle["stroke-linejoin"]?.type === "static" &&
                    computedStyle["stroke-linejoin"].value === "round"
                  : true;
                var data = path2js(node);
                if (data.length) {
                  convertToRelative(data);
                  data = filters(data, newParams, {
                    isSafeToUseZ,
                    maybeHasStrokeAndLinecap,
                    hasMarkerMid,
                  });
                  if (utilizeAbsolute) {
                    data = convertToMixed(data, newParams);
                  }
                  js2path(node, data, newParams);
                }
              }
            },
          },
        };
      };
      const convertToRelative = (pathData) => {
        let start = [0, 0];
        let cursor = [0, 0];
        let prevCoords = [0, 0];
        for (let i = 0; i < pathData.length; i += 1) {
          const pathItem = pathData[i];
          let { command, args } = pathItem;
          if (command === "m") {
            cursor[0] += args[0];
            cursor[1] += args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
          }
          if (command === "M") {
            if (i !== 0) {
              command = "m";
            }
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            cursor[0] += args[0];
            cursor[1] += args[1];
            start[0] = cursor[0];
            start[1] = cursor[1];
          }
          if (command === "l") {
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "L") {
            command = "l";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "h") {
            cursor[0] += args[0];
          }
          if (command === "H") {
            command = "h";
            args[0] -= cursor[0];
            cursor[0] += args[0];
          }
          if (command === "v") {
            cursor[1] += args[0];
          }
          if (command === "V") {
            command = "v";
            args[0] -= cursor[1];
            cursor[1] += args[0];
          }
          if (command === "c") {
            cursor[0] += args[4];
            cursor[1] += args[5];
          }
          if (command === "C") {
            command = "c";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            args[2] -= cursor[0];
            args[3] -= cursor[1];
            args[4] -= cursor[0];
            args[5] -= cursor[1];
            cursor[0] += args[4];
            cursor[1] += args[5];
          }
          if (command === "s") {
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "S") {
            command = "s";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            args[2] -= cursor[0];
            args[3] -= cursor[1];
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "q") {
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "Q") {
            command = "q";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            args[2] -= cursor[0];
            args[3] -= cursor[1];
            cursor[0] += args[2];
            cursor[1] += args[3];
          }
          if (command === "t") {
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "T") {
            command = "t";
            args[0] -= cursor[0];
            args[1] -= cursor[1];
            cursor[0] += args[0];
            cursor[1] += args[1];
          }
          if (command === "a") {
            cursor[0] += args[5];
            cursor[1] += args[6];
          }
          if (command === "A") {
            command = "a";
            args[5] -= cursor[0];
            args[6] -= cursor[1];
            cursor[0] += args[5];
            cursor[1] += args[6];
          }
          if (command === "Z" || command === "z") {
            cursor[0] = start[0];
            cursor[1] = start[1];
          }
          pathItem.command = command;
          pathItem.args = args;
          pathItem.base = prevCoords;
          pathItem.coords = [cursor[0], cursor[1]];
          prevCoords = pathItem.coords;
        }
        return pathData;
      };
      function filters(
        path,
        params,
        { isSafeToUseZ, maybeHasStrokeAndLinecap, hasMarkerMid },
      ) {
        const stringify = data2Path.bind(null, params);
        const relSubpoint = [0, 0];
        const pathBase = [0, 0];
        let prev = {};
        let prevQControlPoint;
        path = path.filter(function (item, index, path) {
          const qControlPoint = prevQControlPoint;
          prevQControlPoint = undefined;
          let command = item.command;
          let data = item.args;
          let next = path[index + 1];
          if (command !== "Z" && command !== "z") {
            var sdata = data,
              circle;
            if (command === "s") {
              sdata = [0, 0].concat(data);
              const pdata = prev.args;
              const n = pdata.length;
              sdata[0] = pdata[n - 2] - pdata[n - 4];
              sdata[1] = pdata[n - 1] - pdata[n - 3];
            }
            if (
              params.makeArcs &&
              (command == "c" || command == "s") &&
              isConvex(sdata) &&
              (circle = findCircle(sdata))
            ) {
              var r = roundData([circle.radius])[0],
                angle = findArcAngle(sdata, circle),
                sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
                arc = {
                  command: "a",
                  args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
                  coords: item.coords.slice(),
                  base: item.base,
                },
                output = [arc],
                relCenter = [
                  circle.center[0] - sdata[4],
                  circle.center[1] - sdata[5],
                ],
                relCircle = { center: relCenter, radius: circle.radius },
                arcCurves = [item],
                hasPrev = 0,
                suffix = "",
                nextLonghand;
              if (
                (prev.command == "c" &&
                  isConvex(prev.args) &&
                  isArcPrev(prev.args, circle)) ||
                (prev.command == "a" &&
                  prev.sdata &&
                  isArcPrev(prev.sdata, circle))
              ) {
                arcCurves.unshift(prev);
                arc.base = prev.base;
                arc.args[5] = arc.coords[0] - arc.base[0];
                arc.args[6] = arc.coords[1] - arc.base[1];
                var prevData = prev.command == "a" ? prev.sdata : prev.args;
                var prevAngle = findArcAngle(prevData, {
                  center: [
                    prevData[4] + circle.center[0],
                    prevData[5] + circle.center[1],
                  ],
                  radius: circle.radius,
                });
                angle += prevAngle;
                if (angle > Math.PI) arc.args[3] = 1;
                hasPrev = 1;
              }
              for (
                var j = index;
                (next = path[++j]) &&
                (next.command === "c" || next.command === "s");

              ) {
                var nextData = next.args;
                if (next.command == "s") {
                  nextLonghand = makeLonghand(
                    { command: "s", args: next.args.slice() },
                    path[j - 1].args,
                  );
                  nextData = nextLonghand.args;
                  nextLonghand.args = nextData.slice(0, 2);
                  suffix = stringify([nextLonghand]);
                }
                if (isConvex(nextData) && isArc(nextData, relCircle)) {
                  angle += findArcAngle(nextData, relCircle);
                  if (angle - 2 * Math.PI > 0.001) break;
                  if (angle > Math.PI) arc.args[3] = 1;
                  arcCurves.push(next);
                  if (2 * Math.PI - angle > 0.001) {
                    arc.coords = next.coords;
                    arc.args[5] = arc.coords[0] - arc.base[0];
                    arc.args[6] = arc.coords[1] - arc.base[1];
                  } else {
                    arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
                    arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
                    arc.coords = [
                      arc.base[0] + arc.args[5],
                      arc.base[1] + arc.args[6],
                    ];
                    arc = {
                      command: "a",
                      args: [
                        r,
                        r,
                        0,
                        0,
                        sweep,
                        next.coords[0] - arc.coords[0],
                        next.coords[1] - arc.coords[1],
                      ],
                      coords: next.coords,
                      base: arc.coords,
                    };
                    output.push(arc);
                    j++;
                    break;
                  }
                  relCenter[0] -= nextData[4];
                  relCenter[1] -= nextData[5];
                } else break;
              }
              if (
                (stringify(output) + suffix).length <
                stringify(arcCurves).length
              ) {
                if (path[j] && path[j].command == "s") {
                  makeLonghand(path[j], path[j - 1].args);
                }
                if (hasPrev) {
                  var prevArc = output.shift();
                  roundData(prevArc.args);
                  relSubpoint[0] +=
                    prevArc.args[5] - prev.args[prev.args.length - 2];
                  relSubpoint[1] +=
                    prevArc.args[6] - prev.args[prev.args.length - 1];
                  prev.command = "a";
                  prev.args = prevArc.args;
                  item.base = prev.coords = prevArc.coords;
                }
                arc = output.shift();
                if (arcCurves.length == 1) {
                  item.sdata = sdata.slice();
                } else if (arcCurves.length - 1 - hasPrev > 0) {
                  path.splice(
                    index + 1,
                    arcCurves.length - 1 - hasPrev,
                    ...output,
                  );
                }
                if (!arc) return false;
                command = "a";
                data = arc.args;
                item.coords = arc.coords;
              }
            }
            if (precision !== false) {
              if (
                command === "m" ||
                command === "l" ||
                command === "t" ||
                command === "q" ||
                command === "s" ||
                command === "c"
              ) {
                for (var i = data.length; i--; ) {
                  data[i] += item.base[i % 2] - relSubpoint[i % 2];
                }
              } else if (command == "h") {
                data[0] += item.base[0] - relSubpoint[0];
              } else if (command == "v") {
                data[0] += item.base[1] - relSubpoint[1];
              } else if (command == "a") {
                data[5] += item.base[0] - relSubpoint[0];
                data[6] += item.base[1] - relSubpoint[1];
              }
              roundData(data);
              if (command == "h") relSubpoint[0] += data[0];
              else if (command == "v") relSubpoint[1] += data[0];
              else {
                relSubpoint[0] += data[data.length - 2];
                relSubpoint[1] += data[data.length - 1];
              }
              roundData(relSubpoint);
              if (command === "M" || command === "m") {
                pathBase[0] = relSubpoint[0];
                pathBase[1] = relSubpoint[1];
              }
            }
            const sagitta =
              command === "a" ? calculateSagitta(data) : undefined;
            if (params.smartArcRounding && sagitta !== undefined && precision) {
              for (
                let precisionNew = precision;
                precisionNew >= 0;
                precisionNew--
              ) {
                const radius = toFixed(data[0], precisionNew);
                const sagittaNew = calculateSagitta([
                  radius,
                  radius,
                  ...data.slice(2),
                ]);
                if (Math.abs(sagitta - sagittaNew) < error) {
                  data[0] = radius;
                  data[1] = radius;
                } else {
                  break;
                }
              }
            }
            if (params.straightCurves) {
              if (
                (command === "c" && isCurveStraightLine(data)) ||
                (command === "s" && isCurveStraightLine(sdata))
              ) {
                if (next && next.command == "s") makeLonghand(next, data);
                command = "l";
                data = data.slice(-2);
              } else if (command === "q" && isCurveStraightLine(data)) {
                if (next && next.command == "t") makeLonghand(next, data);
                command = "l";
                data = data.slice(-2);
              } else if (
                command === "t" &&
                prev.command !== "q" &&
                prev.command !== "t"
              ) {
                command = "l";
                data = data.slice(-2);
              } else if (
                command === "a" &&
                (data[0] === 0 ||
                  data[1] === 0 ||
                  (sagitta !== undefined && sagitta < error))
              ) {
                command = "l";
                data = data.slice(-2);
              }
            }
            if (params.convertToQ && command == "c") {
              const x1 = 0.75 * (item.base[0] + data[0]) - 0.25 * item.base[0];
              const x2 =
                0.75 * (item.base[0] + data[2]) -
                0.25 * (item.base[0] + data[4]);
              if (Math.abs(x1 - x2) < error * 2) {
                const y1 =
                  0.75 * (item.base[1] + data[1]) - 0.25 * item.base[1];
                const y2 =
                  0.75 * (item.base[1] + data[3]) -
                  0.25 * (item.base[1] + data[5]);
                if (Math.abs(y1 - y2) < error * 2) {
                  const newData = data.slice();
                  newData.splice(
                    0,
                    4,
                    x1 + x2 - item.base[0],
                    y1 + y2 - item.base[1],
                  );
                  roundData(newData);
                  const originalLength = cleanupOutData(data, params).length,
                    newLength = cleanupOutData(newData, params).length;
                  if (newLength < originalLength) {
                    command = "q";
                    data = newData;
                    if (next && next.command == "s") makeLonghand(next, data);
                  }
                }
              }
            }
            if (params.lineShorthands && command === "l") {
              if (data[1] === 0) {
                command = "h";
                data.pop();
              } else if (data[0] === 0) {
                command = "v";
                data.shift();
              }
            }
            if (
              params.collapseRepeated &&
              hasMarkerMid === false &&
              (command === "m" || command === "h" || command === "v") &&
              prev.command &&
              command == prev.command.toLowerCase() &&
              ((command != "h" && command != "v") ||
                prev.args[0] >= 0 == data[0] >= 0)
            ) {
              prev.args[0] += data[0];
              if (command != "h" && command != "v") {
                prev.args[1] += data[1];
              }
              prev.coords = item.coords;
              path[index] = prev;
              return false;
            }
            if (params.curveSmoothShorthands && prev.command) {
              if (command === "c") {
                if (
                  prev.command === "c" &&
                  Math.abs(data[0] - -(prev.args[2] - prev.args[4])) < error &&
                  Math.abs(data[1] - -(prev.args[3] - prev.args[5])) < error
                ) {
                  command = "s";
                  data = data.slice(2);
                } else if (
                  prev.command === "s" &&
                  Math.abs(data[0] - -(prev.args[0] - prev.args[2])) < error &&
                  Math.abs(data[1] - -(prev.args[1] - prev.args[3])) < error
                ) {
                  command = "s";
                  data = data.slice(2);
                } else if (
                  prev.command !== "c" &&
                  prev.command !== "s" &&
                  Math.abs(data[0]) < error &&
                  Math.abs(data[1]) < error
                ) {
                  command = "s";
                  data = data.slice(2);
                }
              } else if (command === "q") {
                if (
                  prev.command === "q" &&
                  Math.abs(data[0] - (prev.args[2] - prev.args[0])) < error &&
                  Math.abs(data[1] - (prev.args[3] - prev.args[1])) < error
                ) {
                  command = "t";
                  data = data.slice(2);
                } else if (prev.command === "t") {
                  const predictedControlPoint = reflectPoint(
                    qControlPoint,
                    item.base,
                  );
                  const realControlPoint = [
                    data[0] + item.base[0],
                    data[1] + item.base[1],
                  ];
                  if (
                    Math.abs(predictedControlPoint[0] - realControlPoint[0]) <
                      error &&
                    Math.abs(predictedControlPoint[1] - realControlPoint[1]) <
                      error
                  ) {
                    command = "t";
                    data = data.slice(2);
                  }
                }
              }
            }
            if (params.removeUseless && !maybeHasStrokeAndLinecap) {
              if (
                (command === "l" ||
                  command === "h" ||
                  command === "v" ||
                  command === "q" ||
                  command === "t" ||
                  command === "c" ||
                  command === "s") &&
                data.every(function (i) {
                  return i === 0;
                })
              ) {
                path[index] = prev;
                return false;
              }
              if (command === "a" && data[5] === 0 && data[6] === 0) {
                path[index] = prev;
                return false;
              }
            }
            if (
              params.convertToZ &&
              (isSafeToUseZ ||
                next?.command === "Z" ||
                next?.command === "z") &&
              (command === "l" || command === "h" || command === "v")
            ) {
              if (
                Math.abs(pathBase[0] - item.coords[0]) < error &&
                Math.abs(pathBase[1] - item.coords[1]) < error
              ) {
                command = "z";
                data = [];
              }
            }
            item.command = command;
            item.args = data;
          } else {
            relSubpoint[0] = pathBase[0];
            relSubpoint[1] = pathBase[1];
            if (prev.command === "Z" || prev.command === "z") return false;
          }
          if (
            (command === "Z" || command === "z") &&
            params.removeUseless &&
            isSafeToUseZ &&
            Math.abs(item.base[0] - item.coords[0]) < error / 10 &&
            Math.abs(item.base[1] - item.coords[1]) < error / 10
          )
            return false;
          if (command === "q") {
            prevQControlPoint = [
              data[0] + item.base[0],
              data[1] + item.base[1],
            ];
          } else if (command === "t") {
            if (qControlPoint) {
              prevQControlPoint = reflectPoint(qControlPoint, item.base);
            } else {
              prevQControlPoint = item.coords;
            }
          }
          prev = item;
          return true;
        });
        return path;
      }
      function convertToMixed(path, params) {
        var prev = path[0];
        path = path.filter(function (item, index) {
          if (index == 0) return true;
          if (item.command === "Z" || item.command === "z") {
            prev = item;
            return true;
          }
          var command = item.command,
            data = item.args,
            adata = data.slice(),
            rdata = data.slice();
          if (
            command === "m" ||
            command === "l" ||
            command === "t" ||
            command === "q" ||
            command === "s" ||
            command === "c"
          ) {
            for (var i = adata.length; i--; ) {
              adata[i] += item.base[i % 2];
            }
          } else if (command == "h") {
            adata[0] += item.base[0];
          } else if (command == "v") {
            adata[0] += item.base[1];
          } else if (command == "a") {
            adata[5] += item.base[0];
            adata[6] += item.base[1];
          }
          roundData(adata);
          roundData(rdata);
          var absoluteDataStr = cleanupOutData(adata, params),
            relativeDataStr = cleanupOutData(rdata, params);
          if (
            params.forceAbsolutePath ||
            (absoluteDataStr.length < relativeDataStr.length &&
              !(
                params.negativeExtraSpace &&
                command == prev.command &&
                prev.command.charCodeAt(0) > 96 &&
                absoluteDataStr.length == relativeDataStr.length - 1 &&
                (data[0] < 0 ||
                  (Math.floor(data[0]) === 0 &&
                    !Number.isInteger(data[0]) &&
                    prev.args[prev.args.length - 1] % 1))
              ))
          ) {
            item.command = command.toUpperCase();
            item.args = adata;
          }
          prev = item;
          return true;
        });
        return path;
      }
      function isConvex(data) {
        var center = getIntersection([
          0,
          0,
          data[2],
          data[3],
          data[0],
          data[1],
          data[4],
          data[5],
        ]);
        return (
          center != null &&
          data[2] < center[0] == center[0] < 0 &&
          data[3] < center[1] == center[1] < 0 &&
          data[4] < center[0] == center[0] < data[0] &&
          data[5] < center[1] == center[1] < data[1]
        );
      }
      function getIntersection(coords) {
        var a1 = coords[1] - coords[3],
          b1 = coords[2] - coords[0],
          c1 = coords[0] * coords[3] - coords[2] * coords[1],
          a2 = coords[5] - coords[7],
          b2 = coords[6] - coords[4],
          c2 = coords[4] * coords[7] - coords[5] * coords[6],
          denom = a1 * b2 - a2 * b1;
        if (!denom) return;
        var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
        if (
          !isNaN(cross[0]) &&
          !isNaN(cross[1]) &&
          isFinite(cross[0]) &&
          isFinite(cross[1])
        ) {
          return cross;
        }
      }
      function strongRound(data) {
        const precisionNum = precision || 0;
        for (let i = data.length; i-- > 0; ) {
          const fixed = toFixed(data[i], precisionNum);
          if (fixed !== data[i]) {
            const rounded = toFixed(data[i], precisionNum - 1);
            data[i] =
              toFixed(Math.abs(rounded - data[i]), precisionNum + 1) >= error
                ? fixed
                : rounded;
          }
        }
        return data;
      }
      function round(data) {
        for (var i = data.length; i-- > 0; ) {
          data[i] = Math.round(data[i]);
        }
        return data;
      }
      function isCurveStraightLine(data) {
        var i = data.length - 2,
          a = -data[i + 1],
          b = data[i],
          d = 1 / (a * a + b * b);
        if (i <= 1 || !isFinite(d)) return false;
        while ((i -= 2) >= 0) {
          if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
            return false;
        }
        return true;
      }
      function calculateSagitta(data) {
        if (data[3] === 1) return undefined;
        const [rx, ry] = data;
        if (Math.abs(rx - ry) > error) return undefined;
        const chord = Math.sqrt(data[5] ** 2 + data[6] ** 2);
        if (chord > rx * 2) return undefined;
        return rx - Math.sqrt(rx ** 2 - 0.25 * chord ** 2);
      }
      function makeLonghand(item, data) {
        switch (item.command) {
          case "s":
            item.command = "c";
            break;
          case "t":
            item.command = "q";
            break;
        }
        item.args.unshift(
          data[data.length - 2] - data[data.length - 4],
          data[data.length - 1] - data[data.length - 3],
        );
        return item;
      }
      function getDistance(point1, point2) {
        return Math.sqrt(
          (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2,
        );
      }
      function reflectPoint(controlPoint, base) {
        return [2 * base[0] - controlPoint[0], 2 * base[1] - controlPoint[1]];
      }
      function getCubicBezierPoint(curve, t) {
        var sqrT = t * t,
          cubT = sqrT * t,
          mt = 1 - t,
          sqrMt = mt * mt;
        return [
          3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
          3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],
        ];
      }
      function findCircle(curve) {
        var midPoint = getCubicBezierPoint(curve, 1 / 2),
          m1 = [midPoint[0] / 2, midPoint[1] / 2],
          m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
          center = getIntersection([
            m1[0],
            m1[1],
            m1[0] + m1[1],
            m1[1] - m1[0],
            m2[0],
            m2[1],
            m2[0] + (m2[1] - midPoint[1]),
            m2[1] - (m2[0] - midPoint[0]),
          ]),
          radius = center && getDistance([0, 0], center),
          tolerance = Math.min(
            arcThreshold * error,
            (arcTolerance * radius) / 100,
          );
        if (
          center &&
          radius < 1e15 &&
          [1 / 4, 3 / 4].every(function (point) {
            return (
              Math.abs(
                getDistance(getCubicBezierPoint(curve, point), center) - radius,
              ) <= tolerance
            );
          })
        )
          return { center, radius };
      }
      function isArc(curve, circle) {
        var tolerance = Math.min(
          arcThreshold * error,
          (arcTolerance * circle.radius) / 100,
        );
        return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {
          return (
            Math.abs(
              getDistance(getCubicBezierPoint(curve, point), circle.center) -
                circle.radius,
            ) <= tolerance
          );
        });
      }
      function isArcPrev(curve, circle) {
        return isArc(curve, {
          center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
          radius: circle.radius,
        });
      }
      function findArcAngle(curve, relCircle) {
        var x1 = -relCircle.center[0],
          y1 = -relCircle.center[1],
          x2 = curve[4] - relCircle.center[0],
          y2 = curve[5] - relCircle.center[1];
        return Math.acos(
          (x1 * x2 + y1 * y2) /
            Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)),
        );
      }
      function data2Path(params, pathData) {
        return pathData.reduce(function (pathString, item) {
          var strData = "";
          if (item.args) {
            strData = cleanupOutData(roundData(item.args.slice()), params);
          }
          return pathString + item.command + strData;
        }, "");
      }
    },
    834: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { stringifyPathData } = __nccwpck_require__(2162);
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "convertShapeToPath";
      exports.description = "converts basic shapes to more compact path form";
      const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
      exports.fn = (root, params) => {
        const { convertArcs = false, floatPrecision: precision } = params;
        return {
          element: {
            enter: (node, parentNode) => {
              if (
                node.name === "rect" &&
                node.attributes.width != null &&
                node.attributes.height != null &&
                node.attributes.rx == null &&
                node.attributes.ry == null
              ) {
                const x = Number(node.attributes.x || "0");
                const y = Number(node.attributes.y || "0");
                const width = Number(node.attributes.width);
                const height = Number(node.attributes.height);
                if (Number.isNaN(x - y + width - height)) return;
                const pathData = [
                  { command: "M", args: [x, y] },
                  { command: "H", args: [x + width] },
                  { command: "V", args: [y + height] },
                  { command: "H", args: [x] },
                  { command: "z", args: [] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.x;
                delete node.attributes.y;
                delete node.attributes.width;
                delete node.attributes.height;
              }
              if (node.name === "line") {
                const x1 = Number(node.attributes.x1 || "0");
                const y1 = Number(node.attributes.y1 || "0");
                const x2 = Number(node.attributes.x2 || "0");
                const y2 = Number(node.attributes.y2 || "0");
                if (Number.isNaN(x1 - y1 + x2 - y2)) return;
                const pathData = [
                  { command: "M", args: [x1, y1] },
                  { command: "L", args: [x2, y2] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.x1;
                delete node.attributes.y1;
                delete node.attributes.x2;
                delete node.attributes.y2;
              }
              if (
                (node.name === "polyline" || node.name === "polygon") &&
                node.attributes.points != null
              ) {
                const coords = (
                  node.attributes.points.match(regNumber) || []
                ).map(Number);
                if (coords.length < 4) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
                const pathData = [];
                for (let i = 0; i < coords.length; i += 2) {
                  pathData.push({
                    command: i === 0 ? "M" : "L",
                    args: coords.slice(i, i + 2),
                  });
                }
                if (node.name === "polygon") {
                  pathData.push({ command: "z", args: [] });
                }
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.points;
              }
              if (node.name === "circle" && convertArcs) {
                const cx = Number(node.attributes.cx || "0");
                const cy = Number(node.attributes.cy || "0");
                const r = Number(node.attributes.r || "0");
                if (Number.isNaN(cx - cy + r)) {
                  return;
                }
                const pathData = [
                  { command: "M", args: [cx, cy - r] },
                  { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
                  { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
                  { command: "z", args: [] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.cx;
                delete node.attributes.cy;
                delete node.attributes.r;
              }
              if (node.name === "ellipse" && convertArcs) {
                const ecx = Number(node.attributes.cx || "0");
                const ecy = Number(node.attributes.cy || "0");
                const rx = Number(node.attributes.rx || "0");
                const ry = Number(node.attributes.ry || "0");
                if (Number.isNaN(ecx - ecy + rx - ry)) {
                  return;
                }
                const pathData = [
                  { command: "M", args: [ecx, ecy - ry] },
                  { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
                  { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
                  { command: "z", args: [] },
                ];
                node.name = "path";
                node.attributes.d = stringifyPathData({ pathData, precision });
                delete node.attributes.cx;
                delete node.attributes.cy;
                delete node.attributes.rx;
                delete node.attributes.ry;
              }
            },
          },
        };
      };
    },
    9601: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { attrsGroups } = __nccwpck_require__(4298);
      exports.name = "convertStyleToAttrs";
      exports.description = "converts style to attributes";
      const g = (...args) => "(?:" + args.join("|") + ")";
      const stylingProps = attrsGroups.presentation;
      const rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)";
      const rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*";
      const rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)";
      const rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)';
      const rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$");
      const rParenthesis =
        "\\(" +
        g("[^'\"()\\\\]+", rEscape, rSingleQuotes, rQuotes) +
        "*?" +
        "\\)";
      const rValue =
        "\\s*(" +
        g(
          "[^!'\"();\\\\]+?",
          rEscape,
          rSingleQuotes,
          rQuotes,
          rParenthesis,
          "[^;]*?",
        ) +
        "*?" +
        ")";
      const rDeclEnd = "\\s*(?:;\\s*|$)";
      const rImportant = "(\\s*!important(?![-(\\w]))?";
      const regDeclarationBlock = new RegExp(
        rAttr + ":" + rValue + rImportant + rDeclEnd,
        "ig",
      );
      const regStripComments = new RegExp(
        g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
        "ig",
      );
      exports.fn = (_root, params) => {
        const { keepImportant = false } = params;
        return {
          element: {
            enter: (node) => {
              if (node.attributes.style != null) {
                let styles = [];
                const newAttributes = {};
                const styleValue = node.attributes.style.replace(
                  regStripComments,
                  (match) =>
                    match[0] == "/"
                      ? ""
                      : match[0] == "\\" && /[-g-z]/i.test(match[1])
                        ? match[1]
                        : match,
                );
                regDeclarationBlock.lastIndex = 0;
                for (
                  var rule;
                  (rule = regDeclarationBlock.exec(styleValue));

                ) {
                  if (!keepImportant || !rule[3]) {
                    styles.push([rule[1], rule[2]]);
                  }
                }
                if (styles.length) {
                  styles = styles.filter(function (style) {
                    if (style[0]) {
                      var prop = style[0].toLowerCase(),
                        val = style[1];
                      if (rQuotedString.test(val)) {
                        val = val.slice(1, -1);
                      }
                      if (stylingProps.has(prop)) {
                        newAttributes[prop] = val;
                        return false;
                      }
                    }
                    return true;
                  });
                  Object.assign(node.attributes, newAttributes);
                  if (styles.length) {
                    node.attributes.style = styles
                      .map((declaration) => declaration.join(":"))
                      .join(";");
                  } else {
                    delete node.attributes.style;
                  }
                }
              }
            },
          },
        };
      };
    },
    7016: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { cleanupOutData, toFixed } = __nccwpck_require__(5916);
      const { transform2js, transformsMultiply, matrixToTransform } =
        __nccwpck_require__(5203);
      exports.name = "convertTransform";
      exports.description =
        "collapses multiple transformations and optimizes it";
      exports.fn = (_root, params) => {
        const {
          convertToShorts = true,
          degPrecision,
          floatPrecision = 3,
          transformPrecision = 5,
          matrixToTransform = true,
          shortTranslate = true,
          shortScale = true,
          shortRotate = true,
          removeUseless = true,
          collapseIntoOne = true,
          leadingZero = true,
          negativeExtraSpace = false,
        } = params;
        const newParams = {
          convertToShorts,
          degPrecision,
          floatPrecision,
          transformPrecision,
          matrixToTransform,
          shortTranslate,
          shortScale,
          shortRotate,
          removeUseless,
          collapseIntoOne,
          leadingZero,
          negativeExtraSpace,
        };
        return {
          element: {
            enter: (node) => {
              if (node.attributes.transform != null) {
                convertTransform(node, "transform", newParams);
              }
              if (node.attributes.gradientTransform != null) {
                convertTransform(node, "gradientTransform", newParams);
              }
              if (node.attributes.patternTransform != null) {
                convertTransform(node, "patternTransform", newParams);
              }
            },
          },
        };
      };
      const convertTransform = (item, attrName, params) => {
        let data = transform2js(item.attributes[attrName]);
        params = definePrecision(data, params);
        if (params.collapseIntoOne && data.length > 1) {
          data = [transformsMultiply(data)];
        }
        if (params.convertToShorts) {
          data = convertToShorts(data, params);
        } else {
          data.forEach((item) => roundTransform(item, params));
        }
        if (params.removeUseless) {
          data = removeUseless(data);
        }
        if (data.length) {
          item.attributes[attrName] = js2transform(data, params);
        } else {
          delete item.attributes[attrName];
        }
      };
      const definePrecision = (data, { ...newParams }) => {
        const matrixData = [];
        for (const item of data) {
          if (item.name == "matrix") {
            matrixData.push(...item.data.slice(0, 4));
          }
        }
        let numberOfDigits = newParams.transformPrecision;
        if (matrixData.length) {
          newParams.transformPrecision = Math.min(
            newParams.transformPrecision,
            Math.max.apply(Math, matrixData.map(floatDigits)) ||
              newParams.transformPrecision,
          );
          numberOfDigits = Math.max.apply(
            Math,
            matrixData.map((n) => n.toString().replace(/\D+/g, "").length),
          );
        }
        if (newParams.degPrecision == null) {
          newParams.degPrecision = Math.max(
            0,
            Math.min(newParams.floatPrecision, numberOfDigits - 2),
          );
        }
        return newParams;
      };
      const degRound = (data, params) => {
        if (
          params.degPrecision != null &&
          params.degPrecision >= 1 &&
          params.floatPrecision < 20
        ) {
          return smartRound(params.degPrecision, data);
        } else {
          return round(data);
        }
      };
      const floatRound = (data, params) => {
        if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
          return smartRound(params.floatPrecision, data);
        } else {
          return round(data);
        }
      };
      const transformRound = (data, params) => {
        if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
          return smartRound(params.transformPrecision, data);
        } else {
          return round(data);
        }
      };
      const floatDigits = (n) => {
        const str = n.toString();
        return str.slice(str.indexOf(".")).length - 1;
      };
      const convertToShorts = (transforms, params) => {
        for (var i = 0; i < transforms.length; i++) {
          let transform = transforms[i];
          if (params.matrixToTransform && transform.name === "matrix") {
            var decomposed = matrixToTransform(transform, params);
            if (
              js2transform(decomposed, params).length <=
              js2transform([transform], params).length
            ) {
              transforms.splice(i, 1, ...decomposed);
            }
            transform = transforms[i];
          }
          roundTransform(transform, params);
          if (
            params.shortTranslate &&
            transform.name === "translate" &&
            transform.data.length === 2 &&
            !transform.data[1]
          ) {
            transform.data.pop();
          }
          if (
            params.shortScale &&
            transform.name === "scale" &&
            transform.data.length === 2 &&
            transform.data[0] === transform.data[1]
          ) {
            transform.data.pop();
          }
          if (
            params.shortRotate &&
            transforms[i - 2]?.name === "translate" &&
            transforms[i - 1].name === "rotate" &&
            transforms[i].name === "translate" &&
            transforms[i - 2].data[0] === -transforms[i].data[0] &&
            transforms[i - 2].data[1] === -transforms[i].data[1]
          ) {
            transforms.splice(i - 2, 3, {
              name: "rotate",
              data: [
                transforms[i - 1].data[0],
                transforms[i - 2].data[0],
                transforms[i - 2].data[1],
              ],
            });
            i -= 2;
          }
        }
        return transforms;
      };
      const removeUseless = (transforms) =>
        transforms.filter((transform) => {
          if (
            (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) >
              -1 &&
              (transform.data.length == 1 || transform.name == "rotate") &&
              !transform.data[0]) ||
            (transform.name == "translate" &&
              !transform.data[0] &&
              !transform.data[1]) ||
            (transform.name == "scale" &&
              transform.data[0] == 1 &&
              (transform.data.length < 2 || transform.data[1] == 1)) ||
            (transform.name == "matrix" &&
              transform.data[0] == 1 &&
              transform.data[3] == 1 &&
              !(
                transform.data[1] ||
                transform.data[2] ||
                transform.data[4] ||
                transform.data[5]
              ))
          ) {
            return false;
          }
          return true;
        });
      const js2transform = (transformJS, params) => {
        const transformString = transformJS
          .map((transform) => {
            roundTransform(transform, params);
            return `${transform.name}(${cleanupOutData(transform.data, params)})`;
          })
          .join("");
        return transformString;
      };
      const roundTransform = (transform, params) => {
        switch (transform.name) {
          case "translate":
            transform.data = floatRound(transform.data, params);
            break;
          case "rotate":
            transform.data = [
              ...degRound(transform.data.slice(0, 1), params),
              ...floatRound(transform.data.slice(1), params),
            ];
            break;
          case "skewX":
          case "skewY":
            transform.data = degRound(transform.data, params);
            break;
          case "scale":
            transform.data = transformRound(transform.data, params);
            break;
          case "matrix":
            transform.data = [
              ...transformRound(transform.data.slice(0, 4), params),
              ...floatRound(transform.data.slice(4), params),
            ];
            break;
        }
        return transform;
      };
      const round = (data) => data.map(Math.round);
      const smartRound = (precision, data) => {
        for (
          var i = data.length,
            tolerance = +Math.pow(0.1, precision).toFixed(precision);
          i--;

        ) {
          if (toFixed(data[i], precision) !== data[i]) {
            var rounded = +data[i].toFixed(precision - 1);
            data[i] =
              +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance
                ? +data[i].toFixed(precision)
                : rounded;
          }
        }
        return data;
      };
    },
    7996: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csstree = __nccwpck_require__(203);
      const {
        syntax: { specificity },
      } = __nccwpck_require__(6846);
      const { visitSkip, querySelectorAll, detachNodeFromParent } =
        __nccwpck_require__(4315);
      const { compareSpecificity, includesAttrSelector } =
        __nccwpck_require__(3630);
      const { attrsGroups, pseudoClasses } = __nccwpck_require__(4298);
      exports.name = "inlineStyles";
      exports.description = "inline styles (additional options)";
      const preservedPseudos = [
        ...pseudoClasses.functional,
        ...pseudoClasses.treeStructural,
      ];
      exports.fn = (root, params) => {
        const {
          onlyMatchedOnce = true,
          removeMatchedSelectors = true,
          useMqs = ["", "screen"],
          usePseudos = [""],
        } = params;
        const styles = [];
        let selectors = [];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "foreignObject") {
                return visitSkip;
              }
              if (node.name !== "style" || node.children.length === 0) {
                return;
              }
              if (
                node.attributes.type != null &&
                node.attributes.type !== "" &&
                node.attributes.type !== "text/css"
              ) {
                return;
              }
              const cssText = node.children
                .filter(
                  (child) => child.type === "text" || child.type === "cdata",
                )
                .map((child) => child.value)
                .join("");
              let cssAst = null;
              try {
                cssAst = csstree.parse(cssText, {
                  parseValue: false,
                  parseCustomProperty: false,
                });
              } catch {
                return;
              }
              if (cssAst.type === "StyleSheet") {
                styles.push({ node, parentNode, cssAst });
              }
              csstree.walk(cssAst, {
                visit: "Rule",
                enter(node) {
                  const atrule = this.atrule;
                  let mediaQuery = "";
                  if (atrule != null) {
                    mediaQuery = atrule.name;
                    if (atrule.prelude != null) {
                      mediaQuery += ` ${csstree.generate(atrule.prelude)}`;
                    }
                  }
                  if (!useMqs.includes(mediaQuery)) {
                    return;
                  }
                  if (node.prelude.type === "SelectorList") {
                    node.prelude.children.forEach((childNode, item) => {
                      if (childNode.type === "Selector") {
                        const pseudos = [];
                        childNode.children.forEach(
                          (grandchildNode, grandchildItem, grandchildList) => {
                            const isPseudo =
                              grandchildNode.type === "PseudoClassSelector" ||
                              grandchildNode.type === "PseudoElementSelector";
                            if (
                              isPseudo &&
                              !preservedPseudos.includes(grandchildNode.name)
                            ) {
                              pseudos.push({
                                item: grandchildItem,
                                list: grandchildList,
                              });
                            }
                          },
                        );
                        const pseudoSelectors = csstree.generate({
                          type: "Selector",
                          children: new csstree.List().fromArray(
                            pseudos.map((pseudo) => pseudo.item.data),
                          ),
                        });
                        if (usePseudos.includes(pseudoSelectors)) {
                          for (const pseudo of pseudos) {
                            pseudo.list.remove(pseudo.item);
                          }
                        }
                        selectors.push({ node: childNode, rule: node, item });
                      }
                    });
                  }
                },
              });
            },
          },
          root: {
            exit: () => {
              if (styles.length === 0) {
                return;
              }
              const sortedSelectors = selectors
                .slice()
                .sort((a, b) => {
                  const aSpecificity = specificity(a.item.data);
                  const bSpecificity = specificity(b.item.data);
                  return compareSpecificity(aSpecificity, bSpecificity);
                })
                .reverse();
              for (const selector of sortedSelectors) {
                const selectorText = csstree.generate(selector.item.data);
                const matchedElements = [];
                try {
                  for (const node of querySelectorAll(root, selectorText)) {
                    if (node.type === "element") {
                      matchedElements.push(node);
                    }
                  }
                } catch (selectError) {
                  continue;
                }
                if (matchedElements.length === 0) {
                  continue;
                }
                if (onlyMatchedOnce && matchedElements.length > 1) {
                  continue;
                }
                for (const selectedEl of matchedElements) {
                  const styleDeclarationList = csstree.parse(
                    selectedEl.attributes.style ?? "",
                    { context: "declarationList", parseValue: false },
                  );
                  if (styleDeclarationList.type !== "DeclarationList") {
                    continue;
                  }
                  const styleDeclarationItems = new Map();
                  let firstListItem;
                  csstree.walk(styleDeclarationList, {
                    visit: "Declaration",
                    enter(node, item) {
                      if (firstListItem == null) {
                        firstListItem = item;
                      }
                      styleDeclarationItems.set(
                        node.property.toLowerCase(),
                        item,
                      );
                    },
                  });
                  csstree.walk(selector.rule, {
                    visit: "Declaration",
                    enter(ruleDeclaration) {
                      const property = ruleDeclaration.property;
                      if (
                        attrsGroups.presentation.has(property) &&
                        !selectors.some((selector) =>
                          includesAttrSelector(selector.item, property),
                        )
                      ) {
                        delete selectedEl.attributes[property];
                      }
                      const matchedItem = styleDeclarationItems.get(property);
                      const ruleDeclarationItem =
                        styleDeclarationList.children.createItem(
                          ruleDeclaration,
                        );
                      if (matchedItem == null) {
                        styleDeclarationList.children.insert(
                          ruleDeclarationItem,
                          firstListItem,
                        );
                      } else if (
                        matchedItem.data.important !== true &&
                        ruleDeclaration.important === true
                      ) {
                        styleDeclarationList.children.replace(
                          matchedItem,
                          ruleDeclarationItem,
                        );
                        styleDeclarationItems.set(
                          property,
                          ruleDeclarationItem,
                        );
                      }
                    },
                  });
                  const newStyles = csstree.generate(styleDeclarationList);
                  if (newStyles.length !== 0) {
                    selectedEl.attributes.style = newStyles;
                  }
                }
                if (
                  removeMatchedSelectors &&
                  matchedElements.length !== 0 &&
                  selector.rule.prelude.type === "SelectorList"
                ) {
                  selector.rule.prelude.children.remove(selector.item);
                }
                selector.matchedElements = matchedElements;
              }
              if (!removeMatchedSelectors) {
                return;
              }
              for (const selector of sortedSelectors) {
                if (selector.matchedElements == null) {
                  continue;
                }
                if (onlyMatchedOnce && selector.matchedElements.length > 1) {
                  continue;
                }
                for (const selectedEl of selector.matchedElements) {
                  const classList = new Set(
                    selectedEl.attributes.class == null
                      ? null
                      : selectedEl.attributes.class.split(" "),
                  );
                  for (const child of selector.node.children) {
                    if (
                      child.type === "ClassSelector" &&
                      !selectors.some((selector) =>
                        includesAttrSelector(
                          selector.item,
                          "class",
                          child.name,
                          true,
                        ),
                      )
                    ) {
                      classList.delete(child.name);
                    }
                  }
                  if (classList.size === 0) {
                    delete selectedEl.attributes.class;
                  } else {
                    selectedEl.attributes.class =
                      Array.from(classList).join(" ");
                  }
                  const firstSubSelector = selector.node.children.first;
                  if (
                    firstSubSelector?.type === "IdSelector" &&
                    selectedEl.attributes.id === firstSubSelector.name &&
                    !selectors.some((selector) =>
                      includesAttrSelector(
                        selector.item,
                        "id",
                        firstSubSelector.name,
                        true,
                      ),
                    )
                  ) {
                    delete selectedEl.attributes.id;
                  }
                }
              }
              for (const style of styles) {
                csstree.walk(style.cssAst, {
                  visit: "Rule",
                  enter: function (node, item, list) {
                    if (
                      node.type === "Rule" &&
                      node.prelude.type === "SelectorList" &&
                      node.prelude.children.isEmpty
                    ) {
                      list.remove(item);
                    }
                  },
                });
                if (style.cssAst.children.isEmpty) {
                  detachNodeFromParent(style.node, style.parentNode);
                } else {
                  const firstChild = style.node.children[0];
                  if (
                    firstChild.type === "text" ||
                    firstChild.type === "cdata"
                  ) {
                    firstChild.value = csstree.generate(style.cssAst);
                  }
                }
              }
            },
          },
        };
      };
    },
    9061: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { collectStylesheet, computeStyle } = __nccwpck_require__(3630);
      const { path2js, js2path, intersects } = __nccwpck_require__(515);
      exports.name = "mergePaths";
      exports.description = "merges multiple paths in one if possible";
      exports.fn = (root, params) => {
        const {
          force = false,
          floatPrecision,
          noSpaceAfterFlags = false,
        } = params;
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node) => {
              if (node.children.length <= 1) {
                return;
              }
              const elementsToRemove = [];
              let prevChild = node.children[0];
              let prevPathData = null;
              const updatePreviousPath = (child, pathData) => {
                js2path(child, pathData, { floatPrecision, noSpaceAfterFlags });
                prevPathData = null;
              };
              for (let i = 1; i < node.children.length; i++) {
                const child = node.children[i];
                if (
                  prevChild.type !== "element" ||
                  prevChild.name !== "path" ||
                  prevChild.children.length !== 0 ||
                  prevChild.attributes.d == null
                ) {
                  if (prevPathData && prevChild.type === "element") {
                    updatePreviousPath(prevChild, prevPathData);
                  }
                  prevChild = child;
                  continue;
                }
                if (
                  child.type !== "element" ||
                  child.name !== "path" ||
                  child.children.length !== 0 ||
                  child.attributes.d == null
                ) {
                  if (prevPathData) {
                    updatePreviousPath(prevChild, prevPathData);
                  }
                  prevChild = child;
                  continue;
                }
                const computedStyle = computeStyle(stylesheet, child);
                if (
                  computedStyle["marker-start"] ||
                  computedStyle["marker-mid"] ||
                  computedStyle["marker-end"]
                ) {
                  if (prevPathData) {
                    updatePreviousPath(prevChild, prevPathData);
                  }
                  prevChild = child;
                  continue;
                }
                const childAttrs = Object.keys(child.attributes);
                if (
                  childAttrs.length !== Object.keys(prevChild.attributes).length
                ) {
                  if (prevPathData) {
                    updatePreviousPath(prevChild, prevPathData);
                  }
                  prevChild = child;
                  continue;
                }
                const areAttrsEqual = childAttrs.some(
                  (attr) =>
                    attr !== "d" &&
                    prevChild.type === "element" &&
                    prevChild.attributes[attr] !== child.attributes[attr],
                );
                if (areAttrsEqual) {
                  if (prevPathData) {
                    updatePreviousPath(prevChild, prevPathData);
                  }
                  prevChild = child;
                  continue;
                }
                const hasPrevPath = prevPathData != null;
                const currentPathData = path2js(child);
                prevPathData = prevPathData ?? path2js(prevChild);
                if (force || !intersects(prevPathData, currentPathData)) {
                  prevPathData.push(...currentPathData);
                  elementsToRemove.push(child);
                  continue;
                }
                if (hasPrevPath) {
                  updatePreviousPath(prevChild, prevPathData);
                }
                prevChild = child;
                prevPathData = null;
              }
              if (prevPathData && prevChild.type === "element") {
                updatePreviousPath(prevChild, prevPathData);
              }
              node.children = node.children.filter(
                (child) => !elementsToRemove.includes(child),
              );
            },
          },
        };
      };
    },
    2325: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip, detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "mergeStyles";
      exports.description = "merge multiple style elements into one";
      exports.fn = () => {
        let firstStyleElement = null;
        let collectedStyles = "";
        let styleContentType = "text";
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "foreignObject") {
                return visitSkip;
              }
              if (node.name !== "style") {
                return;
              }
              if (
                node.attributes.type != null &&
                node.attributes.type !== "" &&
                node.attributes.type !== "text/css"
              ) {
                return;
              }
              let css = "";
              for (const child of node.children) {
                if (child.type === "text") {
                  css += child.value;
                }
                if (child.type === "cdata") {
                  styleContentType = "cdata";
                  css += child.value;
                }
              }
              if (css.trim().length === 0) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (node.attributes.media == null) {
                collectedStyles += css;
              } else {
                collectedStyles += `@media ${node.attributes.media}{${css}}`;
                delete node.attributes.media;
              }
              if (firstStyleElement == null) {
                firstStyleElement = node;
              } else {
                detachNodeFromParent(node, parentNode);
                const child = {
                  type: styleContentType,
                  value: collectedStyles,
                };
                Object.defineProperty(child, "parentNode", {
                  writable: true,
                  value: firstStyleElement,
                });
                firstStyleElement.children = [child];
              }
            },
          },
        };
      };
    },
    5346: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csso = __nccwpck_require__(6846);
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      const { hasScripts } = __nccwpck_require__(5916);
      exports.name = "minifyStyles";
      exports.description = "minifies styles and removes unused styles";
      exports.fn = (_root, { usage, ...params }) => {
        const styleElements = new Map();
        const elementsWithStyleAttributes = [];
        const tagsUsage = new Set();
        const idsUsage = new Set();
        const classesUsage = new Set();
        let enableTagsUsage = true;
        let enableIdsUsage = true;
        let enableClassesUsage = true;
        let forceUsageDeoptimized = false;
        if (typeof usage === "boolean") {
          enableTagsUsage = usage;
          enableIdsUsage = usage;
          enableClassesUsage = usage;
        } else if (usage) {
          enableTagsUsage = usage.tags == null ? true : usage.tags;
          enableIdsUsage = usage.ids == null ? true : usage.ids;
          enableClassesUsage = usage.classes == null ? true : usage.classes;
          forceUsageDeoptimized = usage.force == null ? false : usage.force;
        }
        let deoptimized = false;
        return {
          element: {
            enter: (node, parentNode) => {
              if (hasScripts(node)) {
                deoptimized = true;
              }
              tagsUsage.add(node.name);
              if (node.attributes.id != null) {
                idsUsage.add(node.attributes.id);
              }
              if (node.attributes.class != null) {
                for (const className of node.attributes.class.split(/\s+/)) {
                  classesUsage.add(className);
                }
              }
              if (node.name === "style" && node.children.length !== 0) {
                styleElements.set(node, parentNode);
              } else if (node.attributes.style != null) {
                elementsWithStyleAttributes.push(node);
              }
            },
          },
          root: {
            exit: () => {
              const cssoUsage = {};
              if (!deoptimized || forceUsageDeoptimized) {
                if (enableTagsUsage) {
                  cssoUsage.tags = Array.from(tagsUsage);
                }
                if (enableIdsUsage) {
                  cssoUsage.ids = Array.from(idsUsage);
                }
                if (enableClassesUsage) {
                  cssoUsage.classes = Array.from(classesUsage);
                }
              }
              for (const [
                styleNode,
                styleNodeParent,
              ] of styleElements.entries()) {
                if (
                  styleNode.children[0].type === "text" ||
                  styleNode.children[0].type === "cdata"
                ) {
                  const cssText = styleNode.children[0].value;
                  const minified = csso.minify(cssText, {
                    ...params,
                    usage: cssoUsage,
                  }).css;
                  if (minified.length === 0) {
                    detachNodeFromParent(styleNode, styleNodeParent);
                    continue;
                  }
                  if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
                    styleNode.children[0].type = "cdata";
                    styleNode.children[0].value = minified;
                  } else {
                    styleNode.children[0].type = "text";
                    styleNode.children[0].value = minified;
                  }
                }
              }
              for (const node of elementsWithStyleAttributes) {
                const elemStyle = node.attributes.style;
                node.attributes.style = csso.minifyBlock(elemStyle, {
                  ...params,
                }).css;
              }
            },
          },
        };
      };
    },
    9843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit } = __nccwpck_require__(4315);
      const { inheritableAttrs, pathElems } = __nccwpck_require__(4298);
      exports.name = "moveElemsAttrsToGroup";
      exports.description =
        "Move common attributes of group children to the group";
      exports.fn = (root) => {
        let deoptimizedWithStyles = false;
        visit(root, {
          element: {
            enter: (node) => {
              if (node.name === "style") {
                deoptimizedWithStyles = true;
              }
            },
          },
        });
        return {
          element: {
            exit: (node) => {
              if (node.name !== "g" || node.children.length <= 1) {
                return;
              }
              if (deoptimizedWithStyles) {
                return;
              }
              const commonAttributes = new Map();
              let initial = true;
              let everyChildIsPath = true;
              for (const child of node.children) {
                if (child.type === "element") {
                  if (!pathElems.has(child.name)) {
                    everyChildIsPath = false;
                  }
                  if (initial) {
                    initial = false;
                    for (const [name, value] of Object.entries(
                      child.attributes,
                    )) {
                      if (inheritableAttrs.has(name)) {
                        commonAttributes.set(name, value);
                      }
                    }
                  } else {
                    for (const [name, value] of commonAttributes) {
                      if (child.attributes[name] !== value) {
                        commonAttributes.delete(name);
                      }
                    }
                  }
                }
              }
              if (
                node.attributes["clip-path"] != null ||
                node.attributes.mask != null
              ) {
                commonAttributes.delete("transform");
              }
              if (everyChildIsPath) {
                commonAttributes.delete("transform");
              }
              for (const [name, value] of commonAttributes) {
                if (name === "transform") {
                  if (node.attributes.transform != null) {
                    node.attributes.transform = `${node.attributes.transform} ${value}`;
                  } else {
                    node.attributes.transform = value;
                  }
                } else {
                  node.attributes[name] = value;
                }
              }
              for (const child of node.children) {
                if (child.type === "element") {
                  for (const [name] of commonAttributes) {
                    delete child.attributes[name];
                  }
                }
              }
            },
          },
        };
      };
    },
    8005: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { pathElems, referencesProps } = __nccwpck_require__(4298);
      const { includesUrlReference } = __nccwpck_require__(5916);
      exports.name = "moveGroupAttrsToElems";
      exports.description =
        "moves some group attributes to the content elements";
      const pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (
              node.name === "g" &&
              node.children.length !== 0 &&
              node.attributes.transform != null &&
              Object.entries(node.attributes).some(
                ([name, value]) =>
                  referencesProps.has(name) && includesUrlReference(value),
              ) === false &&
              node.children.every(
                (child) =>
                  child.type === "element" &&
                  pathElemsWithGroupsAndText.includes(child.name) &&
                  child.attributes.id == null,
              )
            ) {
              for (const child of node.children) {
                const value = node.attributes.transform;
                if (child.type === "element") {
                  if (child.attributes.transform != null) {
                    child.attributes.transform = `${value} ${child.attributes.transform}`;
                  } else {
                    child.attributes.transform = value;
                  }
                }
              }
              delete node.attributes.transform;
            }
          },
        },
      });
    },
    7366: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const csstree = __nccwpck_require__(203);
      const { referencesProps } = __nccwpck_require__(4298);
      exports.name = "prefixIds";
      exports.description = "prefix IDs";
      const getBasename = (path) => {
        const matched = /[/\\]?([^/\\]+)$/.exec(path);
        if (matched) {
          return matched[1];
        }
        return "";
      };
      const escapeIdentifierName = (str) => str.replace(/[. ]/g, "_");
      const unquote = (string) => {
        if (
          (string.startsWith('"') && string.endsWith('"')) ||
          (string.startsWith("'") && string.endsWith("'"))
        ) {
          return string.slice(1, -1);
        }
        return string;
      };
      const prefixId = (prefixGenerator, body) => {
        const prefix = prefixGenerator(body);
        if (body.startsWith(prefix)) {
          return body;
        }
        return prefix + body;
      };
      const prefixReference = (prefixGenerator, reference) => {
        if (reference.startsWith("#")) {
          return "#" + prefixId(prefixGenerator, reference.slice(1));
        }
        return null;
      };
      const generatePrefix = (
        body,
        node,
        info,
        prefixGenerator,
        delim,
        history,
      ) => {
        if (typeof prefixGenerator === "function") {
          let prefix = history.get(body);
          if (prefix != null) {
            return prefix;
          }
          prefix = prefixGenerator(node, info) + delim;
          history.set(body, prefix);
          return prefix;
        }
        if (typeof prefixGenerator === "string") {
          return prefixGenerator + delim;
        }
        if (prefixGenerator === false) {
          return "";
        }
        if (info.path != null && info.path.length > 0) {
          return escapeIdentifierName(getBasename(info.path)) + delim;
        }
        return "prefix" + delim;
      };
      exports.fn = (_root, params, info) => {
        const {
          delim = "__",
          prefix,
          prefixIds = true,
          prefixClassNames = true,
        } = params;
        const prefixMap = new Map();
        return {
          element: {
            enter: (node) => {
              const prefixGenerator = (id) =>
                generatePrefix(id, node, info, prefix, delim, prefixMap);
              if (node.name === "style") {
                if (node.children.length === 0) {
                  return;
                }
                for (const child of node.children) {
                  if (child.type !== "text" && child.type !== "cdata") {
                    continue;
                  }
                  const cssText = child.value;
                  let cssAst = null;
                  try {
                    cssAst = csstree.parse(cssText, {
                      parseValue: true,
                      parseCustomProperty: false,
                    });
                  } catch {
                    return;
                  }
                  csstree.walk(cssAst, (node) => {
                    if (
                      (prefixIds && node.type === "IdSelector") ||
                      (prefixClassNames && node.type === "ClassSelector")
                    ) {
                      node.name = prefixId(prefixGenerator, node.name);
                      return;
                    }
                    if (node.type === "Url" && node.value.length > 0) {
                      const prefixed = prefixReference(
                        prefixGenerator,
                        unquote(node.value),
                      );
                      if (prefixed != null) {
                        node.value = prefixed;
                      }
                    }
                  });
                  child.value = csstree.generate(cssAst);
                  return;
                }
              }
              if (
                prefixIds &&
                node.attributes.id != null &&
                node.attributes.id.length !== 0
              ) {
                node.attributes.id = prefixId(
                  prefixGenerator,
                  node.attributes.id,
                );
              }
              if (
                prefixClassNames &&
                node.attributes.class != null &&
                node.attributes.class.length !== 0
              ) {
                node.attributes.class = node.attributes.class
                  .split(/\s+/)
                  .map((name) => prefixId(prefixGenerator, name))
                  .join(" ");
              }
              for (const name of ["href", "xlink:href"]) {
                if (
                  node.attributes[name] != null &&
                  node.attributes[name].length !== 0
                ) {
                  const prefixed = prefixReference(
                    prefixGenerator,
                    node.attributes[name],
                  );
                  if (prefixed != null) {
                    node.attributes[name] = prefixed;
                  }
                }
              }
              for (const name of referencesProps) {
                if (
                  node.attributes[name] != null &&
                  node.attributes[name].length !== 0
                ) {
                  node.attributes[name] = node.attributes[name].replace(
                    /\burl\((["'])?(#.+?)\1\)/gi,
                    (match, _, url) => {
                      const prefixed = prefixReference(prefixGenerator, url);
                      if (prefixed == null) {
                        return match;
                      }
                      return `url(${prefixed})`;
                    },
                  );
                }
              }
              for (const name of ["begin", "end"]) {
                if (
                  node.attributes[name] != null &&
                  node.attributes[name].length !== 0
                ) {
                  const parts = node.attributes[name]
                    .split(/\s*;\s+/)
                    .map((val) => {
                      if (val.endsWith(".end") || val.endsWith(".start")) {
                        const [id, postfix] = val.split(".");
                        return `${prefixId(prefixGenerator, id)}.${postfix}`;
                      }
                      return val;
                    });
                  node.attributes[name] = parts.join("; ");
                }
              }
            },
          },
        };
      };
    },
    4174: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { createPreset } = __nccwpck_require__(973);
      const removeDoctype = __nccwpck_require__(8219);
      const removeXMLProcInst = __nccwpck_require__(5927);
      const removeComments = __nccwpck_require__(954);
      const removeMetadata = __nccwpck_require__(2391);
      const removeEditorsNSData = __nccwpck_require__(2502);
      const cleanupAttrs = __nccwpck_require__(3188);
      const mergeStyles = __nccwpck_require__(2325);
      const inlineStyles = __nccwpck_require__(7996);
      const minifyStyles = __nccwpck_require__(5346);
      const cleanupIds = __nccwpck_require__(7719);
      const removeUselessDefs = __nccwpck_require__(3467);
      const cleanupNumericValues = __nccwpck_require__(6260);
      const convertColors = __nccwpck_require__(8352);
      const removeUnknownsAndDefaults = __nccwpck_require__(5718);
      const removeNonInheritableGroupAttrs = __nccwpck_require__(4398);
      const removeUselessStrokeAndFill = __nccwpck_require__(8627);
      const removeViewBox = __nccwpck_require__(6766);
      const cleanupEnableBackground = __nccwpck_require__(2938);
      const removeHiddenElems = __nccwpck_require__(9542);
      const removeEmptyText = __nccwpck_require__(2804);
      const convertShapeToPath = __nccwpck_require__(834);
      const convertEllipseToCircle = __nccwpck_require__(1083);
      const moveElemsAttrsToGroup = __nccwpck_require__(9843);
      const moveGroupAttrsToElems = __nccwpck_require__(8005);
      const collapseGroups = __nccwpck_require__(5793);
      const convertPathData = __nccwpck_require__(4106);
      const convertTransform = __nccwpck_require__(7016);
      const removeEmptyAttrs = __nccwpck_require__(1273);
      const removeEmptyContainers = __nccwpck_require__(8402);
      const mergePaths = __nccwpck_require__(9061);
      const removeUnusedNS = __nccwpck_require__(4256);
      const sortAttrs = __nccwpck_require__(8175);
      const sortDefsChildren = __nccwpck_require__(21);
      const removeTitle = __nccwpck_require__(906);
      const removeDesc = __nccwpck_require__(5147);
      const presetDefault = createPreset({
        name: "preset-default",
        plugins: [
          removeDoctype,
          removeXMLProcInst,
          removeComments,
          removeMetadata,
          removeEditorsNSData,
          cleanupAttrs,
          mergeStyles,
          inlineStyles,
          minifyStyles,
          cleanupIds,
          removeUselessDefs,
          cleanupNumericValues,
          convertColors,
          removeUnknownsAndDefaults,
          removeNonInheritableGroupAttrs,
          removeUselessStrokeAndFill,
          removeViewBox,
          cleanupEnableBackground,
          removeHiddenElems,
          removeEmptyText,
          convertShapeToPath,
          convertEllipseToCircle,
          moveElemsAttrsToGroup,
          moveGroupAttrsToElems,
          collapseGroups,
          convertPathData,
          convertTransform,
          removeEmptyAttrs,
          removeEmptyContainers,
          mergePaths,
          removeUnusedNS,
          sortAttrs,
          sortDefsChildren,
          removeTitle,
          removeDesc,
        ],
      });
      module.exports = presetDefault;
    },
    7874: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { querySelectorAll } = __nccwpck_require__(4315);
      exports.name = "removeAttributesBySelector";
      exports.description =
        "removes attributes of elements that match a css selector";
      exports.fn = (root, params) => {
        const selectors = Array.isArray(params.selectors)
          ? params.selectors
          : [params];
        for (const { selector, attributes } of selectors) {
          const nodes = querySelectorAll(root, selector);
          for (const node of nodes) {
            if (node.type === "element") {
              if (Array.isArray(attributes)) {
                for (const name of attributes) {
                  delete node.attributes[name];
                }
              } else {
                delete node.attributes[attributes];
              }
            }
          }
        }
        return {};
      };
    },
    7096: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeAttrs";
      exports.description = "removes specified attributes";
      const DEFAULT_SEPARATOR = ":";
      const ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: "removeAttrs",\n    params: {\n      attrs: "(fill|stroke)"\n    }\n  }\n]\n`;
      exports.fn = (root, params) => {
        if (typeof params.attrs == "undefined") {
          console.warn(ENOATTRS);
          return null;
        }
        const elemSeparator =
          typeof params.elemSeparator == "string"
            ? params.elemSeparator
            : DEFAULT_SEPARATOR;
        const preserveCurrentColor =
          typeof params.preserveCurrentColor == "boolean"
            ? params.preserveCurrentColor
            : false;
        const attrs = Array.isArray(params.attrs)
          ? params.attrs
          : [params.attrs];
        return {
          element: {
            enter: (node) => {
              for (let pattern of attrs) {
                if (!pattern.includes(elemSeparator)) {
                  pattern = [".*", pattern, ".*"].join(elemSeparator);
                } else if (pattern.split(elemSeparator).length < 3) {
                  pattern = [pattern, ".*"].join(elemSeparator);
                }
                const list = pattern.split(elemSeparator).map((value) => {
                  if (value === "*") {
                    value = ".*";
                  }
                  return new RegExp(["^", value, "$"].join(""), "i");
                });
                if (list[0].test(node.name)) {
                  for (const [name, value] of Object.entries(node.attributes)) {
                    const isFillCurrentColor =
                      preserveCurrentColor &&
                      name == "fill" &&
                      value == "currentColor";
                    const isStrokeCurrentColor =
                      preserveCurrentColor &&
                      name == "stroke" &&
                      value == "currentColor";
                    if (
                      !isFillCurrentColor &&
                      !isStrokeCurrentColor &&
                      list[1].test(name) &&
                      list[2].test(value)
                    ) {
                      delete node.attributes[name];
                    }
                  }
                }
              }
            },
          },
        };
      };
    },
    954: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeComments";
      exports.description = "removes comments";
      const DEFAULT_PRESERVE_PATTERNS = [/^!/];
      exports.fn = (_root, params) => {
        const { preservePatterns = DEFAULT_PRESERVE_PATTERNS } = params;
        return {
          comment: {
            enter: (node, parentNode) => {
              if (preservePatterns) {
                if (!Array.isArray(preservePatterns)) {
                  throw Error(
                    `Expected array in removeComments preservePatterns parameter but received ${preservePatterns}`,
                  );
                }
                const matches = preservePatterns.some((pattern) =>
                  new RegExp(pattern).test(node.value),
                );
                if (matches) {
                  return;
                }
              }
              detachNodeFromParent(node, parentNode);
            },
          },
        };
      };
    },
    5147: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeDesc";
      exports.description = "removes <desc>";
      const standardDescs = /^(Created with|Created using)/;
      exports.fn = (root, params) => {
        const { removeAny = false } = params;
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "desc") {
                if (
                  removeAny ||
                  node.children.length === 0 ||
                  (node.children[0].type === "text" &&
                    standardDescs.test(node.children[0].value))
                ) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    6760: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeDimensions";
      exports.description =
        "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "svg") {
              if (node.attributes.viewBox != null) {
                delete node.attributes.width;
                delete node.attributes.height;
              } else if (
                node.attributes.width != null &&
                node.attributes.height != null &&
                Number.isNaN(Number(node.attributes.width)) === false &&
                Number.isNaN(Number(node.attributes.height)) === false
              ) {
                const width = Number(node.attributes.width);
                const height = Number(node.attributes.height);
                node.attributes.viewBox = `0 0 ${width} ${height}`;
                delete node.attributes.width;
                delete node.attributes.height;
              }
            }
          },
        },
      });
    },
    8219: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeDoctype";
      exports.description = "removes doctype declaration";
      exports.fn = () => ({
        doctype: {
          enter: (node, parentNode) => {
            detachNodeFromParent(node, parentNode);
          },
        },
      });
    },
    2502: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      const { editorNamespaces } = __nccwpck_require__(4298);
      exports.name = "removeEditorsNSData";
      exports.description =
        "removes editors namespaces, elements and attributes";
      exports.fn = (_root, params) => {
        let namespaces = [...editorNamespaces];
        if (Array.isArray(params.additionalNamespaces)) {
          namespaces = [...editorNamespaces, ...params.additionalNamespaces];
        }
        const prefixes = [];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg") {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (name.startsWith("xmlns:") && namespaces.includes(value)) {
                    prefixes.push(name.slice("xmlns:".length));
                    delete node.attributes[name];
                  }
                }
              }
              for (const name of Object.keys(node.attributes)) {
                if (name.includes(":")) {
                  const [prefix] = name.split(":");
                  if (prefixes.includes(prefix)) {
                    delete node.attributes[name];
                  }
                }
              }
              if (node.name.includes(":")) {
                const [prefix] = node.name.split(":");
                if (prefixes.includes(prefix)) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    4009: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeElementsByAttr";
      exports.description =
        "removes arbitrary elements by ID or className (disabled by default)";
      exports.fn = (root, params) => {
        const ids =
          params.id == null
            ? []
            : Array.isArray(params.id)
              ? params.id
              : [params.id];
        const classes =
          params.class == null
            ? []
            : Array.isArray(params.class)
              ? params.class
              : [params.class];
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.attributes.id != null && ids.length !== 0) {
                if (ids.includes(node.attributes.id)) {
                  detachNodeFromParent(node, parentNode);
                }
              }
              if (node.attributes.class && classes.length !== 0) {
                const classList = node.attributes.class.split(" ");
                for (const item of classes) {
                  if (classList.includes(item)) {
                    detachNodeFromParent(node, parentNode);
                    break;
                  }
                }
              }
            },
          },
        };
      };
    },
    1273: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { attrsGroups } = __nccwpck_require__(4298);
      exports.name = "removeEmptyAttrs";
      exports.description = "removes empty attributes";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (
                value === "" &&
                !attrsGroups.conditionalProcessing.has(name)
              ) {
                delete node.attributes[name];
              }
            }
          },
        },
      });
    },
    8402: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      const { elemsGroups } = __nccwpck_require__(4298);
      exports.name = "removeEmptyContainers";
      exports.description = "removes empty container elements";
      exports.fn = () => ({
        element: {
          exit: (node, parentNode) => {
            if (
              node.name === "svg" ||
              !elemsGroups.container.has(node.name) ||
              node.children.length !== 0
            ) {
              return;
            }
            if (
              node.name === "pattern" &&
              Object.keys(node.attributes).length !== 0
            ) {
              return;
            }
            if (node.name === "g" && node.attributes.filter != null) {
              return;
            }
            if (node.name === "mask" && node.attributes.id != null) {
              return;
            }
            if (parentNode.type === "element" && parentNode.name === "switch") {
              return;
            }
            detachNodeFromParent(node, parentNode);
          },
        },
      });
    },
    2804: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeEmptyText";
      exports.description = "removes empty <text> elements";
      exports.fn = (root, params) => {
        const { text = true, tspan = true, tref = true } = params;
        return {
          element: {
            enter: (node, parentNode) => {
              if (text && node.name === "text" && node.children.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              if (
                tspan &&
                node.name === "tspan" &&
                node.children.length === 0
              ) {
                detachNodeFromParent(node, parentNode);
              }
              if (
                tref &&
                node.name === "tref" &&
                node.attributes["xlink:href"] == null
              ) {
                detachNodeFromParent(node, parentNode);
              }
            },
          },
        };
      };
    },
    9542: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { elemsGroups } = __nccwpck_require__(4298);
      const { visit, visitSkip, querySelector, detachNodeFromParent } =
        __nccwpck_require__(4315);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(3630);
      const { parsePathData } = __nccwpck_require__(2162);
      const { hasScripts, findReferences } = __nccwpck_require__(5916);
      const nonRendering = elemsGroups.nonRendering;
      exports.name = "removeHiddenElems";
      exports.description =
        "removes hidden elements (zero sized, with absent attributes)";
      exports.fn = (root, params) => {
        const {
          isHidden = true,
          displayNone = true,
          opacity0 = true,
          circleR0 = true,
          ellipseRX0 = true,
          ellipseRY0 = true,
          rectWidth0 = true,
          rectHeight0 = true,
          patternWidth0 = true,
          patternHeight0 = true,
          imageWidth0 = true,
          imageHeight0 = true,
          pathEmptyD = true,
          polylineEmptyPoints = true,
          polygonEmptyPoints = true,
        } = params;
        const stylesheet = collectStylesheet(root);
        const nonRenderedNodes = new Map();
        const removedDefIds = new Set();
        const allDefs = new Map();
        const allReferences = new Set();
        const referencesById = new Map();
        let deoptimized = false;
        function removeElement(node, parentNode) {
          if (
            node.type === "element" &&
            node.attributes.id != null &&
            parentNode.type === "element" &&
            parentNode.name === "defs"
          ) {
            removedDefIds.add(node.attributes.id);
          }
          detachNodeFromParent(node, parentNode);
        }
        visit(root, {
          element: {
            enter: (node, parentNode) => {
              if (nonRendering.has(node.name)) {
                if (node.attributes.id == null) {
                  detachNodeFromParent(node, parentNode);
                  return visitSkip;
                }
                nonRenderedNodes.set(node, parentNode);
                return visitSkip;
              }
              const computedStyle = computeStyle(stylesheet, node);
              if (
                opacity0 &&
                computedStyle.opacity &&
                computedStyle.opacity.type === "static" &&
                computedStyle.opacity.value === "0"
              ) {
                removeElement(node, parentNode);
              }
            },
          },
        });
        return {
          element: {
            enter: (node, parentNode) => {
              if (
                (node.name === "style" && node.children.length !== 0) ||
                hasScripts(node)
              ) {
                deoptimized = true;
                return;
              }
              if (node.name === "defs") {
                allDefs.set(node, parentNode);
              }
              if (node.name === "use") {
                for (const attr of Object.keys(node.attributes)) {
                  if (attr !== "href" && !attr.endsWith(":href")) continue;
                  const value = node.attributes[attr];
                  const id = value.slice(1);
                  let refs = referencesById.get(id);
                  if (!refs) {
                    refs = [];
                    referencesById.set(id, refs);
                  }
                  refs.push({ node, parentNode });
                }
              }
              const computedStyle = computeStyle(stylesheet, node);
              if (
                isHidden &&
                computedStyle.visibility &&
                computedStyle.visibility.type === "static" &&
                computedStyle.visibility.value === "hidden" &&
                querySelector(node, "[visibility=visible]") == null
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                displayNone &&
                computedStyle.display &&
                computedStyle.display.type === "static" &&
                computedStyle.display.value === "none" &&
                node.name !== "marker"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                circleR0 &&
                node.name === "circle" &&
                node.children.length === 0 &&
                node.attributes.r === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                ellipseRX0 &&
                node.name === "ellipse" &&
                node.children.length === 0 &&
                node.attributes.rx === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                ellipseRY0 &&
                node.name === "ellipse" &&
                node.children.length === 0 &&
                node.attributes.ry === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                rectWidth0 &&
                node.name === "rect" &&
                node.children.length === 0 &&
                node.attributes.width === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                rectHeight0 &&
                rectWidth0 &&
                node.name === "rect" &&
                node.children.length === 0 &&
                node.attributes.height === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                patternWidth0 &&
                node.name === "pattern" &&
                node.attributes.width === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                patternHeight0 &&
                node.name === "pattern" &&
                node.attributes.height === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                imageWidth0 &&
                node.name === "image" &&
                node.attributes.width === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                imageHeight0 &&
                node.name === "image" &&
                node.attributes.height === "0"
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (pathEmptyD && node.name === "path") {
                if (node.attributes.d == null) {
                  removeElement(node, parentNode);
                  return;
                }
                const pathData = parsePathData(node.attributes.d);
                if (pathData.length === 0) {
                  removeElement(node, parentNode);
                  return;
                }
                if (
                  pathData.length === 1 &&
                  computedStyle["marker-start"] == null &&
                  computedStyle["marker-end"] == null
                ) {
                  removeElement(node, parentNode);
                  return;
                }
              }
              if (
                polylineEmptyPoints &&
                node.name === "polyline" &&
                node.attributes.points == null
              ) {
                removeElement(node, parentNode);
                return;
              }
              if (
                polygonEmptyPoints &&
                node.name === "polygon" &&
                node.attributes.points == null
              ) {
                removeElement(node, parentNode);
                return;
              }
              for (const [name, value] of Object.entries(node.attributes)) {
                const ids = findReferences(name, value);
                for (const id of ids) {
                  allReferences.add(id);
                }
              }
            },
          },
          root: {
            exit: () => {
              for (const id of removedDefIds) {
                const refs = referencesById.get(id);
                if (refs) {
                  for (const { node, parentNode } of refs) {
                    detachNodeFromParent(node, parentNode);
                  }
                }
              }
              if (!deoptimized) {
                for (const [
                  nonRenderedNode,
                  nonRenderedParent,
                ] of nonRenderedNodes.entries()) {
                  const id = nonRenderedNode.attributes.id;
                  if (!allReferences.has(id)) {
                    detachNodeFromParent(nonRenderedNode, nonRenderedParent);
                  }
                }
              }
              for (const [node, parentNode] of allDefs.entries()) {
                if (node.children.length === 0) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    2391: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeMetadata";
      exports.description = "removes <metadata>";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "metadata") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    4398: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const {
        inheritableAttrs,
        attrsGroups,
        presentationNonInheritableGroupAttrs,
      } = __nccwpck_require__(4298);
      exports.name = "removeNonInheritableGroupAttrs";
      exports.description =
        "removes non-inheritable group’s presentational attributes";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "g") {
              for (const name of Object.keys(node.attributes)) {
                if (
                  attrsGroups.presentation.has(name) &&
                  !inheritableAttrs.has(name) &&
                  !presentationNonInheritableGroupAttrs.has(name)
                ) {
                  delete node.attributes[name];
                }
              }
            }
          },
        },
      });
    },
    6086: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip, detachNodeFromParent } = __nccwpck_require__(4315);
      const { parsePathData } = __nccwpck_require__(2162);
      const { intersects } = __nccwpck_require__(515);
      exports.name = "removeOffCanvasPaths";
      exports.description =
        "removes elements that are drawn outside of the viewbox (disabled by default)";
      exports.fn = () => {
        let viewBoxData = null;
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                let viewBox = "";
                if (node.attributes.viewBox != null) {
                  viewBox = node.attributes.viewBox;
                } else if (
                  node.attributes.height != null &&
                  node.attributes.width != null
                ) {
                  viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
                }
                viewBox = viewBox
                  .replace(/[,+]|px/g, " ")
                  .replace(/\s+/g, " ")
                  .replace(/^\s*|\s*$/g, "");
                const m =
                  /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
                    viewBox,
                  );
                if (m == null) {
                  return;
                }
                const left = Number.parseFloat(m[1]);
                const top = Number.parseFloat(m[2]);
                const width = Number.parseFloat(m[3]);
                const height = Number.parseFloat(m[4]);
                viewBoxData = {
                  left,
                  top,
                  right: left + width,
                  bottom: top + height,
                  width,
                  height,
                };
              }
              if (node.attributes.transform != null) {
                return visitSkip;
              }
              if (
                node.name === "path" &&
                node.attributes.d != null &&
                viewBoxData != null
              ) {
                const pathData = parsePathData(node.attributes.d);
                let visible = false;
                for (const pathDataItem of pathData) {
                  if (pathDataItem.command === "M") {
                    const [x, y] = pathDataItem.args;
                    if (
                      x >= viewBoxData.left &&
                      x <= viewBoxData.right &&
                      y >= viewBoxData.top &&
                      y <= viewBoxData.bottom
                    ) {
                      visible = true;
                    }
                  }
                }
                if (visible) {
                  return;
                }
                if (pathData.length === 2) {
                  pathData.push({ command: "z", args: [] });
                }
                const { left, top, width, height } = viewBoxData;
                const viewBoxPathData = [
                  { command: "M", args: [left, top] },
                  { command: "h", args: [width] },
                  { command: "v", args: [height] },
                  { command: "H", args: [left] },
                  { command: "z", args: [] },
                ];
                if (intersects(viewBoxPathData, pathData) === false) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    2166: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeRasterImages";
      exports.description = "removes raster images (disabled by default)";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (
              node.name === "image" &&
              node.attributes["xlink:href"] != null &&
              /(\.|image\/)(jpe?g|png|gif)/.test(node.attributes["xlink:href"])
            ) {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    4064: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      const { attrsGroups } = __nccwpck_require__(4298);
      exports.name = "removeScriptElement";
      exports.description = "removes scripts (disabled by default)";
      const eventAttrs = [
        ...attrsGroups.animationEvent,
        ...attrsGroups.documentEvent,
        ...attrsGroups.documentElementEvent,
        ...attrsGroups.globalEvent,
        ...attrsGroups.graphicalEvent,
      ];
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "script") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            for (const attr of eventAttrs) {
              if (node.attributes[attr] != null) {
                delete node.attributes[attr];
              }
            }
          },
          exit: (node, parentNode) => {
            if (node.name !== "a") {
              return;
            }
            for (const attr of Object.keys(node.attributes)) {
              if (attr === "href" || attr.endsWith(":href")) {
                if (
                  node.attributes[attr] == null ||
                  !node.attributes[attr].trimStart().startsWith("javascript:")
                ) {
                  continue;
                }
                const index = parentNode.children.indexOf(node);
                parentNode.children.splice(index, 1, ...node.children);
                for (const child of node.children) {
                  Object.defineProperty(child, "parentNode", {
                    writable: true,
                    value: parentNode,
                  });
                }
              }
            }
          },
        },
      });
    },
    5843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeStyleElement";
      exports.description = "removes <style> element (disabled by default)";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "style") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    906: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeTitle";
      exports.description = "removes <title>";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "title") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    5718: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visitSkip, detachNodeFromParent } = __nccwpck_require__(4315);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(3630);
      const {
        elems,
        attrsGroups,
        elemsGroups,
        attrsGroupsDefaults,
        presentationNonInheritableGroupAttrs,
      } = __nccwpck_require__(4298);
      exports.name = "removeUnknownsAndDefaults";
      exports.description =
        "removes unknown elements content and attributes, removes attrs with default values";
      const allowedChildrenPerElement = new Map();
      const allowedAttributesPerElement = new Map();
      const attributesDefaultsPerElement = new Map();
      for (const [name, config] of Object.entries(elems)) {
        const allowedChildren = new Set();
        if (config.content) {
          for (const elementName of config.content) {
            allowedChildren.add(elementName);
          }
        }
        if (config.contentGroups) {
          for (const contentGroupName of config.contentGroups) {
            const elemsGroup = elemsGroups[contentGroupName];
            if (elemsGroup) {
              for (const elementName of elemsGroup) {
                allowedChildren.add(elementName);
              }
            }
          }
        }
        const allowedAttributes = new Set();
        if (config.attrs) {
          for (const attrName of config.attrs) {
            allowedAttributes.add(attrName);
          }
        }
        const attributesDefaults = new Map();
        if (config.defaults) {
          for (const [attrName, defaultValue] of Object.entries(
            config.defaults,
          )) {
            attributesDefaults.set(attrName, defaultValue);
          }
        }
        for (const attrsGroupName of config.attrsGroups) {
          const attrsGroup = attrsGroups[attrsGroupName];
          if (attrsGroup) {
            for (const attrName of attrsGroup) {
              allowedAttributes.add(attrName);
            }
          }
          const groupDefaults = attrsGroupsDefaults[attrsGroupName];
          if (groupDefaults) {
            for (const [attrName, defaultValue] of Object.entries(
              groupDefaults,
            )) {
              attributesDefaults.set(attrName, defaultValue);
            }
          }
        }
        allowedChildrenPerElement.set(name, allowedChildren);
        allowedAttributesPerElement.set(name, allowedAttributes);
        attributesDefaultsPerElement.set(name, attributesDefaults);
      }
      exports.fn = (root, params) => {
        const {
          unknownContent = true,
          unknownAttrs = true,
          defaultAttrs = true,
          defaultMarkupDeclarations = true,
          uselessOverrides = true,
          keepDataAttrs = true,
          keepAriaAttrs = true,
          keepRoleAttr = false,
        } = params;
        const stylesheet = collectStylesheet(root);
        return {
          instruction: {
            enter: (node) => {
              if (defaultMarkupDeclarations) {
                node.value = node.value.replace(
                  /\s*standalone\s*=\s*(["'])no\1/,
                  "",
                );
              }
            },
          },
          element: {
            enter: (node, parentNode) => {
              if (node.name.includes(":")) {
                return;
              }
              if (node.name === "foreignObject") {
                return visitSkip;
              }
              if (unknownContent && parentNode.type === "element") {
                const allowedChildren = allowedChildrenPerElement.get(
                  parentNode.name,
                );
                if (allowedChildren == null || allowedChildren.size === 0) {
                  if (allowedChildrenPerElement.get(node.name) == null) {
                    detachNodeFromParent(node, parentNode);
                    return;
                  }
                } else {
                  if (allowedChildren.has(node.name) === false) {
                    detachNodeFromParent(node, parentNode);
                    return;
                  }
                }
              }
              const allowedAttributes = allowedAttributesPerElement.get(
                node.name,
              );
              const attributesDefaults = attributesDefaultsPerElement.get(
                node.name,
              );
              const computedParentStyle =
                parentNode.type === "element"
                  ? computeStyle(stylesheet, parentNode)
                  : null;
              for (const [name, value] of Object.entries(node.attributes)) {
                if (keepDataAttrs && name.startsWith("data-")) {
                  continue;
                }
                if (keepAriaAttrs && name.startsWith("aria-")) {
                  continue;
                }
                if (keepRoleAttr && name === "role") {
                  continue;
                }
                if (name === "xmlns") {
                  continue;
                }
                if (name.includes(":")) {
                  const [prefix] = name.split(":");
                  if (prefix !== "xml" && prefix !== "xlink") {
                    continue;
                  }
                }
                if (
                  unknownAttrs &&
                  allowedAttributes &&
                  allowedAttributes.has(name) === false
                ) {
                  delete node.attributes[name];
                }
                if (
                  defaultAttrs &&
                  node.attributes.id == null &&
                  attributesDefaults &&
                  attributesDefaults.get(name) === value
                ) {
                  if (computedParentStyle?.[name] == null) {
                    delete node.attributes[name];
                  }
                }
                if (uselessOverrides && node.attributes.id == null) {
                  const style = computedParentStyle?.[name];
                  if (
                    presentationNonInheritableGroupAttrs.has(name) === false &&
                    style != null &&
                    style.type === "static" &&
                    style.value === value
                  ) {
                    delete node.attributes[name];
                  }
                }
              }
            },
          },
        };
      };
    },
    4256: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeUnusedNS";
      exports.description = "removes unused namespaces declaration";
      exports.fn = () => {
        const unusedNamespaces = new Set();
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                for (const name of Object.keys(node.attributes)) {
                  if (name.startsWith("xmlns:")) {
                    const local = name.slice("xmlns:".length);
                    unusedNamespaces.add(local);
                  }
                }
              }
              if (unusedNamespaces.size !== 0) {
                if (node.name.includes(":")) {
                  const [ns] = node.name.split(":");
                  if (unusedNamespaces.has(ns)) {
                    unusedNamespaces.delete(ns);
                  }
                }
                for (const name of Object.keys(node.attributes)) {
                  if (name.includes(":")) {
                    const [ns] = name.split(":");
                    unusedNamespaces.delete(ns);
                  }
                }
              }
            },
            exit: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                for (const name of unusedNamespaces) {
                  delete node.attributes[`xmlns:${name}`];
                }
              }
            },
          },
        };
      };
    },
    3467: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      const { elemsGroups } = __nccwpck_require__(4298);
      exports.name = "removeUselessDefs";
      exports.description = "removes elements in <defs> without id";
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (node.name === "defs") {
              const usefulNodes = [];
              collectUsefulNodes(node, usefulNodes);
              if (usefulNodes.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              for (const usefulNode of usefulNodes) {
                Object.defineProperty(usefulNode, "parentNode", {
                  writable: true,
                  value: node,
                });
              }
              node.children = usefulNodes;
            } else if (
              elemsGroups.nonRendering.has(node.name) &&
              node.attributes.id == null
            ) {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
      const collectUsefulNodes = (node, usefulNodes) => {
        for (const child of node.children) {
          if (child.type === "element") {
            if (child.attributes.id != null || child.name === "style") {
              usefulNodes.push(child);
            } else {
              collectUsefulNodes(child, usefulNodes);
            }
          }
        }
      };
    },
    8627: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { visit, visitSkip, detachNodeFromParent } =
        __nccwpck_require__(4315);
      const { collectStylesheet, computeStyle } = __nccwpck_require__(3630);
      const { hasScripts } = __nccwpck_require__(5916);
      const { elemsGroups } = __nccwpck_require__(4298);
      exports.name = "removeUselessStrokeAndFill";
      exports.description = "removes useless stroke and fill attributes";
      exports.fn = (root, params) => {
        const {
          stroke: removeStroke = true,
          fill: removeFill = true,
          removeNone = false,
        } = params;
        let hasStyleOrScript = false;
        visit(root, {
          element: {
            enter: (node) => {
              if (node.name === "style" || hasScripts(node)) {
                hasStyleOrScript = true;
              }
            },
          },
        });
        if (hasStyleOrScript) {
          return null;
        }
        const stylesheet = collectStylesheet(root);
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.attributes.id != null) {
                return visitSkip;
              }
              if (!elemsGroups.shape.has(node.name)) {
                return;
              }
              const computedStyle = computeStyle(stylesheet, node);
              const stroke = computedStyle.stroke;
              const strokeOpacity = computedStyle["stroke-opacity"];
              const strokeWidth = computedStyle["stroke-width"];
              const markerEnd = computedStyle["marker-end"];
              const fill = computedStyle.fill;
              const fillOpacity = computedStyle["fill-opacity"];
              const computedParentStyle =
                parentNode.type === "element"
                  ? computeStyle(stylesheet, parentNode)
                  : null;
              const parentStroke =
                computedParentStyle == null ? null : computedParentStyle.stroke;
              if (removeStroke) {
                if (
                  stroke == null ||
                  (stroke.type === "static" && stroke.value == "none") ||
                  (strokeOpacity != null &&
                    strokeOpacity.type === "static" &&
                    strokeOpacity.value === "0") ||
                  (strokeWidth != null &&
                    strokeWidth.type === "static" &&
                    strokeWidth.value === "0")
                ) {
                  if (
                    (strokeWidth != null &&
                      strokeWidth.type === "static" &&
                      strokeWidth.value === "0") ||
                    markerEnd == null
                  ) {
                    for (const name of Object.keys(node.attributes)) {
                      if (name.startsWith("stroke")) {
                        delete node.attributes[name];
                      }
                    }
                    if (
                      parentStroke != null &&
                      parentStroke.type === "static" &&
                      parentStroke.value !== "none"
                    ) {
                      node.attributes.stroke = "none";
                    }
                  }
                }
              }
              if (removeFill) {
                if (
                  (fill != null &&
                    fill.type === "static" &&
                    fill.value === "none") ||
                  (fillOpacity != null &&
                    fillOpacity.type === "static" &&
                    fillOpacity.value === "0")
                ) {
                  for (const name of Object.keys(node.attributes)) {
                    if (name.startsWith("fill-")) {
                      delete node.attributes[name];
                    }
                  }
                  if (
                    fill == null ||
                    (fill.type === "static" && fill.value !== "none")
                  ) {
                    node.attributes.fill = "none";
                  }
                }
              }
              if (removeNone) {
                if (
                  (stroke == null || node.attributes.stroke === "none") &&
                  ((fill != null &&
                    fill.type === "static" &&
                    fill.value === "none") ||
                    node.attributes.fill === "none")
                ) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            },
          },
        };
      };
    },
    6766: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeViewBox";
      exports.description = "removes viewBox attribute when possible";
      const viewBoxElems = new Set(["pattern", "svg", "symbol"]);
      exports.fn = () => ({
        element: {
          enter: (node, parentNode) => {
            if (
              viewBoxElems.has(node.name) &&
              node.attributes.viewBox != null &&
              node.attributes.width != null &&
              node.attributes.height != null
            ) {
              if (node.name === "svg" && parentNode.type !== "root") {
                return;
              }
              const nums = node.attributes.viewBox.split(/[ ,]+/g);
              if (
                nums[0] === "0" &&
                nums[1] === "0" &&
                node.attributes.width.replace(/px$/, "") === nums[2] &&
                node.attributes.height.replace(/px$/, "") === nums[3]
              ) {
                delete node.attributes.viewBox;
              }
            }
          },
        },
      });
    },
    7110: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "removeXMLNS";
      exports.description =
        "removes xmlns attribute (for inline svg, disabled by default)";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "svg") {
              delete node.attributes.xmlns;
            }
          },
        },
      });
    },
    5927: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { detachNodeFromParent } = __nccwpck_require__(4315);
      exports.name = "removeXMLProcInst";
      exports.description = "removes XML processing instructions";
      exports.fn = () => ({
        instruction: {
          enter: (node, parentNode) => {
            if (node.name === "xml") {
              detachNodeFromParent(node, parentNode);
            }
          },
        },
      });
    },
    7425: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { elems } = __nccwpck_require__(4298);
      exports.name = "removeXlink";
      exports.description =
        "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable";
      const XLINK_NAMESPACE = "http://www.w3.org/1999/xlink";
      const SHOW_TO_TARGET = { new: "_blank", replace: "_self" };
      const LEGACY_ELEMENTS = new Set([
        "cursor",
        "filter",
        "font-face-uri",
        "glyphRef",
        "tref",
      ]);
      const findPrefixedAttrs = (node, prefixes, attr) =>
        prefixes
          .map((prefix) => `${prefix}:${attr}`)
          .filter((attr) => node.attributes[attr] != null);
      exports.fn = (_, params) => {
        const { includeLegacy } = params;
        const xlinkPrefixes = [];
        const overriddenPrefixes = [];
        const usedInLegacyElement = [];
        return {
          element: {
            enter: (node) => {
              for (const [key, value] of Object.entries(node.attributes)) {
                if (key.startsWith("xmlns:")) {
                  const prefix = key.split(":", 2)[1];
                  if (value === XLINK_NAMESPACE) {
                    xlinkPrefixes.push(prefix);
                    continue;
                  }
                  if (xlinkPrefixes.includes(prefix)) {
                    overriddenPrefixes.push(prefix);
                  }
                }
              }
              if (
                overriddenPrefixes.some((prefix) =>
                  xlinkPrefixes.includes(prefix),
                )
              ) {
                return;
              }
              const showAttrs = findPrefixedAttrs(node, xlinkPrefixes, "show");
              let showHandled = node.attributes.target != null;
              for (let i = showAttrs.length - 1; i >= 0; i--) {
                const attr = showAttrs[i];
                const value = node.attributes[attr];
                const mapping = SHOW_TO_TARGET[value];
                if (showHandled || mapping == null) {
                  delete node.attributes[attr];
                  continue;
                }
                if (mapping !== elems[node.name]?.defaults?.target) {
                  node.attributes.target = mapping;
                }
                delete node.attributes[attr];
                showHandled = true;
              }
              const titleAttrs = findPrefixedAttrs(
                node,
                xlinkPrefixes,
                "title",
              );
              for (let i = titleAttrs.length - 1; i >= 0; i--) {
                const attr = titleAttrs[i];
                const value = node.attributes[attr];
                const hasTitle = node.children.filter(
                  (child) => child.type === "element" && child.name === "title",
                );
                if (hasTitle.length > 0) {
                  delete node.attributes[attr];
                  continue;
                }
                const titleTag = {
                  type: "element",
                  name: "title",
                  attributes: {},
                  children: [{ type: "text", value }],
                };
                Object.defineProperty(titleTag, "parentNode", {
                  writable: true,
                  value: node,
                });
                node.children.unshift(titleTag);
                delete node.attributes[attr];
              }
              const hrefAttrs = findPrefixedAttrs(node, xlinkPrefixes, "href");
              if (
                hrefAttrs.length > 0 &&
                LEGACY_ELEMENTS.has(node.name) &&
                !includeLegacy
              ) {
                hrefAttrs
                  .map((attr) => attr.split(":", 1)[0])
                  .forEach((prefix) => usedInLegacyElement.push(prefix));
                return;
              }
              for (let i = hrefAttrs.length - 1; i >= 0; i--) {
                const attr = hrefAttrs[i];
                const value = node.attributes[attr];
                if (node.attributes.href != null) {
                  delete node.attributes[attr];
                  continue;
                }
                node.attributes.href = value;
                delete node.attributes[attr];
              }
            },
            exit: (node) => {
              for (const [key, value] of Object.entries(node.attributes)) {
                const [prefix, attr] = key.split(":", 2);
                if (
                  xlinkPrefixes.includes(prefix) &&
                  !overriddenPrefixes.includes(prefix) &&
                  !usedInLegacyElement.includes(prefix) &&
                  !includeLegacy
                ) {
                  delete node.attributes[key];
                  continue;
                }
                if (
                  key.startsWith("xmlns:") &&
                  !usedInLegacyElement.includes(attr)
                ) {
                  if (value === XLINK_NAMESPACE) {
                    const index = xlinkPrefixes.indexOf(attr);
                    xlinkPrefixes.splice(index, 1);
                    delete node.attributes[key];
                    continue;
                  }
                  if (overriddenPrefixes.includes(prefix)) {
                    const index = overriddenPrefixes.indexOf(attr);
                    overriddenPrefixes.splice(index, 1);
                  }
                }
              }
            },
          },
        };
      };
    },
    4727: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { collectStylesheet } = __nccwpck_require__(3630);
      const { detachNodeFromParent, querySelectorAll } =
        __nccwpck_require__(4315);
      exports.name = "reusePaths";
      exports.description =
        "Finds <path> elements with the same d, fill, and " +
        "stroke, and converts them to <use> elements " +
        "referencing a single <path> def.";
      exports.fn = (root) => {
        const stylesheet = collectStylesheet(root);
        const paths = new Map();
        let svgDefs;
        const hrefs = new Set();
        return {
          element: {
            enter: (node, parentNode) => {
              if (node.name === "path" && node.attributes.d != null) {
                const d = node.attributes.d;
                const fill = node.attributes.fill || "";
                const stroke = node.attributes.stroke || "";
                const key = d + ";s:" + stroke + ";f:" + fill;
                let list = paths.get(key);
                if (list == null) {
                  list = [];
                  paths.set(key, list);
                }
                list.push(node);
              }
              if (
                svgDefs == null &&
                node.name === "defs" &&
                parentNode.type === "element" &&
                parentNode.name === "svg"
              ) {
                svgDefs = node;
              }
              if (node.name === "use") {
                for (const name of ["href", "xlink:href"]) {
                  const href = node.attributes[name];
                  if (href != null && href.startsWith("#") && href.length > 1) {
                    hrefs.add(href.slice(1));
                  }
                }
              }
            },
            exit: (node, parentNode) => {
              if (node.name === "svg" && parentNode.type === "root") {
                let defsTag = svgDefs;
                if (defsTag == null) {
                  defsTag = {
                    type: "element",
                    name: "defs",
                    attributes: {},
                    children: [],
                  };
                  Object.defineProperty(defsTag, "parentNode", {
                    writable: true,
                    value: node,
                  });
                }
                let index = 0;
                for (const list of paths.values()) {
                  if (list.length > 1) {
                    const reusablePath = {
                      type: "element",
                      name: "path",
                      attributes: {},
                      children: [],
                    };
                    for (const attr of ["fill", "stroke", "d"]) {
                      if (list[0].attributes[attr] != null) {
                        reusablePath.attributes[attr] =
                          list[0].attributes[attr];
                      }
                    }
                    const originalId = list[0].attributes.id;
                    if (
                      originalId == null ||
                      hrefs.has(originalId) ||
                      stylesheet.rules.some(
                        (rule) => rule.selector === `#${originalId}`,
                      )
                    ) {
                      reusablePath.attributes.id = "reuse-" + index++;
                    } else {
                      reusablePath.attributes.id = originalId;
                      delete list[0].attributes.id;
                    }
                    Object.defineProperty(reusablePath, "parentNode", {
                      writable: true,
                      value: defsTag,
                    });
                    defsTag.children.push(reusablePath);
                    for (const pathNode of list) {
                      delete pathNode.attributes.d;
                      delete pathNode.attributes.stroke;
                      delete pathNode.attributes.fill;
                      if (
                        defsTag.children.includes(pathNode) &&
                        pathNode.children.length === 0
                      ) {
                        if (Object.keys(pathNode.attributes).length === 0) {
                          detachNodeFromParent(pathNode, defsTag);
                          continue;
                        }
                        if (
                          Object.keys(pathNode.attributes).length === 1 &&
                          pathNode.attributes.id != null
                        ) {
                          detachNodeFromParent(pathNode, defsTag);
                          const selector = `[xlink\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;
                          for (const child of querySelectorAll(
                            node,
                            selector,
                          )) {
                            if (child.type !== "element") {
                              continue;
                            }
                            for (const name of ["href", "xlink:href"]) {
                              if (child.attributes[name] != null) {
                                child.attributes[name] =
                                  "#" + reusablePath.attributes.id;
                              }
                            }
                          }
                          continue;
                        }
                      }
                      pathNode.name = "use";
                      pathNode.attributes["xlink:href"] =
                        "#" + reusablePath.attributes.id;
                    }
                  }
                }
                if (defsTag.children.length !== 0) {
                  if (node.attributes["xmlns:xlink"] == null) {
                    node.attributes["xmlns:xlink"] =
                      "http://www.w3.org/1999/xlink";
                  }
                  if (svgDefs == null) {
                    node.children.unshift(defsTag);
                  }
                }
              }
            },
          },
        };
      };
    },
    8175: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "sortAttrs";
      exports.description = "Sort element attributes for better compression";
      exports.fn = (_root, params) => {
        const {
          order = [
            "id",
            "width",
            "height",
            "x",
            "x1",
            "x2",
            "y",
            "y1",
            "y2",
            "cx",
            "cy",
            "r",
            "fill",
            "stroke",
            "marker",
            "d",
            "points",
          ],
          xmlnsOrder = "front",
        } = params;
        const getNsPriority = (name) => {
          if (xmlnsOrder === "front") {
            if (name === "xmlns") {
              return 3;
            }
            if (name.startsWith("xmlns:")) {
              return 2;
            }
          }
          if (name.includes(":")) {
            return 1;
          }
          return 0;
        };
        const compareAttrs = ([aName], [bName]) => {
          const aPriority = getNsPriority(aName);
          const bPriority = getNsPriority(bName);
          const priorityNs = bPriority - aPriority;
          if (priorityNs !== 0) {
            return priorityNs;
          }
          const [aPart] = aName.split("-");
          const [bPart] = bName.split("-");
          if (aPart !== bPart) {
            const aInOrderFlag = order.includes(aPart) ? 1 : 0;
            const bInOrderFlag = order.includes(bPart) ? 1 : 0;
            if (aInOrderFlag === 1 && bInOrderFlag === 1) {
              return order.indexOf(aPart) - order.indexOf(bPart);
            }
            const priorityOrder = bInOrderFlag - aInOrderFlag;
            if (priorityOrder !== 0) {
              return priorityOrder;
            }
          }
          return aName < bName ? -1 : 1;
        };
        return {
          element: {
            enter: (node) => {
              const attrs = Object.entries(node.attributes);
              attrs.sort(compareAttrs);
              const sortedAttributes = {};
              for (const [name, value] of attrs) {
                sortedAttributes[name] = value;
              }
              node.attributes = sortedAttributes;
            },
          },
        };
      };
    },
    21: (__unused_webpack_module, exports) => {
      "use strict";
      exports.name = "sortDefsChildren";
      exports.description = "Sorts children of <defs> to improve compression";
      exports.fn = () => ({
        element: {
          enter: (node) => {
            if (node.name === "defs") {
              const frequencies = new Map();
              for (const child of node.children) {
                if (child.type === "element") {
                  const frequency = frequencies.get(child.name);
                  if (frequency == null) {
                    frequencies.set(child.name, 1);
                  } else {
                    frequencies.set(child.name, frequency + 1);
                  }
                }
              }
              node.children.sort((a, b) => {
                if (a.type !== "element" || b.type !== "element") {
                  return 0;
                }
                const aFrequency = frequencies.get(a.name);
                const bFrequency = frequencies.get(b.name);
                if (aFrequency != null && bFrequency != null) {
                  const frequencyComparison = bFrequency - aFrequency;
                  if (frequencyComparison !== 0) {
                    return frequencyComparison;
                  }
                }
                const lengthComparison = b.name.length - a.name.length;
                if (lengthComparison !== 0) {
                  return lengthComparison;
                }
                if (a.name !== b.name) {
                  return a.name > b.name ? -1 : 1;
                }
                return 0;
              });
            }
          },
        },
      });
    },
    4609: (module) => {
      function webpackEmptyAsyncContext(req) {
        return Promise.resolve().then(() => {
          var e = new Error("Cannot find module '" + req + "'");
          e.code = "MODULE_NOT_FOUND";
          throw e;
        });
      }
      webpackEmptyAsyncContext.keys = () => [];
      webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
      webpackEmptyAsyncContext.id = 4609;
      module.exports = webpackEmptyAsyncContext;
    },
    2512: (module) => {
      "use strict";
      module.exports = require("../../cosmiconfig");
    },
    3684: (module) => {
      "use strict";
      module.exports = require("./package.json");
    },
    7147: (module) => {
      "use strict";
      module.exports = require("fs");
    },
    2037: (module) => {
      "use strict";
      module.exports = require("os");
    },
    1017: (module) => {
      "use strict";
      module.exports = require("path");
    },
    7310: (module) => {
      "use strict";
      module.exports = require("url");
    },
    2505: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(3681);
      function createConvertor(walk) {
        return {
          fromPlainObject(ast) {
            walk(ast, {
              enter(node) {
                if (
                  node.children &&
                  node.children instanceof List.List === false
                ) {
                  node.children = new List.List().fromArray(node.children);
                }
              },
            });
            return ast;
          },
          toPlainObject(ast) {
            walk(ast, {
              leave(node) {
                if (node.children && node.children instanceof List.List) {
                  node.children = node.children.toArray();
                }
              },
            });
            return ast;
          },
        };
      }
      exports.createConvertor = createConvertor;
    },
    5884: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const patch = __nccwpck_require__(1835);
      const patch$1 = patch;
      module.exports = patch$1;
    },
    9650: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const dataPatch = __nccwpck_require__(5884);
      const mdnAtrules = __nccwpck_require__(5260);
      const mdnProperties = __nccwpck_require__(1005);
      const mdnSyntaxes = __nccwpck_require__(8022);
      const extendSyntax = /^\s*\|\s*/;
      function preprocessAtrules(dict) {
        const result = Object.create(null);
        for (const atruleName in dict) {
          const atrule = dict[atruleName];
          let descriptors = null;
          if (atrule.descriptors) {
            descriptors = Object.create(null);
            for (const descriptor in atrule.descriptors) {
              descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
          }
          result[atruleName.substr(1)] = {
            prelude:
              atrule.syntax
                .trim()
                .replace(/\{(.|\s)+\}/, "")
                .match(/^@\S+\s+([^;\{]*)/)[1]
                .trim() || null,
            descriptors,
          };
        }
        return result;
      }
      function patchDictionary(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          result[key] = dict[key].syntax || dict[key];
        }
        for (const key in patchDict) {
          if (key in dict) {
            if (patchDict[key].syntax) {
              result[key] = extendSyntax.test(patchDict[key].syntax)
                ? result[key] + " " + patchDict[key].syntax.trim()
                : patchDict[key].syntax;
            } else {
              delete result[key];
            }
          } else {
            if (patchDict[key].syntax) {
              result[key] = patchDict[key].syntax.replace(extendSyntax, "");
            }
          }
        }
        return result;
      }
      function patchAtrules(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          const patchDescriptors =
            (patchDict[key] && patchDict[key].descriptors) || null;
          result[key] = {
            prelude:
              key in patchDict && "prelude" in patchDict[key]
                ? patchDict[key].prelude
                : dict[key].prelude || null,
            descriptors: patchDictionary(
              dict[key].descriptors || {},
              patchDescriptors || {},
            ),
          };
        }
        for (const key in patchDict) {
          if (!hasOwnProperty.call(dict, key)) {
            result[key] = {
              prelude: patchDict[key].prelude || null,
              descriptors:
                patchDict[key].descriptors &&
                patchDictionary({}, patchDict[key].descriptors),
            };
          }
        }
        return result;
      }
      const definitions = {
        types: patchDictionary(mdnSyntaxes, dataPatch.types),
        atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
        properties: patchDictionary(mdnProperties, dataPatch.properties),
      };
      module.exports = definitions;
    },
    741: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const createCustomError = __nccwpck_require__(6893);
      function SyntaxError(message, input, offset) {
        return Object.assign(
          createCustomError.createCustomError("SyntaxError", message),
          {
            input,
            offset,
            rawMessage: message,
            message:
              message +
              "\n" +
              "  " +
              input +
              "\n" +
              "--" +
              new Array((offset || input.length) + 1).join("-") +
              "^",
          },
        );
      }
      exports.SyntaxError = SyntaxError;
    },
    6709: (__unused_webpack_module, exports) => {
      "use strict";
      function noop(value) {
        return value;
      }
      function generateMultiplier(multiplier) {
        const { min, max, comma } = multiplier;
        if (min === 0 && max === 0) {
          return comma ? "#?" : "*";
        }
        if (min === 0 && max === 1) {
          return "?";
        }
        if (min === 1 && max === 0) {
          return comma ? "#" : "+";
        }
        if (min === 1 && max === 1) {
          return "";
        }
        return (
          (comma ? "#" : "") +
          (min === max
            ? "{" + min + "}"
            : "{" + min + "," + (max !== 0 ? max : "") + "}")
        );
      }
      function generateTypeOpts(node) {
        switch (node.type) {
          case "Range":
            return (
              " [" +
              (node.min === null ? "-∞" : node.min) +
              "," +
              (node.max === null ? "∞" : node.max) +
              "]"
            );
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
      }
      function generateSequence(node, decorate, forceBraces, compact) {
        const combinator =
          node.combinator === " " || compact
            ? node.combinator
            : " " + node.combinator + " ";
        const result = node.terms
          .map((term) => internalGenerate(term, decorate, forceBraces, compact))
          .join(combinator);
        if (node.explicit || forceBraces) {
          return (
            (compact || result[0] === "," ? "[" : "[ ") +
            result +
            (compact ? "]" : " ]")
          );
        }
        return result;
      }
      function internalGenerate(node, decorate, forceBraces, compact) {
        let result;
        switch (node.type) {
          case "Group":
            result =
              generateSequence(node, decorate, forceBraces, compact) +
              (node.disallowEmpty ? "!" : "");
            break;
          case "Multiplier":
            return (
              internalGenerate(node.term, decorate, forceBraces, compact) +
              decorate(generateMultiplier(node), node)
            );
          case "Type":
            result =
              "<" +
              node.name +
              (node.opts
                ? decorate(generateTypeOpts(node.opts), node.opts)
                : "") +
              ">";
            break;
          case "Property":
            result = "<'" + node.name + "'>";
            break;
          case "Keyword":
            result = node.name;
            break;
          case "AtKeyword":
            result = "@" + node.name;
            break;
          case "Function":
            result = node.name + "(";
            break;
          case "String":
          case "Token":
            result = node.value;
            break;
          case "Comma":
            result = ",";
            break;
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
        return decorate(result, node);
      }
      function generate(node, options) {
        let decorate = noop;
        let forceBraces = false;
        let compact = false;
        if (typeof options === "function") {
          decorate = options;
        } else if (options) {
          forceBraces = Boolean(options.forceBraces);
          compact = Boolean(options.compact);
          if (typeof options.decorate === "function") {
            decorate = options.decorate;
          }
        }
        return internalGenerate(node, decorate, forceBraces, compact);
      }
      exports.generate = generate;
    },
    394: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const SyntaxError = __nccwpck_require__(741);
      const generate = __nccwpck_require__(6709);
      const parse = __nccwpck_require__(3108);
      const walk = __nccwpck_require__(4433);
      exports.SyntaxError = SyntaxError.SyntaxError;
      exports.generate = generate.generate;
      exports.parse = parse.parse;
      exports.walk = walk.walk;
    },
    3108: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const tokenizer = __nccwpck_require__(6398);
      const TAB = 9;
      const N = 10;
      const F = 12;
      const R = 13;
      const SPACE = 32;
      const EXCLAMATIONMARK = 33;
      const NUMBERSIGN = 35;
      const AMPERSAND = 38;
      const APOSTROPHE = 39;
      const LEFTPARENTHESIS = 40;
      const RIGHTPARENTHESIS = 41;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const COMMA = 44;
      const HYPERMINUS = 45;
      const LESSTHANSIGN = 60;
      const GREATERTHANSIGN = 62;
      const QUESTIONMARK = 63;
      const COMMERCIALAT = 64;
      const LEFTSQUAREBRACKET = 91;
      const RIGHTSQUAREBRACKET = 93;
      const LEFTCURLYBRACKET = 123;
      const VERTICALLINE = 124;
      const RIGHTCURLYBRACKET = 125;
      const INFINITY = 8734;
      const NAME_CHAR = new Uint8Array(128).map((_, idx) =>
        /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0,
      );
      const COMBINATOR_PRECEDENCE = { " ": 1, "&&": 2, "||": 3, "|": 4 };
      function scanSpaces(tokenizer) {
        return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
      }
      function scanWord(tokenizer) {
        let end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          const code = tokenizer.str.charCodeAt(end);
          if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a keyword");
        }
        return tokenizer.substringToPos(end);
      }
      function scanNumber(tokenizer) {
        let end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          const code = tokenizer.str.charCodeAt(end);
          if (code < 48 || code > 57) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a number");
        }
        return tokenizer.substringToPos(end);
      }
      function scanString(tokenizer) {
        const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
        if (end === -1) {
          tokenizer.pos = tokenizer.str.length;
          tokenizer.error("Expect an apostrophe");
        }
        return tokenizer.substringToPos(end + 1);
      }
      function readMultiplierRange(tokenizer) {
        let min = null;
        let max = null;
        tokenizer.eat(LEFTCURLYBRACKET);
        min = scanNumber(tokenizer);
        if (tokenizer.charCode() === COMMA) {
          tokenizer.pos++;
          if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
          }
        } else {
          max = min;
        }
        tokenizer.eat(RIGHTCURLYBRACKET);
        return { min: Number(min), max: max ? Number(max) : 0 };
      }
      function readMultiplier(tokenizer) {
        let range = null;
        let comma = false;
        switch (tokenizer.charCode()) {
          case ASTERISK:
            tokenizer.pos++;
            range = { min: 0, max: 0 };
            break;
          case PLUSSIGN:
            tokenizer.pos++;
            range = { min: 1, max: 0 };
            break;
          case QUESTIONMARK:
            tokenizer.pos++;
            range = { min: 0, max: 1 };
            break;
          case NUMBERSIGN:
            tokenizer.pos++;
            comma = true;
            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
              range = readMultiplierRange(tokenizer);
            } else if (tokenizer.charCode() === QUESTIONMARK) {
              tokenizer.pos++;
              range = { min: 0, max: 0 };
            } else {
              range = { min: 1, max: 0 };
            }
            break;
          case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;
          default:
            return null;
        }
        return {
          type: "Multiplier",
          comma,
          min: range.min,
          max: range.max,
          term: null,
        };
      }
      function maybeMultiplied(tokenizer, node) {
        const multiplier = readMultiplier(tokenizer);
        if (multiplier !== null) {
          multiplier.term = node;
          if (
            tokenizer.charCode() === NUMBERSIGN &&
            tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN
          ) {
            return maybeMultiplied(tokenizer, multiplier);
          }
          return multiplier;
        }
        return node;
      }
      function maybeToken(tokenizer) {
        const ch = tokenizer.peek();
        if (ch === "") {
          return null;
        }
        return { type: "Token", value: ch };
      }
      function readProperty(tokenizer) {
        let name;
        tokenizer.eat(LESSTHANSIGN);
        tokenizer.eat(APOSTROPHE);
        name = scanWord(tokenizer);
        tokenizer.eat(APOSTROPHE);
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, { type: "Property", name });
      }
      function readTypeRange(tokenizer) {
        let min = null;
        let max = null;
        let sign = 1;
        tokenizer.eat(LEFTSQUAREBRACKET);
        if (tokenizer.charCode() === HYPERMINUS) {
          tokenizer.peek();
          sign = -1;
        }
        if (sign == -1 && tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          min = sign * Number(scanNumber(tokenizer));
          if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            min += scanWord(tokenizer);
          }
        }
        scanSpaces(tokenizer);
        tokenizer.eat(COMMA);
        scanSpaces(tokenizer);
        if (tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          sign = 1;
          if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
          }
          max = sign * Number(scanNumber(tokenizer));
          if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            max += scanWord(tokenizer);
          }
        }
        tokenizer.eat(RIGHTSQUAREBRACKET);
        return { type: "Range", min, max };
      }
      function readType(tokenizer) {
        let name;
        let opts = null;
        tokenizer.eat(LESSTHANSIGN);
        name = scanWord(tokenizer);
        if (
          tokenizer.charCode() === LEFTPARENTHESIS &&
          tokenizer.nextCharCode() === RIGHTPARENTHESIS
        ) {
          tokenizer.pos += 2;
          name += "()";
        }
        if (
          tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) ===
          LEFTSQUAREBRACKET
        ) {
          scanSpaces(tokenizer);
          opts = readTypeRange(tokenizer);
        }
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, { type: "Type", name, opts });
      }
      function readKeywordOrFunction(tokenizer) {
        const name = scanWord(tokenizer);
        if (tokenizer.charCode() === LEFTPARENTHESIS) {
          tokenizer.pos++;
          return { type: "Function", name };
        }
        return maybeMultiplied(tokenizer, { type: "Keyword", name });
      }
      function regroupTerms(terms, combinators) {
        function createGroup(terms, combinator) {
          return {
            type: "Group",
            terms,
            combinator,
            disallowEmpty: false,
            explicit: false,
          };
        }
        let combinator;
        combinators = Object.keys(combinators).sort(
          (a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b],
        );
        while (combinators.length > 0) {
          combinator = combinators.shift();
          let i = 0;
          let subgroupStart = 0;
          for (; i < terms.length; i++) {
            const term = terms[i];
            if (term.type === "Combinator") {
              if (term.value === combinator) {
                if (subgroupStart === -1) {
                  subgroupStart = i - 1;
                }
                terms.splice(i, 1);
                i--;
              } else {
                if (subgroupStart !== -1 && i - subgroupStart > 1) {
                  terms.splice(
                    subgroupStart,
                    i - subgroupStart,
                    createGroup(terms.slice(subgroupStart, i), combinator),
                  );
                  i = subgroupStart + 1;
                }
                subgroupStart = -1;
              }
            }
          }
          if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator),
            );
          }
        }
        return combinator;
      }
      function readImplicitGroup(tokenizer) {
        const terms = [];
        const combinators = {};
        let token;
        let prevToken = null;
        let prevTokenPos = tokenizer.pos;
        while ((token = peek(tokenizer))) {
          if (token.type !== "Spaces") {
            if (token.type === "Combinator") {
              if (prevToken === null || prevToken.type === "Combinator") {
                tokenizer.pos = prevTokenPos;
                tokenizer.error("Unexpected combinator");
              }
              combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== "Combinator") {
              combinators[" "] = true;
              terms.push({ type: "Combinator", value: " " });
            }
            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
          }
        }
        if (prevToken !== null && prevToken.type === "Combinator") {
          tokenizer.pos -= prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }
        return {
          type: "Group",
          terms,
          combinator: regroupTerms(terms, combinators) || " ",
          disallowEmpty: false,
          explicit: false,
        };
      }
      function readGroup(tokenizer) {
        let result;
        tokenizer.eat(LEFTSQUAREBRACKET);
        result = readImplicitGroup(tokenizer);
        tokenizer.eat(RIGHTSQUAREBRACKET);
        result.explicit = true;
        if (tokenizer.charCode() === EXCLAMATIONMARK) {
          tokenizer.pos++;
          result.disallowEmpty = true;
        }
        return result;
      }
      function peek(tokenizer) {
        let code = tokenizer.charCode();
        if (code < 128 && NAME_CHAR[code] === 1) {
          return readKeywordOrFunction(tokenizer);
        }
        switch (code) {
          case RIGHTSQUAREBRACKET:
            break;
          case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));
          case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
              ? readProperty(tokenizer)
              : readType(tokenizer);
          case VERTICALLINE:
            return {
              type: "Combinator",
              value: tokenizer.substringToPos(
                tokenizer.pos +
                  (tokenizer.nextCharCode() === VERTICALLINE ? 2 : 1),
              ),
            };
          case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);
            return { type: "Combinator", value: "&&" };
          case COMMA:
            tokenizer.pos++;
            return { type: "Comma" };
          case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
              type: "String",
              value: scanString(tokenizer),
            });
          case SPACE:
          case TAB:
          case N:
          case R:
          case F:
            return { type: "Spaces", value: scanSpaces(tokenizer) };
          case COMMERCIALAT:
            code = tokenizer.nextCharCode();
            if (code < 128 && NAME_CHAR[code] === 1) {
              tokenizer.pos++;
              return { type: "AtKeyword", name: scanWord(tokenizer) };
            }
            return maybeToken(tokenizer);
          case ASTERISK:
          case PLUSSIGN:
          case QUESTIONMARK:
          case NUMBERSIGN:
          case EXCLAMATIONMARK:
            break;
          case LEFTCURLYBRACKET:
            code = tokenizer.nextCharCode();
            if (code < 48 || code > 57) {
              return maybeToken(tokenizer);
            }
            break;
          default:
            return maybeToken(tokenizer);
        }
      }
      function parse(source) {
        const tokenizer$1 = new tokenizer.Tokenizer(source);
        const result = readImplicitGroup(tokenizer$1);
        if (tokenizer$1.pos !== source.length) {
          tokenizer$1.error("Unexpected input");
        }
        if (result.terms.length === 1 && result.terms[0].type === "Group") {
          return result.terms[0];
        }
        return result;
      }
      exports.parse = parse;
    },
    6398: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const SyntaxError = __nccwpck_require__(741);
      const TAB = 9;
      const N = 10;
      const F = 12;
      const R = 13;
      const SPACE = 32;
      class Tokenizer {
        constructor(str) {
          this.str = str;
          this.pos = 0;
        }
        charCodeAt(pos) {
          return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
        }
        charCode() {
          return this.charCodeAt(this.pos);
        }
        nextCharCode() {
          return this.charCodeAt(this.pos + 1);
        }
        nextNonWsCode(pos) {
          return this.charCodeAt(this.findWsEnd(pos));
        }
        findWsEnd(pos) {
          for (; pos < this.str.length; pos++) {
            const code = this.str.charCodeAt(pos);
            if (
              code !== R &&
              code !== N &&
              code !== F &&
              code !== SPACE &&
              code !== TAB
            ) {
              break;
            }
          }
          return pos;
        }
        substringToPos(end) {
          return this.str.substring(this.pos, (this.pos = end));
        }
        eat(code) {
          if (this.charCode() !== code) {
            this.error("Expect `" + String.fromCharCode(code) + "`");
          }
          this.pos++;
        }
        peek() {
          return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
        }
        error(message) {
          throw new SyntaxError.SyntaxError(message, this.str, this.pos);
        }
      }
      exports.Tokenizer = Tokenizer;
    },
    4433: (__unused_webpack_module, exports) => {
      "use strict";
      const noop = function () {};
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop;
      }
      function walk(node, options, context) {
        function walk(node) {
          enter.call(context, node);
          switch (node.type) {
            case "Group":
              node.terms.forEach(walk);
              break;
            case "Multiplier":
              walk(node.term);
              break;
            case "Type":
            case "Property":
            case "Keyword":
            case "AtKeyword":
            case "Function":
            case "String":
            case "Token":
            case "Comma":
              break;
            default:
              throw new Error("Unknown type: " + node.type);
          }
          leave.call(context, node);
        }
        let enter = noop;
        let leave = noop;
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
        }
        if (enter === noop && leave === noop) {
          throw new Error(
            "Neither `enter` nor `leave` walker handler is set or both aren't a function",
          );
        }
        walk(node);
      }
      exports.walk = walk;
    },
    8919: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(8008);
      const sourceMap = __nccwpck_require__(9694);
      const tokenBefore = __nccwpck_require__(819);
      const types = __nccwpck_require__(7783);
      const REVERSESOLIDUS = 92;
      function processChildren(node, delimeter) {
        if (typeof delimeter === "function") {
          let prev = null;
          node.children.forEach((node) => {
            if (prev !== null) {
              delimeter.call(this, prev);
            }
            this.node(node);
            prev = node;
          });
          return;
        }
        node.children.forEach(this.node, this);
      }
      function processChunk(chunk) {
        index.tokenize(chunk, (type, start, end) => {
          this.token(type, chunk.slice(start, end));
        });
      }
      function createGenerator(config) {
        const types$1 = new Map();
        for (let name in config.node) {
          const item = config.node[name];
          const fn = item.generate || item;
          if (typeof fn === "function") {
            types$1.set(name, item.generate || item);
          }
        }
        return function (node, options) {
          let buffer = "";
          let prevCode = 0;
          let handlers = {
            node(node) {
              if (types$1.has(node.type)) {
                types$1.get(node.type).call(publicApi, node);
              } else {
                throw new Error("Unknown node type: " + node.type);
              }
            },
            tokenBefore: tokenBefore.safe,
            token(type, value) {
              prevCode = this.tokenBefore(prevCode, type, value);
              this.emit(value, type, false);
              if (
                type === types.Delim &&
                value.charCodeAt(0) === REVERSESOLIDUS
              ) {
                this.emit("\n", types.WhiteSpace, true);
              }
            },
            emit(value) {
              buffer += value;
            },
            result() {
              return buffer;
            },
          };
          if (options) {
            if (typeof options.decorator === "function") {
              handlers = options.decorator(handlers);
            }
            if (options.sourceMap) {
              handlers = sourceMap.generateSourceMap(handlers);
            }
            if (options.mode in tokenBefore) {
              handlers.tokenBefore = tokenBefore[options.mode];
            }
          }
          const publicApi = {
            node: (node) => handlers.node(node),
            children: processChildren,
            token: (type, value) => handlers.token(type, value),
            tokenize: processChunk,
          };
          handlers.node(node);
          return handlers.result();
        };
      }
      exports.createGenerator = createGenerator;
    },
    9694: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const sourceMapGenerator_js = __nccwpck_require__(4209);
      const trackNodes = new Set(["Atrule", "Selector", "Declaration"]);
      function generateSourceMap(handlers) {
        const map = new sourceMapGenerator_js.SourceMapGenerator();
        const generated = { line: 1, column: 0 };
        const original = { line: 0, column: 0 };
        const activatedGenerated = { line: 1, column: 0 };
        const activatedMapping = { generated: activatedGenerated };
        let line = 1;
        let column = 0;
        let sourceMappingActive = false;
        const origHandlersNode = handlers.node;
        handlers.node = function (node) {
          if (node.loc && node.loc.start && trackNodes.has(node.type)) {
            const nodeLine = node.loc.start.line;
            const nodeColumn = node.loc.start.column - 1;
            if (original.line !== nodeLine || original.column !== nodeColumn) {
              original.line = nodeLine;
              original.column = nodeColumn;
              generated.line = line;
              generated.column = column;
              if (sourceMappingActive) {
                sourceMappingActive = false;
                if (
                  generated.line !== activatedGenerated.line ||
                  generated.column !== activatedGenerated.column
                ) {
                  map.addMapping(activatedMapping);
                }
              }
              sourceMappingActive = true;
              map.addMapping({ source: node.loc.source, original, generated });
            }
          }
          origHandlersNode.call(this, node);
          if (sourceMappingActive && trackNodes.has(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
          }
        };
        const origHandlersEmit = handlers.emit;
        handlers.emit = function (value, type, auto) {
          for (let i = 0; i < value.length; i++) {
            if (value.charCodeAt(i) === 10) {
              line++;
              column = 0;
            } else {
              column++;
            }
          }
          origHandlersEmit(value, type, auto);
        };
        const origHandlersResult = handlers.result;
        handlers.result = function () {
          if (sourceMappingActive) {
            map.addMapping(activatedMapping);
          }
          return { css: origHandlersResult(), map };
        };
        return handlers;
      }
      exports.generateSourceMap = generateSourceMap;
    },
    819: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const code = (type, value) => {
        if (type === types.Delim) {
          type = value;
        }
        if (typeof type === "string") {
          const charCode = type.charCodeAt(0);
          return charCode > 127 ? 32768 : charCode << 8;
        }
        return type;
      };
      const specPairs = [
        [types.Ident, types.Ident],
        [types.Ident, types.Function],
        [types.Ident, types.Url],
        [types.Ident, types.BadUrl],
        [types.Ident, "-"],
        [types.Ident, types.Number],
        [types.Ident, types.Percentage],
        [types.Ident, types.Dimension],
        [types.Ident, types.CDC],
        [types.Ident, types.LeftParenthesis],
        [types.AtKeyword, types.Ident],
        [types.AtKeyword, types.Function],
        [types.AtKeyword, types.Url],
        [types.AtKeyword, types.BadUrl],
        [types.AtKeyword, "-"],
        [types.AtKeyword, types.Number],
        [types.AtKeyword, types.Percentage],
        [types.AtKeyword, types.Dimension],
        [types.AtKeyword, types.CDC],
        [types.Hash, types.Ident],
        [types.Hash, types.Function],
        [types.Hash, types.Url],
        [types.Hash, types.BadUrl],
        [types.Hash, "-"],
        [types.Hash, types.Number],
        [types.Hash, types.Percentage],
        [types.Hash, types.Dimension],
        [types.Hash, types.CDC],
        [types.Dimension, types.Ident],
        [types.Dimension, types.Function],
        [types.Dimension, types.Url],
        [types.Dimension, types.BadUrl],
        [types.Dimension, "-"],
        [types.Dimension, types.Number],
        [types.Dimension, types.Percentage],
        [types.Dimension, types.Dimension],
        [types.Dimension, types.CDC],
        ["#", types.Ident],
        ["#", types.Function],
        ["#", types.Url],
        ["#", types.BadUrl],
        ["#", "-"],
        ["#", types.Number],
        ["#", types.Percentage],
        ["#", types.Dimension],
        ["#", types.CDC],
        ["-", types.Ident],
        ["-", types.Function],
        ["-", types.Url],
        ["-", types.BadUrl],
        ["-", "-"],
        ["-", types.Number],
        ["-", types.Percentage],
        ["-", types.Dimension],
        ["-", types.CDC],
        [types.Number, types.Ident],
        [types.Number, types.Function],
        [types.Number, types.Url],
        [types.Number, types.BadUrl],
        [types.Number, types.Number],
        [types.Number, types.Percentage],
        [types.Number, types.Dimension],
        [types.Number, "%"],
        [types.Number, types.CDC],
        ["@", types.Ident],
        ["@", types.Function],
        ["@", types.Url],
        ["@", types.BadUrl],
        ["@", "-"],
        ["@", types.CDC],
        [".", types.Number],
        [".", types.Percentage],
        [".", types.Dimension],
        ["+", types.Number],
        ["+", types.Percentage],
        ["+", types.Dimension],
        ["/", "*"],
      ];
      const safePairs = specPairs.concat([
        [types.Ident, types.Hash],
        [types.Dimension, types.Hash],
        [types.Hash, types.Hash],
        [types.AtKeyword, types.LeftParenthesis],
        [types.AtKeyword, types.String],
        [types.AtKeyword, types.Colon],
        [types.Percentage, types.Percentage],
        [types.Percentage, types.Dimension],
        [types.Percentage, types.Function],
        [types.Percentage, "-"],
        [types.RightParenthesis, types.Ident],
        [types.RightParenthesis, types.Function],
        [types.RightParenthesis, types.Percentage],
        [types.RightParenthesis, types.Dimension],
        [types.RightParenthesis, types.Hash],
        [types.RightParenthesis, "-"],
      ]);
      function createMap(pairs) {
        const isWhiteSpaceRequired = new Set(
          pairs.map(([prev, next]) => (code(prev) << 16) | code(next)),
        );
        return function (prevCode, type, value) {
          const nextCode = code(type, value);
          const nextCharCode = value.charCodeAt(0);
          const emitWs =
            (nextCharCode === HYPHENMINUS &&
              type !== types.Ident &&
              type !== types.Function &&
              type !== types.CDC) ||
            nextCharCode === PLUSSIGN
              ? isWhiteSpaceRequired.has((prevCode << 16) | (nextCharCode << 8))
              : isWhiteSpaceRequired.has((prevCode << 16) | nextCode);
          if (emitWs) {
            this.emit(" ", types.WhiteSpace, true);
          }
          return nextCode;
        };
      }
      const spec = createMap(specPairs);
      const safe = createMap(safePairs);
      exports.safe = safe;
      exports.spec = spec;
    },
    4884: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const index$1 = __nccwpck_require__(454);
      const version = __nccwpck_require__(423);
      const create = __nccwpck_require__(5958);
      const List = __nccwpck_require__(3681);
      const Lexer = __nccwpck_require__(6522);
      const index = __nccwpck_require__(394);
      const clone = __nccwpck_require__(5250);
      const names$1 = __nccwpck_require__(627);
      const ident = __nccwpck_require__(5286);
      const string = __nccwpck_require__(7688);
      const url = __nccwpck_require__(9056);
      const types = __nccwpck_require__(7783);
      const names = __nccwpck_require__(7755);
      const TokenStream = __nccwpck_require__(7978);
      const {
        tokenize,
        parse,
        generate,
        lexer,
        createLexer,
        walk,
        find,
        findLast,
        findAll,
        toPlainObject,
        fromPlainObject,
        fork,
      } = index$1;
      exports.version = version.version;
      exports.createSyntax = create;
      exports.List = List.List;
      exports.Lexer = Lexer.Lexer;
      exports.definitionSyntax = index;
      exports.clone = clone.clone;
      exports.isCustomProperty = names$1.isCustomProperty;
      exports.keyword = names$1.keyword;
      exports.property = names$1.property;
      exports.vendorPrefix = names$1.vendorPrefix;
      exports.ident = ident;
      exports.string = string;
      exports.url = url;
      exports.tokenTypes = types;
      exports.tokenNames = names;
      exports.TokenStream = TokenStream.TokenStream;
      exports.createLexer = createLexer;
      exports.find = find;
      exports.findAll = findAll;
      exports.findLast = findLast;
      exports.fork = fork;
      exports.fromPlainObject = fromPlainObject;
      exports.generate = generate;
      exports.lexer = lexer;
      exports.parse = parse;
      exports.toPlainObject = toPlainObject;
      exports.tokenize = tokenize;
      exports.walk = walk;
    },
    6522: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const error = __nccwpck_require__(9002);
      const names = __nccwpck_require__(627);
      const genericConst = __nccwpck_require__(5728);
      const generic = __nccwpck_require__(7030);
      const prepareTokens = __nccwpck_require__(1630);
      const matchGraph = __nccwpck_require__(2856);
      const match = __nccwpck_require__(9738);
      const trace = __nccwpck_require__(4574);
      const search = __nccwpck_require__(5444);
      const structure = __nccwpck_require__(1424);
      const parse = __nccwpck_require__(3108);
      const generate = __nccwpck_require__(6709);
      const walk = __nccwpck_require__(4433);
      const cssWideKeywordsSyntax = matchGraph.buildMatchGraph(
        genericConst.cssWideKeywords.join(" | "),
      );
      function dumpMapSyntax(map, compact, syntaxAsAst) {
        const result = {};
        for (const name in map) {
          if (map[name].syntax) {
            result[name] = syntaxAsAst
              ? map[name].syntax
              : generate.generate(map[name].syntax, { compact });
          }
        }
        return result;
      }
      function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
        const result = {};
        for (const [name, atrule] of Object.entries(map)) {
          result[name] = {
            prelude:
              atrule.prelude &&
              (syntaxAsAst
                ? atrule.prelude.syntax
                : generate.generate(atrule.prelude.syntax, { compact })),
            descriptors:
              atrule.descriptors &&
              dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst),
          };
        }
        return result;
      }
      function valueHasVar(tokens) {
        for (let i = 0; i < tokens.length; i++) {
          if (tokens[i].value.toLowerCase() === "var(") {
            return true;
          }
        }
        return false;
      }
      function buildMatchResult(matched, error, iterations) {
        return { matched, iterations, error, ...trace };
      }
      function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
        const tokens = prepareTokens(value, lexer.syntax);
        let result;
        if (valueHasVar(tokens)) {
          return buildMatchResult(
            null,
            new Error("Matching for a tree with var() is not supported"),
          );
        }
        if (useCssWideKeywords) {
          result = match.matchAsTree(
            tokens,
            lexer.cssWideKeywordsSyntax,
            lexer,
          );
        }
        if (!useCssWideKeywords || !result.match) {
          result = match.matchAsTree(tokens, syntax.match, lexer);
          if (!result.match) {
            return buildMatchResult(
              null,
              new error.SyntaxMatchError(
                result.reason,
                syntax.syntax,
                value,
                result,
              ),
              result.iterations,
            );
          }
        }
        return buildMatchResult(result.match, null, result.iterations);
      }
      class Lexer {
        constructor(config, syntax, structure$1) {
          this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
          this.syntax = syntax;
          this.generic = false;
          this.atrules = Object.create(null);
          this.properties = Object.create(null);
          this.types = Object.create(null);
          this.structure =
            structure$1 || structure.getStructureFromConfig(config);
          if (config) {
            if (config.types) {
              for (const name in config.types) {
                this.addType_(name, config.types[name]);
              }
            }
            if (config.generic) {
              this.generic = true;
              for (const name in generic) {
                this.addType_(name, generic[name]);
              }
            }
            if (config.atrules) {
              for (const name in config.atrules) {
                this.addAtrule_(name, config.atrules[name]);
              }
            }
            if (config.properties) {
              for (const name in config.properties) {
                this.addProperty_(name, config.properties[name]);
              }
            }
          }
        }
        checkStructure(ast) {
          function collectWarning(node, message) {
            warns.push({ node, message });
          }
          const structure = this.structure;
          const warns = [];
          this.syntax.walk(ast, function (node) {
            if (structure.hasOwnProperty(node.type)) {
              structure[node.type].check(node, collectWarning);
            } else {
              collectWarning(node, "Unknown node type `" + node.type + "`");
            }
          });
          return warns.length ? warns : false;
        }
        createDescriptor(syntax, type, name, parent = null) {
          const ref = { type, name };
          const descriptor = {
            type,
            name,
            parent,
            serializable:
              typeof syntax === "string" ||
              (syntax && typeof syntax.type === "string"),
            syntax: null,
            match: null,
          };
          if (typeof syntax === "function") {
            descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
          } else {
            if (typeof syntax === "string") {
              Object.defineProperty(descriptor, "syntax", {
                get() {
                  Object.defineProperty(descriptor, "syntax", {
                    value: parse.parse(syntax),
                  });
                  return descriptor.syntax;
                },
              });
            } else {
              descriptor.syntax = syntax;
            }
            Object.defineProperty(descriptor, "match", {
              get() {
                Object.defineProperty(descriptor, "match", {
                  value: matchGraph.buildMatchGraph(descriptor.syntax, ref),
                });
                return descriptor.match;
              },
            });
          }
          return descriptor;
        }
        addAtrule_(name, syntax) {
          if (!syntax) {
            return;
          }
          this.atrules[name] = {
            type: "Atrule",
            name,
            prelude: syntax.prelude
              ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name)
              : null,
            descriptors: syntax.descriptors
              ? Object.keys(syntax.descriptors).reduce((map, descName) => {
                  map[descName] = this.createDescriptor(
                    syntax.descriptors[descName],
                    "AtruleDescriptor",
                    descName,
                    name,
                  );
                  return map;
                }, Object.create(null))
              : null,
          };
        }
        addProperty_(name, syntax) {
          if (!syntax) {
            return;
          }
          this.properties[name] = this.createDescriptor(
            syntax,
            "Property",
            name,
          );
        }
        addType_(name, syntax) {
          if (!syntax) {
            return;
          }
          this.types[name] = this.createDescriptor(syntax, "Type", name);
        }
        checkAtruleName(atruleName) {
          if (!this.getAtrule(atruleName)) {
            return new error.SyntaxReferenceError(
              "Unknown at-rule",
              "@" + atruleName,
            );
          }
        }
        checkAtrulePrelude(atruleName, prelude) {
          const error = this.checkAtruleName(atruleName);
          if (error) {
            return error;
          }
          const atrule = this.getAtrule(atruleName);
          if (!atrule.prelude && prelude) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` should not contain a prelude",
            );
          }
          if (atrule.prelude && !prelude) {
            if (!matchSyntax(this, atrule.prelude, "", false).matched) {
              return new SyntaxError(
                "At-rule `@" + atruleName + "` should contain a prelude",
              );
            }
          }
        }
        checkAtruleDescriptorName(atruleName, descriptorName) {
          const error$1 = this.checkAtruleName(atruleName);
          if (error$1) {
            return error$1;
          }
          const atrule = this.getAtrule(atruleName);
          const descriptor = names.keyword(descriptorName);
          if (!atrule.descriptors) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` has no known descriptors",
            );
          }
          if (
            !atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]
          ) {
            return new error.SyntaxReferenceError(
              "Unknown at-rule descriptor",
              descriptorName,
            );
          }
        }
        checkPropertyName(propertyName) {
          if (!this.getProperty(propertyName)) {
            return new error.SyntaxReferenceError(
              "Unknown property",
              propertyName,
            );
          }
        }
        matchAtrulePrelude(atruleName, prelude) {
          const error = this.checkAtrulePrelude(atruleName, prelude);
          if (error) {
            return buildMatchResult(null, error);
          }
          const atrule = this.getAtrule(atruleName);
          if (!atrule.prelude) {
            return buildMatchResult(null, null);
          }
          return matchSyntax(this, atrule.prelude, prelude || "", false);
        }
        matchAtruleDescriptor(atruleName, descriptorName, value) {
          const error = this.checkAtruleDescriptorName(
            atruleName,
            descriptorName,
          );
          if (error) {
            return buildMatchResult(null, error);
          }
          const atrule = this.getAtrule(atruleName);
          const descriptor = names.keyword(descriptorName);
          return matchSyntax(
            this,
            atrule.descriptors[descriptor.name] ||
              atrule.descriptors[descriptor.basename],
            value,
            false,
          );
        }
        matchDeclaration(node) {
          if (node.type !== "Declaration") {
            return buildMatchResult(null, new Error("Not a Declaration node"));
          }
          return this.matchProperty(node.property, node.value);
        }
        matchProperty(propertyName, value) {
          if (names.property(propertyName).custom) {
            return buildMatchResult(
              null,
              new Error(
                "Lexer matching doesn't applicable for custom properties",
              ),
            );
          }
          const error = this.checkPropertyName(propertyName);
          if (error) {
            return buildMatchResult(null, error);
          }
          return matchSyntax(this, this.getProperty(propertyName), value, true);
        }
        matchType(typeName, value) {
          const typeSyntax = this.getType(typeName);
          if (!typeSyntax) {
            return buildMatchResult(
              null,
              new error.SyntaxReferenceError("Unknown type", typeName),
            );
          }
          return matchSyntax(this, typeSyntax, value, false);
        }
        match(syntax, value) {
          if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
            return buildMatchResult(
              null,
              new error.SyntaxReferenceError("Bad syntax"),
            );
          }
          if (typeof syntax === "string" || !syntax.match) {
            syntax = this.createDescriptor(syntax, "Type", "anonymous");
          }
          return matchSyntax(this, syntax, value, false);
        }
        findValueFragments(propertyName, value, type, name) {
          return search.matchFragments(
            this,
            value,
            this.matchProperty(propertyName, value),
            type,
            name,
          );
        }
        findDeclarationValueFragments(declaration, type, name) {
          return search.matchFragments(
            this,
            declaration.value,
            this.matchDeclaration(declaration),
            type,
            name,
          );
        }
        findAllFragments(ast, type, name) {
          const result = [];
          this.syntax.walk(ast, {
            visit: "Declaration",
            enter: (declaration) => {
              result.push.apply(
                result,
                this.findDeclarationValueFragments(declaration, type, name),
              );
            },
          });
          return result;
        }
        getAtrule(atruleName, fallbackBasename = true) {
          const atrule = names.keyword(atruleName);
          const atruleEntry =
            atrule.vendor && fallbackBasename
              ? this.atrules[atrule.name] || this.atrules[atrule.basename]
              : this.atrules[atrule.name];
          return atruleEntry || null;
        }
        getAtrulePrelude(atruleName, fallbackBasename = true) {
          const atrule = this.getAtrule(atruleName, fallbackBasename);
          return (atrule && atrule.prelude) || null;
        }
        getAtruleDescriptor(atruleName, name) {
          return this.atrules.hasOwnProperty(atruleName) &&
            this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
        }
        getProperty(propertyName, fallbackBasename = true) {
          const property = names.property(propertyName);
          const propertyEntry =
            property.vendor && fallbackBasename
              ? this.properties[property.name] ||
                this.properties[property.basename]
              : this.properties[property.name];
          return propertyEntry || null;
        }
        getType(name) {
          return hasOwnProperty.call(this.types, name)
            ? this.types[name]
            : null;
        }
        validate() {
          function validate(syntax, name, broken, descriptor) {
            if (broken.has(name)) {
              return broken.get(name);
            }
            broken.set(name, false);
            if (descriptor.syntax !== null) {
              walk.walk(
                descriptor.syntax,
                function (node) {
                  if (node.type !== "Type" && node.type !== "Property") {
                    return;
                  }
                  const map =
                    node.type === "Type" ? syntax.types : syntax.properties;
                  const brokenMap =
                    node.type === "Type" ? brokenTypes : brokenProperties;
                  if (
                    !hasOwnProperty.call(map, node.name) ||
                    validate(syntax, node.name, brokenMap, map[node.name])
                  ) {
                    broken.set(name, true);
                  }
                },
                this,
              );
            }
          }
          let brokenTypes = new Map();
          let brokenProperties = new Map();
          for (const key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
          }
          for (const key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
          }
          brokenTypes = [...brokenTypes.keys()].filter((name) =>
            brokenTypes.get(name),
          );
          brokenProperties = [...brokenProperties.keys()].filter((name) =>
            brokenProperties.get(name),
          );
          if (brokenTypes.length || brokenProperties.length) {
            return { types: brokenTypes, properties: brokenProperties };
          }
          return null;
        }
        dump(syntaxAsAst, pretty) {
          return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst),
          };
        }
        toString() {
          return JSON.stringify(this.dump());
        }
      }
      exports.Lexer = Lexer;
    },
    9002: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const createCustomError = __nccwpck_require__(6893);
      const generate = __nccwpck_require__(6709);
      const defaultLoc = { offset: 0, line: 1, column: 1 };
      function locateMismatch(matchResult, node) {
        const tokens = matchResult.tokens;
        const longestMatch = matchResult.longestMatch;
        const mismatchNode =
          longestMatch < tokens.length
            ? tokens[longestMatch].node || null
            : null;
        const badNode = mismatchNode !== node ? mismatchNode : null;
        let mismatchOffset = 0;
        let mismatchLength = 0;
        let entries = 0;
        let css = "";
        let start;
        let end;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i].value;
          if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
          }
          if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
              entries++;
            } else {
              entries = 0;
            }
          }
          css += token;
        }
        if (longestMatch === tokens.length || entries > 1) {
          start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
          end = buildLoc(start);
        } else {
          start =
            fromLoc(badNode, "start") ||
            buildLoc(
              fromLoc(node, "start") || defaultLoc,
              css.slice(0, mismatchOffset),
            );
          end =
            fromLoc(badNode, "end") ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
        }
        return { css, mismatchOffset, mismatchLength, start, end };
      }
      function fromLoc(node, point) {
        const value = node && node.loc && node.loc[point];
        if (value) {
          return "line" in value ? buildLoc(value) : value;
        }
        return null;
      }
      function buildLoc({ offset, line, column }, extra) {
        const loc = { offset, line, column };
        if (extra) {
          const lines = extra.split(/\n|\r\n?|\f/);
          loc.offset += extra.length;
          loc.line += lines.length - 1;
          loc.column =
            lines.length === 1
              ? loc.column + extra.length
              : lines.pop().length + 1;
        }
        return loc;
      }
      const SyntaxReferenceError = function (type, referenceName) {
        const error = createCustomError.createCustomError(
          "SyntaxReferenceError",
          type + (referenceName ? " `" + referenceName + "`" : ""),
        );
        error.reference = referenceName;
        return error;
      };
      const SyntaxMatchError = function (message, syntax, node, matchResult) {
        const error = createCustomError.createCustomError(
          "SyntaxMatchError",
          message,
        );
        const { css, mismatchOffset, mismatchLength, start, end } =
          locateMismatch(matchResult, node);
        error.rawMessage = message;
        error.syntax = syntax ? generate.generate(syntax) : "<generic>";
        error.css = css;
        error.mismatchOffset = mismatchOffset;
        error.mismatchLength = mismatchLength;
        error.message =
          message +
          "\n" +
          "  syntax: " +
          error.syntax +
          "\n" +
          "   value: " +
          (css || "<empty string>") +
          "\n" +
          "  --------" +
          new Array(error.mismatchOffset + 1).join("-") +
          "^";
        Object.assign(error, start);
        error.loc = {
          source: (node && node.loc && node.loc.source) || "<unknown>",
          start,
          end,
        };
        return error;
      };
      exports.SyntaxMatchError = SyntaxMatchError;
      exports.SyntaxReferenceError = SyntaxReferenceError;
    },
    8223: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(7332);
      const types = __nccwpck_require__(7783);
      const utils = __nccwpck_require__(2850);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const N = 110;
      const DISALLOW_SIGN = true;
      const ALLOW_SIGN = false;
      function isDelim(token, code) {
        return (
          token !== null &&
          token.type === types.Delim &&
          token.value.charCodeAt(0) === code
        );
      }
      function skipSC(token, offset, getNextToken) {
        while (
          token !== null &&
          (token.type === types.WhiteSpace || token.type === types.Comment)
        ) {
          token = getNextToken(++offset);
        }
        return offset;
      }
      function checkInteger(token, valueOffset, disallowSign, offset) {
        if (!token) {
          return 0;
        }
        const code = token.value.charCodeAt(valueOffset);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            return 0;
          }
          valueOffset++;
        }
        for (; valueOffset < token.value.length; valueOffset++) {
          if (
            !charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))
          ) {
            return 0;
          }
        }
        return offset + 1;
      }
      function consumeB(token, offset_, getNextToken) {
        let sign = false;
        let offset = skipSC(token, offset_, getNextToken);
        token = getNextToken(offset);
        if (token === null) {
          return offset_;
        }
        if (token.type !== types.Number) {
          if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            if (token === null || token.type !== types.Number) {
              return 0;
            }
          } else {
            return offset_;
          }
        }
        if (!sign) {
          const code = token.value.charCodeAt(0);
          if (code !== PLUSSIGN && code !== HYPHENMINUS) {
            return 0;
          }
        }
        return checkInteger(token, sign ? 0 : 1, sign, offset);
      }
      function anPlusB(token, getNextToken) {
        let offset = 0;
        if (!token) {
          return 0;
        }
        if (token.type === types.Number) {
          return checkInteger(token, 0, ALLOW_SIGN, offset);
        } else if (
          token.type === types.Ident &&
          token.value.charCodeAt(0) === HYPHENMINUS
        ) {
          if (!utils.cmpChar(token.value, 1, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 2:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 3:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 3, DISALLOW_SIGN, offset);
          }
        } else if (
          token.type === types.Ident ||
          (isDelim(token, PLUSSIGN) &&
            getNextToken(offset + 1).type === types.Ident)
        ) {
          if (token.type !== types.Ident) {
            token = getNextToken(++offset);
          }
          if (token === null || !utils.cmpChar(token.value, 0, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 1:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 2:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 2, DISALLOW_SIGN, offset);
          }
        } else if (token.type === types.Dimension) {
          let code = token.value.charCodeAt(0);
          let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
          let i = sign;
          for (; i < token.value.length; i++) {
            if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
              break;
            }
          }
          if (i === sign) {
            return 0;
          }
          if (!utils.cmpChar(token.value, i, N)) {
            return 0;
          }
          if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
          } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
              return 0;
            }
            if (i + 2 === token.value.length) {
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            } else {
              return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
          }
        }
        return 0;
      }
      module.exports = anPlusB;
    },
    5728: (__unused_webpack_module, exports) => {
      "use strict";
      const cssWideKeywords = [
        "initial",
        "inherit",
        "unset",
        "revert",
        "revert-layer",
      ];
      exports.cssWideKeywords = cssWideKeywords;
    },
    4622: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(7332);
      const types = __nccwpck_require__(7783);
      const utils = __nccwpck_require__(2850);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const QUESTIONMARK = 63;
      const U = 117;
      function isDelim(token, code) {
        return (
          token !== null &&
          token.type === types.Delim &&
          token.value.charCodeAt(0) === code
        );
      }
      function startsWith(token, code) {
        return token.value.charCodeAt(0) === code;
      }
      function hexSequence(token, offset, allowDash) {
        let hexlen = 0;
        for (let pos = offset; pos < token.value.length; pos++) {
          const code = token.value.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
            hexSequence(token, offset + hexlen + 1, false);
            return 6;
          }
          if (!charCodeDefinitions.isHexDigit(code)) {
            return 0;
          }
          if (++hexlen > 6) {
            return 0;
          }
        }
        return hexlen;
      }
      function withQuestionMarkSequence(consumed, length, getNextToken) {
        if (!consumed) {
          return 0;
        }
        while (isDelim(getNextToken(length), QUESTIONMARK)) {
          if (++consumed > 6) {
            return 0;
          }
          length++;
        }
        return length;
      }
      function urange(token, getNextToken) {
        let length = 0;
        if (
          token === null ||
          token.type !== types.Ident ||
          !utils.cmpChar(token.value, 0, U)
        ) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (isDelim(token, PLUSSIGN)) {
          token = getNextToken(++length);
          if (token === null) {
            return 0;
          }
          if (token.type === types.Ident) {
            return withQuestionMarkSequence(
              hexSequence(token, 0, true),
              ++length,
              getNextToken,
            );
          }
          if (isDelim(token, QUESTIONMARK)) {
            return withQuestionMarkSequence(1, ++length, getNextToken);
          }
          return 0;
        }
        if (token.type === types.Number) {
          const consumedHexLength = hexSequence(token, 1, true);
          if (consumedHexLength === 0) {
            return 0;
          }
          token = getNextToken(++length);
          if (token === null) {
            return length;
          }
          if (token.type === types.Dimension || token.type === types.Number) {
            if (
              !startsWith(token, HYPHENMINUS) ||
              !hexSequence(token, 1, false)
            ) {
              return 0;
            }
            return length + 1;
          }
          return withQuestionMarkSequence(
            consumedHexLength,
            length,
            getNextToken,
          );
        }
        if (token.type === types.Dimension) {
          return withQuestionMarkSequence(
            hexSequence(token, 1, true),
            ++length,
            getNextToken,
          );
        }
        return 0;
      }
      module.exports = urange;
    },
    7030: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const genericConst = __nccwpck_require__(5728);
      const genericAnPlusB = __nccwpck_require__(8223);
      const genericUrange = __nccwpck_require__(4622);
      const types = __nccwpck_require__(7783);
      const charCodeDefinitions = __nccwpck_require__(7332);
      const utils = __nccwpck_require__(2850);
      const calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
      const balancePair = new Map([
        [types.Function, types.RightParenthesis],
        [types.LeftParenthesis, types.RightParenthesis],
        [types.LeftSquareBracket, types.RightSquareBracket],
        [types.LeftCurlyBracket, types.RightCurlyBracket],
      ]);
      const LENGTH = [
        "cm",
        "mm",
        "q",
        "in",
        "pt",
        "pc",
        "px",
        "em",
        "rem",
        "ex",
        "rex",
        "cap",
        "rcap",
        "ch",
        "rch",
        "ic",
        "ric",
        "lh",
        "rlh",
        "vw",
        "svw",
        "lvw",
        "dvw",
        "vh",
        "svh",
        "lvh",
        "dvh",
        "vi",
        "svi",
        "lvi",
        "dvi",
        "vb",
        "svb",
        "lvb",
        "dvb",
        "vmin",
        "svmin",
        "lvmin",
        "dvmin",
        "vmax",
        "svmax",
        "lvmax",
        "dvmax",
        "cqw",
        "cqh",
        "cqi",
        "cqb",
        "cqmin",
        "cqmax",
      ];
      const ANGLE = ["deg", "grad", "rad", "turn"];
      const TIME = ["s", "ms"];
      const FREQUENCY = ["hz", "khz"];
      const RESOLUTION = ["dpi", "dpcm", "dppx", "x"];
      const FLEX = ["fr"];
      const DECIBEL = ["db"];
      const SEMITONES = ["st"];
      function charCodeAt(str, index) {
        return index < str.length ? str.charCodeAt(index) : 0;
      }
      function eqStr(actual, expected) {
        return utils.cmpStr(actual, 0, actual.length, expected);
      }
      function eqStrAny(actual, expected) {
        for (let i = 0; i < expected.length; i++) {
          if (eqStr(actual, expected[i])) {
            return true;
          }
        }
        return false;
      }
      function isPostfixIeHack(str, offset) {
        if (offset !== str.length - 2) {
          return false;
        }
        return (
          charCodeAt(str, offset) === 92 &&
          charCodeDefinitions.isDigit(charCodeAt(str, offset + 1))
        );
      }
      function outOfRange(opts, value, numEnd) {
        if (opts && opts.type === "Range") {
          const num = Number(
            numEnd !== undefined && numEnd !== value.length
              ? value.substr(0, numEnd)
              : value,
          );
          if (isNaN(num)) {
            return true;
          }
          if (
            opts.min !== null &&
            num < opts.min &&
            typeof opts.min !== "string"
          ) {
            return true;
          }
          if (
            opts.max !== null &&
            num > opts.max &&
            typeof opts.max !== "string"
          ) {
            return true;
          }
        }
        return false;
      }
      function consumeFunction(token, getNextToken) {
        let balanceCloseType = 0;
        let balanceStash = [];
        let length = 0;
        scan: do {
          switch (token.type) {
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              if (balanceStash.length === 0) {
                length++;
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while ((token = getNextToken(length)));
        return length;
      }
      function calc(next) {
        return function (token, getNextToken, opts) {
          if (token === null) {
            return 0;
          }
          if (
            token.type === types.Function &&
            eqStrAny(token.value, calcFunctionNames)
          ) {
            return consumeFunction(token, getNextToken);
          }
          return next(token, getNextToken, opts);
        };
      }
      function tokenType(expectedTokenType) {
        return function (token) {
          if (token === null || token.type !== expectedTokenType) {
            return 0;
          }
          return 1;
        };
      }
      function customIdent(token) {
        if (token === null || token.type !== types.Ident) {
          return 0;
        }
        const name = token.value.toLowerCase();
        if (eqStrAny(name, genericConst.cssWideKeywords)) {
          return 0;
        }
        if (eqStr(name, "default")) {
          return 0;
        }
        return 1;
      }
      function customPropertyName(token) {
        if (token === null || token.type !== types.Ident) {
          return 0;
        }
        if (
          charCodeAt(token.value, 0) !== 45 ||
          charCodeAt(token.value, 1) !== 45
        ) {
          return 0;
        }
        return 1;
      }
      function hexColor(token) {
        if (token === null || token.type !== types.Hash) {
          return 0;
        }
        const length = token.value.length;
        if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
          return 0;
        }
        for (let i = 1; i < length; i++) {
          if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
            return 0;
          }
        }
        return 1;
      }
      function idSelector(token) {
        if (token === null || token.type !== types.Hash) {
          return 0;
        }
        if (
          !charCodeDefinitions.isIdentifierStart(
            charCodeAt(token.value, 1),
            charCodeAt(token.value, 2),
            charCodeAt(token.value, 3),
          )
        ) {
          return 0;
        }
        return 1;
      }
      function declarationValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        let balanceCloseType = 0;
        let balanceStash = [];
        let length = 0;
        scan: do {
          switch (token.type) {
            case types.BadString:
            case types.BadUrl:
              break scan;
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Semicolon:
              if (balanceCloseType === 0) {
                break scan;
              }
              break;
            case types.Delim:
              if (balanceCloseType === 0 && token.value === "!") {
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while ((token = getNextToken(length)));
        return length;
      }
      function anyValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        let balanceCloseType = 0;
        let balanceStash = [];
        let length = 0;
        scan: do {
          switch (token.type) {
            case types.BadString:
            case types.BadUrl:
              break scan;
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while ((token = getNextToken(length)));
        return length;
      }
      function dimension(type) {
        if (type) {
          type = new Set(type);
        }
        return function (token, getNextToken, opts) {
          if (token === null || token.type !== types.Dimension) {
            return 0;
          }
          const numberEnd = utils.consumeNumber(token.value, 0);
          if (type !== null) {
            const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
            const unit =
              reverseSolidusOffset === -1 ||
              !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);
            if (type.has(unit.toLowerCase()) === false) {
              return 0;
            }
          }
          if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
          }
          return 1;
        };
      }
      function percentage(token, getNextToken, opts) {
        if (token === null || token.type !== types.Percentage) {
          return 0;
        }
        if (outOfRange(opts, token.value, token.value.length - 1)) {
          return 0;
        }
        return 1;
      }
      function zero(next) {
        if (typeof next !== "function") {
          next = function () {
            return 0;
          };
        }
        return function (token, getNextToken, opts) {
          if (token !== null && token.type === types.Number) {
            if (Number(token.value) === 0) {
              return 1;
            }
          }
          return next(token, getNextToken, opts);
        };
      }
      function number(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        const numberEnd = utils.consumeNumber(token.value, 0);
        const isNumber = numberEnd === token.value.length;
        if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
          return 0;
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      }
      function integer(token, getNextToken, opts) {
        if (token === null || token.type !== types.Number) {
          return 0;
        }
        let i =
          charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45
            ? 1
            : 0;
        for (; i < token.value.length; i++) {
          if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, i)) {
          return 0;
        }
        return 1;
      }
      const genericSyntaxes = {
        "ident-token": tokenType(types.Ident),
        "function-token": tokenType(types.Function),
        "at-keyword-token": tokenType(types.AtKeyword),
        "hash-token": tokenType(types.Hash),
        "string-token": tokenType(types.String),
        "bad-string-token": tokenType(types.BadString),
        "url-token": tokenType(types.Url),
        "bad-url-token": tokenType(types.BadUrl),
        "delim-token": tokenType(types.Delim),
        "number-token": tokenType(types.Number),
        "percentage-token": tokenType(types.Percentage),
        "dimension-token": tokenType(types.Dimension),
        "whitespace-token": tokenType(types.WhiteSpace),
        "CDO-token": tokenType(types.CDO),
        "CDC-token": tokenType(types.CDC),
        "colon-token": tokenType(types.Colon),
        "semicolon-token": tokenType(types.Semicolon),
        "comma-token": tokenType(types.Comma),
        "[-token": tokenType(types.LeftSquareBracket),
        "]-token": tokenType(types.RightSquareBracket),
        "(-token": tokenType(types.LeftParenthesis),
        ")-token": tokenType(types.RightParenthesis),
        "{-token": tokenType(types.LeftCurlyBracket),
        "}-token": tokenType(types.RightCurlyBracket),
        string: tokenType(types.String),
        ident: tokenType(types.Ident),
        "custom-ident": customIdent,
        "custom-property-name": customPropertyName,
        "hex-color": hexColor,
        "id-selector": idSelector,
        "an-plus-b": genericAnPlusB,
        urange: genericUrange,
        "declaration-value": declarationValue,
        "any-value": anyValue,
        dimension: calc(dimension(null)),
        angle: calc(dimension(ANGLE)),
        decibel: calc(dimension(DECIBEL)),
        frequency: calc(dimension(FREQUENCY)),
        flex: calc(dimension(FLEX)),
        length: calc(zero(dimension(LENGTH))),
        resolution: calc(dimension(RESOLUTION)),
        semitones: calc(dimension(SEMITONES)),
        time: calc(dimension(TIME)),
        percentage: calc(percentage),
        zero: zero(),
        number: calc(number),
        integer: calc(integer),
      };
      module.exports = genericSyntaxes;
    },
    2856: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const parse = __nccwpck_require__(3108);
      const MATCH = { type: "Match" };
      const MISMATCH = { type: "Mismatch" };
      const DISALLOW_EMPTY = { type: "DisallowEmpty" };
      const LEFTPARENTHESIS = 40;
      const RIGHTPARENTHESIS = 41;
      function createCondition(match, thenBranch, elseBranch) {
        if (thenBranch === MATCH && elseBranch === MISMATCH) {
          return match;
        }
        if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
          return match;
        }
        if (
          match.type === "If" &&
          match.else === MISMATCH &&
          thenBranch === MATCH
        ) {
          thenBranch = match.then;
          match = match.match;
        }
        return { type: "If", match, then: thenBranch, else: elseBranch };
      }
      function isFunctionType(name) {
        return (
          name.length > 2 &&
          name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
          name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
        );
      }
      function isEnumCapatible(term) {
        return (
          term.type === "Keyword" ||
          term.type === "AtKeyword" ||
          term.type === "Function" ||
          (term.type === "Type" && isFunctionType(term.name))
        );
      }
      function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
        switch (combinator) {
          case " ": {
            let result = MATCH;
            for (let i = terms.length - 1; i >= 0; i--) {
              const term = terms[i];
              result = createCondition(term, result, MISMATCH);
            }
            return result;
          }
          case "|": {
            let result = MISMATCH;
            let map = null;
            for (let i = terms.length - 1; i >= 0; i--) {
              let term = terms[i];
              if (isEnumCapatible(term)) {
                if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                  map = Object.create(null);
                  result = createCondition(
                    { type: "Enum", map },
                    MATCH,
                    result,
                  );
                }
                if (map !== null) {
                  const key = (
                    isFunctionType(term.name)
                      ? term.name.slice(0, -1)
                      : term.name
                  ).toLowerCase();
                  if (key in map === false) {
                    map[key] = term;
                    continue;
                  }
                }
              }
              map = null;
              result = createCondition(term, MATCH, result);
            }
            return result;
          }
          case "&&": {
            if (terms.length > 5) {
              return { type: "MatchOnce", terms, all: true };
            }
            let result = MISMATCH;
            for (let i = terms.length - 1; i >= 0; i--) {
              const term = terms[i];
              let thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function (newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  false,
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(term, thenClause, result);
            }
            return result;
          }
          case "||": {
            if (terms.length > 5) {
              return { type: "MatchOnce", terms, all: false };
            }
            let result = atLeastOneTermMatched ? MATCH : MISMATCH;
            for (let i = terms.length - 1; i >= 0; i--) {
              const term = terms[i];
              let thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function (newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  true,
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(term, thenClause, result);
            }
            return result;
          }
        }
      }
      function buildMultiplierMatchGraph(node) {
        let result = MATCH;
        let matchTerm = buildMatchGraphInternal(node.term);
        if (node.max === 0) {
          matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
          result = createCondition(matchTerm, null, MISMATCH);
          result.then = createCondition(MATCH, MATCH, result);
          if (node.comma) {
            result.then.else = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH,
            );
          }
        } else {
          for (let i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH,
              );
            }
            result = createCondition(
              matchTerm,
              createCondition(MATCH, MATCH, result),
              MISMATCH,
            );
          }
        }
        if (node.min === 0) {
          result = createCondition(MATCH, MATCH, result);
        } else {
          for (let i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH,
              );
            }
            result = createCondition(matchTerm, result, MISMATCH);
          }
        }
        return result;
      }
      function buildMatchGraphInternal(node) {
        if (typeof node === "function") {
          return { type: "Generic", fn: node };
        }
        switch (node.type) {
          case "Group": {
            let result = buildGroupMatchGraph(
              node.combinator,
              node.terms.map(buildMatchGraphInternal),
              false,
            );
            if (node.disallowEmpty) {
              result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
            }
            return result;
          }
          case "Multiplier":
            return buildMultiplierMatchGraph(node);
          case "Type":
          case "Property":
            return { type: node.type, name: node.name, syntax: node };
          case "Keyword":
            return {
              type: node.type,
              name: node.name.toLowerCase(),
              syntax: node,
            };
          case "AtKeyword":
            return {
              type: node.type,
              name: "@" + node.name.toLowerCase(),
              syntax: node,
            };
          case "Function":
            return {
              type: node.type,
              name: node.name.toLowerCase() + "(",
              syntax: node,
            };
          case "String":
            if (node.value.length === 3) {
              return {
                type: "Token",
                value: node.value.charAt(1),
                syntax: node,
              };
            }
            return {
              type: node.type,
              value: node.value
                .substr(1, node.value.length - 2)
                .replace(/\\'/g, "'"),
              syntax: node,
            };
          case "Token":
            return { type: node.type, value: node.value, syntax: node };
          case "Comma":
            return { type: node.type, syntax: node };
          default:
            throw new Error("Unknown node type:", node.type);
        }
      }
      function buildMatchGraph(syntaxTree, ref) {
        if (typeof syntaxTree === "string") {
          syntaxTree = parse.parse(syntaxTree);
        }
        return {
          type: "MatchGraph",
          match: buildMatchGraphInternal(syntaxTree),
          syntax: ref || null,
          source: syntaxTree,
        };
      }
      exports.DISALLOW_EMPTY = DISALLOW_EMPTY;
      exports.MATCH = MATCH;
      exports.MISMATCH = MISMATCH;
      exports.buildMatchGraph = buildMatchGraph;
    },
    9738: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const matchGraph = __nccwpck_require__(2856);
      const types = __nccwpck_require__(7783);
      const { hasOwnProperty } = Object.prototype;
      const STUB = 0;
      const TOKEN = 1;
      const OPEN_SYNTAX = 2;
      const CLOSE_SYNTAX = 3;
      const EXIT_REASON_MATCH = "Match";
      const EXIT_REASON_MISMATCH = "Mismatch";
      const EXIT_REASON_ITERATION_LIMIT =
        "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
      const ITERATION_LIMIT = 15e3;
      function reverseList(list) {
        let prev = null;
        let next = null;
        let item = list;
        while (item !== null) {
          next = item.prev;
          item.prev = prev;
          prev = item;
          item = next;
        }
        return prev;
      }
      function areStringsEqualCaseInsensitive(testStr, referenceStr) {
        if (testStr.length !== referenceStr.length) {
          return false;
        }
        for (let i = 0; i < testStr.length; i++) {
          const referenceCode = referenceStr.charCodeAt(i);
          let testCode = testStr.charCodeAt(i);
          if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function isContextEdgeDelim(token) {
        if (token.type !== types.Delim) {
          return false;
        }
        return token.value !== "?";
      }
      function isCommaContextStart(token) {
        if (token === null) {
          return true;
        }
        return (
          token.type === types.Comma ||
          token.type === types.Function ||
          token.type === types.LeftParenthesis ||
          token.type === types.LeftSquareBracket ||
          token.type === types.LeftCurlyBracket ||
          isContextEdgeDelim(token)
        );
      }
      function isCommaContextEnd(token) {
        if (token === null) {
          return true;
        }
        return (
          token.type === types.RightParenthesis ||
          token.type === types.RightSquareBracket ||
          token.type === types.RightCurlyBracket ||
          (token.type === types.Delim && token.value === "/")
        );
      }
      function internalMatch(tokens, state, syntaxes) {
        function moveToNextToken() {
          do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          } while (
            token !== null &&
            (token.type === types.WhiteSpace || token.type === types.Comment)
          );
        }
        function getNextToken(offset) {
          const nextIndex = tokenIndex + offset;
          return nextIndex < tokens.length ? tokens[nextIndex] : null;
        }
        function stateSnapshotFromSyntax(nextState, prev) {
          return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev,
          };
        }
        function pushThenStack(nextState) {
          thenStack = { nextState, matchStack, syntaxStack, prev: thenStack };
        }
        function pushElseStack(nextState) {
          elseStack = stateSnapshotFromSyntax(nextState, elseStack);
        }
        function addTokenToMatch() {
          matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token,
            prev: matchStack,
          };
          moveToNextToken();
          syntaxStash = null;
          if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
          }
        }
        function openSyntax() {
          syntaxStack = {
            syntax: state.syntax,
            opts:
              state.syntax.opts ||
              (syntaxStack !== null && syntaxStack.opts) ||
              null,
            prev: syntaxStack,
          };
          matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack,
          };
        }
        function closeSyntax() {
          if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
          } else {
            matchStack = {
              type: CLOSE_SYNTAX,
              syntax: syntaxStack.syntax,
              token: matchStack.token,
              prev: matchStack,
            };
          }
          syntaxStack = syntaxStack.prev;
        }
        let syntaxStack = null;
        let thenStack = null;
        let elseStack = null;
        let syntaxStash = null;
        let iterationCount = 0;
        let exitReason = null;
        let token = null;
        let tokenIndex = -1;
        let longestMatch = 0;
        let matchStack = { type: STUB, syntax: null, token: null, prev: null };
        moveToNextToken();
        while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
          switch (state.type) {
            case "Match":
              if (thenStack === null) {
                if (token !== null) {
                  if (
                    tokenIndex !== tokens.length - 1 ||
                    (token.value !== "\\0" && token.value !== "\\9")
                  ) {
                    state = matchGraph.MISMATCH;
                    break;
                  }
                }
                exitReason = EXIT_REASON_MATCH;
                break;
              }
              state = thenStack.nextState;
              if (state === matchGraph.DISALLOW_EMPTY) {
                if (thenStack.matchStack === matchStack) {
                  state = matchGraph.MISMATCH;
                  break;
                } else {
                  state = matchGraph.MATCH;
                }
              }
              while (thenStack.syntaxStack !== syntaxStack) {
                closeSyntax();
              }
              thenStack = thenStack.prev;
              break;
            case "Mismatch":
              if (syntaxStash !== null && syntaxStash !== false) {
                if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                  elseStack = syntaxStash;
                  syntaxStash = false;
                }
              } else if (elseStack === null) {
                exitReason = EXIT_REASON_MISMATCH;
                break;
              }
              state = elseStack.nextState;
              thenStack = elseStack.thenStack;
              syntaxStack = elseStack.syntaxStack;
              matchStack = elseStack.matchStack;
              tokenIndex = elseStack.tokenIndex;
              token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
              elseStack = elseStack.prev;
              break;
            case "MatchGraph":
              state = state.match;
              break;
            case "If":
              if (state.else !== matchGraph.MISMATCH) {
                pushElseStack(state.else);
              }
              if (state.then !== matchGraph.MATCH) {
                pushThenStack(state.then);
              }
              state = state.match;
              break;
            case "MatchOnce":
              state = {
                type: "MatchOnceBuffer",
                syntax: state,
                index: 0,
                mask: 0,
              };
              break;
            case "MatchOnceBuffer": {
              const terms = state.syntax.terms;
              if (state.index === terms.length) {
                if (state.mask === 0 || state.syntax.all) {
                  state = matchGraph.MISMATCH;
                  break;
                }
                state = matchGraph.MATCH;
                break;
              }
              if (state.mask === (1 << terms.length) - 1) {
                state = matchGraph.MATCH;
                break;
              }
              for (; state.index < terms.length; state.index++) {
                const matchFlag = 1 << state.index;
                if ((state.mask & matchFlag) === 0) {
                  pushElseStack(state);
                  pushThenStack({
                    type: "AddMatchOnce",
                    syntax: state.syntax,
                    mask: state.mask | matchFlag,
                  });
                  state = terms[state.index++];
                  break;
                }
              }
              break;
            }
            case "AddMatchOnce":
              state = {
                type: "MatchOnceBuffer",
                syntax: state.syntax,
                index: 0,
                mask: state.mask,
              };
              break;
            case "Enum":
              if (token !== null) {
                let name = token.value.toLowerCase();
                if (name.indexOf("\\") !== -1) {
                  name = name.replace(/\\[09].*$/, "");
                }
                if (hasOwnProperty.call(state.map, name)) {
                  state = state.map[name];
                  break;
                }
              }
              state = matchGraph.MISMATCH;
              break;
            case "Generic": {
              const opts = syntaxStack !== null ? syntaxStack.opts : null;
              const lastTokenIndex =
                tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
              if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state = matchGraph.MATCH;
              } else {
                state = matchGraph.MISMATCH;
              }
              break;
            }
            case "Type":
            case "Property": {
              const syntaxDict = state.type === "Type" ? "types" : "properties";
              const dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict)
                ? syntaxes[syntaxDict][state.name]
                : null;
              if (!dictSyntax || !dictSyntax.match) {
                throw new Error(
                  "Bad syntax reference: " +
                    (state.type === "Type"
                      ? "<" + state.name + ">"
                      : "<'" + state.name + "'>"),
                );
              }
              if (
                syntaxStash !== false &&
                token !== null &&
                state.type === "Type"
              ) {
                const lowPriorityMatching =
                  (state.name === "custom-ident" &&
                    token.type === types.Ident) ||
                  (state.name === "length" && token.value === "0");
                if (lowPriorityMatching) {
                  if (syntaxStash === null) {
                    syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                  }
                  state = matchGraph.MISMATCH;
                  break;
                }
              }
              openSyntax();
              state = dictSyntax.match;
              break;
            }
            case "Keyword": {
              const name = state.name;
              if (token !== null) {
                let keywordName = token.value;
                if (keywordName.indexOf("\\") !== -1) {
                  keywordName = keywordName.replace(/\\[09].*$/, "");
                }
                if (areStringsEqualCaseInsensitive(keywordName, name)) {
                  addTokenToMatch();
                  state = matchGraph.MATCH;
                  break;
                }
              }
              state = matchGraph.MISMATCH;
              break;
            }
            case "AtKeyword":
            case "Function":
              if (
                token !== null &&
                areStringsEqualCaseInsensitive(token.value, state.name)
              ) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
              state = matchGraph.MISMATCH;
              break;
            case "Token":
              if (token !== null && token.value === state.value) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
              state = matchGraph.MISMATCH;
              break;
            case "Comma":
              if (token !== null && token.type === types.Comma) {
                if (isCommaContextStart(matchStack.token)) {
                  state = matchGraph.MISMATCH;
                } else {
                  addTokenToMatch();
                  state = isCommaContextEnd(token)
                    ? matchGraph.MISMATCH
                    : matchGraph.MATCH;
                }
              } else {
                state =
                  isCommaContextStart(matchStack.token) ||
                  isCommaContextEnd(token)
                    ? matchGraph.MATCH
                    : matchGraph.MISMATCH;
              }
              break;
            case "String":
              let string = "";
              let lastTokenIndex = tokenIndex;
              for (
                ;
                lastTokenIndex < tokens.length &&
                string.length < state.value.length;
                lastTokenIndex++
              ) {
                string += tokens[lastTokenIndex].value;
              }
              if (areStringsEqualCaseInsensitive(string, state.value)) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state = matchGraph.MATCH;
              } else {
                state = matchGraph.MISMATCH;
              }
              break;
            default:
              throw new Error("Unknown node type: " + state.type);
          }
        }
        switch (exitReason) {
          case null:
            console.warn(
              "[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations",
            );
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;
          case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
              closeSyntax();
            }
            break;
          default:
            matchStack = null;
        }
        return {
          tokens,
          reason: exitReason,
          iterations: iterationCount,
          match: matchStack,
          longestMatch,
        };
      }
      function matchAsList(tokens, matchGraph, syntaxes) {
        const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
        if (matchResult.match !== null) {
          let item = reverseList(matchResult.match).prev;
          matchResult.match = [];
          while (item !== null) {
            switch (item.type) {
              case OPEN_SYNTAX:
              case CLOSE_SYNTAX:
                matchResult.match.push({
                  type: item.type,
                  syntax: item.syntax,
                });
                break;
              default:
                matchResult.match.push({
                  token: item.token.value,
                  node: item.token.node,
                });
                break;
            }
            item = item.prev;
          }
        }
        return matchResult;
      }
      function matchAsTree(tokens, matchGraph, syntaxes) {
        const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
        if (matchResult.match === null) {
          return matchResult;
        }
        let item = matchResult.match;
        let host = (matchResult.match = {
          syntax: matchGraph.syntax || null,
          match: [],
        });
        const hostStack = [host];
        item = reverseList(item).prev;
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
              host.match.push((host = { syntax: item.syntax, match: [] }));
              hostStack.push(host);
              break;
            case CLOSE_SYNTAX:
              hostStack.pop();
              host = hostStack[hostStack.length - 1];
              break;
            default:
              host.match.push({
                syntax: item.syntax || null,
                token: item.token.value,
                node: item.token.node,
              });
          }
          item = item.prev;
        }
        return matchResult;
      }
      exports.matchAsList = matchAsList;
      exports.matchAsTree = matchAsTree;
    },
    1630: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(8008);
      const astToTokens = {
        decorator(handlers) {
          const tokens = [];
          let curNode = null;
          return {
            ...handlers,
            node(node) {
              const tmp = curNode;
              curNode = node;
              handlers.node.call(this, node);
              curNode = tmp;
            },
            emit(value, type, auto) {
              tokens.push({ type, value, node: auto ? null : curNode });
            },
            result() {
              return tokens;
            },
          };
        },
      };
      function stringToTokens(str) {
        const tokens = [];
        index.tokenize(str, (type, start, end) =>
          tokens.push({ type, value: str.slice(start, end), node: null }),
        );
        return tokens;
      }
      function prepareTokens(value, syntax) {
        if (typeof value === "string") {
          return stringToTokens(value);
        }
        return syntax.generate(value, astToTokens);
      }
      module.exports = prepareTokens;
    },
    5444: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(3681);
      function getFirstMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getFirstMatchNode(matchNode.match[0]);
      }
      function getLastMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
      }
      function matchFragments(lexer, ast, match, type, name) {
        function findFragments(matchNode) {
          if (
            matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name
          ) {
            const start = getFirstMatchNode(matchNode);
            const end = getLastMatchNode(matchNode);
            lexer.syntax.walk(ast, function (node, item, list) {
              if (node === start) {
                const nodes = new List.List();
                do {
                  nodes.appendData(item.data);
                  if (item.data === end) {
                    break;
                  }
                  item = item.next;
                } while (item !== null);
                fragments.push({ parent: list, nodes });
              }
            });
          }
          if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
          }
        }
        const fragments = [];
        if (match.matched !== null) {
          findFragments(match.matched);
        }
        return fragments;
      }
      exports.matchFragments = matchFragments;
    },
    1424: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(3681);
      const { hasOwnProperty } = Object.prototype;
      function isValidNumber(value) {
        return (
          typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value &&
          value >= 0
        );
      }
      function isValidLocation(loc) {
        return (
          Boolean(loc) &&
          isValidNumber(loc.offset) &&
          isValidNumber(loc.line) &&
          isValidNumber(loc.column)
        );
      }
      function createNodeStructureChecker(type, fields) {
        return function checkNode(node, warn) {
          if (!node || node.constructor !== Object) {
            return warn(node, "Type of node should be an Object");
          }
          for (let key in node) {
            let valid = true;
            if (hasOwnProperty.call(node, key) === false) {
              continue;
            }
            if (key === "type") {
              if (node.type !== type) {
                warn(
                  node,
                  "Wrong node type `" +
                    node.type +
                    "`, expected `" +
                    type +
                    "`",
                );
              }
            } else if (key === "loc") {
              if (node.loc === null) {
                continue;
              } else if (node.loc && node.loc.constructor === Object) {
                if (typeof node.loc.source !== "string") {
                  key += ".source";
                } else if (!isValidLocation(node.loc.start)) {
                  key += ".start";
                } else if (!isValidLocation(node.loc.end)) {
                  key += ".end";
                } else {
                  continue;
                }
              }
              valid = false;
            } else if (fields.hasOwnProperty(key)) {
              valid = false;
              for (let i = 0; !valid && i < fields[key].length; i++) {
                const fieldType = fields[key][i];
                switch (fieldType) {
                  case String:
                    valid = typeof node[key] === "string";
                    break;
                  case Boolean:
                    valid = typeof node[key] === "boolean";
                    break;
                  case null:
                    valid = node[key] === null;
                    break;
                  default:
                    if (typeof fieldType === "string") {
                      valid = node[key] && node[key].type === fieldType;
                    } else if (Array.isArray(fieldType)) {
                      valid = node[key] instanceof List.List;
                    }
                }
              }
            } else {
              warn(
                node,
                "Unknown field `" + key + "` for " + type + " node type",
              );
            }
            if (!valid) {
              warn(node, "Bad value for `" + type + "." + key + "`");
            }
          }
          for (const key in fields) {
            if (
              hasOwnProperty.call(fields, key) &&
              hasOwnProperty.call(node, key) === false
            ) {
              warn(node, "Field `" + type + "." + key + "` is missed");
            }
          }
        };
      }
      function processStructure(name, nodeType) {
        const structure = nodeType.structure;
        const fields = { type: String, loc: true };
        const docs = { type: '"' + name + '"' };
        for (const key in structure) {
          if (hasOwnProperty.call(structure, key) === false) {
            continue;
          }
          const docsTypes = [];
          const fieldTypes = (fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]]);
          for (let i = 0; i < fieldTypes.length; i++) {
            const fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
              docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
              docsTypes.push("null");
            } else if (typeof fieldType === "string") {
              docsTypes.push("<" + fieldType + ">");
            } else if (Array.isArray(fieldType)) {
              docsTypes.push("List");
            } else {
              throw new Error(
                "Wrong value `" +
                  fieldType +
                  "` in `" +
                  name +
                  "." +
                  key +
                  "` structure definition",
              );
            }
          }
          docs[key] = docsTypes.join(" | ");
        }
        return { docs, check: createNodeStructureChecker(name, fields) };
      }
      function getStructureFromConfig(config) {
        const structure = {};
        if (config.node) {
          for (const name in config.node) {
            if (hasOwnProperty.call(config.node, name)) {
              const nodeType = config.node[name];
              if (nodeType.structure) {
                structure[name] = processStructure(name, nodeType);
              } else {
                throw new Error(
                  "Missed `structure` field in `" +
                    name +
                    "` node type definition",
                );
              }
            }
          }
        }
        return structure;
      }
      exports.getStructureFromConfig = getStructureFromConfig;
    },
    4574: (__unused_webpack_module, exports) => {
      "use strict";
      function getTrace(node) {
        function shouldPutToTrace(syntax) {
          if (syntax === null) {
            return false;
          }
          return (
            syntax.type === "Type" ||
            syntax.type === "Property" ||
            syntax.type === "Keyword"
          );
        }
        function hasMatch(matchNode) {
          if (Array.isArray(matchNode.match)) {
            for (let i = 0; i < matchNode.match.length; i++) {
              if (hasMatch(matchNode.match[i])) {
                if (shouldPutToTrace(matchNode.syntax)) {
                  result.unshift(matchNode.syntax);
                }
                return true;
              }
            }
          } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
              ? [matchNode.syntax]
              : [];
            return true;
          }
          return false;
        }
        let result = null;
        if (this.matched !== null) {
          hasMatch(this.matched);
        }
        return result;
      }
      function isType(node, type) {
        return testNode(
          this,
          node,
          (match) => match.type === "Type" && match.name === type,
        );
      }
      function isProperty(node, property) {
        return testNode(
          this,
          node,
          (match) => match.type === "Property" && match.name === property,
        );
      }
      function isKeyword(node) {
        return testNode(this, node, (match) => match.type === "Keyword");
      }
      function testNode(match, node, fn) {
        const trace = getTrace.call(match, node);
        if (trace === null) {
          return false;
        }
        return trace.some(fn);
      }
      exports.getTrace = getTrace;
      exports.isKeyword = isKeyword;
      exports.isProperty = isProperty;
      exports.isType = isType;
    },
    6072: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const createCustomError = __nccwpck_require__(6893);
      const MAX_LINE_LENGTH = 100;
      const OFFSET_CORRECTION = 60;
      const TAB_REPLACEMENT = "    ";
      function sourceFragment({ source, line, column }, extraLines) {
        function processLines(start, end) {
          return lines
            .slice(start, end)
            .map(
              (line, idx) =>
                String(start + idx + 1).padStart(maxNumLength) + " |" + line,
            )
            .join("\n");
        }
        const lines = source.split(/\r\n?|\n|\f/);
        const startLine = Math.max(1, line - extraLines) - 1;
        const endLine = Math.min(line + extraLines, lines.length + 1);
        const maxNumLength = Math.max(4, String(endLine).length) + 1;
        let cutLeft = 0;
        column +=
          (TAB_REPLACEMENT.length - 1) *
          (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
        if (column > MAX_LINE_LENGTH) {
          cutLeft = column - OFFSET_CORRECTION + 3;
          column = OFFSET_CORRECTION - 2;
        }
        for (let i = startLine; i <= endLine; i++) {
          if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
              (cutLeft > 0 && lines[i].length > cutLeft ? "…" : "") +
              lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
              (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "…" : "");
          }
        }
        return [
          processLines(startLine, line),
          new Array(column + maxNumLength + 2).join("-") + "^",
          processLines(line, endLine),
        ]
          .filter(Boolean)
          .join("\n");
      }
      function SyntaxError(message, source, offset, line, column) {
        const error = Object.assign(
          createCustomError.createCustomError("SyntaxError", message),
          {
            source,
            offset,
            line,
            column,
            sourceFragment(extraLines) {
              return sourceFragment(
                { source, line, column },
                isNaN(extraLines) ? 0 : extraLines,
              );
            },
            get formattedMessage() {
              return (
                `Parse error: ${message}\n` +
                sourceFragment({ source, line, column }, 2)
              );
            },
          },
        );
        return error;
      }
      exports.SyntaxError = SyntaxError;
    },
    1506: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(3681);
      const SyntaxError = __nccwpck_require__(6072);
      const index = __nccwpck_require__(8008);
      const sequence = __nccwpck_require__(9456);
      const OffsetToLocation = __nccwpck_require__(7089);
      const TokenStream = __nccwpck_require__(7978);
      const utils = __nccwpck_require__(2850);
      const types = __nccwpck_require__(7783);
      const names = __nccwpck_require__(7755);
      const NOOP = () => {};
      const EXCLAMATIONMARK = 33;
      const NUMBERSIGN = 35;
      const SEMICOLON = 59;
      const LEFTCURLYBRACKET = 123;
      const NULL = 0;
      function createParseContext(name) {
        return function () {
          return this[name]();
        };
      }
      function fetchParseValues(dict) {
        const result = Object.create(null);
        for (const name in dict) {
          const item = dict[name];
          const fn = item.parse || item;
          if (fn) {
            result[name] = fn;
          }
        }
        return result;
      }
      function processConfig(config) {
        const parseConfig = {
          context: Object.create(null),
          scope: Object.assign(Object.create(null), config.scope),
          atrule: fetchParseValues(config.atrule),
          pseudo: fetchParseValues(config.pseudo),
          node: fetchParseValues(config.node),
        };
        for (const name in config.parseContext) {
          switch (typeof config.parseContext[name]) {
            case "function":
              parseConfig.context[name] = config.parseContext[name];
              break;
            case "string":
              parseConfig.context[name] = createParseContext(
                config.parseContext[name],
              );
              break;
          }
        }
        return { config: parseConfig, ...parseConfig, ...parseConfig.node };
      }
      function createParser(config) {
        let source = "";
        let filename = "<unknown>";
        let needPositions = false;
        let onParseError = NOOP;
        let onParseErrorThrow = false;
        const locationMap = new OffsetToLocation.OffsetToLocation();
        const parser = Object.assign(
          new TokenStream.TokenStream(),
          processConfig(config || {}),
          {
            parseAtrulePrelude: true,
            parseRulePrelude: true,
            parseValue: true,
            parseCustomProperty: false,
            readSequence: sequence.readSequence,
            consumeUntilBalanceEnd: () => 0,
            consumeUntilLeftCurlyBracket(code) {
              return code === LEFTCURLYBRACKET ? 1 : 0;
            },
            consumeUntilLeftCurlyBracketOrSemicolon(code) {
              return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
            },
            consumeUntilExclamationMarkOrSemicolon(code) {
              return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
            },
            consumeUntilSemicolonIncluded(code) {
              return code === SEMICOLON ? 2 : 0;
            },
            createList() {
              return new List.List();
            },
            createSingleNodeList(node) {
              return new List.List().appendData(node);
            },
            getFirstListNode(list) {
              return list && list.first;
            },
            getLastListNode(list) {
              return list && list.last;
            },
            parseWithFallback(consumer, fallback) {
              const startToken = this.tokenIndex;
              try {
                return consumer.call(this);
              } catch (e) {
                if (onParseErrorThrow) {
                  throw e;
                }
                const fallbackNode = fallback.call(this, startToken);
                onParseErrorThrow = true;
                onParseError(e, fallbackNode);
                onParseErrorThrow = false;
                return fallbackNode;
              }
            },
            lookupNonWSType(offset) {
              let type;
              do {
                type = this.lookupType(offset++);
                if (type !== types.WhiteSpace) {
                  return type;
                }
              } while (type !== NULL);
              return NULL;
            },
            charCodeAt(offset) {
              return offset >= 0 && offset < source.length
                ? source.charCodeAt(offset)
                : 0;
            },
            substring(offsetStart, offsetEnd) {
              return source.substring(offsetStart, offsetEnd);
            },
            substrToCursor(start) {
              return this.source.substring(start, this.tokenStart);
            },
            cmpChar(offset, charCode) {
              return utils.cmpChar(source, offset, charCode);
            },
            cmpStr(offsetStart, offsetEnd, str) {
              return utils.cmpStr(source, offsetStart, offsetEnd, str);
            },
            consume(tokenType) {
              const start = this.tokenStart;
              this.eat(tokenType);
              return this.substrToCursor(start);
            },
            consumeFunctionName() {
              const name = source.substring(this.tokenStart, this.tokenEnd - 1);
              this.eat(types.Function);
              return name;
            },
            consumeNumber(type) {
              const number = source.substring(
                this.tokenStart,
                utils.consumeNumber(source, this.tokenStart),
              );
              this.eat(type);
              return number;
            },
            eat(tokenType) {
              if (this.tokenType !== tokenType) {
                const tokenName = names[tokenType]
                  .slice(0, -6)
                  .replace(/-/g, " ")
                  .replace(/^./, (m) => m.toUpperCase());
                let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
                let offset = this.tokenStart;
                switch (tokenType) {
                  case types.Ident:
                    if (
                      this.tokenType === types.Function ||
                      this.tokenType === types.Url
                    ) {
                      offset = this.tokenEnd - 1;
                      message = "Identifier is expected but function found";
                    } else {
                      message = "Identifier is expected";
                    }
                    break;
                  case types.Hash:
                    if (this.isDelim(NUMBERSIGN)) {
                      this.next();
                      offset++;
                      message = "Name is expected";
                    }
                    break;
                  case types.Percentage:
                    if (this.tokenType === types.Number) {
                      offset = this.tokenEnd;
                      message = "Percent sign is expected";
                    }
                    break;
                }
                this.error(message, offset);
              }
              this.next();
            },
            eatIdent(name) {
              if (
                this.tokenType !== types.Ident ||
                this.lookupValue(0, name) === false
              ) {
                this.error(`Identifier "${name}" is expected`);
              }
              this.next();
            },
            eatDelim(code) {
              if (!this.isDelim(code)) {
                this.error(`Delim "${String.fromCharCode(code)}" is expected`);
              }
              this.next();
            },
            getLocation(start, end) {
              if (needPositions) {
                return locationMap.getLocationRange(start, end, filename);
              }
              return null;
            },
            getLocationFromList(list) {
              if (needPositions) {
                const head = this.getFirstListNode(list);
                const tail = this.getLastListNode(list);
                return locationMap.getLocationRange(
                  head !== null
                    ? head.loc.start.offset - locationMap.startOffset
                    : this.tokenStart,
                  tail !== null
                    ? tail.loc.end.offset - locationMap.startOffset
                    : this.tokenStart,
                  filename,
                );
              }
              return null;
            },
            error(message, offset) {
              const location =
                typeof offset !== "undefined" && offset < source.length
                  ? locationMap.getLocation(offset)
                  : this.eof
                    ? locationMap.getLocation(
                        utils.findWhiteSpaceStart(source, source.length - 1),
                      )
                    : locationMap.getLocation(this.tokenStart);
              throw new SyntaxError.SyntaxError(
                message || "Unexpected input",
                source,
                location.offset,
                location.line,
                location.column,
              );
            },
          },
        );
        const parse = function (source_, options) {
          source = source_;
          options = options || {};
          parser.setSource(source, index.tokenize);
          locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column,
          );
          filename = options.filename || "<unknown>";
          needPositions = Boolean(options.positions);
          onParseError =
            typeof options.onParseError === "function"
              ? options.onParseError
              : NOOP;
          onParseErrorThrow = false;
          parser.parseAtrulePrelude =
            "parseAtrulePrelude" in options
              ? Boolean(options.parseAtrulePrelude)
              : true;
          parser.parseRulePrelude =
            "parseRulePrelude" in options
              ? Boolean(options.parseRulePrelude)
              : true;
          parser.parseValue =
            "parseValue" in options ? Boolean(options.parseValue) : true;
          parser.parseCustomProperty =
            "parseCustomProperty" in options
              ? Boolean(options.parseCustomProperty)
              : false;
          const { context = "default", onComment } = options;
          if (context in parser.context === false) {
            throw new Error("Unknown context `" + context + "`");
          }
          if (typeof onComment === "function") {
            parser.forEachToken((type, start, end) => {
              if (type === types.Comment) {
                const loc = parser.getLocation(start, end);
                const value = utils.cmpStr(source, end - 2, end, "*/")
                  ? source.slice(start + 2, end - 2)
                  : source.slice(start + 2, end);
                onComment(value, loc);
              }
            });
          }
          const ast = parser.context[context].call(parser, options);
          if (!parser.eof) {
            parser.error();
          }
          return ast;
        };
        return Object.assign(parse, {
          SyntaxError: SyntaxError.SyntaxError,
          config: parser.config,
        });
      }
      exports.createParser = createParser;
    },
    9456: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function readSequence(recognizer) {
        const children = this.createList();
        let space = false;
        const context = { recognizer };
        while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
              this.next();
              continue;
            case types.WhiteSpace:
              space = true;
              this.next();
              continue;
          }
          let child = recognizer.getNode.call(this, context);
          if (child === undefined) {
            break;
          }
          if (space) {
            if (recognizer.onWhiteSpace) {
              recognizer.onWhiteSpace.call(this, child, children, context);
            }
            space = false;
          }
          children.push(child);
        }
        if (space && recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, null, children, context);
        }
        return children;
      }
      exports.readSequence = readSequence;
    },
    4605: (module) => {
      "use strict";
      const fontFace = {
        parse: {
          prelude: null,
          block() {
            return this.Block(true);
          },
        },
      };
      module.exports = fontFace;
    },
    6858: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const importAtrule = {
        parse: {
          prelude() {
            const children = this.createList();
            this.skipSC();
            switch (this.tokenType) {
              case types.String:
                children.push(this.String());
                break;
              case types.Url:
              case types.Function:
                children.push(this.Url());
                break;
              default:
                this.error("String or url() is expected");
            }
            if (
              this.lookupNonWSType(0) === types.Ident ||
              this.lookupNonWSType(0) === types.LeftParenthesis
            ) {
              children.push(this.MediaQueryList());
            }
            return children;
          },
          block: null,
        },
      };
      module.exports = importAtrule;
    },
    9883: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const fontFace = __nccwpck_require__(4605);
      const _import = __nccwpck_require__(6858);
      const media = __nccwpck_require__(7334);
      const page = __nccwpck_require__(225);
      const supports = __nccwpck_require__(4603);
      const atrule = {
        "font-face": fontFace,
        import: _import,
        media,
        page,
        supports,
      };
      module.exports = atrule;
    },
    7334: (module) => {
      "use strict";
      const media = {
        parse: {
          prelude() {
            return this.createSingleNodeList(this.MediaQueryList());
          },
          block() {
            return this.Block(false);
          },
        },
      };
      module.exports = media;
    },
    225: (module) => {
      "use strict";
      const page = {
        parse: {
          prelude() {
            return this.createSingleNodeList(this.SelectorList());
          },
          block() {
            return this.Block(true);
          },
        },
      };
      module.exports = page;
    },
    4603: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function consumeRaw() {
        return this.createSingleNodeList(
          this.Raw(this.tokenIndex, null, false),
        );
      }
      function parentheses() {
        this.skipSC();
        if (
          this.tokenType === types.Ident &&
          this.lookupNonWSType(1) === types.Colon
        ) {
          return this.createSingleNodeList(this.Declaration());
        }
        return readSequence.call(this);
      }
      function readSequence() {
        const children = this.createList();
        let child;
        this.skipSC();
        scan: while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Function:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          children.push(child);
        }
        return children;
      }
      const supports = {
        parse: {
          prelude() {
            const children = readSequence.call(this);
            if (this.getFirstListNode(children) === null) {
              this.error("Condition is expected");
            }
            return children;
          },
          block() {
            return this.Block(false);
          },
        },
      };
      module.exports = supports;
    },
    4314: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const data = __nccwpck_require__(9650);
      const index = __nccwpck_require__(2168);
      const lexerConfig = { generic: true, ...data, node: index };
      module.exports = lexerConfig;
    },
    5027: (module) => {
      "use strict";
      const { hasOwnProperty } = Object.prototype;
      const shape = {
        generic: true,
        types: appendOrAssign,
        atrules: {
          prelude: appendOrAssignOrNull,
          descriptors: appendOrAssignOrNull,
        },
        properties: appendOrAssign,
        parseContext: assign,
        scope: deepAssign,
        atrule: ["parse"],
        pseudo: ["parse"],
        node: ["name", "structure", "parse", "generate", "walkContext"],
      };
      function isObject(value) {
        return value && value.constructor === Object;
      }
      function copy(value) {
        return isObject(value) ? { ...value } : value;
      }
      function assign(dest, src) {
        return Object.assign(dest, src);
      }
      function deepAssign(dest, src) {
        for (const key in src) {
          if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
              deepAssign(dest[key], src[key]);
            } else {
              dest[key] = copy(src[key]);
            }
          }
        }
        return dest;
      }
      function append(a, b) {
        if (typeof b === "string" && /^\s*\|/.test(b)) {
          return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
        }
        return b || null;
      }
      function appendOrAssign(a, b) {
        if (typeof b === "string") {
          return append(a, b);
        }
        const result = { ...a };
        for (let key in b) {
          if (hasOwnProperty.call(b, key)) {
            result[key] = append(
              hasOwnProperty.call(a, key) ? a[key] : undefined,
              b[key],
            );
          }
        }
        return result;
      }
      function appendOrAssignOrNull(a, b) {
        const result = appendOrAssign(a, b);
        return !isObject(result) || Object.keys(result).length ? result : null;
      }
      function mix(dest, src, shape) {
        for (const key in shape) {
          if (hasOwnProperty.call(shape, key) === false) {
            continue;
          }
          if (shape[key] === true) {
            if (hasOwnProperty.call(src, key)) {
              dest[key] = copy(src[key]);
            }
          } else if (shape[key]) {
            if (typeof shape[key] === "function") {
              const fn = shape[key];
              dest[key] = fn({}, dest[key]);
              dest[key] = fn(dest[key] || {}, src[key]);
            } else if (isObject(shape[key])) {
              const result = {};
              for (let name in dest[key]) {
                result[name] = mix({}, dest[key][name], shape[key]);
              }
              for (let name in src[key]) {
                result[name] = mix(
                  result[name] || {},
                  src[key][name],
                  shape[key],
                );
              }
              dest[key] = result;
            } else if (Array.isArray(shape[key])) {
              const res = {};
              const innerShape = shape[key].reduce(function (s, k) {
                s[k] = true;
                return s;
              }, {});
              for (const [name, value] of Object.entries(dest[key] || {})) {
                res[name] = {};
                if (value) {
                  mix(res[name], value, innerShape);
                }
              }
              for (const name in src[key]) {
                if (hasOwnProperty.call(src[key], name)) {
                  if (!res[name]) {
                    res[name] = {};
                  }
                  if (src[key] && src[key][name]) {
                    mix(res[name], src[key][name], innerShape);
                  }
                }
              }
              dest[key] = res;
            }
          }
        }
        return dest;
      }
      const mix$1 = (dest, src) => mix(dest, src, shape);
      module.exports = mix$1;
    },
    8483: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(7404);
      const index$1 = __nccwpck_require__(9883);
      const index$2 = __nccwpck_require__(9072);
      const indexParse = __nccwpck_require__(1080);
      const config = {
        parseContext: {
          default: "StyleSheet",
          stylesheet: "StyleSheet",
          atrule: "Atrule",
          atrulePrelude(options) {
            return this.AtrulePrelude(
              options.atrule ? String(options.atrule) : null,
            );
          },
          mediaQueryList: "MediaQueryList",
          mediaQuery: "MediaQuery",
          rule: "Rule",
          selectorList: "SelectorList",
          selector: "Selector",
          block() {
            return this.Block(true);
          },
          declarationList: "DeclarationList",
          declaration: "Declaration",
          value: "Value",
        },
        scope: index,
        atrule: index$1,
        pseudo: index$2,
        node: indexParse,
      };
      module.exports = config;
    },
    4695: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(2168);
      const config = { node: index };
      module.exports = config;
    },
    5958: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(8008);
      const create = __nccwpck_require__(1506);
      const create$2 = __nccwpck_require__(8919);
      const create$3 = __nccwpck_require__(2505);
      const create$1 = __nccwpck_require__(4778);
      const Lexer = __nccwpck_require__(6522);
      const mix = __nccwpck_require__(5027);
      function createSyntax(config) {
        const parse = create.createParser(config);
        const walk = create$1.createWalker(config);
        const generate = create$2.createGenerator(config);
        const { fromPlainObject, toPlainObject } =
          create$3.createConvertor(walk);
        const syntax = {
          lexer: null,
          createLexer: (config) =>
            new Lexer.Lexer(config, syntax, syntax.lexer.structure),
          tokenize: index.tokenize,
          parse,
          generate,
          walk,
          find: walk.find,
          findLast: walk.findLast,
          findAll: walk.findAll,
          fromPlainObject,
          toPlainObject,
          fork(extension) {
            const base = mix({}, config);
            return createSyntax(
              typeof extension === "function"
                ? extension(base, Object.assign)
                : mix(base, extension),
            );
          },
        };
        syntax.lexer = new Lexer.Lexer(
          {
            generic: true,
            types: config.types,
            atrules: config.atrules,
            properties: config.properties,
            node: config.node,
          },
          syntax,
        );
        return syntax;
      }
      const createSyntax$1 = (config) => createSyntax(mix({}, config));
      module.exports = createSyntax$1;
    },
    7512: (module) => {
      "use strict";
      function expressionFn() {
        return this.createSingleNodeList(
          this.Raw(this.tokenIndex, null, false),
        );
      }
      module.exports = expressionFn;
    },
    8058: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function varFn() {
        const children = this.createList();
        this.skipSC();
        children.push(this.Identifier());
        this.skipSC();
        if (this.tokenType === types.Comma) {
          children.push(this.Operator());
          const startIndex = this.tokenIndex;
          const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(
                this.tokenIndex,
                this.consumeUntilExclamationMarkOrSemicolon,
                false,
              );
          if (value.type === "Value" && value.children.isEmpty) {
            for (
              let offset = startIndex - this.tokenIndex;
              offset <= 0;
              offset++
            ) {
              if (this.lookupType(offset) === types.WhiteSpace) {
                value.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " ",
                });
                break;
              }
            }
          }
          children.push(value);
        }
        return children;
      }
      module.exports = varFn;
    },
    454: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const create = __nccwpck_require__(5958);
      const lexer = __nccwpck_require__(4314);
      const parser = __nccwpck_require__(8483);
      const walker = __nccwpck_require__(4695);
      const syntax = create({ ...lexer, ...parser, ...walker });
      module.exports = syntax;
    },
    4215: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const charCodeDefinitions = __nccwpck_require__(7332);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const N = 110;
      const DISALLOW_SIGN = true;
      const ALLOW_SIGN = false;
      function checkInteger(offset, disallowSign) {
        let pos = this.tokenStart + offset;
        const code = this.charCodeAt(pos);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            this.error("Number sign is not allowed");
          }
          pos++;
        }
        for (; pos < this.tokenEnd; pos++) {
          if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
            this.error("Integer is expected", pos);
          }
        }
      }
      function checkTokenIsInteger(disallowSign) {
        return checkInteger.call(this, 0, disallowSign);
      }
      function expectCharCode(offset, code) {
        if (!this.cmpChar(this.tokenStart + offset, code)) {
          let msg = "";
          switch (code) {
            case N:
              msg = "N is expected";
              break;
            case HYPHENMINUS:
              msg = "HyphenMinus is expected";
              break;
          }
          this.error(msg, this.tokenStart + offset);
        }
      }
      function consumeB() {
        let offset = 0;
        let sign = 0;
        let type = this.tokenType;
        while (type === types.WhiteSpace || type === types.Comment) {
          type = this.lookupType(++offset);
        }
        if (type !== types.Number) {
          if (
            this.isDelim(PLUSSIGN, offset) ||
            this.isDelim(HYPHENMINUS, offset)
          ) {
            sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
            do {
              type = this.lookupType(++offset);
            } while (type === types.WhiteSpace || type === types.Comment);
            if (type !== types.Number) {
              this.skip(offset);
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
          } else {
            return null;
          }
        }
        if (offset > 0) {
          this.skip(offset);
        }
        if (sign === 0) {
          type = this.charCodeAt(this.tokenStart);
          if (type !== PLUSSIGN && type !== HYPHENMINUS) {
            this.error("Number sign is expected");
          }
        }
        checkTokenIsInteger.call(this, sign !== 0);
        return sign === HYPHENMINUS
          ? "-" + this.consume(types.Number)
          : this.consume(types.Number);
      }
      const name = "AnPlusB";
      const structure = { a: [String, null], b: [String, null] };
      function parse() {
        const start = this.tokenStart;
        let a = null;
        let b = null;
        if (this.tokenType === types.Number) {
          checkTokenIsInteger.call(this, ALLOW_SIGN);
          b = this.consume(types.Number);
        } else if (
          this.tokenType === types.Ident &&
          this.cmpChar(this.tokenStart, HYPHENMINUS)
        ) {
          a = "-1";
          expectCharCode.call(this, 1, N);
          switch (this.tokenEnd - this.tokenStart) {
            case 2:
              this.next();
              b = consumeB.call(this);
              break;
            case 3:
              expectCharCode.call(this, 2, HYPHENMINUS);
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(types.Number);
              break;
            default:
              expectCharCode.call(this, 2, HYPHENMINUS);
              checkInteger.call(this, 3, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(start + 2);
          }
        } else if (
          this.tokenType === types.Ident ||
          (this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident)
        ) {
          let sign = 0;
          a = "1";
          if (this.isDelim(PLUSSIGN)) {
            sign = 1;
            this.next();
          }
          expectCharCode.call(this, 0, N);
          switch (this.tokenEnd - this.tokenStart) {
            case 1:
              this.next();
              b = consumeB.call(this);
              break;
            case 2:
              expectCharCode.call(this, 1, HYPHENMINUS);
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(types.Number);
              break;
            default:
              expectCharCode.call(this, 1, HYPHENMINUS);
              checkInteger.call(this, 2, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(start + sign + 1);
          }
        } else if (this.tokenType === types.Dimension) {
          const code = this.charCodeAt(this.tokenStart);
          const sign = code === PLUSSIGN || code === HYPHENMINUS;
          let i = this.tokenStart + sign;
          for (; i < this.tokenEnd; i++) {
            if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
              break;
            }
          }
          if (i === this.tokenStart + sign) {
            this.error("Integer is expected", this.tokenStart + sign);
          }
          expectCharCode.call(this, i - this.tokenStart, N);
          a = this.substring(start, i);
          if (i + 1 === this.tokenEnd) {
            this.next();
            b = consumeB.call(this);
          } else {
            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
            if (i + 2 === this.tokenEnd) {
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(types.Number);
            } else {
              checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(i + 1);
            }
          }
        } else {
          this.error();
        }
        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
          a = a.substr(1);
        }
        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
          b = b.substr(1);
        }
        return {
          type: "AnPlusB",
          loc: this.getLocation(start, this.tokenStart),
          a,
          b,
        };
      }
      function generate(node) {
        if (node.a) {
          const a =
            (node.a === "+1" && "n") ||
            (node.a === "1" && "n") ||
            (node.a === "-1" && "-n") ||
            node.a + "n";
          if (node.b) {
            const b =
              node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
            this.tokenize(a + b);
          } else {
            this.tokenize(a);
          }
        } else {
          this.tokenize(node.b);
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8476: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function consumeRaw(startToken) {
        return this.Raw(
          startToken,
          this.consumeUntilLeftCurlyBracketOrSemicolon,
          true,
        );
      }
      function isDeclarationBlockAtrule() {
        for (let offset = 1, type; (type = this.lookupType(offset)); offset++) {
          if (type === types.RightCurlyBracket) {
            return true;
          }
          if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
            return false;
          }
        }
        return false;
      }
      const name = "Atrule";
      const walkContext = "atrule";
      const structure = {
        name: String,
        prelude: ["AtrulePrelude", "Raw", null],
        block: ["Block", null],
      };
      function parse() {
        const start = this.tokenStart;
        let name;
        let nameLowerCase;
        let prelude = null;
        let block = null;
        this.eat(types.AtKeyword);
        name = this.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.skipSC();
        if (
          this.eof === false &&
          this.tokenType !== types.LeftCurlyBracket &&
          this.tokenType !== types.Semicolon
        ) {
          if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(
              this.AtrulePrelude.bind(this, name),
              consumeRaw,
            );
          } else {
            prelude = consumeRaw.call(this, this.tokenIndex);
          }
          this.skipSC();
        }
        switch (this.tokenType) {
          case types.Semicolon:
            this.next();
            break;
          case types.LeftCurlyBracket:
            if (
              hasOwnProperty.call(this.atrule, nameLowerCase) &&
              typeof this.atrule[nameLowerCase].block === "function"
            ) {
              block = this.atrule[nameLowerCase].block.call(this);
            } else {
              block = this.Block(isDeclarationBlockAtrule.call(this));
            }
            break;
        }
        return {
          type: "Atrule",
          loc: this.getLocation(start, this.tokenStart),
          name,
          prelude,
          block,
        };
      }
      function generate(node) {
        this.token(types.AtKeyword, "@" + node.name);
        if (node.prelude !== null) {
          this.node(node.prelude);
        }
        if (node.block) {
          this.node(node.block);
        } else {
          this.token(types.Semicolon, ";");
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    4484: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "AtrulePrelude";
      const walkContext = "atrulePrelude";
      const structure = { children: [[]] };
      function parse(name) {
        let children = null;
        if (name !== null) {
          name = name.toLowerCase();
        }
        this.skipSC();
        if (
          hasOwnProperty.call(this.atrule, name) &&
          typeof this.atrule[name].prelude === "function"
        ) {
          children = this.atrule[name].prelude.call(this);
        } else {
          children = this.readSequence(this.scope.AtrulePrelude);
        }
        this.skipSC();
        if (
          this.eof !== true &&
          this.tokenType !== types.LeftCurlyBracket &&
          this.tokenType !== types.Semicolon
        ) {
          this.error("Semicolon or block is expected");
        }
        return {
          type: "AtrulePrelude",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    3495: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const DOLLARSIGN = 36;
      const ASTERISK = 42;
      const EQUALSSIGN = 61;
      const CIRCUMFLEXACCENT = 94;
      const VERTICALLINE = 124;
      const TILDE = 126;
      function getAttributeName() {
        if (this.eof) {
          this.error("Unexpected end of input");
        }
        const start = this.tokenStart;
        let expectIdent = false;
        if (this.isDelim(ASTERISK)) {
          expectIdent = true;
          this.next();
        } else if (!this.isDelim(VERTICALLINE)) {
          this.eat(types.Ident);
        }
        if (this.isDelim(VERTICALLINE)) {
          if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
            this.next();
            this.eat(types.Ident);
          } else if (expectIdent) {
            this.error("Identifier is expected", this.tokenEnd);
          }
        } else if (expectIdent) {
          this.error("Vertical line is expected");
        }
        return {
          type: "Identifier",
          loc: this.getLocation(start, this.tokenStart),
          name: this.substrToCursor(start),
        };
      }
      function getOperator() {
        const start = this.tokenStart;
        const code = this.charCodeAt(start);
        if (
          code !== EQUALSSIGN &&
          code !== TILDE &&
          code !== CIRCUMFLEXACCENT &&
          code !== DOLLARSIGN &&
          code !== ASTERISK &&
          code !== VERTICALLINE
        ) {
          this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
        }
        this.next();
        if (code !== EQUALSSIGN) {
          if (!this.isDelim(EQUALSSIGN)) {
            this.error("Equal sign is expected");
          }
          this.next();
        }
        return this.substrToCursor(start);
      }
      const name = "AttributeSelector";
      const structure = {
        name: "Identifier",
        matcher: [String, null],
        value: ["String", "Identifier", null],
        flags: [String, null],
      };
      function parse() {
        const start = this.tokenStart;
        let name;
        let matcher = null;
        let value = null;
        let flags = null;
        this.eat(types.LeftSquareBracket);
        this.skipSC();
        name = getAttributeName.call(this);
        this.skipSC();
        if (this.tokenType !== types.RightSquareBracket) {
          if (this.tokenType !== types.Ident) {
            matcher = getOperator.call(this);
            this.skipSC();
            value =
              this.tokenType === types.String
                ? this.String()
                : this.Identifier();
            this.skipSC();
          }
          if (this.tokenType === types.Ident) {
            flags = this.consume(types.Ident);
            this.skipSC();
          }
        }
        this.eat(types.RightSquareBracket);
        return {
          type: "AttributeSelector",
          loc: this.getLocation(start, this.tokenStart),
          name,
          matcher,
          value,
          flags,
        };
      }
      function generate(node) {
        this.token(types.Delim, "[");
        this.node(node.name);
        if (node.matcher !== null) {
          this.tokenize(node.matcher);
          this.node(node.value);
        }
        if (node.flags !== null) {
          this.token(types.Ident, node.flags);
        }
        this.token(types.Delim, "]");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4628: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, true);
      }
      function consumeRule() {
        return this.parseWithFallback(this.Rule, consumeRaw);
      }
      function consumeRawDeclaration(startToken) {
        return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
      }
      function consumeDeclaration() {
        if (this.tokenType === types.Semicolon) {
          return consumeRawDeclaration.call(this, this.tokenIndex);
        }
        const node = this.parseWithFallback(
          this.Declaration,
          consumeRawDeclaration,
        );
        if (this.tokenType === types.Semicolon) {
          this.next();
        }
        return node;
      }
      const name = "Block";
      const walkContext = "block";
      const structure = { children: [["Atrule", "Rule", "Declaration"]] };
      function parse(isDeclaration) {
        const consumer = isDeclaration ? consumeDeclaration : consumeRule;
        const start = this.tokenStart;
        let children = this.createList();
        this.eat(types.LeftCurlyBracket);
        scan: while (!this.eof) {
          switch (this.tokenType) {
            case types.RightCurlyBracket:
              break scan;
            case types.WhiteSpace:
            case types.Comment:
              this.next();
              break;
            case types.AtKeyword:
              children.push(this.parseWithFallback(this.Atrule, consumeRaw));
              break;
            default:
              children.push(consumer.call(this));
          }
        }
        if (!this.eof) {
          this.eat(types.RightCurlyBracket);
        }
        return {
          type: "Block",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.token(types.LeftCurlyBracket, "{");
        this.children(node, (prev) => {
          if (prev.type === "Declaration") {
            this.token(types.Semicolon, ";");
          }
        });
        this.token(types.RightCurlyBracket, "}");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    1983: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Brackets";
      const structure = { children: [[]] };
      function parse(readSequence, recognizer) {
        const start = this.tokenStart;
        let children = null;
        this.eat(types.LeftSquareBracket);
        children = readSequence.call(this, recognizer);
        if (!this.eof) {
          this.eat(types.RightSquareBracket);
        }
        return {
          type: "Brackets",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.token(types.Delim, "[");
        this.children(node);
        this.token(types.Delim, "]");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8517: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "CDC";
      const structure = [];
      function parse() {
        const start = this.tokenStart;
        this.eat(types.CDC);
        return { type: "CDC", loc: this.getLocation(start, this.tokenStart) };
      }
      function generate() {
        this.token(types.CDC, "--\x3e");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4925: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "CDO";
      const structure = [];
      function parse() {
        const start = this.tokenStart;
        this.eat(types.CDO);
        return { type: "CDO", loc: this.getLocation(start, this.tokenStart) };
      }
      function generate() {
        this.token(types.CDO, "\x3c!--");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4184: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const FULLSTOP = 46;
      const name = "ClassSelector";
      const structure = { name: String };
      function parse() {
        this.eatDelim(FULLSTOP);
        return {
          type: "ClassSelector",
          loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
          name: this.consume(types.Ident),
        };
      }
      function generate(node) {
        this.token(types.Delim, ".");
        this.token(types.Ident, node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    9518: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const PLUSSIGN = 43;
      const SOLIDUS = 47;
      const GREATERTHANSIGN = 62;
      const TILDE = 126;
      const name = "Combinator";
      const structure = { name: String };
      function parse() {
        const start = this.tokenStart;
        let name;
        switch (this.tokenType) {
          case types.WhiteSpace:
            name = " ";
            break;
          case types.Delim:
            switch (this.charCodeAt(this.tokenStart)) {
              case GREATERTHANSIGN:
              case PLUSSIGN:
              case TILDE:
                this.next();
                break;
              case SOLIDUS:
                this.next();
                this.eatIdent("deep");
                this.eatDelim(SOLIDUS);
                break;
              default:
                this.error("Combinator is expected");
            }
            name = this.substrToCursor(start);
            break;
        }
        return {
          type: "Combinator",
          loc: this.getLocation(start, this.tokenStart),
          name,
        };
      }
      function generate(node) {
        this.tokenize(node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2283: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const ASTERISK = 42;
      const SOLIDUS = 47;
      const name = "Comment";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        let end = this.tokenEnd;
        this.eat(types.Comment);
        if (
          end - start + 2 >= 2 &&
          this.charCodeAt(end - 2) === ASTERISK &&
          this.charCodeAt(end - 1) === SOLIDUS
        ) {
          end -= 2;
        }
        return {
          type: "Comment",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substring(start + 2, end),
        };
      }
      function generate(node) {
        this.token(types.Comment, "/*" + node.value + "*/");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    6507: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const names = __nccwpck_require__(627);
      const types = __nccwpck_require__(7783);
      const EXCLAMATIONMARK = 33;
      const NUMBERSIGN = 35;
      const DOLLARSIGN = 36;
      const AMPERSAND = 38;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const SOLIDUS = 47;
      function consumeValueRaw(startToken) {
        return this.Raw(
          startToken,
          this.consumeUntilExclamationMarkOrSemicolon,
          true,
        );
      }
      function consumeCustomPropertyRaw(startToken) {
        return this.Raw(
          startToken,
          this.consumeUntilExclamationMarkOrSemicolon,
          false,
        );
      }
      function consumeValue() {
        const startValueToken = this.tokenIndex;
        const value = this.Value();
        if (
          value.type !== "Raw" &&
          this.eof === false &&
          this.tokenType !== types.Semicolon &&
          this.isDelim(EXCLAMATIONMARK) === false &&
          this.isBalanceEdge(startValueToken) === false
        ) {
          this.error();
        }
        return value;
      }
      const name = "Declaration";
      const walkContext = "declaration";
      const structure = {
        important: [Boolean, String],
        property: String,
        value: ["Value", "Raw"],
      };
      function parse() {
        const start = this.tokenStart;
        const startToken = this.tokenIndex;
        const property = readProperty.call(this);
        const customProperty = names.isCustomProperty(property);
        const parseValue = customProperty
          ? this.parseCustomProperty
          : this.parseValue;
        const consumeRaw = customProperty
          ? consumeCustomPropertyRaw
          : consumeValueRaw;
        let important = false;
        let value;
        this.skipSC();
        this.eat(types.Colon);
        const valueStart = this.tokenIndex;
        if (!customProperty) {
          this.skipSC();
        }
        if (parseValue) {
          value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
          value = consumeRaw.call(this, this.tokenIndex);
        }
        if (
          customProperty &&
          value.type === "Value" &&
          value.children.isEmpty
        ) {
          for (
            let offset = valueStart - this.tokenIndex;
            offset <= 0;
            offset++
          ) {
            if (this.lookupType(offset) === types.WhiteSpace) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " ",
              });
              break;
            }
          }
        }
        if (this.isDelim(EXCLAMATIONMARK)) {
          important = getImportant.call(this);
          this.skipSC();
        }
        if (
          this.eof === false &&
          this.tokenType !== types.Semicolon &&
          this.isBalanceEdge(startToken) === false
        ) {
          this.error();
        }
        return {
          type: "Declaration",
          loc: this.getLocation(start, this.tokenStart),
          important,
          property,
          value,
        };
      }
      function generate(node) {
        this.token(types.Ident, node.property);
        this.token(types.Colon, ":");
        this.node(node.value);
        if (node.important) {
          this.token(types.Delim, "!");
          this.token(
            types.Ident,
            node.important === true ? "important" : node.important,
          );
        }
      }
      function readProperty() {
        const start = this.tokenStart;
        if (this.tokenType === types.Delim) {
          switch (this.charCodeAt(this.tokenStart)) {
            case ASTERISK:
            case DOLLARSIGN:
            case PLUSSIGN:
            case NUMBERSIGN:
            case AMPERSAND:
              this.next();
              break;
            case SOLIDUS:
              this.next();
              if (this.isDelim(SOLIDUS)) {
                this.next();
              }
              break;
          }
        }
        if (this.tokenType === types.Hash) {
          this.eat(types.Hash);
        } else {
          this.eat(types.Ident);
        }
        return this.substrToCursor(start);
      }
      function getImportant() {
        this.eat(types.Delim);
        this.skipSC();
        const important = this.consume(types.Ident);
        return important === "important" ? true : important;
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    7700: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function consumeRaw(startToken) {
        return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
      }
      const name = "DeclarationList";
      const structure = { children: [["Declaration"]] };
      function parse() {
        const children = this.createList();
        while (!this.eof) {
          switch (this.tokenType) {
            case types.WhiteSpace:
            case types.Comment:
            case types.Semicolon:
              this.next();
              break;
            default:
              children.push(
                this.parseWithFallback(this.Declaration, consumeRaw),
              );
          }
        }
        return {
          type: "DeclarationList",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node, (prev) => {
          if (prev.type === "Declaration") {
            this.token(types.Semicolon, ";");
          }
        });
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4513: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Dimension";
      const structure = { value: String, unit: String };
      function parse() {
        const start = this.tokenStart;
        const value = this.consumeNumber(types.Dimension);
        return {
          type: "Dimension",
          loc: this.getLocation(start, this.tokenStart),
          value,
          unit: this.substring(start + value.length, this.tokenStart),
        };
      }
      function generate(node) {
        this.token(types.Dimension, node.value + node.unit);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    6607: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Function";
      const walkContext = "function";
      const structure = { name: String, children: [[]] };
      function parse(readSequence, recognizer) {
        const start = this.tokenStart;
        const name = this.consumeFunctionName();
        const nameLowerCase = name.toLowerCase();
        let children;
        children = recognizer.hasOwnProperty(nameLowerCase)
          ? recognizer[nameLowerCase].call(this, recognizer)
          : readSequence.call(this, recognizer);
        if (!this.eof) {
          this.eat(types.RightParenthesis);
        }
        return {
          type: "Function",
          loc: this.getLocation(start, this.tokenStart),
          name,
          children,
        };
      }
      function generate(node) {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    3165: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const xxx = "XXX";
      const name = "Hash";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        this.eat(types.Hash);
        return {
          type: "Hash",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substrToCursor(start + 1),
        };
      }
      function generate(node) {
        this.token(types.Hash, "#" + node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.xxx = xxx;
    },
    2455: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "IdSelector";
      const structure = { name: String };
      function parse() {
        const start = this.tokenStart;
        this.eat(types.Hash);
        return {
          type: "IdSelector",
          loc: this.getLocation(start, this.tokenStart),
          name: this.substrToCursor(start + 1),
        };
      }
      function generate(node) {
        this.token(types.Delim, "#" + node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    5605: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Identifier";
      const structure = { name: String };
      function parse() {
        return {
          type: "Identifier",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          name: this.consume(types.Ident),
        };
      }
      function generate(node) {
        this.token(types.Ident, node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    728: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "MediaFeature";
      const structure = {
        name: String,
        value: ["Identifier", "Number", "Dimension", "Ratio", null],
      };
      function parse() {
        const start = this.tokenStart;
        let name;
        let value = null;
        this.eat(types.LeftParenthesis);
        this.skipSC();
        name = this.consume(types.Ident);
        this.skipSC();
        if (this.tokenType !== types.RightParenthesis) {
          this.eat(types.Colon);
          this.skipSC();
          switch (this.tokenType) {
            case types.Number:
              if (this.lookupNonWSType(1) === types.Delim) {
                value = this.Ratio();
              } else {
                value = this.Number();
              }
              break;
            case types.Dimension:
              value = this.Dimension();
              break;
            case types.Ident:
              value = this.Identifier();
              break;
            default:
              this.error("Number, dimension, ratio or identifier is expected");
          }
          this.skipSC();
        }
        this.eat(types.RightParenthesis);
        return {
          type: "MediaFeature",
          loc: this.getLocation(start, this.tokenStart),
          name,
          value,
        };
      }
      function generate(node) {
        this.token(types.LeftParenthesis, "(");
        this.token(types.Ident, node.name);
        if (node.value !== null) {
          this.token(types.Colon, ":");
          this.node(node.value);
        }
        this.token(types.RightParenthesis, ")");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2631: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "MediaQuery";
      const structure = {
        children: [["Identifier", "MediaFeature", "WhiteSpace"]],
      };
      function parse() {
        const children = this.createList();
        let child = null;
        this.skipSC();
        scan: while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.MediaFeature();
              break;
            default:
              break scan;
          }
          children.push(child);
        }
        if (child === null) {
          this.error("Identifier or parenthesis is expected");
        }
        return {
          type: "MediaQuery",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    7164: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "MediaQueryList";
      const structure = { children: [["MediaQuery"]] };
      function parse() {
        const children = this.createList();
        this.skipSC();
        while (!this.eof) {
          children.push(this.MediaQuery());
          if (this.tokenType !== types.Comma) {
            break;
          }
          this.next();
        }
        return {
          type: "MediaQueryList",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node, () => this.token(types.Comma, ","));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    6189: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Nth";
      const structure = {
        nth: ["AnPlusB", "Identifier"],
        selector: ["SelectorList", null],
      };
      function parse() {
        this.skipSC();
        const start = this.tokenStart;
        let end = start;
        let selector = null;
        let nth;
        if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
          nth = this.Identifier();
        } else {
          nth = this.AnPlusB();
        }
        end = this.tokenStart;
        this.skipSC();
        if (this.lookupValue(0, "of")) {
          this.next();
          selector = this.SelectorList();
          end = this.tokenStart;
        }
        return {
          type: "Nth",
          loc: this.getLocation(start, end),
          nth,
          selector,
        };
      }
      function generate(node) {
        this.node(node.nth);
        if (node.selector !== null) {
          this.token(types.Ident, "of");
          this.node(node.selector);
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    5512: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Number";
      const structure = { value: String };
      function parse() {
        return {
          type: "Number",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          value: this.consume(types.Number),
        };
      }
      function generate(node) {
        this.token(types.Number, node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    3680: (__unused_webpack_module, exports) => {
      "use strict";
      const name = "Operator";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        this.next();
        return {
          type: "Operator",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substrToCursor(start),
        };
      }
      function generate(node) {
        this.tokenize(node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8282: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Parentheses";
      const structure = { children: [[]] };
      function parse(readSequence, recognizer) {
        const start = this.tokenStart;
        let children = null;
        this.eat(types.LeftParenthesis);
        children = readSequence.call(this, recognizer);
        if (!this.eof) {
          this.eat(types.RightParenthesis);
        }
        return {
          type: "Parentheses",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.token(types.LeftParenthesis, "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    6339: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "Percentage";
      const structure = { value: String };
      function parse() {
        return {
          type: "Percentage",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          value: this.consumeNumber(types.Percentage),
        };
      }
      function generate(node) {
        this.token(types.Percentage, node.value + "%");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    3672: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "PseudoClassSelector";
      const walkContext = "function";
      const structure = { name: String, children: [["Raw"], null] };
      function parse() {
        const start = this.tokenStart;
        let children = null;
        let name;
        let nameLowerCase;
        this.eat(types.Colon);
        if (this.tokenType === types.Function) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
          } else {
            children = this.createList();
            children.push(this.Raw(this.tokenIndex, null, false));
          }
          this.eat(types.RightParenthesis);
        } else {
          name = this.consume(types.Ident);
        }
        return {
          type: "PseudoClassSelector",
          loc: this.getLocation(start, this.tokenStart),
          name,
          children,
        };
      }
      function generate(node) {
        this.token(types.Colon, ":");
        if (node.children === null) {
          this.token(types.Ident, node.name);
        } else {
          this.token(types.Function, node.name + "(");
          this.children(node);
          this.token(types.RightParenthesis, ")");
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    6578: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "PseudoElementSelector";
      const walkContext = "function";
      const structure = { name: String, children: [["Raw"], null] };
      function parse() {
        const start = this.tokenStart;
        let children = null;
        let name;
        let nameLowerCase;
        this.eat(types.Colon);
        this.eat(types.Colon);
        if (this.tokenType === types.Function) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
          } else {
            children = this.createList();
            children.push(this.Raw(this.tokenIndex, null, false));
          }
          this.eat(types.RightParenthesis);
        } else {
          name = this.consume(types.Ident);
        }
        return {
          type: "PseudoElementSelector",
          loc: this.getLocation(start, this.tokenStart),
          name,
          children,
        };
      }
      function generate(node) {
        this.token(types.Colon, ":");
        this.token(types.Colon, ":");
        if (node.children === null) {
          this.token(types.Ident, node.name);
        } else {
          this.token(types.Function, node.name + "(");
          this.children(node);
          this.token(types.RightParenthesis, ")");
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    3917: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const charCodeDefinitions = __nccwpck_require__(7332);
      const SOLIDUS = 47;
      const FULLSTOP = 46;
      function consumeNumber() {
        this.skipSC();
        const value = this.consume(types.Number);
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {
            this.error(
              "Unsigned number is expected",
              this.tokenStart - value.length + i,
            );
          }
        }
        if (Number(value) === 0) {
          this.error(
            "Zero number is not allowed",
            this.tokenStart - value.length,
          );
        }
        return value;
      }
      const name = "Ratio";
      const structure = { left: String, right: String };
      function parse() {
        const start = this.tokenStart;
        const left = consumeNumber.call(this);
        let right;
        this.skipSC();
        this.eatDelim(SOLIDUS);
        right = consumeNumber.call(this);
        return {
          type: "Ratio",
          loc: this.getLocation(start, this.tokenStart),
          left,
          right,
        };
      }
      function generate(node) {
        this.token(types.Number, node.left);
        this.token(types.Delim, "/");
        this.token(types.Number, node.right);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8140: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function getOffsetExcludeWS() {
        if (this.tokenIndex > 0) {
          if (this.lookupType(-1) === types.WhiteSpace) {
            return this.tokenIndex > 1
              ? this.getTokenStart(this.tokenIndex - 1)
              : this.firstCharOffset;
          }
        }
        return this.tokenStart;
      }
      const name = "Raw";
      const structure = { value: String };
      function parse(startToken, consumeUntil, excludeWhiteSpace) {
        const startOffset = this.getTokenStart(startToken);
        let endOffset;
        this.skipUntilBalanced(
          startToken,
          consumeUntil || this.consumeUntilBalanceEnd,
        );
        if (excludeWhiteSpace && this.tokenStart > startOffset) {
          endOffset = getOffsetExcludeWS.call(this);
        } else {
          endOffset = this.tokenStart;
        }
        return {
          type: "Raw",
          loc: this.getLocation(startOffset, endOffset),
          value: this.substring(startOffset, endOffset),
        };
      }
      function generate(node) {
        this.tokenize(node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    1079: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      function consumeRaw(startToken) {
        return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
      }
      function consumePrelude() {
        const prelude = this.SelectorList();
        if (
          prelude.type !== "Raw" &&
          this.eof === false &&
          this.tokenType !== types.LeftCurlyBracket
        ) {
          this.error();
        }
        return prelude;
      }
      const name = "Rule";
      const walkContext = "rule";
      const structure = { prelude: ["SelectorList", "Raw"], block: ["Block"] };
      function parse() {
        const startToken = this.tokenIndex;
        const startOffset = this.tokenStart;
        let prelude;
        let block;
        if (this.parseRulePrelude) {
          prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
          prelude = consumeRaw.call(this, startToken);
        }
        block = this.Block(true);
        return {
          type: "Rule",
          loc: this.getLocation(startOffset, this.tokenStart),
          prelude,
          block,
        };
      }
      function generate(node) {
        this.node(node.prelude);
        this.node(node.block);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    3222: (__unused_webpack_module, exports) => {
      "use strict";
      const name = "Selector";
      const structure = {
        children: [
          [
            "TypeSelector",
            "IdSelector",
            "ClassSelector",
            "AttributeSelector",
            "PseudoClassSelector",
            "PseudoElementSelector",
            "Combinator",
            "WhiteSpace",
          ],
        ],
      };
      function parse() {
        const children = this.readSequence(this.scope.Selector);
        if (this.getFirstListNode(children) === null) {
          this.error("Selector is expected");
        }
        return {
          type: "Selector",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    5933: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const name = "SelectorList";
      const walkContext = "selector";
      const structure = { children: [["Selector", "Raw"]] };
      function parse() {
        const children = this.createList();
        while (!this.eof) {
          children.push(this.Selector());
          if (this.tokenType === types.Comma) {
            this.next();
            continue;
          }
          break;
        }
        return {
          type: "SelectorList",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node, () => this.token(types.Comma, ","));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    6435: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const string = __nccwpck_require__(7688);
      const types = __nccwpck_require__(7783);
      const name = "String";
      const structure = { value: String };
      function parse() {
        return {
          type: "String",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          value: string.decode(this.consume(types.String)),
        };
      }
      function generate(node) {
        this.token(types.String, string.encode(node.value));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    1121: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const EXCLAMATIONMARK = 33;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, false);
      }
      const name = "StyleSheet";
      const walkContext = "stylesheet";
      const structure = {
        children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]],
      };
      function parse() {
        const start = this.tokenStart;
        const children = this.createList();
        let child;
        while (!this.eof) {
          switch (this.tokenType) {
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Comment:
              if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
                this.next();
                continue;
              }
              child = this.Comment();
              break;
            case types.CDO:
              child = this.CDO();
              break;
            case types.CDC:
              child = this.CDC();
              break;
            case types.AtKeyword:
              child = this.parseWithFallback(this.Atrule, consumeRaw);
              break;
            default:
              child = this.parseWithFallback(this.Rule, consumeRaw);
          }
          children.push(child);
        }
        return {
          type: "StyleSheet",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    3866: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const ASTERISK = 42;
      const VERTICALLINE = 124;
      function eatIdentifierOrAsterisk() {
        if (
          this.tokenType !== types.Ident &&
          this.isDelim(ASTERISK) === false
        ) {
          this.error("Identifier or asterisk is expected");
        }
        this.next();
      }
      const name = "TypeSelector";
      const structure = { name: String };
      function parse() {
        const start = this.tokenStart;
        if (this.isDelim(VERTICALLINE)) {
          this.next();
          eatIdentifierOrAsterisk.call(this);
        } else {
          eatIdentifierOrAsterisk.call(this);
          if (this.isDelim(VERTICALLINE)) {
            this.next();
            eatIdentifierOrAsterisk.call(this);
          }
        }
        return {
          type: "TypeSelector",
          loc: this.getLocation(start, this.tokenStart),
          name: this.substrToCursor(start),
        };
      }
      function generate(node) {
        this.tokenize(node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    1487: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const charCodeDefinitions = __nccwpck_require__(7332);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const QUESTIONMARK = 63;
      function eatHexSequence(offset, allowDash) {
        let len = 0;
        for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
          const code = this.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && len !== 0) {
            eatHexSequence.call(this, offset + len + 1, false);
            return -1;
          }
          if (!charCodeDefinitions.isHexDigit(code)) {
            this.error(
              allowDash && len !== 0
                ? "Hyphen minus" +
                    (len < 6 ? " or hex digit" : "") +
                    " is expected"
                : len < 6
                  ? "Hex digit is expected"
                  : "Unexpected input",
              pos,
            );
          }
          if (++len > 6) {
            this.error("Too many hex digits", pos);
          }
        }
        this.next();
        return len;
      }
      function eatQuestionMarkSequence(max) {
        let count = 0;
        while (this.isDelim(QUESTIONMARK)) {
          if (++count > max) {
            this.error("Too many question marks");
          }
          this.next();
        }
      }
      function startsWith(code) {
        if (this.charCodeAt(this.tokenStart) !== code) {
          this.error(
            (code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected",
          );
        }
      }
      function scanUnicodeRange() {
        let hexLength = 0;
        switch (this.tokenType) {
          case types.Number:
            hexLength = eatHexSequence.call(this, 1, true);
            if (this.isDelim(QUESTIONMARK)) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
              break;
            }
            if (
              this.tokenType === types.Dimension ||
              this.tokenType === types.Number
            ) {
              startsWith.call(this, HYPHENMINUS);
              eatHexSequence.call(this, 1, false);
              break;
            }
            break;
          case types.Dimension:
            hexLength = eatHexSequence.call(this, 1, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            break;
          default:
            this.eatDelim(PLUSSIGN);
            if (this.tokenType === types.Ident) {
              hexLength = eatHexSequence.call(this, 0, true);
              if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
              }
              break;
            }
            if (this.isDelim(QUESTIONMARK)) {
              this.next();
              eatQuestionMarkSequence.call(this, 5);
              break;
            }
            this.error("Hex digit or question mark is expected");
        }
      }
      const name = "UnicodeRange";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        this.eatIdent("u");
        scanUnicodeRange.call(this);
        return {
          type: "UnicodeRange",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substrToCursor(start),
        };
      }
      function generate(node) {
        this.tokenize(node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    7159: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const url = __nccwpck_require__(9056);
      const string = __nccwpck_require__(7688);
      const types = __nccwpck_require__(7783);
      const name = "Url";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        let value;
        switch (this.tokenType) {
          case types.Url:
            value = url.decode(this.consume(types.Url));
            break;
          case types.Function:
            if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
              this.error("Function name must be `url`");
            }
            this.eat(types.Function);
            this.skipSC();
            value = string.decode(this.consume(types.String));
            this.skipSC();
            if (!this.eof) {
              this.eat(types.RightParenthesis);
            }
            break;
          default:
            this.error("Url or Function is expected");
        }
        return {
          type: "Url",
          loc: this.getLocation(start, this.tokenStart),
          value,
        };
      }
      function generate(node) {
        this.token(types.Url, url.encode(node.value));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    805: (__unused_webpack_module, exports) => {
      "use strict";
      const name = "Value";
      const structure = { children: [[]] };
      function parse() {
        const start = this.tokenStart;
        const children = this.readSequence(this.scope.Value);
        return {
          type: "Value",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    3656: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const SPACE = Object.freeze({
        type: "WhiteSpace",
        loc: null,
        value: " ",
      });
      const name = "WhiteSpace";
      const structure = { value: String };
      function parse() {
        this.eat(types.WhiteSpace);
        return SPACE;
      }
      function generate(node) {
        this.token(types.WhiteSpace, node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    1080: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const AnPlusB = __nccwpck_require__(4215);
      const Atrule = __nccwpck_require__(8476);
      const AtrulePrelude = __nccwpck_require__(4484);
      const AttributeSelector = __nccwpck_require__(3495);
      const Block = __nccwpck_require__(4628);
      const Brackets = __nccwpck_require__(1983);
      const CDC = __nccwpck_require__(8517);
      const CDO = __nccwpck_require__(4925);
      const ClassSelector = __nccwpck_require__(4184);
      const Combinator = __nccwpck_require__(9518);
      const Comment = __nccwpck_require__(2283);
      const Declaration = __nccwpck_require__(6507);
      const DeclarationList = __nccwpck_require__(7700);
      const Dimension = __nccwpck_require__(4513);
      const Function = __nccwpck_require__(6607);
      const Hash = __nccwpck_require__(3165);
      const Identifier = __nccwpck_require__(5605);
      const IdSelector = __nccwpck_require__(2455);
      const MediaFeature = __nccwpck_require__(728);
      const MediaQuery = __nccwpck_require__(2631);
      const MediaQueryList = __nccwpck_require__(7164);
      const Nth = __nccwpck_require__(6189);
      const Number = __nccwpck_require__(5512);
      const Operator = __nccwpck_require__(3680);
      const Parentheses = __nccwpck_require__(8282);
      const Percentage = __nccwpck_require__(6339);
      const PseudoClassSelector = __nccwpck_require__(3672);
      const PseudoElementSelector = __nccwpck_require__(6578);
      const Ratio = __nccwpck_require__(3917);
      const Raw = __nccwpck_require__(8140);
      const Rule = __nccwpck_require__(1079);
      const Selector = __nccwpck_require__(3222);
      const SelectorList = __nccwpck_require__(5933);
      const String = __nccwpck_require__(6435);
      const StyleSheet = __nccwpck_require__(1121);
      const TypeSelector = __nccwpck_require__(3866);
      const UnicodeRange = __nccwpck_require__(1487);
      const Url = __nccwpck_require__(7159);
      const Value = __nccwpck_require__(805);
      const WhiteSpace = __nccwpck_require__(3656);
      exports.AnPlusB = AnPlusB.parse;
      exports.Atrule = Atrule.parse;
      exports.AtrulePrelude = AtrulePrelude.parse;
      exports.AttributeSelector = AttributeSelector.parse;
      exports.Block = Block.parse;
      exports.Brackets = Brackets.parse;
      exports.CDC = CDC.parse;
      exports.CDO = CDO.parse;
      exports.ClassSelector = ClassSelector.parse;
      exports.Combinator = Combinator.parse;
      exports.Comment = Comment.parse;
      exports.Declaration = Declaration.parse;
      exports.DeclarationList = DeclarationList.parse;
      exports.Dimension = Dimension.parse;
      exports.Function = Function.parse;
      exports.Hash = Hash.parse;
      exports.Identifier = Identifier.parse;
      exports.IdSelector = IdSelector.parse;
      exports.MediaFeature = MediaFeature.parse;
      exports.MediaQuery = MediaQuery.parse;
      exports.MediaQueryList = MediaQueryList.parse;
      exports.Nth = Nth.parse;
      exports.Number = Number.parse;
      exports.Operator = Operator.parse;
      exports.Parentheses = Parentheses.parse;
      exports.Percentage = Percentage.parse;
      exports.PseudoClassSelector = PseudoClassSelector.parse;
      exports.PseudoElementSelector = PseudoElementSelector.parse;
      exports.Ratio = Ratio.parse;
      exports.Raw = Raw.parse;
      exports.Rule = Rule.parse;
      exports.Selector = Selector.parse;
      exports.SelectorList = SelectorList.parse;
      exports.String = String.parse;
      exports.StyleSheet = StyleSheet.parse;
      exports.TypeSelector = TypeSelector.parse;
      exports.UnicodeRange = UnicodeRange.parse;
      exports.Url = Url.parse;
      exports.Value = Value.parse;
      exports.WhiteSpace = WhiteSpace.parse;
    },
    2168: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const AnPlusB = __nccwpck_require__(4215);
      const Atrule = __nccwpck_require__(8476);
      const AtrulePrelude = __nccwpck_require__(4484);
      const AttributeSelector = __nccwpck_require__(3495);
      const Block = __nccwpck_require__(4628);
      const Brackets = __nccwpck_require__(1983);
      const CDC = __nccwpck_require__(8517);
      const CDO = __nccwpck_require__(4925);
      const ClassSelector = __nccwpck_require__(4184);
      const Combinator = __nccwpck_require__(9518);
      const Comment = __nccwpck_require__(2283);
      const Declaration = __nccwpck_require__(6507);
      const DeclarationList = __nccwpck_require__(7700);
      const Dimension = __nccwpck_require__(4513);
      const Function = __nccwpck_require__(6607);
      const Hash = __nccwpck_require__(3165);
      const Identifier = __nccwpck_require__(5605);
      const IdSelector = __nccwpck_require__(2455);
      const MediaFeature = __nccwpck_require__(728);
      const MediaQuery = __nccwpck_require__(2631);
      const MediaQueryList = __nccwpck_require__(7164);
      const Nth = __nccwpck_require__(6189);
      const Number$1 = __nccwpck_require__(5512);
      const Operator = __nccwpck_require__(3680);
      const Parentheses = __nccwpck_require__(8282);
      const Percentage = __nccwpck_require__(6339);
      const PseudoClassSelector = __nccwpck_require__(3672);
      const PseudoElementSelector = __nccwpck_require__(6578);
      const Ratio = __nccwpck_require__(3917);
      const Raw = __nccwpck_require__(8140);
      const Rule = __nccwpck_require__(1079);
      const Selector = __nccwpck_require__(3222);
      const SelectorList = __nccwpck_require__(5933);
      const String$1 = __nccwpck_require__(6435);
      const StyleSheet = __nccwpck_require__(1121);
      const TypeSelector = __nccwpck_require__(3866);
      const UnicodeRange = __nccwpck_require__(1487);
      const Url = __nccwpck_require__(7159);
      const Value = __nccwpck_require__(805);
      const WhiteSpace = __nccwpck_require__(3656);
      exports.AnPlusB = AnPlusB;
      exports.Atrule = Atrule;
      exports.AtrulePrelude = AtrulePrelude;
      exports.AttributeSelector = AttributeSelector;
      exports.Block = Block;
      exports.Brackets = Brackets;
      exports.CDC = CDC;
      exports.CDO = CDO;
      exports.ClassSelector = ClassSelector;
      exports.Combinator = Combinator;
      exports.Comment = Comment;
      exports.Declaration = Declaration;
      exports.DeclarationList = DeclarationList;
      exports.Dimension = Dimension;
      exports.Function = Function;
      exports.Hash = Hash;
      exports.Identifier = Identifier;
      exports.IdSelector = IdSelector;
      exports.MediaFeature = MediaFeature;
      exports.MediaQuery = MediaQuery;
      exports.MediaQueryList = MediaQueryList;
      exports.Nth = Nth;
      exports.Number = Number$1;
      exports.Operator = Operator;
      exports.Parentheses = Parentheses;
      exports.Percentage = Percentage;
      exports.PseudoClassSelector = PseudoClassSelector;
      exports.PseudoElementSelector = PseudoElementSelector;
      exports.Ratio = Ratio;
      exports.Raw = Raw;
      exports.Rule = Rule;
      exports.Selector = Selector;
      exports.SelectorList = SelectorList;
      exports.String = String$1;
      exports.StyleSheet = StyleSheet;
      exports.TypeSelector = TypeSelector;
      exports.UnicodeRange = UnicodeRange;
      exports.Url = Url;
      exports.Value = Value;
      exports.WhiteSpace = WhiteSpace;
    },
    9072: (module) => {
      "use strict";
      const selectorList = {
        parse() {
          return this.createSingleNodeList(this.SelectorList());
        },
      };
      const selector = {
        parse() {
          return this.createSingleNodeList(this.Selector());
        },
      };
      const identList = {
        parse() {
          return this.createSingleNodeList(this.Identifier());
        },
      };
      const nth = {
        parse() {
          return this.createSingleNodeList(this.Nth());
        },
      };
      const pseudo = {
        dir: identList,
        has: selectorList,
        lang: identList,
        matches: selectorList,
        is: selectorList,
        "-moz-any": selectorList,
        "-webkit-any": selectorList,
        where: selectorList,
        not: selectorList,
        "nth-child": nth,
        "nth-last-child": nth,
        "nth-last-of-type": nth,
        "nth-of-type": nth,
        slotted: selector,
      };
      module.exports = pseudo;
    },
    3938: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const _default = __nccwpck_require__(2526);
      const atrulePrelude = { getNode: _default };
      module.exports = atrulePrelude;
    },
    2526: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const NUMBERSIGN = 35;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const SOLIDUS = 47;
      const U = 117;
      function defaultRecognizer(context) {
        switch (this.tokenType) {
          case types.Hash:
            return this.Hash();
          case types.Comma:
            return this.Operator();
          case types.LeftParenthesis:
            return this.Parentheses(this.readSequence, context.recognizer);
          case types.LeftSquareBracket:
            return this.Brackets(this.readSequence, context.recognizer);
          case types.String:
            return this.String();
          case types.Dimension:
            return this.Dimension();
          case types.Percentage:
            return this.Percentage();
          case types.Number:
            return this.Number();
          case types.Function:
            return this.cmpStr(this.tokenStart, this.tokenEnd, "url(")
              ? this.Url()
              : this.Function(this.readSequence, context.recognizer);
          case types.Url:
            return this.Url();
          case types.Ident:
            if (
              this.cmpChar(this.tokenStart, U) &&
              this.cmpChar(this.tokenStart + 1, PLUSSIGN)
            ) {
              return this.UnicodeRange();
            } else {
              return this.Identifier();
            }
          case types.Delim: {
            const code = this.charCodeAt(this.tokenStart);
            if (
              code === SOLIDUS ||
              code === ASTERISK ||
              code === PLUSSIGN ||
              code === HYPHENMINUS
            ) {
              return this.Operator();
            }
            if (code === NUMBERSIGN) {
              this.error("Hex or identifier is expected", this.tokenStart + 1);
            }
            break;
          }
        }
      }
      module.exports = defaultRecognizer;
    },
    7404: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const atrulePrelude = __nccwpck_require__(3938);
      const selector = __nccwpck_require__(8957);
      const value = __nccwpck_require__(3382);
      exports.AtrulePrelude = atrulePrelude;
      exports.Selector = selector;
      exports.Value = value;
    },
    8957: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const NUMBERSIGN = 35;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const SOLIDUS = 47;
      const FULLSTOP = 46;
      const GREATERTHANSIGN = 62;
      const VERTICALLINE = 124;
      const TILDE = 126;
      function onWhiteSpace(next, children) {
        if (
          children.last !== null &&
          children.last.type !== "Combinator" &&
          next !== null &&
          next.type !== "Combinator"
        ) {
          children.push({ type: "Combinator", loc: null, name: " " });
        }
      }
      function getNode() {
        switch (this.tokenType) {
          case types.LeftSquareBracket:
            return this.AttributeSelector();
          case types.Hash:
            return this.IdSelector();
          case types.Colon:
            if (this.lookupType(1) === types.Colon) {
              return this.PseudoElementSelector();
            } else {
              return this.PseudoClassSelector();
            }
          case types.Ident:
            return this.TypeSelector();
          case types.Number:
          case types.Percentage:
            return this.Percentage();
          case types.Dimension:
            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
              this.error("Identifier is expected", this.tokenStart + 1);
            }
            break;
          case types.Delim: {
            const code = this.charCodeAt(this.tokenStart);
            switch (code) {
              case PLUSSIGN:
              case GREATERTHANSIGN:
              case TILDE:
              case SOLIDUS:
                return this.Combinator();
              case FULLSTOP:
                return this.ClassSelector();
              case ASTERISK:
              case VERTICALLINE:
                return this.TypeSelector();
              case NUMBERSIGN:
                return this.IdSelector();
            }
            break;
          }
        }
      }
      const Selector = { onWhiteSpace, getNode };
      module.exports = Selector;
    },
    3382: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const _default = __nccwpck_require__(2526);
      const expression = __nccwpck_require__(7512);
      const _var = __nccwpck_require__(8058);
      function isPlusMinusOperator(node) {
        return (
          node !== null &&
          node.type === "Operator" &&
          (node.value[node.value.length - 1] === "-" ||
            node.value[node.value.length - 1] === "+")
        );
      }
      const value = {
        getNode: _default,
        onWhiteSpace(next, children) {
          if (isPlusMinusOperator(next)) {
            next.value = " " + next.value;
          }
          if (isPlusMinusOperator(children.last)) {
            children.last.value += " ";
          }
        },
        expression,
        var: _var,
      };
      module.exports = value;
    },
    7089: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const adoptBuffer = __nccwpck_require__(7780);
      const charCodeDefinitions = __nccwpck_require__(7332);
      const N = 10;
      const F = 12;
      const R = 13;
      function computeLinesAndColumns(host) {
        const source = host.source;
        const sourceLength = source.length;
        const startOffset =
          source.length > 0
            ? charCodeDefinitions.isBOM(source.charCodeAt(0))
            : 0;
        const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
        const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
        let line = host.startLine;
        let column = host.startColumn;
        for (let i = startOffset; i < sourceLength; i++) {
          const code = source.charCodeAt(i);
          lines[i] = line;
          columns[i] = column++;
          if (code === N || code === R || code === F) {
            if (
              code === R &&
              i + 1 < sourceLength &&
              source.charCodeAt(i + 1) === N
            ) {
              i++;
              lines[i] = line;
              columns[i] = column;
            }
            line++;
            column = 1;
          }
        }
        lines[sourceLength] = line;
        columns[sourceLength] = column;
        host.lines = lines;
        host.columns = columns;
        host.computed = true;
      }
      class OffsetToLocation {
        constructor() {
          this.lines = null;
          this.columns = null;
          this.computed = false;
        }
        setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
          this.source = source;
          this.startOffset = startOffset;
          this.startLine = startLine;
          this.startColumn = startColumn;
          this.computed = false;
        }
        getLocation(offset, filename) {
          if (!this.computed) {
            computeLinesAndColumns(this);
          }
          return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset],
          };
        }
        getLocationRange(start, end, filename) {
          if (!this.computed) {
            computeLinesAndColumns(this);
          }
          return {
            source: filename,
            start: {
              offset: this.startOffset + start,
              line: this.lines[start],
              column: this.columns[start],
            },
            end: {
              offset: this.startOffset + end,
              line: this.lines[end],
              column: this.columns[end],
            },
          };
        }
      }
      exports.OffsetToLocation = OffsetToLocation;
    },
    7978: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const adoptBuffer = __nccwpck_require__(7780);
      const utils = __nccwpck_require__(2850);
      const names = __nccwpck_require__(7755);
      const types = __nccwpck_require__(7783);
      const OFFSET_MASK = 16777215;
      const TYPE_SHIFT = 24;
      const balancePair = new Map([
        [types.Function, types.RightParenthesis],
        [types.LeftParenthesis, types.RightParenthesis],
        [types.LeftSquareBracket, types.RightSquareBracket],
        [types.LeftCurlyBracket, types.RightCurlyBracket],
      ]);
      class TokenStream {
        constructor(source, tokenize) {
          this.setSource(source, tokenize);
        }
        reset() {
          this.eof = false;
          this.tokenIndex = -1;
          this.tokenType = 0;
          this.tokenStart = this.firstCharOffset;
          this.tokenEnd = this.firstCharOffset;
        }
        setSource(source = "", tokenize = () => {}) {
          source = String(source || "");
          const sourceLength = source.length;
          const offsetAndType = adoptBuffer.adoptBuffer(
            this.offsetAndType,
            source.length + 1,
          );
          const balance = adoptBuffer.adoptBuffer(
            this.balance,
            source.length + 1,
          );
          let tokenCount = 0;
          let balanceCloseType = 0;
          let balanceStart = 0;
          let firstCharOffset = -1;
          this.offsetAndType = null;
          this.balance = null;
          tokenize(source, (type, start, end) => {
            switch (type) {
              default:
                balance[tokenCount] = sourceLength;
                break;
              case balanceCloseType: {
                let balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                  if (balance[balancePrev] === sourceLength) {
                    balance[balancePrev] = tokenCount;
                  }
                }
                break;
              }
              case types.LeftParenthesis:
              case types.Function:
              case types.LeftSquareBracket:
              case types.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = balancePair.get(type);
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
            }
            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;
            if (firstCharOffset === -1) {
              firstCharOffset = start;
            }
          });
          offsetAndType[tokenCount] = (types.EOF << TYPE_SHIFT) | sourceLength;
          balance[tokenCount] = sourceLength;
          balance[sourceLength] = sourceLength;
          while (balanceStart !== 0) {
            const balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balance[balancePrev] = sourceLength;
          }
          this.source = source;
          this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
          this.tokenCount = tokenCount;
          this.offsetAndType = offsetAndType;
          this.balance = balance;
          this.reset();
          this.next();
        }
        lookupType(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
          }
          return types.EOF;
        }
        lookupOffset(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
          }
          return this.source.length;
        }
        lookupValue(offset, referenceStr) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return utils.cmpStr(
              this.source,
              this.offsetAndType[offset - 1] & OFFSET_MASK,
              this.offsetAndType[offset] & OFFSET_MASK,
              referenceStr,
            );
          }
          return false;
        }
        getTokenStart(tokenIndex) {
          if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
          }
          if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
              ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
              : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
          }
          return this.firstCharOffset;
        }
        substrToCursor(start) {
          return this.source.substring(start, this.tokenStart);
        }
        isBalanceEdge(pos) {
          return this.balance[this.tokenIndex] < pos;
        }
        isDelim(code, offset) {
          if (offset) {
            return (
              this.lookupType(offset) === types.Delim &&
              this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
          }
          return (
            this.tokenType === types.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
          );
        }
        skip(tokenCount) {
          let next = this.tokenIndex + tokenCount;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.next();
          }
        }
        next() {
          let next = this.tokenIndex + 1;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.eof = true;
            this.tokenIndex = this.tokenCount;
            this.tokenType = types.EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
          }
        }
        skipSC() {
          while (
            this.tokenType === types.WhiteSpace ||
            this.tokenType === types.Comment
          ) {
            this.next();
          }
        }
        skipUntilBalanced(startToken, stopConsume) {
          let cursor = startToken;
          let balanceEnd;
          let offset;
          loop: for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            offset =
              cursor > 0
                ? this.offsetAndType[cursor - 1] & OFFSET_MASK
                : this.firstCharOffset;
            switch (stopConsume(this.source.charCodeAt(offset))) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
            }
          }
          this.skip(cursor - this.tokenIndex);
        }
        forEachToken(fn) {
          for (
            let i = 0, offset = this.firstCharOffset;
            i < this.tokenCount;
            i++
          ) {
            const start = offset;
            const item = this.offsetAndType[i];
            const end = item & OFFSET_MASK;
            const type = item >> TYPE_SHIFT;
            offset = end;
            fn(type, start, end, i);
          }
        }
        dump() {
          const tokens = new Array(this.tokenCount);
          this.forEachToken((type, start, end, index) => {
            tokens[index] = {
              idx: index,
              type: names[type],
              chunk: this.source.substring(start, end),
              balance: this.balance[index],
            };
          });
          return tokens;
        }
      }
      exports.TokenStream = TokenStream;
    },
    7780: (__unused_webpack_module, exports) => {
      "use strict";
      const MIN_SIZE = 16 * 1024;
      function adoptBuffer(buffer = null, size) {
        if (buffer === null || buffer.length < size) {
          return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
        }
        return buffer;
      }
      exports.adoptBuffer = adoptBuffer;
    },
    7332: (__unused_webpack_module, exports) => {
      "use strict";
      const EOF = 0;
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isHexDigit(code) {
        return (
          isDigit(code) ||
          (code >= 65 && code <= 70) ||
          (code >= 97 && code <= 102)
        );
      }
      function isUppercaseLetter(code) {
        return code >= 65 && code <= 90;
      }
      function isLowercaseLetter(code) {
        return code >= 97 && code <= 122;
      }
      function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
      }
      function isNonAscii(code) {
        return code >= 128;
      }
      function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 95;
      }
      function isName(code) {
        return isNameStart(code) || isDigit(code) || code === 45;
      }
      function isNonPrintable(code) {
        return (
          (code >= 0 && code <= 8) ||
          code === 11 ||
          (code >= 14 && code <= 31) ||
          code === 127
        );
      }
      function isNewline(code) {
        return code === 10 || code === 13 || code === 12;
      }
      function isWhiteSpace(code) {
        return isNewline(code) || code === 32 || code === 9;
      }
      function isValidEscape(first, second) {
        if (first !== 92) {
          return false;
        }
        if (isNewline(second) || second === EOF) {
          return false;
        }
        return true;
      }
      function isIdentifierStart(first, second, third) {
        if (first === 45) {
          return (
            isNameStart(second) || second === 45 || isValidEscape(second, third)
          );
        }
        if (isNameStart(first)) {
          return true;
        }
        if (first === 92) {
          return isValidEscape(first, second);
        }
        return false;
      }
      function isNumberStart(first, second, third) {
        if (first === 43 || first === 45) {
          if (isDigit(second)) {
            return 2;
          }
          return second === 46 && isDigit(third) ? 3 : 0;
        }
        if (first === 46) {
          return isDigit(second) ? 2 : 0;
        }
        if (isDigit(first)) {
          return 1;
        }
        return 0;
      }
      function isBOM(code) {
        if (code === 65279) {
          return 1;
        }
        if (code === 65534) {
          return 1;
        }
        return 0;
      }
      const CATEGORY = new Array(128);
      const EofCategory = 128;
      const WhiteSpaceCategory = 130;
      const DigitCategory = 131;
      const NameStartCategory = 132;
      const NonPrintableCategory = 133;
      for (let i = 0; i < CATEGORY.length; i++) {
        CATEGORY[i] =
          (isWhiteSpace(i) && WhiteSpaceCategory) ||
          (isDigit(i) && DigitCategory) ||
          (isNameStart(i) && NameStartCategory) ||
          (isNonPrintable(i) && NonPrintableCategory) ||
          i ||
          EofCategory;
      }
      function charCodeCategory(code) {
        return code < 128 ? CATEGORY[code] : NameStartCategory;
      }
      exports.DigitCategory = DigitCategory;
      exports.EofCategory = EofCategory;
      exports.NameStartCategory = NameStartCategory;
      exports.NonPrintableCategory = NonPrintableCategory;
      exports.WhiteSpaceCategory = WhiteSpaceCategory;
      exports.charCodeCategory = charCodeCategory;
      exports.isBOM = isBOM;
      exports.isDigit = isDigit;
      exports.isHexDigit = isHexDigit;
      exports.isIdentifierStart = isIdentifierStart;
      exports.isLetter = isLetter;
      exports.isLowercaseLetter = isLowercaseLetter;
      exports.isName = isName;
      exports.isNameStart = isNameStart;
      exports.isNewline = isNewline;
      exports.isNonAscii = isNonAscii;
      exports.isNonPrintable = isNonPrintable;
      exports.isNumberStart = isNumberStart;
      exports.isUppercaseLetter = isUppercaseLetter;
      exports.isValidEscape = isValidEscape;
      exports.isWhiteSpace = isWhiteSpace;
    },
    8008: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(7783);
      const charCodeDefinitions = __nccwpck_require__(7332);
      const utils = __nccwpck_require__(2850);
      const names = __nccwpck_require__(7755);
      const OffsetToLocation = __nccwpck_require__(7089);
      const TokenStream = __nccwpck_require__(7978);
      function tokenize(source, onToken) {
        function getCharCode(offset) {
          return offset < sourceLength ? source.charCodeAt(offset) : 0;
        }
        function consumeNumericToken() {
          offset = utils.consumeNumber(source, offset);
          if (
            charCodeDefinitions.isIdentifierStart(
              getCharCode(offset),
              getCharCode(offset + 1),
              getCharCode(offset + 2),
            )
          ) {
            type = types.Dimension;
            offset = utils.consumeName(source, offset);
            return;
          }
          if (getCharCode(offset) === 37) {
            type = types.Percentage;
            offset++;
            return;
          }
          type = types.Number;
        }
        function consumeIdentLikeToken() {
          const nameStartOffset = offset;
          offset = utils.consumeName(source, offset);
          if (
            utils.cmpStr(source, nameStartOffset, offset, "url") &&
            getCharCode(offset) === 40
          ) {
            offset = utils.findWhiteSpaceEnd(source, offset + 1);
            if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
              type = types.Function;
              offset = nameStartOffset + 4;
              return;
            }
            consumeUrlToken();
            return;
          }
          if (getCharCode(offset) === 40) {
            type = types.Function;
            offset++;
            return;
          }
          type = types.Ident;
        }
        function consumeStringToken(endingCodePoint) {
          if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
          }
          type = types.String;
          for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);
            switch (charCodeDefinitions.charCodeCategory(code)) {
              case endingCodePoint:
                offset++;
                return;
              case charCodeDefinitions.WhiteSpaceCategory:
                if (charCodeDefinitions.isNewline(code)) {
                  offset += utils.getNewlineLength(source, offset, code);
                  type = types.BadString;
                  return;
                }
                break;
              case 92:
                if (offset === source.length - 1) {
                  break;
                }
                const nextCode = getCharCode(offset + 1);
                if (charCodeDefinitions.isNewline(nextCode)) {
                  offset += utils.getNewlineLength(
                    source,
                    offset + 1,
                    nextCode,
                  );
                } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
                  offset = utils.consumeEscaped(source, offset) - 1;
                }
                break;
            }
          }
        }
        function consumeUrlToken() {
          type = types.Url;
          offset = utils.findWhiteSpaceEnd(source, offset);
          for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);
            switch (charCodeDefinitions.charCodeCategory(code)) {
              case 41:
                offset++;
                return;
              case charCodeDefinitions.WhiteSpaceCategory:
                offset = utils.findWhiteSpaceEnd(source, offset);
                if (getCharCode(offset) === 41 || offset >= source.length) {
                  if (offset < source.length) {
                    offset++;
                  }
                  return;
                }
                offset = utils.consumeBadUrlRemnants(source, offset);
                type = types.BadUrl;
                return;
              case 34:
              case 39:
              case 40:
              case charCodeDefinitions.NonPrintableCategory:
                offset = utils.consumeBadUrlRemnants(source, offset);
                type = types.BadUrl;
                return;
              case 92:
                if (
                  charCodeDefinitions.isValidEscape(
                    code,
                    getCharCode(offset + 1),
                  )
                ) {
                  offset = utils.consumeEscaped(source, offset) - 1;
                  break;
                }
                offset = utils.consumeBadUrlRemnants(source, offset);
                type = types.BadUrl;
                return;
            }
          }
        }
        source = String(source || "");
        const sourceLength = source.length;
        let start = charCodeDefinitions.isBOM(getCharCode(0));
        let offset = start;
        let type;
        while (offset < sourceLength) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            case charCodeDefinitions.WhiteSpaceCategory:
              type = types.WhiteSpace;
              offset = utils.findWhiteSpaceEnd(source, offset + 1);
              break;
            case 34:
              consumeStringToken();
              break;
            case 35:
              if (
                charCodeDefinitions.isName(getCharCode(offset + 1)) ||
                charCodeDefinitions.isValidEscape(
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                type = types.Hash;
                offset = utils.consumeName(source, offset + 1);
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 39:
              consumeStringToken();
              break;
            case 40:
              type = types.LeftParenthesis;
              offset++;
              break;
            case 41:
              type = types.RightParenthesis;
              offset++;
              break;
            case 43:
              if (
                charCodeDefinitions.isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 44:
              type = types.Comma;
              offset++;
              break;
            case 45:
              if (
                charCodeDefinitions.isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                if (
                  getCharCode(offset + 1) === 45 &&
                  getCharCode(offset + 2) === 62
                ) {
                  type = types.CDC;
                  offset = offset + 3;
                } else {
                  if (
                    charCodeDefinitions.isIdentifierStart(
                      code,
                      getCharCode(offset + 1),
                      getCharCode(offset + 2),
                    )
                  ) {
                    consumeIdentLikeToken();
                  } else {
                    type = types.Delim;
                    offset++;
                  }
                }
              }
              break;
            case 46:
              if (
                charCodeDefinitions.isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 47:
              if (getCharCode(offset + 1) === 42) {
                type = types.Comment;
                offset = source.indexOf("*/", offset + 2);
                offset = offset === -1 ? source.length : offset + 2;
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 58:
              type = types.Colon;
              offset++;
              break;
            case 59:
              type = types.Semicolon;
              offset++;
              break;
            case 60:
              if (
                getCharCode(offset + 1) === 33 &&
                getCharCode(offset + 2) === 45 &&
                getCharCode(offset + 3) === 45
              ) {
                type = types.CDO;
                offset = offset + 4;
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 64:
              if (
                charCodeDefinitions.isIdentifierStart(
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                  getCharCode(offset + 3),
                )
              ) {
                type = types.AtKeyword;
                offset = utils.consumeName(source, offset + 1);
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 91:
              type = types.LeftSquareBracket;
              offset++;
              break;
            case 92:
              if (
                charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))
              ) {
                consumeIdentLikeToken();
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 93:
              type = types.RightSquareBracket;
              offset++;
              break;
            case 123:
              type = types.LeftCurlyBracket;
              offset++;
              break;
            case 125:
              type = types.RightCurlyBracket;
              offset++;
              break;
            case charCodeDefinitions.DigitCategory:
              consumeNumericToken();
              break;
            case charCodeDefinitions.NameStartCategory:
              consumeIdentLikeToken();
              break;
            default:
              type = types.Delim;
              offset++;
          }
          onToken(type, start, (start = offset));
        }
      }
      exports.AtKeyword = types.AtKeyword;
      exports.BadString = types.BadString;
      exports.BadUrl = types.BadUrl;
      exports.CDC = types.CDC;
      exports.CDO = types.CDO;
      exports.Colon = types.Colon;
      exports.Comma = types.Comma;
      exports.Comment = types.Comment;
      exports.Delim = types.Delim;
      exports.Dimension = types.Dimension;
      exports.EOF = types.EOF;
      exports.Function = types.Function;
      exports.Hash = types.Hash;
      exports.Ident = types.Ident;
      exports.LeftCurlyBracket = types.LeftCurlyBracket;
      exports.LeftParenthesis = types.LeftParenthesis;
      exports.LeftSquareBracket = types.LeftSquareBracket;
      exports.Number = types.Number;
      exports.Percentage = types.Percentage;
      exports.RightCurlyBracket = types.RightCurlyBracket;
      exports.RightParenthesis = types.RightParenthesis;
      exports.RightSquareBracket = types.RightSquareBracket;
      exports.Semicolon = types.Semicolon;
      exports.String = types.String;
      exports.Url = types.Url;
      exports.WhiteSpace = types.WhiteSpace;
      exports.tokenTypes = types;
      exports.DigitCategory = charCodeDefinitions.DigitCategory;
      exports.EofCategory = charCodeDefinitions.EofCategory;
      exports.NameStartCategory = charCodeDefinitions.NameStartCategory;
      exports.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
      exports.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
      exports.charCodeCategory = charCodeDefinitions.charCodeCategory;
      exports.isBOM = charCodeDefinitions.isBOM;
      exports.isDigit = charCodeDefinitions.isDigit;
      exports.isHexDigit = charCodeDefinitions.isHexDigit;
      exports.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
      exports.isLetter = charCodeDefinitions.isLetter;
      exports.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
      exports.isName = charCodeDefinitions.isName;
      exports.isNameStart = charCodeDefinitions.isNameStart;
      exports.isNewline = charCodeDefinitions.isNewline;
      exports.isNonAscii = charCodeDefinitions.isNonAscii;
      exports.isNonPrintable = charCodeDefinitions.isNonPrintable;
      exports.isNumberStart = charCodeDefinitions.isNumberStart;
      exports.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
      exports.isValidEscape = charCodeDefinitions.isValidEscape;
      exports.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
      exports.cmpChar = utils.cmpChar;
      exports.cmpStr = utils.cmpStr;
      exports.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
      exports.consumeEscaped = utils.consumeEscaped;
      exports.consumeName = utils.consumeName;
      exports.consumeNumber = utils.consumeNumber;
      exports.decodeEscaped = utils.decodeEscaped;
      exports.findDecimalNumberEnd = utils.findDecimalNumberEnd;
      exports.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
      exports.findWhiteSpaceStart = utils.findWhiteSpaceStart;
      exports.getNewlineLength = utils.getNewlineLength;
      exports.tokenNames = names;
      exports.OffsetToLocation = OffsetToLocation.OffsetToLocation;
      exports.TokenStream = TokenStream.TokenStream;
      exports.tokenize = tokenize;
    },
    7755: (module) => {
      "use strict";
      const tokenNames = [
        "EOF-token",
        "ident-token",
        "function-token",
        "at-keyword-token",
        "hash-token",
        "string-token",
        "bad-string-token",
        "url-token",
        "bad-url-token",
        "delim-token",
        "number-token",
        "percentage-token",
        "dimension-token",
        "whitespace-token",
        "CDO-token",
        "CDC-token",
        "colon-token",
        "semicolon-token",
        "comma-token",
        "[-token",
        "]-token",
        "(-token",
        ")-token",
        "{-token",
        "}-token",
      ];
      module.exports = tokenNames;
    },
    7783: (__unused_webpack_module, exports) => {
      "use strict";
      const EOF = 0;
      const Ident = 1;
      const Function = 2;
      const AtKeyword = 3;
      const Hash = 4;
      const String = 5;
      const BadString = 6;
      const Url = 7;
      const BadUrl = 8;
      const Delim = 9;
      const Number = 10;
      const Percentage = 11;
      const Dimension = 12;
      const WhiteSpace = 13;
      const CDO = 14;
      const CDC = 15;
      const Colon = 16;
      const Semicolon = 17;
      const Comma = 18;
      const LeftSquareBracket = 19;
      const RightSquareBracket = 20;
      const LeftParenthesis = 21;
      const RightParenthesis = 22;
      const LeftCurlyBracket = 23;
      const RightCurlyBracket = 24;
      const Comment = 25;
      exports.AtKeyword = AtKeyword;
      exports.BadString = BadString;
      exports.BadUrl = BadUrl;
      exports.CDC = CDC;
      exports.CDO = CDO;
      exports.Colon = Colon;
      exports.Comma = Comma;
      exports.Comment = Comment;
      exports.Delim = Delim;
      exports.Dimension = Dimension;
      exports.EOF = EOF;
      exports.Function = Function;
      exports.Hash = Hash;
      exports.Ident = Ident;
      exports.LeftCurlyBracket = LeftCurlyBracket;
      exports.LeftParenthesis = LeftParenthesis;
      exports.LeftSquareBracket = LeftSquareBracket;
      exports.Number = Number;
      exports.Percentage = Percentage;
      exports.RightCurlyBracket = RightCurlyBracket;
      exports.RightParenthesis = RightParenthesis;
      exports.RightSquareBracket = RightSquareBracket;
      exports.Semicolon = Semicolon;
      exports.String = String;
      exports.Url = Url;
      exports.WhiteSpace = WhiteSpace;
    },
    2850: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(7332);
      function getCharCode(source, offset) {
        return offset < source.length ? source.charCodeAt(offset) : 0;
      }
      function getNewlineLength(source, offset, code) {
        if (code === 13 && getCharCode(source, offset + 1) === 10) {
          return 2;
        }
        return 1;
      }
      function cmpChar(testStr, offset, referenceCode) {
        let code = testStr.charCodeAt(offset);
        if (charCodeDefinitions.isUppercaseLetter(code)) {
          code = code | 32;
        }
        return code === referenceCode;
      }
      function cmpStr(testStr, start, end, referenceStr) {
        if (end - start !== referenceStr.length) {
          return false;
        }
        if (start < 0 || end > testStr.length) {
          return false;
        }
        for (let i = start; i < end; i++) {
          const referenceCode = referenceStr.charCodeAt(i - start);
          let testCode = testStr.charCodeAt(i);
          if (charCodeDefinitions.isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function findWhiteSpaceStart(source, offset) {
        for (; offset >= 0; offset--) {
          if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset + 1;
      }
      function findWhiteSpaceEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function findDecimalNumberEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function consumeEscaped(source, offset) {
        offset += 2;
        if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
          for (
            const maxOffset = Math.min(source.length, offset + 5);
            offset < maxOffset;
            offset++
          ) {
            if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
              break;
            }
          }
          const code = getCharCode(source, offset);
          if (charCodeDefinitions.isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
          }
        }
        return offset;
      }
      function consumeName(source, offset) {
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          if (charCodeDefinitions.isName(code)) {
            continue;
          }
          if (
            charCodeDefinitions.isValidEscape(
              code,
              getCharCode(source, offset + 1),
            )
          ) {
            offset = consumeEscaped(source, offset) - 1;
            continue;
          }
          break;
        }
        return offset;
      }
      function consumeNumber(source, offset) {
        let code = source.charCodeAt(offset);
        if (code === 43 || code === 45) {
          code = source.charCodeAt((offset += 1));
        }
        if (charCodeDefinitions.isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1);
          code = source.charCodeAt(offset);
        }
        if (
          code === 46 &&
          charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))
        ) {
          offset += 2;
          offset = findDecimalNumberEnd(source, offset);
        }
        if (cmpChar(source, offset, 101)) {
          let sign = 0;
          code = source.charCodeAt(offset + 1);
          if (code === 45 || code === 43) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
          }
          if (charCodeDefinitions.isDigit(code)) {
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
          }
        }
        return offset;
      }
      function consumeBadUrlRemnants(source, offset) {
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          if (code === 41) {
            offset++;
            break;
          }
          if (
            charCodeDefinitions.isValidEscape(
              code,
              getCharCode(source, offset + 1),
            )
          ) {
            offset = consumeEscaped(source, offset);
          }
        }
        return offset;
      }
      function decodeEscaped(escaped) {
        if (
          escaped.length === 1 &&
          !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))
        ) {
          return escaped[0];
        }
        let code = parseInt(escaped, 16);
        if (code === 0 || (code >= 55296 && code <= 57343) || code > 1114111) {
          code = 65533;
        }
        return String.fromCodePoint(code);
      }
      exports.cmpChar = cmpChar;
      exports.cmpStr = cmpStr;
      exports.consumeBadUrlRemnants = consumeBadUrlRemnants;
      exports.consumeEscaped = consumeEscaped;
      exports.consumeName = consumeName;
      exports.consumeNumber = consumeNumber;
      exports.decodeEscaped = decodeEscaped;
      exports.findDecimalNumberEnd = findDecimalNumberEnd;
      exports.findWhiteSpaceEnd = findWhiteSpaceEnd;
      exports.findWhiteSpaceStart = findWhiteSpaceStart;
      exports.getNewlineLength = getNewlineLength;
    },
    3681: (__unused_webpack_module, exports) => {
      "use strict";
      let releasedCursors = null;
      class List {
        static createItem(data) {
          return { prev: null, next: null, data };
        }
        constructor() {
          this.head = null;
          this.tail = null;
          this.cursor = null;
        }
        createItem(data) {
          return List.createItem(data);
        }
        allocateCursor(prev, next) {
          let cursor;
          if (releasedCursors !== null) {
            cursor = releasedCursors;
            releasedCursors = releasedCursors.cursor;
            cursor.prev = prev;
            cursor.next = next;
            cursor.cursor = this.cursor;
          } else {
            cursor = { prev, next, cursor: this.cursor };
          }
          this.cursor = cursor;
          return cursor;
        }
        releaseCursor() {
          const { cursor } = this;
          this.cursor = cursor.cursor;
          cursor.prev = null;
          cursor.next = null;
          cursor.cursor = releasedCursors;
          releasedCursors = cursor;
        }
        updateCursors(prevOld, prevNew, nextOld, nextNew) {
          let { cursor } = this;
          while (cursor !== null) {
            if (cursor.prev === prevOld) {
              cursor.prev = prevNew;
            }
            if (cursor.next === nextOld) {
              cursor.next = nextNew;
            }
            cursor = cursor.cursor;
          }
        }
        *[Symbol.iterator]() {
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            yield cursor.data;
          }
        }
        get size() {
          let size = 0;
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            size++;
          }
          return size;
        }
        get isEmpty() {
          return this.head === null;
        }
        get first() {
          return this.head && this.head.data;
        }
        get last() {
          return this.tail && this.tail.data;
        }
        fromArray(array) {
          let cursor = null;
          this.head = null;
          for (let data of array) {
            const item = List.createItem(data);
            if (cursor !== null) {
              cursor.next = item;
            } else {
              this.head = item;
            }
            item.prev = cursor;
            cursor = item;
          }
          this.tail = cursor;
          return this;
        }
        toArray() {
          return [...this];
        }
        toJSON() {
          return [...this];
        }
        forEach(fn, thisArg = this) {
          const cursor = this.allocateCursor(null, this.head);
          while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            fn.call(thisArg, item.data, item, this);
          }
          this.releaseCursor();
        }
        forEachRight(fn, thisArg = this) {
          const cursor = this.allocateCursor(this.tail, null);
          while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            fn.call(thisArg, item.data, item, this);
          }
          this.releaseCursor();
        }
        reduce(fn, initialValue, thisArg = this) {
          let cursor = this.allocateCursor(null, this.head);
          let acc = initialValue;
          let item;
          while (cursor.next !== null) {
            item = cursor.next;
            cursor.next = item.next;
            acc = fn.call(thisArg, acc, item.data, item, this);
          }
          this.releaseCursor();
          return acc;
        }
        reduceRight(fn, initialValue, thisArg = this) {
          let cursor = this.allocateCursor(this.tail, null);
          let acc = initialValue;
          let item;
          while (cursor.prev !== null) {
            item = cursor.prev;
            cursor.prev = item.prev;
            acc = fn.call(thisArg, acc, item.data, item, this);
          }
          this.releaseCursor();
          return acc;
        }
        some(fn, thisArg = this) {
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
              return true;
            }
          }
          return false;
        }
        map(fn, thisArg = this) {
          const result = new List();
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            result.appendData(fn.call(thisArg, cursor.data, cursor, this));
          }
          return result;
        }
        filter(fn, thisArg = this) {
          const result = new List();
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
              result.appendData(cursor.data);
            }
          }
          return result;
        }
        nextUntil(start, fn, thisArg = this) {
          if (start === null) {
            return;
          }
          const cursor = this.allocateCursor(null, start);
          while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            if (fn.call(thisArg, item.data, item, this)) {
              break;
            }
          }
          this.releaseCursor();
        }
        prevUntil(start, fn, thisArg = this) {
          if (start === null) {
            return;
          }
          const cursor = this.allocateCursor(start, null);
          while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            if (fn.call(thisArg, item.data, item, this)) {
              break;
            }
          }
          this.releaseCursor();
        }
        clear() {
          this.head = null;
          this.tail = null;
        }
        copy() {
          const result = new List();
          for (let data of this) {
            result.appendData(data);
          }
          return result;
        }
        prepend(item) {
          this.updateCursors(null, item, this.head, item);
          if (this.head !== null) {
            this.head.prev = item;
            item.next = this.head;
          } else {
            this.tail = item;
          }
          this.head = item;
          return this;
        }
        prependData(data) {
          return this.prepend(List.createItem(data));
        }
        append(item) {
          return this.insert(item);
        }
        appendData(data) {
          return this.insert(List.createItem(data));
        }
        insert(item, before = null) {
          if (before !== null) {
            this.updateCursors(before.prev, item, before, item);
            if (before.prev === null) {
              if (this.head !== before) {
                throw new Error("before doesn't belong to list");
              }
              this.head = item;
              before.prev = item;
              item.next = before;
              this.updateCursors(null, item);
            } else {
              before.prev.next = item;
              item.prev = before.prev;
              before.prev = item;
              item.next = before;
            }
          } else {
            this.updateCursors(this.tail, item, null, item);
            if (this.tail !== null) {
              this.tail.next = item;
              item.prev = this.tail;
            } else {
              this.head = item;
            }
            this.tail = item;
          }
          return this;
        }
        insertData(data, before) {
          return this.insert(List.createItem(data), before);
        }
        remove(item) {
          this.updateCursors(item, item.prev, item, item.next);
          if (item.prev !== null) {
            item.prev.next = item.next;
          } else {
            if (this.head !== item) {
              throw new Error("item doesn't belong to list");
            }
            this.head = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          } else {
            if (this.tail !== item) {
              throw new Error("item doesn't belong to list");
            }
            this.tail = item.prev;
          }
          item.prev = null;
          item.next = null;
          return item;
        }
        push(data) {
          this.insert(List.createItem(data));
        }
        pop() {
          return this.tail !== null ? this.remove(this.tail) : null;
        }
        unshift(data) {
          this.prepend(List.createItem(data));
        }
        shift() {
          return this.head !== null ? this.remove(this.head) : null;
        }
        prependList(list) {
          return this.insertList(list, this.head);
        }
        appendList(list) {
          return this.insertList(list);
        }
        insertList(list, before) {
          if (list.head === null) {
            return this;
          }
          if (before !== undefined && before !== null) {
            this.updateCursors(before.prev, list.tail, before, list.head);
            if (before.prev !== null) {
              before.prev.next = list.head;
              list.head.prev = before.prev;
            } else {
              this.head = list.head;
            }
            before.prev = list.tail;
            list.tail.next = before;
          } else {
            this.updateCursors(this.tail, list.tail, null, list.head);
            if (this.tail !== null) {
              this.tail.next = list.head;
              list.head.prev = this.tail;
            } else {
              this.head = list.head;
            }
            this.tail = list.tail;
          }
          list.head = null;
          list.tail = null;
          return this;
        }
        replace(oldItem, newItemOrList) {
          if ("head" in newItemOrList) {
            this.insertList(newItemOrList, oldItem);
          } else {
            this.insert(newItemOrList, oldItem);
          }
          this.remove(oldItem);
        }
      }
      exports.List = List;
    },
    5250: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(3681);
      function clone(node) {
        const result = {};
        for (const key in node) {
          let value = node[key];
          if (value) {
            if (Array.isArray(value) || value instanceof List.List) {
              value = value.map(clone);
            } else if (value.constructor === Object) {
              value = clone(value);
            }
          }
          result[key] = value;
        }
        return result;
      }
      exports.clone = clone;
    },
    6893: (__unused_webpack_module, exports) => {
      "use strict";
      function createCustomError(name, message) {
        const error = Object.create(SyntaxError.prototype);
        const errorStack = new Error();
        return Object.assign(error, {
          name,
          message,
          get stack() {
            return (errorStack.stack || "").replace(
              /^(.+\n){1,3}/,
              `${name}: ${message}\n`,
            );
          },
        });
      }
      exports.createCustomError = createCustomError;
    },
    5286: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(7332);
      const utils = __nccwpck_require__(2850);
      const REVERSE_SOLIDUS = 92;
      function decode(str) {
        const end = str.length - 1;
        let decoded = "";
        for (let i = 0; i < str.length; i++) {
          let code = str.charCodeAt(i);
          if (code === REVERSE_SOLIDUS) {
            if (i === end) {
              break;
            }
            code = str.charCodeAt(++i);
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
              const escapeStart = i - 1;
              const escapeEnd = utils.consumeEscaped(str, escapeStart);
              i = escapeEnd - 1;
              decoded += utils.decodeEscaped(
                str.substring(escapeStart + 1, escapeEnd),
              );
            } else {
              if (code === 13 && str.charCodeAt(i + 1) === 10) {
                i++;
              }
            }
          } else {
            decoded += str[i];
          }
        }
        return decoded;
      }
      function encode(str) {
        let encoded = "";
        if (str.length === 1 && str.charCodeAt(0) === 45) {
          return "\\-";
        }
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code === 0) {
            encoded += "�";
            continue;
          }
          if (
            code <= 31 ||
            code === 127 ||
            (code >= 48 &&
              code <= 57 &&
              (i === 0 || (i === 1 && str.charCodeAt(0) === 45)))
          ) {
            encoded += "\\" + code.toString(16) + " ";
            continue;
          }
          if (charCodeDefinitions.isName(code)) {
            encoded += str.charAt(i);
          } else {
            encoded += "\\" + str.charAt(i);
          }
        }
        return encoded;
      }
      exports.decode = decode;
      exports.encode = encode;
    },
    627: (__unused_webpack_module, exports) => {
      "use strict";
      const keywords = new Map();
      const properties = new Map();
      const HYPHENMINUS = 45;
      const keyword = getKeywordDescriptor;
      const property = getPropertyDescriptor;
      const vendorPrefix = getVendorPrefix;
      function isCustomProperty(str, offset) {
        offset = offset || 0;
        return (
          str.length - offset >= 2 &&
          str.charCodeAt(offset) === HYPHENMINUS &&
          str.charCodeAt(offset + 1) === HYPHENMINUS
        );
      }
      function getVendorPrefix(str, offset) {
        offset = offset || 0;
        if (str.length - offset >= 3) {
          if (
            str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS
          ) {
            const secondDashIndex = str.indexOf("-", offset + 2);
            if (secondDashIndex !== -1) {
              return str.substring(offset, secondDashIndex + 1);
            }
          }
        }
        return "";
      }
      function getKeywordDescriptor(keyword) {
        if (keywords.has(keyword)) {
          return keywords.get(keyword);
        }
        const name = keyword.toLowerCase();
        let descriptor = keywords.get(name);
        if (descriptor === undefined) {
          const custom = isCustomProperty(name, 0);
          const vendor = !custom ? getVendorPrefix(name, 0) : "";
          descriptor = Object.freeze({
            basename: name.substr(vendor.length),
            name,
            prefix: vendor,
            vendor,
            custom,
          });
        }
        keywords.set(keyword, descriptor);
        return descriptor;
      }
      function getPropertyDescriptor(property) {
        if (properties.has(property)) {
          return properties.get(property);
        }
        let name = property;
        let hack = property[0];
        if (hack === "/") {
          hack = property[1] === "/" ? "//" : "/";
        } else if (
          hack !== "_" &&
          hack !== "*" &&
          hack !== "$" &&
          hack !== "#" &&
          hack !== "+" &&
          hack !== "&"
        ) {
          hack = "";
        }
        const custom = isCustomProperty(name, hack.length);
        if (!custom) {
          name = name.toLowerCase();
          if (properties.has(name)) {
            const descriptor = properties.get(name);
            properties.set(property, descriptor);
            return descriptor;
          }
        }
        const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
        const prefix = name.substr(0, hack.length + vendor.length);
        const descriptor = Object.freeze({
          basename: name.substr(prefix.length),
          name: name.substr(hack.length),
          hack,
          vendor,
          prefix,
          custom,
        });
        properties.set(property, descriptor);
        return descriptor;
      }
      exports.isCustomProperty = isCustomProperty;
      exports.keyword = keyword;
      exports.property = property;
      exports.vendorPrefix = vendorPrefix;
    },
    7688: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(7332);
      const utils = __nccwpck_require__(2850);
      const REVERSE_SOLIDUS = 92;
      const QUOTATION_MARK = 34;
      const APOSTROPHE = 39;
      function decode(str) {
        const len = str.length;
        const firstChar = str.charCodeAt(0);
        const start =
          firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
        const end =
          start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar
            ? len - 2
            : len - 1;
        let decoded = "";
        for (let i = start; i <= end; i++) {
          let code = str.charCodeAt(i);
          if (code === REVERSE_SOLIDUS) {
            if (i === end) {
              if (i !== len - 1) {
                decoded = str.substr(i + 1);
              }
              break;
            }
            code = str.charCodeAt(++i);
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
              const escapeStart = i - 1;
              const escapeEnd = utils.consumeEscaped(str, escapeStart);
              i = escapeEnd - 1;
              decoded += utils.decodeEscaped(
                str.substring(escapeStart + 1, escapeEnd),
              );
            } else {
              if (code === 13 && str.charCodeAt(i + 1) === 10) {
                i++;
              }
            }
          } else {
            decoded += str[i];
          }
        }
        return decoded;
      }
      function encode(str, apostrophe) {
        const quote = apostrophe ? "'" : '"';
        const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
        let encoded = "";
        let wsBeforeHexIsNeeded = false;
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code === 0) {
            encoded += "�";
            continue;
          }
          if (code <= 31 || code === 127) {
            encoded += "\\" + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
          }
          if (code === quoteCode || code === REVERSE_SOLIDUS) {
            encoded += "\\" + str.charAt(i);
            wsBeforeHexIsNeeded = false;
          } else {
            if (
              wsBeforeHexIsNeeded &&
              (charCodeDefinitions.isHexDigit(code) ||
                charCodeDefinitions.isWhiteSpace(code))
            ) {
              encoded += " ";
            }
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
          }
        }
        return quote + encoded + quote;
      }
      exports.decode = decode;
      exports.encode = encode;
    },
    9056: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(7332);
      const utils = __nccwpck_require__(2850);
      const SPACE = 32;
      const REVERSE_SOLIDUS = 92;
      const QUOTATION_MARK = 34;
      const APOSTROPHE = 39;
      const LEFTPARENTHESIS = 40;
      const RIGHTPARENTHESIS = 41;
      function decode(str) {
        const len = str.length;
        let start = 4;
        let end =
          str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
        let decoded = "";
        while (
          start < end &&
          charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))
        ) {
          start++;
        }
        while (
          start < end &&
          charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))
        ) {
          end--;
        }
        for (let i = start; i <= end; i++) {
          let code = str.charCodeAt(i);
          if (code === REVERSE_SOLIDUS) {
            if (i === end) {
              if (i !== len - 1) {
                decoded = str.substr(i + 1);
              }
              break;
            }
            code = str.charCodeAt(++i);
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
              const escapeStart = i - 1;
              const escapeEnd = utils.consumeEscaped(str, escapeStart);
              i = escapeEnd - 1;
              decoded += utils.decodeEscaped(
                str.substring(escapeStart + 1, escapeEnd),
              );
            } else {
              if (code === 13 && str.charCodeAt(i + 1) === 10) {
                i++;
              }
            }
          } else {
            decoded += str[i];
          }
        }
        return decoded;
      }
      function encode(str) {
        let encoded = "";
        let wsBeforeHexIsNeeded = false;
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code === 0) {
            encoded += "�";
            continue;
          }
          if (code <= 31 || code === 127) {
            encoded += "\\" + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
          }
          if (
            code === SPACE ||
            code === REVERSE_SOLIDUS ||
            code === QUOTATION_MARK ||
            code === APOSTROPHE ||
            code === LEFTPARENTHESIS ||
            code === RIGHTPARENTHESIS
          ) {
            encoded += "\\" + str.charAt(i);
            wsBeforeHexIsNeeded = false;
          } else {
            if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
              encoded += " ";
            }
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
          }
        }
        return "url(" + encoded + ")";
      }
      exports.decode = decode;
      exports.encode = encode;
    },
    423: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { version } = __nccwpck_require__(3684);
      exports.version = version;
    },
    4778: (__unused_webpack_module, exports) => {
      "use strict";
      const { hasOwnProperty } = Object.prototype;
      const noop = function () {};
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop;
      }
      function invokeForType(fn, type) {
        return function (node, item, list) {
          if (node.type === type) {
            fn.call(this, node, item, list);
          }
        };
      }
      function getWalkersFromStructure(name, nodeType) {
        const structure = nodeType.structure;
        const walkers = [];
        for (const key in structure) {
          if (hasOwnProperty.call(structure, key) === false) {
            continue;
          }
          let fieldTypes = structure[key];
          const walker = { name: key, type: false, nullable: false };
          if (!Array.isArray(fieldTypes)) {
            fieldTypes = [fieldTypes];
          }
          for (const fieldType of fieldTypes) {
            if (fieldType === null) {
              walker.nullable = true;
            } else if (typeof fieldType === "string") {
              walker.type = "node";
            } else if (Array.isArray(fieldType)) {
              walker.type = "list";
            }
          }
          if (walker.type) {
            walkers.push(walker);
          }
        }
        if (walkers.length) {
          return { context: nodeType.walkContext, fields: walkers };
        }
        return null;
      }
      function getTypesFromConfig(config) {
        const types = {};
        for (const name in config.node) {
          if (hasOwnProperty.call(config.node, name)) {
            const nodeType = config.node[name];
            if (!nodeType.structure) {
              throw new Error(
                "Missed `structure` field in `" +
                  name +
                  "` node type definition",
              );
            }
            types[name] = getWalkersFromStructure(name, nodeType);
          }
        }
        return types;
      }
      function createTypeIterator(config, reverse) {
        const fields = config.fields.slice();
        const contextName = config.context;
        const useContext = typeof contextName === "string";
        if (reverse) {
          fields.reverse();
        }
        return function (node, context, walk, walkReducer) {
          let prevContextValue;
          if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
          }
          for (const field of fields) {
            const ref = node[field.name];
            if (!field.nullable || ref) {
              if (field.type === "list") {
                const breakWalk = reverse
                  ? ref.reduceRight(walkReducer, false)
                  : ref.reduce(walkReducer, false);
                if (breakWalk) {
                  return true;
                }
              } else if (walk(ref)) {
                return true;
              }
            }
          }
          if (useContext) {
            context[contextName] = prevContextValue;
          }
        };
      }
      function createFastTraveralMap({
        StyleSheet,
        Atrule,
        Rule,
        Block,
        DeclarationList,
      }) {
        return {
          Atrule: { StyleSheet, Atrule, Rule, Block },
          Rule: { StyleSheet, Atrule, Rule, Block },
          Declaration: { StyleSheet, Atrule, Rule, Block, DeclarationList },
        };
      }
      function createWalker(config) {
        const types = getTypesFromConfig(config);
        const iteratorsNatural = {};
        const iteratorsReverse = {};
        const breakWalk = Symbol("break-walk");
        const skipNode = Symbol("skip-node");
        for (const name in types) {
          if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
          }
        }
        const fastTraversalIteratorsNatural =
          createFastTraveralMap(iteratorsNatural);
        const fastTraversalIteratorsReverse =
          createFastTraveralMap(iteratorsReverse);
        const walk = function (root, options) {
          function walkNode(node, item, list) {
            const enterRet = enter.call(context, node, item, list);
            if (enterRet === breakWalk) {
              return true;
            }
            if (enterRet === skipNode) {
              return false;
            }
            if (iterators.hasOwnProperty(node.type)) {
              if (iterators[node.type](node, context, walkNode, walkReducer)) {
                return true;
              }
            }
            if (leave.call(context, node, item, list) === breakWalk) {
              return true;
            }
            return false;
          }
          let enter = noop;
          let leave = noop;
          let iterators = iteratorsNatural;
          let walkReducer = (ret, data, item, list) =>
            ret || walkNode(data, item, list);
          const context = {
            break: breakWalk,
            skip: skipNode,
            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null,
          };
          if (typeof options === "function") {
            enter = options;
          } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);
            if (options.reverse) {
              iterators = iteratorsReverse;
            }
            if (options.visit) {
              if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                iterators = options.reverse
                  ? fastTraversalIteratorsReverse[options.visit]
                  : fastTraversalIteratorsNatural[options.visit];
              } else if (!types.hasOwnProperty(options.visit)) {
                throw new Error(
                  "Bad value `" +
                    options.visit +
                    "` for `visit` option (should be: " +
                    Object.keys(types).sort().join(", ") +
                    ")",
                );
              }
              enter = invokeForType(enter, options.visit);
              leave = invokeForType(leave, options.visit);
            }
          }
          if (enter === noop && leave === noop) {
            throw new Error(
              "Neither `enter` nor `leave` walker handler is set or both aren't a function",
            );
          }
          walkNode(root);
        };
        walk.break = breakWalk;
        walk.skip = skipNode;
        walk.find = function (ast, fn) {
          let found = null;
          walk(ast, function (node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          });
          return found;
        };
        walk.findLast = function (ast, fn) {
          let found = null;
          walk(ast, {
            reverse: true,
            enter(node, item, list) {
              if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
              }
            },
          });
          return found;
        };
        walk.findAll = function (ast, fn) {
          const found = [];
          walk(ast, function (node, item, list) {
            if (fn.call(this, node, item, list)) {
              found.push(node);
            }
          });
          return found;
        };
        return walk;
      }
      exports.createWalker = createWalker;
    },
    9863: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(6929);
      function createConvertor(walk) {
        return {
          fromPlainObject(ast) {
            walk(ast, {
              enter(node) {
                if (
                  node.children &&
                  node.children instanceof List.List === false
                ) {
                  node.children = new List.List().fromArray(node.children);
                }
              },
            });
            return ast;
          },
          toPlainObject(ast) {
            walk(ast, {
              leave(node) {
                if (node.children && node.children instanceof List.List) {
                  node.children = node.children.toArray();
                }
              },
            });
            return ast;
          },
        };
      }
      exports.createConvertor = createConvertor;
    },
    339: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const patch = __nccwpck_require__(9750);
      const patch$1 = patch;
      module.exports = patch$1;
    },
    9743: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const dataPatch = __nccwpck_require__(339);
      const mdnAtrules = __nccwpck_require__(8072);
      const mdnProperties = __nccwpck_require__(8837);
      const mdnSyntaxes = __nccwpck_require__(1509);
      const extendSyntax = /^\s*\|\s*/;
      function preprocessAtrules(dict) {
        const result = Object.create(null);
        for (const atruleName in dict) {
          const atrule = dict[atruleName];
          let descriptors = null;
          if (atrule.descriptors) {
            descriptors = Object.create(null);
            for (const descriptor in atrule.descriptors) {
              descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
          }
          result[atruleName.substr(1)] = {
            prelude:
              atrule.syntax
                .trim()
                .replace(/\{(.|\s)+\}/, "")
                .match(/^@\S+\s+([^;\{]*)/)[1]
                .trim() || null,
            descriptors,
          };
        }
        return result;
      }
      function patchDictionary(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          result[key] = dict[key].syntax || dict[key];
        }
        for (const key in patchDict) {
          if (key in dict) {
            if (patchDict[key].syntax) {
              result[key] = extendSyntax.test(patchDict[key].syntax)
                ? result[key] + " " + patchDict[key].syntax.trim()
                : patchDict[key].syntax;
            } else {
              delete result[key];
            }
          } else {
            if (patchDict[key].syntax) {
              result[key] = patchDict[key].syntax.replace(extendSyntax, "");
            }
          }
        }
        return result;
      }
      function patchAtrules(dict, patchDict) {
        const result = {};
        for (const key in dict) {
          const atrulePatch = patchDict[key] || {};
          result[key] = {
            prelude:
              key in patchDict && "prelude" in atrulePatch
                ? atrulePatch.prelude
                : dict[key].prelude || null,
            descriptors: patchDictionary(
              dict[key].descriptors || {},
              atrulePatch.descriptors || {},
            ),
          };
        }
        for (const key in patchDict) {
          if (!hasOwnProperty.call(dict, key)) {
            const atrulePatch = patchDict[key] || {};
            result[key] = {
              prelude: atrulePatch.prelude || null,
              descriptors:
                atrulePatch.descriptors &&
                patchDictionary({}, atrulePatch.descriptors),
            };
          }
        }
        return result;
      }
      const definitions = {
        types: patchDictionary(mdnSyntaxes, dataPatch.types),
        atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
        properties: patchDictionary(mdnProperties, dataPatch.properties),
      };
      module.exports = definitions;
    },
    443: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const createCustomError = __nccwpck_require__(5850);
      function SyntaxError(message, input, offset) {
        return Object.assign(
          createCustomError.createCustomError("SyntaxError", message),
          {
            input,
            offset,
            rawMessage: message,
            message:
              message +
              "\n" +
              "  " +
              input +
              "\n" +
              "--" +
              new Array((offset || input.length) + 1).join("-") +
              "^",
          },
        );
      }
      exports.SyntaxError = SyntaxError;
    },
    2359: (__unused_webpack_module, exports) => {
      "use strict";
      function noop(value) {
        return value;
      }
      function generateMultiplier(multiplier) {
        const { min, max, comma } = multiplier;
        if (min === 0 && max === 0) {
          return comma ? "#?" : "*";
        }
        if (min === 0 && max === 1) {
          return "?";
        }
        if (min === 1 && max === 0) {
          return comma ? "#" : "+";
        }
        if (min === 1 && max === 1) {
          return "";
        }
        return (
          (comma ? "#" : "") +
          (min === max
            ? "{" + min + "}"
            : "{" + min + "," + (max !== 0 ? max : "") + "}")
        );
      }
      function generateTypeOpts(node) {
        switch (node.type) {
          case "Range":
            return (
              " [" +
              (node.min === null ? "-∞" : node.min) +
              "," +
              (node.max === null ? "∞" : node.max) +
              "]"
            );
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
      }
      function generateSequence(node, decorate, forceBraces, compact) {
        const combinator =
          node.combinator === " " || compact
            ? node.combinator
            : " " + node.combinator + " ";
        const result = node.terms
          .map((term) => internalGenerate(term, decorate, forceBraces, compact))
          .join(combinator);
        if (node.explicit || forceBraces) {
          return (
            (compact || result[0] === "," ? "[" : "[ ") +
            result +
            (compact ? "]" : " ]")
          );
        }
        return result;
      }
      function internalGenerate(node, decorate, forceBraces, compact) {
        let result;
        switch (node.type) {
          case "Group":
            result =
              generateSequence(node, decorate, forceBraces, compact) +
              (node.disallowEmpty ? "!" : "");
            break;
          case "Multiplier":
            return (
              internalGenerate(node.term, decorate, forceBraces, compact) +
              decorate(generateMultiplier(node), node)
            );
          case "Type":
            result =
              "<" +
              node.name +
              (node.opts
                ? decorate(generateTypeOpts(node.opts), node.opts)
                : "") +
              ">";
            break;
          case "Property":
            result = "<'" + node.name + "'>";
            break;
          case "Keyword":
            result = node.name;
            break;
          case "AtKeyword":
            result = "@" + node.name;
            break;
          case "Function":
            result = node.name + "(";
            break;
          case "String":
          case "Token":
            result = node.value;
            break;
          case "Comma":
            result = ",";
            break;
          default:
            throw new Error("Unknown node type `" + node.type + "`");
        }
        return decorate(result, node);
      }
      function generate(node, options) {
        let decorate = noop;
        let forceBraces = false;
        let compact = false;
        if (typeof options === "function") {
          decorate = options;
        } else if (options) {
          forceBraces = Boolean(options.forceBraces);
          compact = Boolean(options.compact);
          if (typeof options.decorate === "function") {
            decorate = options.decorate;
          }
        }
        return internalGenerate(node, decorate, forceBraces, compact);
      }
      exports.generate = generate;
    },
    5509: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const SyntaxError = __nccwpck_require__(443);
      const generate = __nccwpck_require__(2359);
      const parse = __nccwpck_require__(9242);
      const walk = __nccwpck_require__(9746);
      exports.SyntaxError = SyntaxError.SyntaxError;
      exports.generate = generate.generate;
      exports.parse = parse.parse;
      exports.walk = walk.walk;
    },
    9242: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const tokenizer = __nccwpck_require__(5621);
      const TAB = 9;
      const N = 10;
      const F = 12;
      const R = 13;
      const SPACE = 32;
      const EXCLAMATIONMARK = 33;
      const NUMBERSIGN = 35;
      const AMPERSAND = 38;
      const APOSTROPHE = 39;
      const LEFTPARENTHESIS = 40;
      const RIGHTPARENTHESIS = 41;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const COMMA = 44;
      const HYPERMINUS = 45;
      const LESSTHANSIGN = 60;
      const GREATERTHANSIGN = 62;
      const QUESTIONMARK = 63;
      const COMMERCIALAT = 64;
      const LEFTSQUAREBRACKET = 91;
      const RIGHTSQUAREBRACKET = 93;
      const LEFTCURLYBRACKET = 123;
      const VERTICALLINE = 124;
      const RIGHTCURLYBRACKET = 125;
      const INFINITY = 8734;
      const NAME_CHAR = new Uint8Array(128).map((_, idx) =>
        /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0,
      );
      const COMBINATOR_PRECEDENCE = { " ": 1, "&&": 2, "||": 3, "|": 4 };
      function scanSpaces(tokenizer) {
        return tokenizer.substringToPos(tokenizer.findWsEnd(tokenizer.pos));
      }
      function scanWord(tokenizer) {
        let end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          const code = tokenizer.str.charCodeAt(end);
          if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a keyword");
        }
        return tokenizer.substringToPos(end);
      }
      function scanNumber(tokenizer) {
        let end = tokenizer.pos;
        for (; end < tokenizer.str.length; end++) {
          const code = tokenizer.str.charCodeAt(end);
          if (code < 48 || code > 57) {
            break;
          }
        }
        if (tokenizer.pos === end) {
          tokenizer.error("Expect a number");
        }
        return tokenizer.substringToPos(end);
      }
      function scanString(tokenizer) {
        const end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
        if (end === -1) {
          tokenizer.pos = tokenizer.str.length;
          tokenizer.error("Expect an apostrophe");
        }
        return tokenizer.substringToPos(end + 1);
      }
      function readMultiplierRange(tokenizer) {
        let min = null;
        let max = null;
        tokenizer.eat(LEFTCURLYBRACKET);
        min = scanNumber(tokenizer);
        if (tokenizer.charCode() === COMMA) {
          tokenizer.pos++;
          if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
          }
        } else {
          max = min;
        }
        tokenizer.eat(RIGHTCURLYBRACKET);
        return { min: Number(min), max: max ? Number(max) : 0 };
      }
      function readMultiplier(tokenizer) {
        let range = null;
        let comma = false;
        switch (tokenizer.charCode()) {
          case ASTERISK:
            tokenizer.pos++;
            range = { min: 0, max: 0 };
            break;
          case PLUSSIGN:
            tokenizer.pos++;
            range = { min: 1, max: 0 };
            break;
          case QUESTIONMARK:
            tokenizer.pos++;
            range = { min: 0, max: 1 };
            break;
          case NUMBERSIGN:
            tokenizer.pos++;
            comma = true;
            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
              range = readMultiplierRange(tokenizer);
            } else if (tokenizer.charCode() === QUESTIONMARK) {
              tokenizer.pos++;
              range = { min: 0, max: 0 };
            } else {
              range = { min: 1, max: 0 };
            }
            break;
          case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;
          default:
            return null;
        }
        return {
          type: "Multiplier",
          comma,
          min: range.min,
          max: range.max,
          term: null,
        };
      }
      function maybeMultiplied(tokenizer, node) {
        const multiplier = readMultiplier(tokenizer);
        if (multiplier !== null) {
          multiplier.term = node;
          if (
            tokenizer.charCode() === NUMBERSIGN &&
            tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN
          ) {
            return maybeMultiplied(tokenizer, multiplier);
          }
          return multiplier;
        }
        return node;
      }
      function maybeToken(tokenizer) {
        const ch = tokenizer.peek();
        if (ch === "") {
          return null;
        }
        return { type: "Token", value: ch };
      }
      function readProperty(tokenizer) {
        let name;
        tokenizer.eat(LESSTHANSIGN);
        tokenizer.eat(APOSTROPHE);
        name = scanWord(tokenizer);
        tokenizer.eat(APOSTROPHE);
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, { type: "Property", name });
      }
      function readTypeRange(tokenizer) {
        let min = null;
        let max = null;
        let sign = 1;
        tokenizer.eat(LEFTSQUAREBRACKET);
        if (tokenizer.charCode() === HYPERMINUS) {
          tokenizer.peek();
          sign = -1;
        }
        if (sign == -1 && tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          min = sign * Number(scanNumber(tokenizer));
          if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            min += scanWord(tokenizer);
          }
        }
        scanSpaces(tokenizer);
        tokenizer.eat(COMMA);
        scanSpaces(tokenizer);
        if (tokenizer.charCode() === INFINITY) {
          tokenizer.peek();
        } else {
          sign = 1;
          if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
          }
          max = sign * Number(scanNumber(tokenizer));
          if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            max += scanWord(tokenizer);
          }
        }
        tokenizer.eat(RIGHTSQUAREBRACKET);
        return { type: "Range", min, max };
      }
      function readType(tokenizer) {
        let name;
        let opts = null;
        tokenizer.eat(LESSTHANSIGN);
        name = scanWord(tokenizer);
        if (
          tokenizer.charCode() === LEFTPARENTHESIS &&
          tokenizer.nextCharCode() === RIGHTPARENTHESIS
        ) {
          tokenizer.pos += 2;
          name += "()";
        }
        if (
          tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) ===
          LEFTSQUAREBRACKET
        ) {
          scanSpaces(tokenizer);
          opts = readTypeRange(tokenizer);
        }
        tokenizer.eat(GREATERTHANSIGN);
        return maybeMultiplied(tokenizer, { type: "Type", name, opts });
      }
      function readKeywordOrFunction(tokenizer) {
        const name = scanWord(tokenizer);
        if (tokenizer.charCode() === LEFTPARENTHESIS) {
          tokenizer.pos++;
          return { type: "Function", name };
        }
        return maybeMultiplied(tokenizer, { type: "Keyword", name });
      }
      function regroupTerms(terms, combinators) {
        function createGroup(terms, combinator) {
          return {
            type: "Group",
            terms,
            combinator,
            disallowEmpty: false,
            explicit: false,
          };
        }
        let combinator;
        combinators = Object.keys(combinators).sort(
          (a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b],
        );
        while (combinators.length > 0) {
          combinator = combinators.shift();
          let i = 0;
          let subgroupStart = 0;
          for (; i < terms.length; i++) {
            const term = terms[i];
            if (term.type === "Combinator") {
              if (term.value === combinator) {
                if (subgroupStart === -1) {
                  subgroupStart = i - 1;
                }
                terms.splice(i, 1);
                i--;
              } else {
                if (subgroupStart !== -1 && i - subgroupStart > 1) {
                  terms.splice(
                    subgroupStart,
                    i - subgroupStart,
                    createGroup(terms.slice(subgroupStart, i), combinator),
                  );
                  i = subgroupStart + 1;
                }
                subgroupStart = -1;
              }
            }
          }
          if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
              subgroupStart,
              i - subgroupStart,
              createGroup(terms.slice(subgroupStart, i), combinator),
            );
          }
        }
        return combinator;
      }
      function readImplicitGroup(tokenizer) {
        const terms = [];
        const combinators = {};
        let token;
        let prevToken = null;
        let prevTokenPos = tokenizer.pos;
        while ((token = peek(tokenizer))) {
          if (token.type !== "Spaces") {
            if (token.type === "Combinator") {
              if (prevToken === null || prevToken.type === "Combinator") {
                tokenizer.pos = prevTokenPos;
                tokenizer.error("Unexpected combinator");
              }
              combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== "Combinator") {
              combinators[" "] = true;
              terms.push({ type: "Combinator", value: " " });
            }
            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
          }
        }
        if (prevToken !== null && prevToken.type === "Combinator") {
          tokenizer.pos -= prevTokenPos;
          tokenizer.error("Unexpected combinator");
        }
        return {
          type: "Group",
          terms,
          combinator: regroupTerms(terms, combinators) || " ",
          disallowEmpty: false,
          explicit: false,
        };
      }
      function readGroup(tokenizer) {
        let result;
        tokenizer.eat(LEFTSQUAREBRACKET);
        result = readImplicitGroup(tokenizer);
        tokenizer.eat(RIGHTSQUAREBRACKET);
        result.explicit = true;
        if (tokenizer.charCode() === EXCLAMATIONMARK) {
          tokenizer.pos++;
          result.disallowEmpty = true;
        }
        return result;
      }
      function peek(tokenizer) {
        let code = tokenizer.charCode();
        if (code < 128 && NAME_CHAR[code] === 1) {
          return readKeywordOrFunction(tokenizer);
        }
        switch (code) {
          case RIGHTSQUAREBRACKET:
            break;
          case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));
          case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
              ? readProperty(tokenizer)
              : readType(tokenizer);
          case VERTICALLINE:
            return {
              type: "Combinator",
              value: tokenizer.substringToPos(
                tokenizer.pos +
                  (tokenizer.nextCharCode() === VERTICALLINE ? 2 : 1),
              ),
            };
          case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);
            return { type: "Combinator", value: "&&" };
          case COMMA:
            tokenizer.pos++;
            return { type: "Comma" };
          case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
              type: "String",
              value: scanString(tokenizer),
            });
          case SPACE:
          case TAB:
          case N:
          case R:
          case F:
            return { type: "Spaces", value: scanSpaces(tokenizer) };
          case COMMERCIALAT:
            code = tokenizer.nextCharCode();
            if (code < 128 && NAME_CHAR[code] === 1) {
              tokenizer.pos++;
              return { type: "AtKeyword", name: scanWord(tokenizer) };
            }
            return maybeToken(tokenizer);
          case ASTERISK:
          case PLUSSIGN:
          case QUESTIONMARK:
          case NUMBERSIGN:
          case EXCLAMATIONMARK:
            break;
          case LEFTCURLYBRACKET:
            code = tokenizer.nextCharCode();
            if (code < 48 || code > 57) {
              return maybeToken(tokenizer);
            }
            break;
          default:
            return maybeToken(tokenizer);
        }
      }
      function parse(source) {
        const tokenizer$1 = new tokenizer.Tokenizer(source);
        const result = readImplicitGroup(tokenizer$1);
        if (tokenizer$1.pos !== source.length) {
          tokenizer$1.error("Unexpected input");
        }
        if (result.terms.length === 1 && result.terms[0].type === "Group") {
          return result.terms[0];
        }
        return result;
      }
      exports.parse = parse;
    },
    5621: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const SyntaxError = __nccwpck_require__(443);
      const TAB = 9;
      const N = 10;
      const F = 12;
      const R = 13;
      const SPACE = 32;
      class Tokenizer {
        constructor(str) {
          this.str = str;
          this.pos = 0;
        }
        charCodeAt(pos) {
          return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
        }
        charCode() {
          return this.charCodeAt(this.pos);
        }
        nextCharCode() {
          return this.charCodeAt(this.pos + 1);
        }
        nextNonWsCode(pos) {
          return this.charCodeAt(this.findWsEnd(pos));
        }
        findWsEnd(pos) {
          for (; pos < this.str.length; pos++) {
            const code = this.str.charCodeAt(pos);
            if (
              code !== R &&
              code !== N &&
              code !== F &&
              code !== SPACE &&
              code !== TAB
            ) {
              break;
            }
          }
          return pos;
        }
        substringToPos(end) {
          return this.str.substring(this.pos, (this.pos = end));
        }
        eat(code) {
          if (this.charCode() !== code) {
            this.error("Expect `" + String.fromCharCode(code) + "`");
          }
          this.pos++;
        }
        peek() {
          return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
        }
        error(message) {
          throw new SyntaxError.SyntaxError(message, this.str, this.pos);
        }
      }
      exports.Tokenizer = Tokenizer;
    },
    9746: (__unused_webpack_module, exports) => {
      "use strict";
      const noop = function () {};
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop;
      }
      function walk(node, options, context) {
        function walk(node) {
          enter.call(context, node);
          switch (node.type) {
            case "Group":
              node.terms.forEach(walk);
              break;
            case "Multiplier":
              walk(node.term);
              break;
            case "Type":
            case "Property":
            case "Keyword":
            case "AtKeyword":
            case "Function":
            case "String":
            case "Token":
            case "Comma":
              break;
            default:
              throw new Error("Unknown type: " + node.type);
          }
          leave.call(context, node);
        }
        let enter = noop;
        let leave = noop;
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
        }
        if (enter === noop && leave === noop) {
          throw new Error(
            "Neither `enter` nor `leave` walker handler is set or both aren't a function",
          );
        }
        walk(node);
      }
      exports.walk = walk;
    },
    8988: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(7324);
      const sourceMap = __nccwpck_require__(3249);
      const tokenBefore = __nccwpck_require__(4757);
      const types = __nccwpck_require__(8839);
      const REVERSESOLIDUS = 92;
      function processChildren(node, delimeter) {
        if (typeof delimeter === "function") {
          let prev = null;
          node.children.forEach((node) => {
            if (prev !== null) {
              delimeter.call(this, prev);
            }
            this.node(node);
            prev = node;
          });
          return;
        }
        node.children.forEach(this.node, this);
      }
      function processChunk(chunk) {
        index.tokenize(chunk, (type, start, end) => {
          this.token(type, chunk.slice(start, end));
        });
      }
      function createGenerator(config) {
        const types$1 = new Map();
        for (let name in config.node) {
          const item = config.node[name];
          const fn = item.generate || item;
          if (typeof fn === "function") {
            types$1.set(name, item.generate || item);
          }
        }
        return function (node, options) {
          let buffer = "";
          let prevCode = 0;
          let handlers = {
            node(node) {
              if (types$1.has(node.type)) {
                types$1.get(node.type).call(publicApi, node);
              } else {
                throw new Error("Unknown node type: " + node.type);
              }
            },
            tokenBefore: tokenBefore.safe,
            token(type, value) {
              prevCode = this.tokenBefore(prevCode, type, value);
              this.emit(value, type, false);
              if (
                type === types.Delim &&
                value.charCodeAt(0) === REVERSESOLIDUS
              ) {
                this.emit("\n", types.WhiteSpace, true);
              }
            },
            emit(value) {
              buffer += value;
            },
            result() {
              return buffer;
            },
          };
          if (options) {
            if (typeof options.decorator === "function") {
              handlers = options.decorator(handlers);
            }
            if (options.sourceMap) {
              handlers = sourceMap.generateSourceMap(handlers);
            }
            if (options.mode in tokenBefore) {
              handlers.tokenBefore = tokenBefore[options.mode];
            }
          }
          const publicApi = {
            node: (node) => handlers.node(node),
            children: processChildren,
            token: (type, value) => handlers.token(type, value),
            tokenize: processChunk,
          };
          handlers.node(node);
          return handlers.result();
        };
      }
      exports.createGenerator = createGenerator;
    },
    3249: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const sourceMapGenerator_js = __nccwpck_require__(4209);
      const trackNodes = new Set(["Atrule", "Selector", "Declaration"]);
      function generateSourceMap(handlers) {
        const map = new sourceMapGenerator_js.SourceMapGenerator();
        const generated = { line: 1, column: 0 };
        const original = { line: 0, column: 0 };
        const activatedGenerated = { line: 1, column: 0 };
        const activatedMapping = { generated: activatedGenerated };
        let line = 1;
        let column = 0;
        let sourceMappingActive = false;
        const origHandlersNode = handlers.node;
        handlers.node = function (node) {
          if (node.loc && node.loc.start && trackNodes.has(node.type)) {
            const nodeLine = node.loc.start.line;
            const nodeColumn = node.loc.start.column - 1;
            if (original.line !== nodeLine || original.column !== nodeColumn) {
              original.line = nodeLine;
              original.column = nodeColumn;
              generated.line = line;
              generated.column = column;
              if (sourceMappingActive) {
                sourceMappingActive = false;
                if (
                  generated.line !== activatedGenerated.line ||
                  generated.column !== activatedGenerated.column
                ) {
                  map.addMapping(activatedMapping);
                }
              }
              sourceMappingActive = true;
              map.addMapping({ source: node.loc.source, original, generated });
            }
          }
          origHandlersNode.call(this, node);
          if (sourceMappingActive && trackNodes.has(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
          }
        };
        const origHandlersEmit = handlers.emit;
        handlers.emit = function (value, type, auto) {
          for (let i = 0; i < value.length; i++) {
            if (value.charCodeAt(i) === 10) {
              line++;
              column = 0;
            } else {
              column++;
            }
          }
          origHandlersEmit(value, type, auto);
        };
        const origHandlersResult = handlers.result;
        handlers.result = function () {
          if (sourceMappingActive) {
            map.addMapping(activatedMapping);
          }
          return { css: origHandlersResult(), map };
        };
        return handlers;
      }
      exports.generateSourceMap = generateSourceMap;
    },
    4757: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const code = (type, value) => {
        if (type === types.Delim) {
          type = value;
        }
        if (typeof type === "string") {
          const charCode = type.charCodeAt(0);
          return charCode > 127 ? 32768 : charCode << 8;
        }
        return type;
      };
      const specPairs = [
        [types.Ident, types.Ident],
        [types.Ident, types.Function],
        [types.Ident, types.Url],
        [types.Ident, types.BadUrl],
        [types.Ident, "-"],
        [types.Ident, types.Number],
        [types.Ident, types.Percentage],
        [types.Ident, types.Dimension],
        [types.Ident, types.CDC],
        [types.Ident, types.LeftParenthesis],
        [types.AtKeyword, types.Ident],
        [types.AtKeyword, types.Function],
        [types.AtKeyword, types.Url],
        [types.AtKeyword, types.BadUrl],
        [types.AtKeyword, "-"],
        [types.AtKeyword, types.Number],
        [types.AtKeyword, types.Percentage],
        [types.AtKeyword, types.Dimension],
        [types.AtKeyword, types.CDC],
        [types.Hash, types.Ident],
        [types.Hash, types.Function],
        [types.Hash, types.Url],
        [types.Hash, types.BadUrl],
        [types.Hash, "-"],
        [types.Hash, types.Number],
        [types.Hash, types.Percentage],
        [types.Hash, types.Dimension],
        [types.Hash, types.CDC],
        [types.Dimension, types.Ident],
        [types.Dimension, types.Function],
        [types.Dimension, types.Url],
        [types.Dimension, types.BadUrl],
        [types.Dimension, "-"],
        [types.Dimension, types.Number],
        [types.Dimension, types.Percentage],
        [types.Dimension, types.Dimension],
        [types.Dimension, types.CDC],
        ["#", types.Ident],
        ["#", types.Function],
        ["#", types.Url],
        ["#", types.BadUrl],
        ["#", "-"],
        ["#", types.Number],
        ["#", types.Percentage],
        ["#", types.Dimension],
        ["#", types.CDC],
        ["-", types.Ident],
        ["-", types.Function],
        ["-", types.Url],
        ["-", types.BadUrl],
        ["-", "-"],
        ["-", types.Number],
        ["-", types.Percentage],
        ["-", types.Dimension],
        ["-", types.CDC],
        [types.Number, types.Ident],
        [types.Number, types.Function],
        [types.Number, types.Url],
        [types.Number, types.BadUrl],
        [types.Number, types.Number],
        [types.Number, types.Percentage],
        [types.Number, types.Dimension],
        [types.Number, "%"],
        [types.Number, types.CDC],
        ["@", types.Ident],
        ["@", types.Function],
        ["@", types.Url],
        ["@", types.BadUrl],
        ["@", "-"],
        ["@", types.CDC],
        [".", types.Number],
        [".", types.Percentage],
        [".", types.Dimension],
        ["+", types.Number],
        ["+", types.Percentage],
        ["+", types.Dimension],
        ["/", "*"],
      ];
      const safePairs = specPairs.concat([
        [types.Ident, types.Hash],
        [types.Dimension, types.Hash],
        [types.Hash, types.Hash],
        [types.AtKeyword, types.LeftParenthesis],
        [types.AtKeyword, types.String],
        [types.AtKeyword, types.Colon],
        [types.Percentage, types.Percentage],
        [types.Percentage, types.Dimension],
        [types.Percentage, types.Function],
        [types.Percentage, "-"],
        [types.RightParenthesis, types.Ident],
        [types.RightParenthesis, types.Function],
        [types.RightParenthesis, types.Percentage],
        [types.RightParenthesis, types.Dimension],
        [types.RightParenthesis, types.Hash],
        [types.RightParenthesis, "-"],
      ]);
      function createMap(pairs) {
        const isWhiteSpaceRequired = new Set(
          pairs.map(([prev, next]) => (code(prev) << 16) | code(next)),
        );
        return function (prevCode, type, value) {
          const nextCode = code(type, value);
          const nextCharCode = value.charCodeAt(0);
          const emitWs =
            (nextCharCode === HYPHENMINUS &&
              type !== types.Ident &&
              type !== types.Function &&
              type !== types.CDC) ||
            nextCharCode === PLUSSIGN
              ? isWhiteSpaceRequired.has((prevCode << 16) | (nextCharCode << 8))
              : isWhiteSpaceRequired.has((prevCode << 16) | nextCode);
          if (emitWs) {
            this.emit(" ", types.WhiteSpace, true);
          }
          return nextCode;
        };
      }
      const spec = createMap(specPairs);
      const safe = createMap(safePairs);
      exports.safe = safe;
      exports.spec = spec;
    },
    203: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const index$1 = __nccwpck_require__(3313);
      const version = __nccwpck_require__(2789);
      const create = __nccwpck_require__(2148);
      const List = __nccwpck_require__(6929);
      const Lexer = __nccwpck_require__(7744);
      const index = __nccwpck_require__(5509);
      const clone = __nccwpck_require__(6231);
      const names$1 = __nccwpck_require__(4195);
      const ident = __nccwpck_require__(1811);
      const string = __nccwpck_require__(590);
      const url = __nccwpck_require__(5602);
      const types = __nccwpck_require__(8839);
      const names = __nccwpck_require__(9516);
      const TokenStream = __nccwpck_require__(1843);
      const {
        tokenize,
        parse,
        generate,
        lexer,
        createLexer,
        walk,
        find,
        findLast,
        findAll,
        toPlainObject,
        fromPlainObject,
        fork,
      } = index$1;
      exports.version = version.version;
      exports.createSyntax = create;
      exports.List = List.List;
      exports.Lexer = Lexer.Lexer;
      exports.definitionSyntax = index;
      exports.clone = clone.clone;
      exports.isCustomProperty = names$1.isCustomProperty;
      exports.keyword = names$1.keyword;
      exports.property = names$1.property;
      exports.vendorPrefix = names$1.vendorPrefix;
      exports.ident = ident;
      exports.string = string;
      exports.url = url;
      exports.tokenTypes = types;
      exports.tokenNames = names;
      exports.TokenStream = TokenStream.TokenStream;
      exports.createLexer = createLexer;
      exports.find = find;
      exports.findAll = findAll;
      exports.findLast = findLast;
      exports.fork = fork;
      exports.fromPlainObject = fromPlainObject;
      exports.generate = generate;
      exports.lexer = lexer;
      exports.parse = parse;
      exports.toPlainObject = toPlainObject;
      exports.tokenize = tokenize;
      exports.walk = walk;
    },
    7744: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const error = __nccwpck_require__(5789);
      const names = __nccwpck_require__(4195);
      const genericConst = __nccwpck_require__(7988);
      const generic = __nccwpck_require__(8259);
      const units = __nccwpck_require__(7830);
      const prepareTokens = __nccwpck_require__(6);
      const matchGraph = __nccwpck_require__(4114);
      const match = __nccwpck_require__(7416);
      const trace = __nccwpck_require__(9178);
      const search = __nccwpck_require__(124);
      const structure = __nccwpck_require__(517);
      const parse = __nccwpck_require__(9242);
      const generate = __nccwpck_require__(2359);
      const walk = __nccwpck_require__(9746);
      const cssWideKeywordsSyntax = matchGraph.buildMatchGraph(
        genericConst.cssWideKeywords.join(" | "),
      );
      function dumpMapSyntax(map, compact, syntaxAsAst) {
        const result = {};
        for (const name in map) {
          if (map[name].syntax) {
            result[name] = syntaxAsAst
              ? map[name].syntax
              : generate.generate(map[name].syntax, { compact });
          }
        }
        return result;
      }
      function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
        const result = {};
        for (const [name, atrule] of Object.entries(map)) {
          result[name] = {
            prelude:
              atrule.prelude &&
              (syntaxAsAst
                ? atrule.prelude.syntax
                : generate.generate(atrule.prelude.syntax, { compact })),
            descriptors:
              atrule.descriptors &&
              dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst),
          };
        }
        return result;
      }
      function valueHasVar(tokens) {
        for (let i = 0; i < tokens.length; i++) {
          if (tokens[i].value.toLowerCase() === "var(") {
            return true;
          }
        }
        return false;
      }
      function buildMatchResult(matched, error, iterations) {
        return { matched, iterations, error, ...trace };
      }
      function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
        const tokens = prepareTokens(value, lexer.syntax);
        let result;
        if (valueHasVar(tokens)) {
          return buildMatchResult(
            null,
            new Error("Matching for a tree with var() is not supported"),
          );
        }
        if (useCssWideKeywords) {
          result = match.matchAsTree(
            tokens,
            lexer.cssWideKeywordsSyntax,
            lexer,
          );
        }
        if (!useCssWideKeywords || !result.match) {
          result = match.matchAsTree(tokens, syntax.match, lexer);
          if (!result.match) {
            return buildMatchResult(
              null,
              new error.SyntaxMatchError(
                result.reason,
                syntax.syntax,
                value,
                result,
              ),
              result.iterations,
            );
          }
        }
        return buildMatchResult(result.match, null, result.iterations);
      }
      class Lexer {
        constructor(config, syntax, structure$1) {
          this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
          this.syntax = syntax;
          this.generic = false;
          this.units = { ...units };
          this.atrules = Object.create(null);
          this.properties = Object.create(null);
          this.types = Object.create(null);
          this.structure =
            structure$1 || structure.getStructureFromConfig(config);
          if (config) {
            if (config.units) {
              for (const group of Object.keys(units)) {
                if (Array.isArray(config.units[group])) {
                  this.units[group] = config.units[group];
                }
              }
            }
            if (config.types) {
              for (const name in config.types) {
                this.addType_(name, config.types[name]);
              }
            }
            if (config.generic) {
              this.generic = true;
              for (const [name, value] of Object.entries(
                generic.createGenericTypes(this.units),
              )) {
                this.addType_(name, value);
              }
            }
            if (config.atrules) {
              for (const name in config.atrules) {
                this.addAtrule_(name, config.atrules[name]);
              }
            }
            if (config.properties) {
              for (const name in config.properties) {
                this.addProperty_(name, config.properties[name]);
              }
            }
          }
        }
        checkStructure(ast) {
          function collectWarning(node, message) {
            warns.push({ node, message });
          }
          const structure = this.structure;
          const warns = [];
          this.syntax.walk(ast, function (node) {
            if (structure.hasOwnProperty(node.type)) {
              structure[node.type].check(node, collectWarning);
            } else {
              collectWarning(node, "Unknown node type `" + node.type + "`");
            }
          });
          return warns.length ? warns : false;
        }
        createDescriptor(syntax, type, name, parent = null) {
          const ref = { type, name };
          const descriptor = {
            type,
            name,
            parent,
            serializable:
              typeof syntax === "string" ||
              (syntax && typeof syntax.type === "string"),
            syntax: null,
            match: null,
          };
          if (typeof syntax === "function") {
            descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
          } else {
            if (typeof syntax === "string") {
              Object.defineProperty(descriptor, "syntax", {
                get() {
                  Object.defineProperty(descriptor, "syntax", {
                    value: parse.parse(syntax),
                  });
                  return descriptor.syntax;
                },
              });
            } else {
              descriptor.syntax = syntax;
            }
            Object.defineProperty(descriptor, "match", {
              get() {
                Object.defineProperty(descriptor, "match", {
                  value: matchGraph.buildMatchGraph(descriptor.syntax, ref),
                });
                return descriptor.match;
              },
            });
          }
          return descriptor;
        }
        addAtrule_(name, syntax) {
          if (!syntax) {
            return;
          }
          this.atrules[name] = {
            type: "Atrule",
            name,
            prelude: syntax.prelude
              ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name)
              : null,
            descriptors: syntax.descriptors
              ? Object.keys(syntax.descriptors).reduce((map, descName) => {
                  map[descName] = this.createDescriptor(
                    syntax.descriptors[descName],
                    "AtruleDescriptor",
                    descName,
                    name,
                  );
                  return map;
                }, Object.create(null))
              : null,
          };
        }
        addProperty_(name, syntax) {
          if (!syntax) {
            return;
          }
          this.properties[name] = this.createDescriptor(
            syntax,
            "Property",
            name,
          );
        }
        addType_(name, syntax) {
          if (!syntax) {
            return;
          }
          this.types[name] = this.createDescriptor(syntax, "Type", name);
        }
        checkAtruleName(atruleName) {
          if (!this.getAtrule(atruleName)) {
            return new error.SyntaxReferenceError(
              "Unknown at-rule",
              "@" + atruleName,
            );
          }
        }
        checkAtrulePrelude(atruleName, prelude) {
          const error = this.checkAtruleName(atruleName);
          if (error) {
            return error;
          }
          const atrule = this.getAtrule(atruleName);
          if (!atrule.prelude && prelude) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` should not contain a prelude",
            );
          }
          if (atrule.prelude && !prelude) {
            if (!matchSyntax(this, atrule.prelude, "", false).matched) {
              return new SyntaxError(
                "At-rule `@" + atruleName + "` should contain a prelude",
              );
            }
          }
        }
        checkAtruleDescriptorName(atruleName, descriptorName) {
          const error$1 = this.checkAtruleName(atruleName);
          if (error$1) {
            return error$1;
          }
          const atrule = this.getAtrule(atruleName);
          const descriptor = names.keyword(descriptorName);
          if (!atrule.descriptors) {
            return new SyntaxError(
              "At-rule `@" + atruleName + "` has no known descriptors",
            );
          }
          if (
            !atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]
          ) {
            return new error.SyntaxReferenceError(
              "Unknown at-rule descriptor",
              descriptorName,
            );
          }
        }
        checkPropertyName(propertyName) {
          if (!this.getProperty(propertyName)) {
            return new error.SyntaxReferenceError(
              "Unknown property",
              propertyName,
            );
          }
        }
        matchAtrulePrelude(atruleName, prelude) {
          const error = this.checkAtrulePrelude(atruleName, prelude);
          if (error) {
            return buildMatchResult(null, error);
          }
          const atrule = this.getAtrule(atruleName);
          if (!atrule.prelude) {
            return buildMatchResult(null, null);
          }
          return matchSyntax(this, atrule.prelude, prelude || "", false);
        }
        matchAtruleDescriptor(atruleName, descriptorName, value) {
          const error = this.checkAtruleDescriptorName(
            atruleName,
            descriptorName,
          );
          if (error) {
            return buildMatchResult(null, error);
          }
          const atrule = this.getAtrule(atruleName);
          const descriptor = names.keyword(descriptorName);
          return matchSyntax(
            this,
            atrule.descriptors[descriptor.name] ||
              atrule.descriptors[descriptor.basename],
            value,
            false,
          );
        }
        matchDeclaration(node) {
          if (node.type !== "Declaration") {
            return buildMatchResult(null, new Error("Not a Declaration node"));
          }
          return this.matchProperty(node.property, node.value);
        }
        matchProperty(propertyName, value) {
          if (names.property(propertyName).custom) {
            return buildMatchResult(
              null,
              new Error(
                "Lexer matching doesn't applicable for custom properties",
              ),
            );
          }
          const error = this.checkPropertyName(propertyName);
          if (error) {
            return buildMatchResult(null, error);
          }
          return matchSyntax(this, this.getProperty(propertyName), value, true);
        }
        matchType(typeName, value) {
          const typeSyntax = this.getType(typeName);
          if (!typeSyntax) {
            return buildMatchResult(
              null,
              new error.SyntaxReferenceError("Unknown type", typeName),
            );
          }
          return matchSyntax(this, typeSyntax, value, false);
        }
        match(syntax, value) {
          if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
            return buildMatchResult(
              null,
              new error.SyntaxReferenceError("Bad syntax"),
            );
          }
          if (typeof syntax === "string" || !syntax.match) {
            syntax = this.createDescriptor(syntax, "Type", "anonymous");
          }
          return matchSyntax(this, syntax, value, false);
        }
        findValueFragments(propertyName, value, type, name) {
          return search.matchFragments(
            this,
            value,
            this.matchProperty(propertyName, value),
            type,
            name,
          );
        }
        findDeclarationValueFragments(declaration, type, name) {
          return search.matchFragments(
            this,
            declaration.value,
            this.matchDeclaration(declaration),
            type,
            name,
          );
        }
        findAllFragments(ast, type, name) {
          const result = [];
          this.syntax.walk(ast, {
            visit: "Declaration",
            enter: (declaration) => {
              result.push.apply(
                result,
                this.findDeclarationValueFragments(declaration, type, name),
              );
            },
          });
          return result;
        }
        getAtrule(atruleName, fallbackBasename = true) {
          const atrule = names.keyword(atruleName);
          const atruleEntry =
            atrule.vendor && fallbackBasename
              ? this.atrules[atrule.name] || this.atrules[atrule.basename]
              : this.atrules[atrule.name];
          return atruleEntry || null;
        }
        getAtrulePrelude(atruleName, fallbackBasename = true) {
          const atrule = this.getAtrule(atruleName, fallbackBasename);
          return (atrule && atrule.prelude) || null;
        }
        getAtruleDescriptor(atruleName, name) {
          return this.atrules.hasOwnProperty(atruleName) &&
            this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
        }
        getProperty(propertyName, fallbackBasename = true) {
          const property = names.property(propertyName);
          const propertyEntry =
            property.vendor && fallbackBasename
              ? this.properties[property.name] ||
                this.properties[property.basename]
              : this.properties[property.name];
          return propertyEntry || null;
        }
        getType(name) {
          return hasOwnProperty.call(this.types, name)
            ? this.types[name]
            : null;
        }
        validate() {
          function validate(syntax, name, broken, descriptor) {
            if (broken.has(name)) {
              return broken.get(name);
            }
            broken.set(name, false);
            if (descriptor.syntax !== null) {
              walk.walk(
                descriptor.syntax,
                function (node) {
                  if (node.type !== "Type" && node.type !== "Property") {
                    return;
                  }
                  const map =
                    node.type === "Type" ? syntax.types : syntax.properties;
                  const brokenMap =
                    node.type === "Type" ? brokenTypes : brokenProperties;
                  if (
                    !hasOwnProperty.call(map, node.name) ||
                    validate(syntax, node.name, brokenMap, map[node.name])
                  ) {
                    broken.set(name, true);
                  }
                },
                this,
              );
            }
          }
          let brokenTypes = new Map();
          let brokenProperties = new Map();
          for (const key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
          }
          for (const key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
          }
          brokenTypes = [...brokenTypes.keys()].filter((name) =>
            brokenTypes.get(name),
          );
          brokenProperties = [...brokenProperties.keys()].filter((name) =>
            brokenProperties.get(name),
          );
          if (brokenTypes.length || brokenProperties.length) {
            return { types: brokenTypes, properties: brokenProperties };
          }
          return null;
        }
        dump(syntaxAsAst, pretty) {
          return {
            generic: this.generic,
            units: this.units,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst),
          };
        }
        toString() {
          return JSON.stringify(this.dump());
        }
      }
      exports.Lexer = Lexer;
    },
    5789: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const createCustomError = __nccwpck_require__(5850);
      const generate = __nccwpck_require__(2359);
      const defaultLoc = { offset: 0, line: 1, column: 1 };
      function locateMismatch(matchResult, node) {
        const tokens = matchResult.tokens;
        const longestMatch = matchResult.longestMatch;
        const mismatchNode =
          longestMatch < tokens.length
            ? tokens[longestMatch].node || null
            : null;
        const badNode = mismatchNode !== node ? mismatchNode : null;
        let mismatchOffset = 0;
        let mismatchLength = 0;
        let entries = 0;
        let css = "";
        let start;
        let end;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i].value;
          if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
          }
          if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
              entries++;
            } else {
              entries = 0;
            }
          }
          css += token;
        }
        if (longestMatch === tokens.length || entries > 1) {
          start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
          end = buildLoc(start);
        } else {
          start =
            fromLoc(badNode, "start") ||
            buildLoc(
              fromLoc(node, "start") || defaultLoc,
              css.slice(0, mismatchOffset),
            );
          end =
            fromLoc(badNode, "end") ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
        }
        return { css, mismatchOffset, mismatchLength, start, end };
      }
      function fromLoc(node, point) {
        const value = node && node.loc && node.loc[point];
        if (value) {
          return "line" in value ? buildLoc(value) : value;
        }
        return null;
      }
      function buildLoc({ offset, line, column }, extra) {
        const loc = { offset, line, column };
        if (extra) {
          const lines = extra.split(/\n|\r\n?|\f/);
          loc.offset += extra.length;
          loc.line += lines.length - 1;
          loc.column =
            lines.length === 1
              ? loc.column + extra.length
              : lines.pop().length + 1;
        }
        return loc;
      }
      const SyntaxReferenceError = function (type, referenceName) {
        const error = createCustomError.createCustomError(
          "SyntaxReferenceError",
          type + (referenceName ? " `" + referenceName + "`" : ""),
        );
        error.reference = referenceName;
        return error;
      };
      const SyntaxMatchError = function (message, syntax, node, matchResult) {
        const error = createCustomError.createCustomError(
          "SyntaxMatchError",
          message,
        );
        const { css, mismatchOffset, mismatchLength, start, end } =
          locateMismatch(matchResult, node);
        error.rawMessage = message;
        error.syntax = syntax ? generate.generate(syntax) : "<generic>";
        error.css = css;
        error.mismatchOffset = mismatchOffset;
        error.mismatchLength = mismatchLength;
        error.message =
          message +
          "\n" +
          "  syntax: " +
          error.syntax +
          "\n" +
          "   value: " +
          (css || "<empty string>") +
          "\n" +
          "  --------" +
          new Array(error.mismatchOffset + 1).join("-") +
          "^";
        Object.assign(error, start);
        error.loc = {
          source: (node && node.loc && node.loc.source) || "<unknown>",
          start,
          end,
        };
        return error;
      };
      exports.SyntaxMatchError = SyntaxMatchError;
      exports.SyntaxReferenceError = SyntaxReferenceError;
    },
    9370: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(6001);
      const types = __nccwpck_require__(8839);
      const utils = __nccwpck_require__(1255);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const N = 110;
      const DISALLOW_SIGN = true;
      const ALLOW_SIGN = false;
      function isDelim(token, code) {
        return (
          token !== null &&
          token.type === types.Delim &&
          token.value.charCodeAt(0) === code
        );
      }
      function skipSC(token, offset, getNextToken) {
        while (
          token !== null &&
          (token.type === types.WhiteSpace || token.type === types.Comment)
        ) {
          token = getNextToken(++offset);
        }
        return offset;
      }
      function checkInteger(token, valueOffset, disallowSign, offset) {
        if (!token) {
          return 0;
        }
        const code = token.value.charCodeAt(valueOffset);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            return 0;
          }
          valueOffset++;
        }
        for (; valueOffset < token.value.length; valueOffset++) {
          if (
            !charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))
          ) {
            return 0;
          }
        }
        return offset + 1;
      }
      function consumeB(token, offset_, getNextToken) {
        let sign = false;
        let offset = skipSC(token, offset_, getNextToken);
        token = getNextToken(offset);
        if (token === null) {
          return offset_;
        }
        if (token.type !== types.Number) {
          if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            if (token === null || token.type !== types.Number) {
              return 0;
            }
          } else {
            return offset_;
          }
        }
        if (!sign) {
          const code = token.value.charCodeAt(0);
          if (code !== PLUSSIGN && code !== HYPHENMINUS) {
            return 0;
          }
        }
        return checkInteger(token, sign ? 0 : 1, sign, offset);
      }
      function anPlusB(token, getNextToken) {
        let offset = 0;
        if (!token) {
          return 0;
        }
        if (token.type === types.Number) {
          return checkInteger(token, 0, ALLOW_SIGN, offset);
        } else if (
          token.type === types.Ident &&
          token.value.charCodeAt(0) === HYPHENMINUS
        ) {
          if (!utils.cmpChar(token.value, 1, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 2:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 3:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(2) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 3, DISALLOW_SIGN, offset);
          }
        } else if (
          token.type === types.Ident ||
          (isDelim(token, PLUSSIGN) &&
            getNextToken(offset + 1).type === types.Ident)
        ) {
          if (token.type !== types.Ident) {
            token = getNextToken(++offset);
          }
          if (token === null || !utils.cmpChar(token.value, 0, N)) {
            return 0;
          }
          switch (token.value.length) {
            case 1:
              return consumeB(getNextToken(++offset), offset, getNextToken);
            case 2:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            default:
              if (token.value.charCodeAt(1) !== HYPHENMINUS) {
                return 0;
              }
              return checkInteger(token, 2, DISALLOW_SIGN, offset);
          }
        } else if (token.type === types.Dimension) {
          let code = token.value.charCodeAt(0);
          let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
          let i = sign;
          for (; i < token.value.length; i++) {
            if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
              break;
            }
          }
          if (i === sign) {
            return 0;
          }
          if (!utils.cmpChar(token.value, i, N)) {
            return 0;
          }
          if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
          } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
              return 0;
            }
            if (i + 2 === token.value.length) {
              offset = skipSC(getNextToken(++offset), offset, getNextToken);
              token = getNextToken(offset);
              return checkInteger(token, 0, DISALLOW_SIGN, offset);
            } else {
              return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
          }
        }
        return 0;
      }
      module.exports = anPlusB;
    },
    7988: (__unused_webpack_module, exports) => {
      "use strict";
      const cssWideKeywords = [
        "initial",
        "inherit",
        "unset",
        "revert",
        "revert-layer",
      ];
      exports.cssWideKeywords = cssWideKeywords;
    },
    2319: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(6001);
      const types = __nccwpck_require__(8839);
      const utils = __nccwpck_require__(1255);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const QUESTIONMARK = 63;
      const U = 117;
      function isDelim(token, code) {
        return (
          token !== null &&
          token.type === types.Delim &&
          token.value.charCodeAt(0) === code
        );
      }
      function startsWith(token, code) {
        return token.value.charCodeAt(0) === code;
      }
      function hexSequence(token, offset, allowDash) {
        let hexlen = 0;
        for (let pos = offset; pos < token.value.length; pos++) {
          const code = token.value.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
            hexSequence(token, offset + hexlen + 1, false);
            return 6;
          }
          if (!charCodeDefinitions.isHexDigit(code)) {
            return 0;
          }
          if (++hexlen > 6) {
            return 0;
          }
        }
        return hexlen;
      }
      function withQuestionMarkSequence(consumed, length, getNextToken) {
        if (!consumed) {
          return 0;
        }
        while (isDelim(getNextToken(length), QUESTIONMARK)) {
          if (++consumed > 6) {
            return 0;
          }
          length++;
        }
        return length;
      }
      function urange(token, getNextToken) {
        let length = 0;
        if (
          token === null ||
          token.type !== types.Ident ||
          !utils.cmpChar(token.value, 0, U)
        ) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (isDelim(token, PLUSSIGN)) {
          token = getNextToken(++length);
          if (token === null) {
            return 0;
          }
          if (token.type === types.Ident) {
            return withQuestionMarkSequence(
              hexSequence(token, 0, true),
              ++length,
              getNextToken,
            );
          }
          if (isDelim(token, QUESTIONMARK)) {
            return withQuestionMarkSequence(1, ++length, getNextToken);
          }
          return 0;
        }
        if (token.type === types.Number) {
          const consumedHexLength = hexSequence(token, 1, true);
          if (consumedHexLength === 0) {
            return 0;
          }
          token = getNextToken(++length);
          if (token === null) {
            return length;
          }
          if (token.type === types.Dimension || token.type === types.Number) {
            if (
              !startsWith(token, HYPHENMINUS) ||
              !hexSequence(token, 1, false)
            ) {
              return 0;
            }
            return length + 1;
          }
          return withQuestionMarkSequence(
            consumedHexLength,
            length,
            getNextToken,
          );
        }
        if (token.type === types.Dimension) {
          return withQuestionMarkSequence(
            hexSequence(token, 1, true),
            ++length,
            getNextToken,
          );
        }
        return 0;
      }
      module.exports = urange;
    },
    8259: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const genericConst = __nccwpck_require__(7988);
      const genericAnPlusB = __nccwpck_require__(9370);
      const genericUrange = __nccwpck_require__(2319);
      const types = __nccwpck_require__(8839);
      const charCodeDefinitions = __nccwpck_require__(6001);
      const utils = __nccwpck_require__(1255);
      const calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
      const balancePair = new Map([
        [types.Function, types.RightParenthesis],
        [types.LeftParenthesis, types.RightParenthesis],
        [types.LeftSquareBracket, types.RightSquareBracket],
        [types.LeftCurlyBracket, types.RightCurlyBracket],
      ]);
      function charCodeAt(str, index) {
        return index < str.length ? str.charCodeAt(index) : 0;
      }
      function eqStr(actual, expected) {
        return utils.cmpStr(actual, 0, actual.length, expected);
      }
      function eqStrAny(actual, expected) {
        for (let i = 0; i < expected.length; i++) {
          if (eqStr(actual, expected[i])) {
            return true;
          }
        }
        return false;
      }
      function isPostfixIeHack(str, offset) {
        if (offset !== str.length - 2) {
          return false;
        }
        return (
          charCodeAt(str, offset) === 92 &&
          charCodeDefinitions.isDigit(charCodeAt(str, offset + 1))
        );
      }
      function outOfRange(opts, value, numEnd) {
        if (opts && opts.type === "Range") {
          const num = Number(
            numEnd !== undefined && numEnd !== value.length
              ? value.substr(0, numEnd)
              : value,
          );
          if (isNaN(num)) {
            return true;
          }
          if (
            opts.min !== null &&
            num < opts.min &&
            typeof opts.min !== "string"
          ) {
            return true;
          }
          if (
            opts.max !== null &&
            num > opts.max &&
            typeof opts.max !== "string"
          ) {
            return true;
          }
        }
        return false;
      }
      function consumeFunction(token, getNextToken) {
        let balanceCloseType = 0;
        let balanceStash = [];
        let length = 0;
        scan: do {
          switch (token.type) {
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              if (balanceStash.length === 0) {
                length++;
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while ((token = getNextToken(length)));
        return length;
      }
      function calc(next) {
        return function (token, getNextToken, opts) {
          if (token === null) {
            return 0;
          }
          if (
            token.type === types.Function &&
            eqStrAny(token.value, calcFunctionNames)
          ) {
            return consumeFunction(token, getNextToken);
          }
          return next(token, getNextToken, opts);
        };
      }
      function tokenType(expectedTokenType) {
        return function (token) {
          if (token === null || token.type !== expectedTokenType) {
            return 0;
          }
          return 1;
        };
      }
      function customIdent(token) {
        if (token === null || token.type !== types.Ident) {
          return 0;
        }
        const name = token.value.toLowerCase();
        if (eqStrAny(name, genericConst.cssWideKeywords)) {
          return 0;
        }
        if (eqStr(name, "default")) {
          return 0;
        }
        return 1;
      }
      function customPropertyName(token) {
        if (token === null || token.type !== types.Ident) {
          return 0;
        }
        if (
          charCodeAt(token.value, 0) !== 45 ||
          charCodeAt(token.value, 1) !== 45
        ) {
          return 0;
        }
        return 1;
      }
      function hexColor(token) {
        if (token === null || token.type !== types.Hash) {
          return 0;
        }
        const length = token.value.length;
        if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
          return 0;
        }
        for (let i = 1; i < length; i++) {
          if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
            return 0;
          }
        }
        return 1;
      }
      function idSelector(token) {
        if (token === null || token.type !== types.Hash) {
          return 0;
        }
        if (
          !charCodeDefinitions.isIdentifierStart(
            charCodeAt(token.value, 1),
            charCodeAt(token.value, 2),
            charCodeAt(token.value, 3),
          )
        ) {
          return 0;
        }
        return 1;
      }
      function declarationValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        let balanceCloseType = 0;
        let balanceStash = [];
        let length = 0;
        scan: do {
          switch (token.type) {
            case types.BadString:
            case types.BadUrl:
              break scan;
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Semicolon:
              if (balanceCloseType === 0) {
                break scan;
              }
              break;
            case types.Delim:
              if (balanceCloseType === 0 && token.value === "!") {
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while ((token = getNextToken(length)));
        return length;
      }
      function anyValue(token, getNextToken) {
        if (!token) {
          return 0;
        }
        let balanceCloseType = 0;
        let balanceStash = [];
        let length = 0;
        scan: do {
          switch (token.type) {
            case types.BadString:
            case types.BadUrl:
              break scan;
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while ((token = getNextToken(length)));
        return length;
      }
      function dimension(type) {
        if (type) {
          type = new Set(type);
        }
        return function (token, getNextToken, opts) {
          if (token === null || token.type !== types.Dimension) {
            return 0;
          }
          const numberEnd = utils.consumeNumber(token.value, 0);
          if (type !== null) {
            const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
            const unit =
              reverseSolidusOffset === -1 ||
              !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);
            if (type.has(unit.toLowerCase()) === false) {
              return 0;
            }
          }
          if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
          }
          return 1;
        };
      }
      function percentage(token, getNextToken, opts) {
        if (token === null || token.type !== types.Percentage) {
          return 0;
        }
        if (outOfRange(opts, token.value, token.value.length - 1)) {
          return 0;
        }
        return 1;
      }
      function zero(next) {
        if (typeof next !== "function") {
          next = function () {
            return 0;
          };
        }
        return function (token, getNextToken, opts) {
          if (token !== null && token.type === types.Number) {
            if (Number(token.value) === 0) {
              return 1;
            }
          }
          return next(token, getNextToken, opts);
        };
      }
      function number(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        const numberEnd = utils.consumeNumber(token.value, 0);
        const isNumber = numberEnd === token.value.length;
        if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
          return 0;
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      }
      function integer(token, getNextToken, opts) {
        if (token === null || token.type !== types.Number) {
          return 0;
        }
        let i =
          charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45
            ? 1
            : 0;
        for (; i < token.value.length; i++) {
          if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, i)) {
          return 0;
        }
        return 1;
      }
      const tokenTypes = {
        "ident-token": tokenType(types.Ident),
        "function-token": tokenType(types.Function),
        "at-keyword-token": tokenType(types.AtKeyword),
        "hash-token": tokenType(types.Hash),
        "string-token": tokenType(types.String),
        "bad-string-token": tokenType(types.BadString),
        "url-token": tokenType(types.Url),
        "bad-url-token": tokenType(types.BadUrl),
        "delim-token": tokenType(types.Delim),
        "number-token": tokenType(types.Number),
        "percentage-token": tokenType(types.Percentage),
        "dimension-token": tokenType(types.Dimension),
        "whitespace-token": tokenType(types.WhiteSpace),
        "CDO-token": tokenType(types.CDO),
        "CDC-token": tokenType(types.CDC),
        "colon-token": tokenType(types.Colon),
        "semicolon-token": tokenType(types.Semicolon),
        "comma-token": tokenType(types.Comma),
        "[-token": tokenType(types.LeftSquareBracket),
        "]-token": tokenType(types.RightSquareBracket),
        "(-token": tokenType(types.LeftParenthesis),
        ")-token": tokenType(types.RightParenthesis),
        "{-token": tokenType(types.LeftCurlyBracket),
        "}-token": tokenType(types.RightCurlyBracket),
      };
      const productionTypes = {
        string: tokenType(types.String),
        ident: tokenType(types.Ident),
        percentage: calc(percentage),
        zero: zero(),
        number: calc(number),
        integer: calc(integer),
        "custom-ident": customIdent,
        "custom-property-name": customPropertyName,
        "hex-color": hexColor,
        "id-selector": idSelector,
        "an-plus-b": genericAnPlusB,
        urange: genericUrange,
        "declaration-value": declarationValue,
        "any-value": anyValue,
      };
      function createDemensionTypes(units) {
        const {
          angle,
          decibel,
          frequency,
          flex,
          length,
          resolution,
          semitones,
          time,
        } = units || {};
        return {
          dimension: calc(dimension(null)),
          angle: calc(dimension(angle)),
          decibel: calc(dimension(decibel)),
          frequency: calc(dimension(frequency)),
          flex: calc(dimension(flex)),
          length: calc(zero(dimension(length))),
          resolution: calc(dimension(resolution)),
          semitones: calc(dimension(semitones)),
          time: calc(dimension(time)),
        };
      }
      function createGenericTypes(units) {
        return {
          ...tokenTypes,
          ...productionTypes,
          ...createDemensionTypes(units),
        };
      }
      exports.createDemensionTypes = createDemensionTypes;
      exports.createGenericTypes = createGenericTypes;
      exports.productionTypes = productionTypes;
      exports.tokenTypes = tokenTypes;
    },
    4114: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const parse = __nccwpck_require__(9242);
      const MATCH = { type: "Match" };
      const MISMATCH = { type: "Mismatch" };
      const DISALLOW_EMPTY = { type: "DisallowEmpty" };
      const LEFTPARENTHESIS = 40;
      const RIGHTPARENTHESIS = 41;
      function createCondition(match, thenBranch, elseBranch) {
        if (thenBranch === MATCH && elseBranch === MISMATCH) {
          return match;
        }
        if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
          return match;
        }
        if (
          match.type === "If" &&
          match.else === MISMATCH &&
          thenBranch === MATCH
        ) {
          thenBranch = match.then;
          match = match.match;
        }
        return { type: "If", match, then: thenBranch, else: elseBranch };
      }
      function isFunctionType(name) {
        return (
          name.length > 2 &&
          name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
          name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
        );
      }
      function isEnumCapatible(term) {
        return (
          term.type === "Keyword" ||
          term.type === "AtKeyword" ||
          term.type === "Function" ||
          (term.type === "Type" && isFunctionType(term.name))
        );
      }
      function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
        switch (combinator) {
          case " ": {
            let result = MATCH;
            for (let i = terms.length - 1; i >= 0; i--) {
              const term = terms[i];
              result = createCondition(term, result, MISMATCH);
            }
            return result;
          }
          case "|": {
            let result = MISMATCH;
            let map = null;
            for (let i = terms.length - 1; i >= 0; i--) {
              let term = terms[i];
              if (isEnumCapatible(term)) {
                if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                  map = Object.create(null);
                  result = createCondition(
                    { type: "Enum", map },
                    MATCH,
                    result,
                  );
                }
                if (map !== null) {
                  const key = (
                    isFunctionType(term.name)
                      ? term.name.slice(0, -1)
                      : term.name
                  ).toLowerCase();
                  if (key in map === false) {
                    map[key] = term;
                    continue;
                  }
                }
              }
              map = null;
              result = createCondition(term, MATCH, result);
            }
            return result;
          }
          case "&&": {
            if (terms.length > 5) {
              return { type: "MatchOnce", terms, all: true };
            }
            let result = MISMATCH;
            for (let i = terms.length - 1; i >= 0; i--) {
              const term = terms[i];
              let thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function (newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  false,
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(term, thenClause, result);
            }
            return result;
          }
          case "||": {
            if (terms.length > 5) {
              return { type: "MatchOnce", terms, all: false };
            }
            let result = atLeastOneTermMatched ? MATCH : MISMATCH;
            for (let i = terms.length - 1; i >= 0; i--) {
              const term = terms[i];
              let thenClause;
              if (terms.length > 1) {
                thenClause = buildGroupMatchGraph(
                  combinator,
                  terms.filter(function (newGroupTerm) {
                    return newGroupTerm !== term;
                  }),
                  true,
                );
              } else {
                thenClause = MATCH;
              }
              result = createCondition(term, thenClause, result);
            }
            return result;
          }
        }
      }
      function buildMultiplierMatchGraph(node) {
        let result = MATCH;
        let matchTerm = buildMatchGraphInternal(node.term);
        if (node.max === 0) {
          matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
          result = createCondition(matchTerm, null, MISMATCH);
          result.then = createCondition(MATCH, MATCH, result);
          if (node.comma) {
            result.then.else = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH,
            );
          }
        } else {
          for (let i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH,
              );
            }
            result = createCondition(
              matchTerm,
              createCondition(MATCH, MATCH, result),
              MISMATCH,
            );
          }
        }
        if (node.min === 0) {
          result = createCondition(MATCH, MATCH, result);
        } else {
          for (let i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
              result = createCondition(
                { type: "Comma", syntax: node },
                result,
                MISMATCH,
              );
            }
            result = createCondition(matchTerm, result, MISMATCH);
          }
        }
        return result;
      }
      function buildMatchGraphInternal(node) {
        if (typeof node === "function") {
          return { type: "Generic", fn: node };
        }
        switch (node.type) {
          case "Group": {
            let result = buildGroupMatchGraph(
              node.combinator,
              node.terms.map(buildMatchGraphInternal),
              false,
            );
            if (node.disallowEmpty) {
              result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
            }
            return result;
          }
          case "Multiplier":
            return buildMultiplierMatchGraph(node);
          case "Type":
          case "Property":
            return { type: node.type, name: node.name, syntax: node };
          case "Keyword":
            return {
              type: node.type,
              name: node.name.toLowerCase(),
              syntax: node,
            };
          case "AtKeyword":
            return {
              type: node.type,
              name: "@" + node.name.toLowerCase(),
              syntax: node,
            };
          case "Function":
            return {
              type: node.type,
              name: node.name.toLowerCase() + "(",
              syntax: node,
            };
          case "String":
            if (node.value.length === 3) {
              return {
                type: "Token",
                value: node.value.charAt(1),
                syntax: node,
              };
            }
            return {
              type: node.type,
              value: node.value
                .substr(1, node.value.length - 2)
                .replace(/\\'/g, "'"),
              syntax: node,
            };
          case "Token":
            return { type: node.type, value: node.value, syntax: node };
          case "Comma":
            return { type: node.type, syntax: node };
          default:
            throw new Error("Unknown node type:", node.type);
        }
      }
      function buildMatchGraph(syntaxTree, ref) {
        if (typeof syntaxTree === "string") {
          syntaxTree = parse.parse(syntaxTree);
        }
        return {
          type: "MatchGraph",
          match: buildMatchGraphInternal(syntaxTree),
          syntax: ref || null,
          source: syntaxTree,
        };
      }
      exports.DISALLOW_EMPTY = DISALLOW_EMPTY;
      exports.MATCH = MATCH;
      exports.MISMATCH = MISMATCH;
      exports.buildMatchGraph = buildMatchGraph;
    },
    7416: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const matchGraph = __nccwpck_require__(4114);
      const types = __nccwpck_require__(8839);
      const { hasOwnProperty } = Object.prototype;
      const STUB = 0;
      const TOKEN = 1;
      const OPEN_SYNTAX = 2;
      const CLOSE_SYNTAX = 3;
      const EXIT_REASON_MATCH = "Match";
      const EXIT_REASON_MISMATCH = "Mismatch";
      const EXIT_REASON_ITERATION_LIMIT =
        "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
      const ITERATION_LIMIT = 15e3;
      function reverseList(list) {
        let prev = null;
        let next = null;
        let item = list;
        while (item !== null) {
          next = item.prev;
          item.prev = prev;
          prev = item;
          item = next;
        }
        return prev;
      }
      function areStringsEqualCaseInsensitive(testStr, referenceStr) {
        if (testStr.length !== referenceStr.length) {
          return false;
        }
        for (let i = 0; i < testStr.length; i++) {
          const referenceCode = referenceStr.charCodeAt(i);
          let testCode = testStr.charCodeAt(i);
          if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function isContextEdgeDelim(token) {
        if (token.type !== types.Delim) {
          return false;
        }
        return token.value !== "?";
      }
      function isCommaContextStart(token) {
        if (token === null) {
          return true;
        }
        return (
          token.type === types.Comma ||
          token.type === types.Function ||
          token.type === types.LeftParenthesis ||
          token.type === types.LeftSquareBracket ||
          token.type === types.LeftCurlyBracket ||
          isContextEdgeDelim(token)
        );
      }
      function isCommaContextEnd(token) {
        if (token === null) {
          return true;
        }
        return (
          token.type === types.RightParenthesis ||
          token.type === types.RightSquareBracket ||
          token.type === types.RightCurlyBracket ||
          (token.type === types.Delim && token.value === "/")
        );
      }
      function internalMatch(tokens, state, syntaxes) {
        function moveToNextToken() {
          do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          } while (
            token !== null &&
            (token.type === types.WhiteSpace || token.type === types.Comment)
          );
        }
        function getNextToken(offset) {
          const nextIndex = tokenIndex + offset;
          return nextIndex < tokens.length ? tokens[nextIndex] : null;
        }
        function stateSnapshotFromSyntax(nextState, prev) {
          return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev,
          };
        }
        function pushThenStack(nextState) {
          thenStack = { nextState, matchStack, syntaxStack, prev: thenStack };
        }
        function pushElseStack(nextState) {
          elseStack = stateSnapshotFromSyntax(nextState, elseStack);
        }
        function addTokenToMatch() {
          matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token,
            prev: matchStack,
          };
          moveToNextToken();
          syntaxStash = null;
          if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
          }
        }
        function openSyntax() {
          syntaxStack = {
            syntax: state.syntax,
            opts:
              state.syntax.opts ||
              (syntaxStack !== null && syntaxStack.opts) ||
              null,
            prev: syntaxStack,
          };
          matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack,
          };
        }
        function closeSyntax() {
          if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
          } else {
            matchStack = {
              type: CLOSE_SYNTAX,
              syntax: syntaxStack.syntax,
              token: matchStack.token,
              prev: matchStack,
            };
          }
          syntaxStack = syntaxStack.prev;
        }
        let syntaxStack = null;
        let thenStack = null;
        let elseStack = null;
        let syntaxStash = null;
        let iterationCount = 0;
        let exitReason = null;
        let token = null;
        let tokenIndex = -1;
        let longestMatch = 0;
        let matchStack = { type: STUB, syntax: null, token: null, prev: null };
        moveToNextToken();
        while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
          switch (state.type) {
            case "Match":
              if (thenStack === null) {
                if (token !== null) {
                  if (
                    tokenIndex !== tokens.length - 1 ||
                    (token.value !== "\\0" && token.value !== "\\9")
                  ) {
                    state = matchGraph.MISMATCH;
                    break;
                  }
                }
                exitReason = EXIT_REASON_MATCH;
                break;
              }
              state = thenStack.nextState;
              if (state === matchGraph.DISALLOW_EMPTY) {
                if (thenStack.matchStack === matchStack) {
                  state = matchGraph.MISMATCH;
                  break;
                } else {
                  state = matchGraph.MATCH;
                }
              }
              while (thenStack.syntaxStack !== syntaxStack) {
                closeSyntax();
              }
              thenStack = thenStack.prev;
              break;
            case "Mismatch":
              if (syntaxStash !== null && syntaxStash !== false) {
                if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                  elseStack = syntaxStash;
                  syntaxStash = false;
                }
              } else if (elseStack === null) {
                exitReason = EXIT_REASON_MISMATCH;
                break;
              }
              state = elseStack.nextState;
              thenStack = elseStack.thenStack;
              syntaxStack = elseStack.syntaxStack;
              matchStack = elseStack.matchStack;
              tokenIndex = elseStack.tokenIndex;
              token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
              elseStack = elseStack.prev;
              break;
            case "MatchGraph":
              state = state.match;
              break;
            case "If":
              if (state.else !== matchGraph.MISMATCH) {
                pushElseStack(state.else);
              }
              if (state.then !== matchGraph.MATCH) {
                pushThenStack(state.then);
              }
              state = state.match;
              break;
            case "MatchOnce":
              state = {
                type: "MatchOnceBuffer",
                syntax: state,
                index: 0,
                mask: 0,
              };
              break;
            case "MatchOnceBuffer": {
              const terms = state.syntax.terms;
              if (state.index === terms.length) {
                if (state.mask === 0 || state.syntax.all) {
                  state = matchGraph.MISMATCH;
                  break;
                }
                state = matchGraph.MATCH;
                break;
              }
              if (state.mask === (1 << terms.length) - 1) {
                state = matchGraph.MATCH;
                break;
              }
              for (; state.index < terms.length; state.index++) {
                const matchFlag = 1 << state.index;
                if ((state.mask & matchFlag) === 0) {
                  pushElseStack(state);
                  pushThenStack({
                    type: "AddMatchOnce",
                    syntax: state.syntax,
                    mask: state.mask | matchFlag,
                  });
                  state = terms[state.index++];
                  break;
                }
              }
              break;
            }
            case "AddMatchOnce":
              state = {
                type: "MatchOnceBuffer",
                syntax: state.syntax,
                index: 0,
                mask: state.mask,
              };
              break;
            case "Enum":
              if (token !== null) {
                let name = token.value.toLowerCase();
                if (name.indexOf("\\") !== -1) {
                  name = name.replace(/\\[09].*$/, "");
                }
                if (hasOwnProperty.call(state.map, name)) {
                  state = state.map[name];
                  break;
                }
              }
              state = matchGraph.MISMATCH;
              break;
            case "Generic": {
              const opts = syntaxStack !== null ? syntaxStack.opts : null;
              const lastTokenIndex =
                tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
              if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state = matchGraph.MATCH;
              } else {
                state = matchGraph.MISMATCH;
              }
              break;
            }
            case "Type":
            case "Property": {
              const syntaxDict = state.type === "Type" ? "types" : "properties";
              const dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict)
                ? syntaxes[syntaxDict][state.name]
                : null;
              if (!dictSyntax || !dictSyntax.match) {
                throw new Error(
                  "Bad syntax reference: " +
                    (state.type === "Type"
                      ? "<" + state.name + ">"
                      : "<'" + state.name + "'>"),
                );
              }
              if (
                syntaxStash !== false &&
                token !== null &&
                state.type === "Type"
              ) {
                const lowPriorityMatching =
                  (state.name === "custom-ident" &&
                    token.type === types.Ident) ||
                  (state.name === "length" && token.value === "0");
                if (lowPriorityMatching) {
                  if (syntaxStash === null) {
                    syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                  }
                  state = matchGraph.MISMATCH;
                  break;
                }
              }
              openSyntax();
              state = dictSyntax.match;
              break;
            }
            case "Keyword": {
              const name = state.name;
              if (token !== null) {
                let keywordName = token.value;
                if (keywordName.indexOf("\\") !== -1) {
                  keywordName = keywordName.replace(/\\[09].*$/, "");
                }
                if (areStringsEqualCaseInsensitive(keywordName, name)) {
                  addTokenToMatch();
                  state = matchGraph.MATCH;
                  break;
                }
              }
              state = matchGraph.MISMATCH;
              break;
            }
            case "AtKeyword":
            case "Function":
              if (
                token !== null &&
                areStringsEqualCaseInsensitive(token.value, state.name)
              ) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
              state = matchGraph.MISMATCH;
              break;
            case "Token":
              if (token !== null && token.value === state.value) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
              state = matchGraph.MISMATCH;
              break;
            case "Comma":
              if (token !== null && token.type === types.Comma) {
                if (isCommaContextStart(matchStack.token)) {
                  state = matchGraph.MISMATCH;
                } else {
                  addTokenToMatch();
                  state = isCommaContextEnd(token)
                    ? matchGraph.MISMATCH
                    : matchGraph.MATCH;
                }
              } else {
                state =
                  isCommaContextStart(matchStack.token) ||
                  isCommaContextEnd(token)
                    ? matchGraph.MATCH
                    : matchGraph.MISMATCH;
              }
              break;
            case "String":
              let string = "";
              let lastTokenIndex = tokenIndex;
              for (
                ;
                lastTokenIndex < tokens.length &&
                string.length < state.value.length;
                lastTokenIndex++
              ) {
                string += tokens[lastTokenIndex].value;
              }
              if (areStringsEqualCaseInsensitive(string, state.value)) {
                while (tokenIndex < lastTokenIndex) {
                  addTokenToMatch();
                }
                state = matchGraph.MATCH;
              } else {
                state = matchGraph.MISMATCH;
              }
              break;
            default:
              throw new Error("Unknown node type: " + state.type);
          }
        }
        switch (exitReason) {
          case null:
            console.warn(
              "[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations",
            );
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;
          case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
              closeSyntax();
            }
            break;
          default:
            matchStack = null;
        }
        return {
          tokens,
          reason: exitReason,
          iterations: iterationCount,
          match: matchStack,
          longestMatch,
        };
      }
      function matchAsList(tokens, matchGraph, syntaxes) {
        const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
        if (matchResult.match !== null) {
          let item = reverseList(matchResult.match).prev;
          matchResult.match = [];
          while (item !== null) {
            switch (item.type) {
              case OPEN_SYNTAX:
              case CLOSE_SYNTAX:
                matchResult.match.push({
                  type: item.type,
                  syntax: item.syntax,
                });
                break;
              default:
                matchResult.match.push({
                  token: item.token.value,
                  node: item.token.node,
                });
                break;
            }
            item = item.prev;
          }
        }
        return matchResult;
      }
      function matchAsTree(tokens, matchGraph, syntaxes) {
        const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
        if (matchResult.match === null) {
          return matchResult;
        }
        let item = matchResult.match;
        let host = (matchResult.match = {
          syntax: matchGraph.syntax || null,
          match: [],
        });
        const hostStack = [host];
        item = reverseList(item).prev;
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
              host.match.push((host = { syntax: item.syntax, match: [] }));
              hostStack.push(host);
              break;
            case CLOSE_SYNTAX:
              hostStack.pop();
              host = hostStack[hostStack.length - 1];
              break;
            default:
              host.match.push({
                syntax: item.syntax || null,
                token: item.token.value,
                node: item.token.node,
              });
          }
          item = item.prev;
        }
        return matchResult;
      }
      exports.matchAsList = matchAsList;
      exports.matchAsTree = matchAsTree;
    },
    6: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(7324);
      const astToTokens = {
        decorator(handlers) {
          const tokens = [];
          let curNode = null;
          return {
            ...handlers,
            node(node) {
              const tmp = curNode;
              curNode = node;
              handlers.node.call(this, node);
              curNode = tmp;
            },
            emit(value, type, auto) {
              tokens.push({ type, value, node: auto ? null : curNode });
            },
            result() {
              return tokens;
            },
          };
        },
      };
      function stringToTokens(str) {
        const tokens = [];
        index.tokenize(str, (type, start, end) =>
          tokens.push({ type, value: str.slice(start, end), node: null }),
        );
        return tokens;
      }
      function prepareTokens(value, syntax) {
        if (typeof value === "string") {
          return stringToTokens(value);
        }
        return syntax.generate(value, astToTokens);
      }
      module.exports = prepareTokens;
    },
    124: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(6929);
      function getFirstMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getFirstMatchNode(matchNode.match[0]);
      }
      function getLastMatchNode(matchNode) {
        if ("node" in matchNode) {
          return matchNode.node;
        }
        return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
      }
      function matchFragments(lexer, ast, match, type, name) {
        function findFragments(matchNode) {
          if (
            matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name
          ) {
            const start = getFirstMatchNode(matchNode);
            const end = getLastMatchNode(matchNode);
            lexer.syntax.walk(ast, function (node, item, list) {
              if (node === start) {
                const nodes = new List.List();
                do {
                  nodes.appendData(item.data);
                  if (item.data === end) {
                    break;
                  }
                  item = item.next;
                } while (item !== null);
                fragments.push({ parent: list, nodes });
              }
            });
          }
          if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
          }
        }
        const fragments = [];
        if (match.matched !== null) {
          findFragments(match.matched);
        }
        return fragments;
      }
      exports.matchFragments = matchFragments;
    },
    517: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(6929);
      const { hasOwnProperty } = Object.prototype;
      function isValidNumber(value) {
        return (
          typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value &&
          value >= 0
        );
      }
      function isValidLocation(loc) {
        return (
          Boolean(loc) &&
          isValidNumber(loc.offset) &&
          isValidNumber(loc.line) &&
          isValidNumber(loc.column)
        );
      }
      function createNodeStructureChecker(type, fields) {
        return function checkNode(node, warn) {
          if (!node || node.constructor !== Object) {
            return warn(node, "Type of node should be an Object");
          }
          for (let key in node) {
            let valid = true;
            if (hasOwnProperty.call(node, key) === false) {
              continue;
            }
            if (key === "type") {
              if (node.type !== type) {
                warn(
                  node,
                  "Wrong node type `" +
                    node.type +
                    "`, expected `" +
                    type +
                    "`",
                );
              }
            } else if (key === "loc") {
              if (node.loc === null) {
                continue;
              } else if (node.loc && node.loc.constructor === Object) {
                if (typeof node.loc.source !== "string") {
                  key += ".source";
                } else if (!isValidLocation(node.loc.start)) {
                  key += ".start";
                } else if (!isValidLocation(node.loc.end)) {
                  key += ".end";
                } else {
                  continue;
                }
              }
              valid = false;
            } else if (fields.hasOwnProperty(key)) {
              valid = false;
              for (let i = 0; !valid && i < fields[key].length; i++) {
                const fieldType = fields[key][i];
                switch (fieldType) {
                  case String:
                    valid = typeof node[key] === "string";
                    break;
                  case Boolean:
                    valid = typeof node[key] === "boolean";
                    break;
                  case null:
                    valid = node[key] === null;
                    break;
                  default:
                    if (typeof fieldType === "string") {
                      valid = node[key] && node[key].type === fieldType;
                    } else if (Array.isArray(fieldType)) {
                      valid = node[key] instanceof List.List;
                    }
                }
              }
            } else {
              warn(
                node,
                "Unknown field `" + key + "` for " + type + " node type",
              );
            }
            if (!valid) {
              warn(node, "Bad value for `" + type + "." + key + "`");
            }
          }
          for (const key in fields) {
            if (
              hasOwnProperty.call(fields, key) &&
              hasOwnProperty.call(node, key) === false
            ) {
              warn(node, "Field `" + type + "." + key + "` is missed");
            }
          }
        };
      }
      function processStructure(name, nodeType) {
        const structure = nodeType.structure;
        const fields = { type: String, loc: true };
        const docs = { type: '"' + name + '"' };
        for (const key in structure) {
          if (hasOwnProperty.call(structure, key) === false) {
            continue;
          }
          const docsTypes = [];
          const fieldTypes = (fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]]);
          for (let i = 0; i < fieldTypes.length; i++) {
            const fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
              docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
              docsTypes.push("null");
            } else if (typeof fieldType === "string") {
              docsTypes.push("<" + fieldType + ">");
            } else if (Array.isArray(fieldType)) {
              docsTypes.push("List");
            } else {
              throw new Error(
                "Wrong value `" +
                  fieldType +
                  "` in `" +
                  name +
                  "." +
                  key +
                  "` structure definition",
              );
            }
          }
          docs[key] = docsTypes.join(" | ");
        }
        return { docs, check: createNodeStructureChecker(name, fields) };
      }
      function getStructureFromConfig(config) {
        const structure = {};
        if (config.node) {
          for (const name in config.node) {
            if (hasOwnProperty.call(config.node, name)) {
              const nodeType = config.node[name];
              if (nodeType.structure) {
                structure[name] = processStructure(name, nodeType);
              } else {
                throw new Error(
                  "Missed `structure` field in `" +
                    name +
                    "` node type definition",
                );
              }
            }
          }
        }
        return structure;
      }
      exports.getStructureFromConfig = getStructureFromConfig;
    },
    9178: (__unused_webpack_module, exports) => {
      "use strict";
      function getTrace(node) {
        function shouldPutToTrace(syntax) {
          if (syntax === null) {
            return false;
          }
          return (
            syntax.type === "Type" ||
            syntax.type === "Property" ||
            syntax.type === "Keyword"
          );
        }
        function hasMatch(matchNode) {
          if (Array.isArray(matchNode.match)) {
            for (let i = 0; i < matchNode.match.length; i++) {
              if (hasMatch(matchNode.match[i])) {
                if (shouldPutToTrace(matchNode.syntax)) {
                  result.unshift(matchNode.syntax);
                }
                return true;
              }
            }
          } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
              ? [matchNode.syntax]
              : [];
            return true;
          }
          return false;
        }
        let result = null;
        if (this.matched !== null) {
          hasMatch(this.matched);
        }
        return result;
      }
      function isType(node, type) {
        return testNode(
          this,
          node,
          (match) => match.type === "Type" && match.name === type,
        );
      }
      function isProperty(node, property) {
        return testNode(
          this,
          node,
          (match) => match.type === "Property" && match.name === property,
        );
      }
      function isKeyword(node) {
        return testNode(this, node, (match) => match.type === "Keyword");
      }
      function testNode(match, node, fn) {
        const trace = getTrace.call(match, node);
        if (trace === null) {
          return false;
        }
        return trace.some(fn);
      }
      exports.getTrace = getTrace;
      exports.isKeyword = isKeyword;
      exports.isProperty = isProperty;
      exports.isType = isType;
    },
    7830: (__unused_webpack_module, exports) => {
      "use strict";
      const length = [
        "cm",
        "mm",
        "q",
        "in",
        "pt",
        "pc",
        "px",
        "em",
        "rem",
        "ex",
        "rex",
        "cap",
        "rcap",
        "ch",
        "rch",
        "ic",
        "ric",
        "lh",
        "rlh",
        "vw",
        "svw",
        "lvw",
        "dvw",
        "vh",
        "svh",
        "lvh",
        "dvh",
        "vi",
        "svi",
        "lvi",
        "dvi",
        "vb",
        "svb",
        "lvb",
        "dvb",
        "vmin",
        "svmin",
        "lvmin",
        "dvmin",
        "vmax",
        "svmax",
        "lvmax",
        "dvmax",
        "cqw",
        "cqh",
        "cqi",
        "cqb",
        "cqmin",
        "cqmax",
      ];
      const angle = ["deg", "grad", "rad", "turn"];
      const time = ["s", "ms"];
      const frequency = ["hz", "khz"];
      const resolution = ["dpi", "dpcm", "dppx", "x"];
      const flex = ["fr"];
      const decibel = ["db"];
      const semitones = ["st"];
      exports.angle = angle;
      exports.decibel = decibel;
      exports.flex = flex;
      exports.frequency = frequency;
      exports.length = length;
      exports.resolution = resolution;
      exports.semitones = semitones;
      exports.time = time;
    },
    6505: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const createCustomError = __nccwpck_require__(5850);
      const MAX_LINE_LENGTH = 100;
      const OFFSET_CORRECTION = 60;
      const TAB_REPLACEMENT = "    ";
      function sourceFragment({ source, line, column }, extraLines) {
        function processLines(start, end) {
          return lines
            .slice(start, end)
            .map(
              (line, idx) =>
                String(start + idx + 1).padStart(maxNumLength) + " |" + line,
            )
            .join("\n");
        }
        const lines = source.split(/\r\n?|\n|\f/);
        const startLine = Math.max(1, line - extraLines) - 1;
        const endLine = Math.min(line + extraLines, lines.length + 1);
        const maxNumLength = Math.max(4, String(endLine).length) + 1;
        let cutLeft = 0;
        column +=
          (TAB_REPLACEMENT.length - 1) *
          (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
        if (column > MAX_LINE_LENGTH) {
          cutLeft = column - OFFSET_CORRECTION + 3;
          column = OFFSET_CORRECTION - 2;
        }
        for (let i = startLine; i <= endLine; i++) {
          if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
              (cutLeft > 0 && lines[i].length > cutLeft ? "…" : "") +
              lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
              (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "…" : "");
          }
        }
        return [
          processLines(startLine, line),
          new Array(column + maxNumLength + 2).join("-") + "^",
          processLines(line, endLine),
        ]
          .filter(Boolean)
          .join("\n");
      }
      function SyntaxError(message, source, offset, line, column) {
        const error = Object.assign(
          createCustomError.createCustomError("SyntaxError", message),
          {
            source,
            offset,
            line,
            column,
            sourceFragment(extraLines) {
              return sourceFragment(
                { source, line, column },
                isNaN(extraLines) ? 0 : extraLines,
              );
            },
            get formattedMessage() {
              return (
                `Parse error: ${message}\n` +
                sourceFragment({ source, line, column }, 2)
              );
            },
          },
        );
        return error;
      }
      exports.SyntaxError = SyntaxError;
    },
    7342: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(6929);
      const SyntaxError = __nccwpck_require__(6505);
      const index = __nccwpck_require__(7324);
      const sequence = __nccwpck_require__(2050);
      const OffsetToLocation = __nccwpck_require__(5149);
      const TokenStream = __nccwpck_require__(1843);
      const utils = __nccwpck_require__(1255);
      const types = __nccwpck_require__(8839);
      const names = __nccwpck_require__(9516);
      const NOOP = () => {};
      const EXCLAMATIONMARK = 33;
      const NUMBERSIGN = 35;
      const SEMICOLON = 59;
      const LEFTCURLYBRACKET = 123;
      const NULL = 0;
      function createParseContext(name) {
        return function () {
          return this[name]();
        };
      }
      function fetchParseValues(dict) {
        const result = Object.create(null);
        for (const name in dict) {
          const item = dict[name];
          const fn = item.parse || item;
          if (fn) {
            result[name] = fn;
          }
        }
        return result;
      }
      function processConfig(config) {
        const parseConfig = {
          context: Object.create(null),
          scope: Object.assign(Object.create(null), config.scope),
          atrule: fetchParseValues(config.atrule),
          pseudo: fetchParseValues(config.pseudo),
          node: fetchParseValues(config.node),
        };
        for (const name in config.parseContext) {
          switch (typeof config.parseContext[name]) {
            case "function":
              parseConfig.context[name] = config.parseContext[name];
              break;
            case "string":
              parseConfig.context[name] = createParseContext(
                config.parseContext[name],
              );
              break;
          }
        }
        return { config: parseConfig, ...parseConfig, ...parseConfig.node };
      }
      function createParser(config) {
        let source = "";
        let filename = "<unknown>";
        let needPositions = false;
        let onParseError = NOOP;
        let onParseErrorThrow = false;
        const locationMap = new OffsetToLocation.OffsetToLocation();
        const parser = Object.assign(
          new TokenStream.TokenStream(),
          processConfig(config || {}),
          {
            parseAtrulePrelude: true,
            parseRulePrelude: true,
            parseValue: true,
            parseCustomProperty: false,
            readSequence: sequence.readSequence,
            consumeUntilBalanceEnd: () => 0,
            consumeUntilLeftCurlyBracket(code) {
              return code === LEFTCURLYBRACKET ? 1 : 0;
            },
            consumeUntilLeftCurlyBracketOrSemicolon(code) {
              return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
            },
            consumeUntilExclamationMarkOrSemicolon(code) {
              return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
            },
            consumeUntilSemicolonIncluded(code) {
              return code === SEMICOLON ? 2 : 0;
            },
            createList() {
              return new List.List();
            },
            createSingleNodeList(node) {
              return new List.List().appendData(node);
            },
            getFirstListNode(list) {
              return list && list.first;
            },
            getLastListNode(list) {
              return list && list.last;
            },
            parseWithFallback(consumer, fallback) {
              const startToken = this.tokenIndex;
              try {
                return consumer.call(this);
              } catch (e) {
                if (onParseErrorThrow) {
                  throw e;
                }
                const fallbackNode = fallback.call(this, startToken);
                onParseErrorThrow = true;
                onParseError(e, fallbackNode);
                onParseErrorThrow = false;
                return fallbackNode;
              }
            },
            lookupNonWSType(offset) {
              let type;
              do {
                type = this.lookupType(offset++);
                if (type !== types.WhiteSpace) {
                  return type;
                }
              } while (type !== NULL);
              return NULL;
            },
            charCodeAt(offset) {
              return offset >= 0 && offset < source.length
                ? source.charCodeAt(offset)
                : 0;
            },
            substring(offsetStart, offsetEnd) {
              return source.substring(offsetStart, offsetEnd);
            },
            substrToCursor(start) {
              return this.source.substring(start, this.tokenStart);
            },
            cmpChar(offset, charCode) {
              return utils.cmpChar(source, offset, charCode);
            },
            cmpStr(offsetStart, offsetEnd, str) {
              return utils.cmpStr(source, offsetStart, offsetEnd, str);
            },
            consume(tokenType) {
              const start = this.tokenStart;
              this.eat(tokenType);
              return this.substrToCursor(start);
            },
            consumeFunctionName() {
              const name = source.substring(this.tokenStart, this.tokenEnd - 1);
              this.eat(types.Function);
              return name;
            },
            consumeNumber(type) {
              const number = source.substring(
                this.tokenStart,
                utils.consumeNumber(source, this.tokenStart),
              );
              this.eat(type);
              return number;
            },
            eat(tokenType) {
              if (this.tokenType !== tokenType) {
                const tokenName = names[tokenType]
                  .slice(0, -6)
                  .replace(/-/g, " ")
                  .replace(/^./, (m) => m.toUpperCase());
                let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
                let offset = this.tokenStart;
                switch (tokenType) {
                  case types.Ident:
                    if (
                      this.tokenType === types.Function ||
                      this.tokenType === types.Url
                    ) {
                      offset = this.tokenEnd - 1;
                      message = "Identifier is expected but function found";
                    } else {
                      message = "Identifier is expected";
                    }
                    break;
                  case types.Hash:
                    if (this.isDelim(NUMBERSIGN)) {
                      this.next();
                      offset++;
                      message = "Name is expected";
                    }
                    break;
                  case types.Percentage:
                    if (this.tokenType === types.Number) {
                      offset = this.tokenEnd;
                      message = "Percent sign is expected";
                    }
                    break;
                }
                this.error(message, offset);
              }
              this.next();
            },
            eatIdent(name) {
              if (
                this.tokenType !== types.Ident ||
                this.lookupValue(0, name) === false
              ) {
                this.error(`Identifier "${name}" is expected`);
              }
              this.next();
            },
            eatDelim(code) {
              if (!this.isDelim(code)) {
                this.error(`Delim "${String.fromCharCode(code)}" is expected`);
              }
              this.next();
            },
            getLocation(start, end) {
              if (needPositions) {
                return locationMap.getLocationRange(start, end, filename);
              }
              return null;
            },
            getLocationFromList(list) {
              if (needPositions) {
                const head = this.getFirstListNode(list);
                const tail = this.getLastListNode(list);
                return locationMap.getLocationRange(
                  head !== null
                    ? head.loc.start.offset - locationMap.startOffset
                    : this.tokenStart,
                  tail !== null
                    ? tail.loc.end.offset - locationMap.startOffset
                    : this.tokenStart,
                  filename,
                );
              }
              return null;
            },
            error(message, offset) {
              const location =
                typeof offset !== "undefined" && offset < source.length
                  ? locationMap.getLocation(offset)
                  : this.eof
                    ? locationMap.getLocation(
                        utils.findWhiteSpaceStart(source, source.length - 1),
                      )
                    : locationMap.getLocation(this.tokenStart);
              throw new SyntaxError.SyntaxError(
                message || "Unexpected input",
                source,
                location.offset,
                location.line,
                location.column,
              );
            },
          },
        );
        const parse = function (source_, options) {
          source = source_;
          options = options || {};
          parser.setSource(source, index.tokenize);
          locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column,
          );
          filename = options.filename || "<unknown>";
          needPositions = Boolean(options.positions);
          onParseError =
            typeof options.onParseError === "function"
              ? options.onParseError
              : NOOP;
          onParseErrorThrow = false;
          parser.parseAtrulePrelude =
            "parseAtrulePrelude" in options
              ? Boolean(options.parseAtrulePrelude)
              : true;
          parser.parseRulePrelude =
            "parseRulePrelude" in options
              ? Boolean(options.parseRulePrelude)
              : true;
          parser.parseValue =
            "parseValue" in options ? Boolean(options.parseValue) : true;
          parser.parseCustomProperty =
            "parseCustomProperty" in options
              ? Boolean(options.parseCustomProperty)
              : false;
          const { context = "default", onComment } = options;
          if (context in parser.context === false) {
            throw new Error("Unknown context `" + context + "`");
          }
          if (typeof onComment === "function") {
            parser.forEachToken((type, start, end) => {
              if (type === types.Comment) {
                const loc = parser.getLocation(start, end);
                const value = utils.cmpStr(source, end - 2, end, "*/")
                  ? source.slice(start + 2, end - 2)
                  : source.slice(start + 2, end);
                onComment(value, loc);
              }
            });
          }
          const ast = parser.context[context].call(parser, options);
          if (!parser.eof) {
            parser.error();
          }
          return ast;
        };
        return Object.assign(parse, {
          SyntaxError: SyntaxError.SyntaxError,
          config: parser.config,
        });
      }
      exports.createParser = createParser;
    },
    2050: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      function readSequence(recognizer) {
        const children = this.createList();
        let space = false;
        const context = { recognizer };
        while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
              this.next();
              continue;
            case types.WhiteSpace:
              space = true;
              this.next();
              continue;
          }
          let child = recognizer.getNode.call(this, context);
          if (child === undefined) {
            break;
          }
          if (space) {
            if (recognizer.onWhiteSpace) {
              recognizer.onWhiteSpace.call(this, child, children, context);
            }
            space = false;
          }
          children.push(child);
        }
        if (space && recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, null, children, context);
        }
        return children;
      }
      exports.readSequence = readSequence;
    },
    7223: (module) => {
      "use strict";
      const fontFace = {
        parse: {
          prelude: null,
          block() {
            return this.Block(true);
          },
        },
      };
      module.exports = fontFace;
    },
    5483: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const importAtrule = {
        parse: {
          prelude() {
            const children = this.createList();
            this.skipSC();
            switch (this.tokenType) {
              case types.String:
                children.push(this.String());
                break;
              case types.Url:
              case types.Function:
                children.push(this.Url());
                break;
              default:
                this.error("String or url() is expected");
            }
            if (
              this.lookupNonWSType(0) === types.Ident ||
              this.lookupNonWSType(0) === types.LeftParenthesis
            ) {
              children.push(this.MediaQueryList());
            }
            return children;
          },
          block: null,
        },
      };
      module.exports = importAtrule;
    },
    253: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const fontFace = __nccwpck_require__(7223);
      const _import = __nccwpck_require__(5483);
      const media = __nccwpck_require__(2847);
      const nest = __nccwpck_require__(8019);
      const page = __nccwpck_require__(1284);
      const supports = __nccwpck_require__(1066);
      const atrule = {
        "font-face": fontFace,
        import: _import,
        media,
        nest,
        page,
        supports,
      };
      module.exports = atrule;
    },
    2847: (module) => {
      "use strict";
      const media = {
        parse: {
          prelude() {
            return this.createSingleNodeList(this.MediaQueryList());
          },
          block(isStyleBlock = false) {
            return this.Block(isStyleBlock);
          },
        },
      };
      module.exports = media;
    },
    8019: (module) => {
      "use strict";
      const nest = {
        parse: {
          prelude() {
            return this.createSingleNodeList(this.SelectorList());
          },
          block() {
            return this.Block(true);
          },
        },
      };
      module.exports = nest;
    },
    1284: (module) => {
      "use strict";
      const page = {
        parse: {
          prelude() {
            return this.createSingleNodeList(this.SelectorList());
          },
          block() {
            return this.Block(true);
          },
        },
      };
      module.exports = page;
    },
    1066: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      function consumeRaw() {
        return this.createSingleNodeList(
          this.Raw(this.tokenIndex, null, false),
        );
      }
      function parentheses() {
        this.skipSC();
        if (
          this.tokenType === types.Ident &&
          this.lookupNonWSType(1) === types.Colon
        ) {
          return this.createSingleNodeList(this.Declaration());
        }
        return readSequence.call(this);
      }
      function readSequence() {
        const children = this.createList();
        let child;
        this.skipSC();
        scan: while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Function:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          children.push(child);
        }
        return children;
      }
      const supports = {
        parse: {
          prelude() {
            const children = readSequence.call(this);
            if (this.getFirstListNode(children) === null) {
              this.error("Condition is expected");
            }
            return children;
          },
          block(isStyleBlock = false) {
            return this.Block(isStyleBlock);
          },
        },
      };
      module.exports = supports;
    },
    7006: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const data = __nccwpck_require__(9743);
      const index = __nccwpck_require__(2853);
      const lexerConfig = { generic: true, ...data, node: index };
      module.exports = lexerConfig;
    },
    67: (module) => {
      "use strict";
      function appendOrSet(a, b) {
        if (typeof b === "string" && /^\s*\|/.test(b)) {
          return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
        }
        return b || null;
      }
      function sliceProps(obj, props) {
        const result = Object.create(null);
        for (const [key, value] of Object.entries(obj)) {
          if (value) {
            result[key] = {};
            for (const prop of Object.keys(value)) {
              if (props.includes(prop)) {
                result[key][prop] = value[prop];
              }
            }
          }
        }
        return result;
      }
      function mix(dest, src) {
        const result = { ...dest };
        for (const [prop, value] of Object.entries(src)) {
          switch (prop) {
            case "generic":
              result[prop] = Boolean(value);
              break;
            case "units":
              result[prop] = { ...dest[prop] };
              for (const [name, patch] of Object.entries(value)) {
                result[prop][name] = Array.isArray(patch) ? patch : [];
              }
              break;
            case "atrules":
              result[prop] = { ...dest[prop] };
              for (const [name, atrule] of Object.entries(value)) {
                const exists = result[prop][name] || {};
                const current = (result[prop][name] = {
                  prelude: exists.prelude || null,
                  descriptors: { ...exists.descriptors },
                });
                if (!atrule) {
                  continue;
                }
                current.prelude = atrule.prelude
                  ? appendOrSet(current.prelude, atrule.prelude)
                  : current.prelude || null;
                for (const [descriptorName, descriptorValue] of Object.entries(
                  atrule.descriptors || {},
                )) {
                  current.descriptors[descriptorName] = descriptorValue
                    ? appendOrSet(
                        current.descriptors[descriptorName],
                        descriptorValue,
                      )
                    : null;
                }
                if (!Object.keys(current.descriptors).length) {
                  current.descriptors = null;
                }
              }
              break;
            case "types":
            case "properties":
              result[prop] = { ...dest[prop] };
              for (const [name, syntax] of Object.entries(value)) {
                result[prop][name] = appendOrSet(result[prop][name], syntax);
              }
              break;
            case "scope":
              result[prop] = { ...dest[prop] };
              for (const [name, props] of Object.entries(value)) {
                result[prop][name] = { ...result[prop][name], ...props };
              }
              break;
            case "parseContext":
              result[prop] = { ...dest[prop], ...value };
              break;
            case "atrule":
            case "pseudo":
              result[prop] = { ...dest[prop], ...sliceProps(value, ["parse"]) };
              break;
            case "node":
              result[prop] = {
                ...dest[prop],
                ...sliceProps(value, [
                  "name",
                  "structure",
                  "parse",
                  "generate",
                  "walkContext",
                ]),
              };
              break;
          }
        }
        return result;
      }
      module.exports = mix;
    },
    6411: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(1735);
      const index$1 = __nccwpck_require__(253);
      const index$2 = __nccwpck_require__(6658);
      const indexParse = __nccwpck_require__(4343);
      const config = {
        parseContext: {
          default: "StyleSheet",
          stylesheet: "StyleSheet",
          atrule: "Atrule",
          atrulePrelude(options) {
            return this.AtrulePrelude(
              options.atrule ? String(options.atrule) : null,
            );
          },
          mediaQueryList: "MediaQueryList",
          mediaQuery: "MediaQuery",
          rule: "Rule",
          selectorList: "SelectorList",
          selector: "Selector",
          block() {
            return this.Block(true);
          },
          declarationList: "DeclarationList",
          declaration: "Declaration",
          value: "Value",
        },
        scope: index,
        atrule: index$1,
        pseudo: index$2,
        node: indexParse,
      };
      module.exports = config;
    },
    5282: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(2853);
      const config = { node: index };
      module.exports = config;
    },
    2148: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(7324);
      const create = __nccwpck_require__(7342);
      const create$2 = __nccwpck_require__(8988);
      const create$3 = __nccwpck_require__(9863);
      const create$1 = __nccwpck_require__(1655);
      const Lexer = __nccwpck_require__(7744);
      const mix = __nccwpck_require__(67);
      function createSyntax(config) {
        const parse = create.createParser(config);
        const walk = create$1.createWalker(config);
        const generate = create$2.createGenerator(config);
        const { fromPlainObject, toPlainObject } =
          create$3.createConvertor(walk);
        const syntax = {
          lexer: null,
          createLexer: (config) =>
            new Lexer.Lexer(config, syntax, syntax.lexer.structure),
          tokenize: index.tokenize,
          parse,
          generate,
          walk,
          find: walk.find,
          findLast: walk.findLast,
          findAll: walk.findAll,
          fromPlainObject,
          toPlainObject,
          fork(extension) {
            const base = mix({}, config);
            return createSyntax(
              typeof extension === "function"
                ? extension(base, Object.assign)
                : mix(base, extension),
            );
          },
        };
        syntax.lexer = new Lexer.Lexer(
          {
            generic: true,
            units: config.units,
            types: config.types,
            atrules: config.atrules,
            properties: config.properties,
            node: config.node,
          },
          syntax,
        );
        return syntax;
      }
      const createSyntax$1 = (config) => createSyntax(mix({}, config));
      module.exports = createSyntax$1;
    },
    6855: (module) => {
      "use strict";
      function expressionFn() {
        return this.createSingleNodeList(
          this.Raw(this.tokenIndex, null, false),
        );
      }
      module.exports = expressionFn;
    },
    2839: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      function varFn() {
        const children = this.createList();
        this.skipSC();
        children.push(this.Identifier());
        this.skipSC();
        if (this.tokenType === types.Comma) {
          children.push(this.Operator());
          const startIndex = this.tokenIndex;
          const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(
                this.tokenIndex,
                this.consumeUntilExclamationMarkOrSemicolon,
                false,
              );
          if (value.type === "Value" && value.children.isEmpty) {
            for (
              let offset = startIndex - this.tokenIndex;
              offset <= 0;
              offset++
            ) {
              if (this.lookupType(offset) === types.WhiteSpace) {
                value.children.appendData({
                  type: "WhiteSpace",
                  loc: null,
                  value: " ",
                });
                break;
              }
            }
          }
          children.push(value);
        }
        return children;
      }
      module.exports = varFn;
    },
    3313: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const create = __nccwpck_require__(2148);
      const lexer = __nccwpck_require__(7006);
      const parser = __nccwpck_require__(6411);
      const walker = __nccwpck_require__(5282);
      const syntax = create({ ...lexer, ...parser, ...walker });
      module.exports = syntax;
    },
    4719: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const charCodeDefinitions = __nccwpck_require__(6001);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const N = 110;
      const DISALLOW_SIGN = true;
      const ALLOW_SIGN = false;
      function checkInteger(offset, disallowSign) {
        let pos = this.tokenStart + offset;
        const code = this.charCodeAt(pos);
        if (code === PLUSSIGN || code === HYPHENMINUS) {
          if (disallowSign) {
            this.error("Number sign is not allowed");
          }
          pos++;
        }
        for (; pos < this.tokenEnd; pos++) {
          if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
            this.error("Integer is expected", pos);
          }
        }
      }
      function checkTokenIsInteger(disallowSign) {
        return checkInteger.call(this, 0, disallowSign);
      }
      function expectCharCode(offset, code) {
        if (!this.cmpChar(this.tokenStart + offset, code)) {
          let msg = "";
          switch (code) {
            case N:
              msg = "N is expected";
              break;
            case HYPHENMINUS:
              msg = "HyphenMinus is expected";
              break;
          }
          this.error(msg, this.tokenStart + offset);
        }
      }
      function consumeB() {
        let offset = 0;
        let sign = 0;
        let type = this.tokenType;
        while (type === types.WhiteSpace || type === types.Comment) {
          type = this.lookupType(++offset);
        }
        if (type !== types.Number) {
          if (
            this.isDelim(PLUSSIGN, offset) ||
            this.isDelim(HYPHENMINUS, offset)
          ) {
            sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
            do {
              type = this.lookupType(++offset);
            } while (type === types.WhiteSpace || type === types.Comment);
            if (type !== types.Number) {
              this.skip(offset);
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
          } else {
            return null;
          }
        }
        if (offset > 0) {
          this.skip(offset);
        }
        if (sign === 0) {
          type = this.charCodeAt(this.tokenStart);
          if (type !== PLUSSIGN && type !== HYPHENMINUS) {
            this.error("Number sign is expected");
          }
        }
        checkTokenIsInteger.call(this, sign !== 0);
        return sign === HYPHENMINUS
          ? "-" + this.consume(types.Number)
          : this.consume(types.Number);
      }
      const name = "AnPlusB";
      const structure = { a: [String, null], b: [String, null] };
      function parse() {
        const start = this.tokenStart;
        let a = null;
        let b = null;
        if (this.tokenType === types.Number) {
          checkTokenIsInteger.call(this, ALLOW_SIGN);
          b = this.consume(types.Number);
        } else if (
          this.tokenType === types.Ident &&
          this.cmpChar(this.tokenStart, HYPHENMINUS)
        ) {
          a = "-1";
          expectCharCode.call(this, 1, N);
          switch (this.tokenEnd - this.tokenStart) {
            case 2:
              this.next();
              b = consumeB.call(this);
              break;
            case 3:
              expectCharCode.call(this, 2, HYPHENMINUS);
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(types.Number);
              break;
            default:
              expectCharCode.call(this, 2, HYPHENMINUS);
              checkInteger.call(this, 3, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(start + 2);
          }
        } else if (
          this.tokenType === types.Ident ||
          (this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident)
        ) {
          let sign = 0;
          a = "1";
          if (this.isDelim(PLUSSIGN)) {
            sign = 1;
            this.next();
          }
          expectCharCode.call(this, 0, N);
          switch (this.tokenEnd - this.tokenStart) {
            case 1:
              this.next();
              b = consumeB.call(this);
              break;
            case 2:
              expectCharCode.call(this, 1, HYPHENMINUS);
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(types.Number);
              break;
            default:
              expectCharCode.call(this, 1, HYPHENMINUS);
              checkInteger.call(this, 2, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(start + sign + 1);
          }
        } else if (this.tokenType === types.Dimension) {
          const code = this.charCodeAt(this.tokenStart);
          const sign = code === PLUSSIGN || code === HYPHENMINUS;
          let i = this.tokenStart + sign;
          for (; i < this.tokenEnd; i++) {
            if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
              break;
            }
          }
          if (i === this.tokenStart + sign) {
            this.error("Integer is expected", this.tokenStart + sign);
          }
          expectCharCode.call(this, i - this.tokenStart, N);
          a = this.substring(start, i);
          if (i + 1 === this.tokenEnd) {
            this.next();
            b = consumeB.call(this);
          } else {
            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
            if (i + 2 === this.tokenEnd) {
              this.next();
              this.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(types.Number);
            } else {
              checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
              this.next();
              b = this.substrToCursor(i + 1);
            }
          }
        } else {
          this.error();
        }
        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
          a = a.substr(1);
        }
        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
          b = b.substr(1);
        }
        return {
          type: "AnPlusB",
          loc: this.getLocation(start, this.tokenStart),
          a,
          b,
        };
      }
      function generate(node) {
        if (node.a) {
          const a =
            (node.a === "+1" && "n") ||
            (node.a === "1" && "n") ||
            (node.a === "-1" && "-n") ||
            node.a + "n";
          if (node.b) {
            const b =
              node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
            this.tokenize(a + b);
          } else {
            this.tokenize(a);
          }
        } else {
          this.tokenize(node.b);
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    60: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      function consumeRaw(startToken) {
        return this.Raw(
          startToken,
          this.consumeUntilLeftCurlyBracketOrSemicolon,
          true,
        );
      }
      function isDeclarationBlockAtrule() {
        for (let offset = 1, type; (type = this.lookupType(offset)); offset++) {
          if (type === types.RightCurlyBracket) {
            return true;
          }
          if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
            return false;
          }
        }
        return false;
      }
      const name = "Atrule";
      const walkContext = "atrule";
      const structure = {
        name: String,
        prelude: ["AtrulePrelude", "Raw", null],
        block: ["Block", null],
      };
      function parse(isDeclaration = false) {
        const start = this.tokenStart;
        let name;
        let nameLowerCase;
        let prelude = null;
        let block = null;
        this.eat(types.AtKeyword);
        name = this.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.skipSC();
        if (
          this.eof === false &&
          this.tokenType !== types.LeftCurlyBracket &&
          this.tokenType !== types.Semicolon
        ) {
          if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(
              this.AtrulePrelude.bind(this, name, isDeclaration),
              consumeRaw,
            );
          } else {
            prelude = consumeRaw.call(this, this.tokenIndex);
          }
          this.skipSC();
        }
        switch (this.tokenType) {
          case types.Semicolon:
            this.next();
            break;
          case types.LeftCurlyBracket:
            if (
              hasOwnProperty.call(this.atrule, nameLowerCase) &&
              typeof this.atrule[nameLowerCase].block === "function"
            ) {
              block = this.atrule[nameLowerCase].block.call(
                this,
                isDeclaration,
              );
            } else {
              block = this.Block(isDeclarationBlockAtrule.call(this));
            }
            break;
        }
        return {
          type: "Atrule",
          loc: this.getLocation(start, this.tokenStart),
          name,
          prelude,
          block,
        };
      }
      function generate(node) {
        this.token(types.AtKeyword, "@" + node.name);
        if (node.prelude !== null) {
          this.node(node.prelude);
        }
        if (node.block) {
          this.node(node.block);
        } else {
          this.token(types.Semicolon, ";");
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    4449: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "AtrulePrelude";
      const walkContext = "atrulePrelude";
      const structure = { children: [[]] };
      function parse(name) {
        let children = null;
        if (name !== null) {
          name = name.toLowerCase();
        }
        this.skipSC();
        if (
          hasOwnProperty.call(this.atrule, name) &&
          typeof this.atrule[name].prelude === "function"
        ) {
          children = this.atrule[name].prelude.call(this);
        } else {
          children = this.readSequence(this.scope.AtrulePrelude);
        }
        this.skipSC();
        if (
          this.eof !== true &&
          this.tokenType !== types.LeftCurlyBracket &&
          this.tokenType !== types.Semicolon
        ) {
          this.error("Semicolon or block is expected");
        }
        return {
          type: "AtrulePrelude",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    7909: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const DOLLARSIGN = 36;
      const ASTERISK = 42;
      const EQUALSSIGN = 61;
      const CIRCUMFLEXACCENT = 94;
      const VERTICALLINE = 124;
      const TILDE = 126;
      function getAttributeName() {
        if (this.eof) {
          this.error("Unexpected end of input");
        }
        const start = this.tokenStart;
        let expectIdent = false;
        if (this.isDelim(ASTERISK)) {
          expectIdent = true;
          this.next();
        } else if (!this.isDelim(VERTICALLINE)) {
          this.eat(types.Ident);
        }
        if (this.isDelim(VERTICALLINE)) {
          if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
            this.next();
            this.eat(types.Ident);
          } else if (expectIdent) {
            this.error("Identifier is expected", this.tokenEnd);
          }
        } else if (expectIdent) {
          this.error("Vertical line is expected");
        }
        return {
          type: "Identifier",
          loc: this.getLocation(start, this.tokenStart),
          name: this.substrToCursor(start),
        };
      }
      function getOperator() {
        const start = this.tokenStart;
        const code = this.charCodeAt(start);
        if (
          code !== EQUALSSIGN &&
          code !== TILDE &&
          code !== CIRCUMFLEXACCENT &&
          code !== DOLLARSIGN &&
          code !== ASTERISK &&
          code !== VERTICALLINE
        ) {
          this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
        }
        this.next();
        if (code !== EQUALSSIGN) {
          if (!this.isDelim(EQUALSSIGN)) {
            this.error("Equal sign is expected");
          }
          this.next();
        }
        return this.substrToCursor(start);
      }
      const name = "AttributeSelector";
      const structure = {
        name: "Identifier",
        matcher: [String, null],
        value: ["String", "Identifier", null],
        flags: [String, null],
      };
      function parse() {
        const start = this.tokenStart;
        let name;
        let matcher = null;
        let value = null;
        let flags = null;
        this.eat(types.LeftSquareBracket);
        this.skipSC();
        name = getAttributeName.call(this);
        this.skipSC();
        if (this.tokenType !== types.RightSquareBracket) {
          if (this.tokenType !== types.Ident) {
            matcher = getOperator.call(this);
            this.skipSC();
            value =
              this.tokenType === types.String
                ? this.String()
                : this.Identifier();
            this.skipSC();
          }
          if (this.tokenType === types.Ident) {
            flags = this.consume(types.Ident);
            this.skipSC();
          }
        }
        this.eat(types.RightSquareBracket);
        return {
          type: "AttributeSelector",
          loc: this.getLocation(start, this.tokenStart),
          name,
          matcher,
          value,
          flags,
        };
      }
      function generate(node) {
        this.token(types.Delim, "[");
        this.node(node.name);
        if (node.matcher !== null) {
          this.tokenize(node.matcher);
          this.node(node.value);
        }
        if (node.flags !== null) {
          this.token(types.Ident, node.flags);
        }
        this.token(types.Delim, "]");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    3129: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const AMPERSAND = 38;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, true);
      }
      function consumeRule() {
        return this.parseWithFallback(this.Rule, consumeRaw);
      }
      function consumeRawDeclaration(startToken) {
        return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
      }
      function consumeDeclaration() {
        if (this.tokenType === types.Semicolon) {
          return consumeRawDeclaration.call(this, this.tokenIndex);
        }
        const node = this.parseWithFallback(
          this.Declaration,
          consumeRawDeclaration,
        );
        if (this.tokenType === types.Semicolon) {
          this.next();
        }
        return node;
      }
      const name = "Block";
      const walkContext = "block";
      const structure = { children: [["Atrule", "Rule", "Declaration"]] };
      function parse(isStyleBlock) {
        const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
        const start = this.tokenStart;
        let children = this.createList();
        this.eat(types.LeftCurlyBracket);
        scan: while (!this.eof) {
          switch (this.tokenType) {
            case types.RightCurlyBracket:
              break scan;
            case types.WhiteSpace:
            case types.Comment:
              this.next();
              break;
            case types.AtKeyword:
              children.push(
                this.parseWithFallback(
                  this.Atrule.bind(this, isStyleBlock),
                  consumeRaw,
                ),
              );
              break;
            default:
              if (isStyleBlock && this.isDelim(AMPERSAND)) {
                children.push(consumeRule.call(this));
              } else {
                children.push(consumer.call(this));
              }
          }
        }
        if (!this.eof) {
          this.eat(types.RightCurlyBracket);
        }
        return {
          type: "Block",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.token(types.LeftCurlyBracket, "{");
        this.children(node, (prev) => {
          if (prev.type === "Declaration") {
            this.token(types.Semicolon, ";");
          }
        });
        this.token(types.RightCurlyBracket, "}");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    9567: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Brackets";
      const structure = { children: [[]] };
      function parse(readSequence, recognizer) {
        const start = this.tokenStart;
        let children = null;
        this.eat(types.LeftSquareBracket);
        children = readSequence.call(this, recognizer);
        if (!this.eof) {
          this.eat(types.RightSquareBracket);
        }
        return {
          type: "Brackets",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.token(types.Delim, "[");
        this.children(node);
        this.token(types.Delim, "]");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    7107: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "CDC";
      const structure = [];
      function parse() {
        const start = this.tokenStart;
        this.eat(types.CDC);
        return { type: "CDC", loc: this.getLocation(start, this.tokenStart) };
      }
      function generate() {
        this.token(types.CDC, "--\x3e");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    566: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "CDO";
      const structure = [];
      function parse() {
        const start = this.tokenStart;
        this.eat(types.CDO);
        return { type: "CDO", loc: this.getLocation(start, this.tokenStart) };
      }
      function generate() {
        this.token(types.CDO, "\x3c!--");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4e3: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const FULLSTOP = 46;
      const name = "ClassSelector";
      const structure = { name: String };
      function parse() {
        this.eatDelim(FULLSTOP);
        return {
          type: "ClassSelector",
          loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
          name: this.consume(types.Ident),
        };
      }
      function generate(node) {
        this.token(types.Delim, ".");
        this.token(types.Ident, node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    6358: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const PLUSSIGN = 43;
      const SOLIDUS = 47;
      const GREATERTHANSIGN = 62;
      const TILDE = 126;
      const name = "Combinator";
      const structure = { name: String };
      function parse() {
        const start = this.tokenStart;
        let name;
        switch (this.tokenType) {
          case types.WhiteSpace:
            name = " ";
            break;
          case types.Delim:
            switch (this.charCodeAt(this.tokenStart)) {
              case GREATERTHANSIGN:
              case PLUSSIGN:
              case TILDE:
                this.next();
                break;
              case SOLIDUS:
                this.next();
                this.eatIdent("deep");
                this.eatDelim(SOLIDUS);
                break;
              default:
                this.error("Combinator is expected");
            }
            name = this.substrToCursor(start);
            break;
        }
        return {
          type: "Combinator",
          loc: this.getLocation(start, this.tokenStart),
          name,
        };
      }
      function generate(node) {
        this.tokenize(node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2924: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const ASTERISK = 42;
      const SOLIDUS = 47;
      const name = "Comment";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        let end = this.tokenEnd;
        this.eat(types.Comment);
        if (
          end - start + 2 >= 2 &&
          this.charCodeAt(end - 2) === ASTERISK &&
          this.charCodeAt(end - 1) === SOLIDUS
        ) {
          end -= 2;
        }
        return {
          type: "Comment",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substring(start + 2, end),
        };
      }
      function generate(node) {
        this.token(types.Comment, "/*" + node.value + "*/");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    9283: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const names = __nccwpck_require__(4195);
      const types = __nccwpck_require__(8839);
      const EXCLAMATIONMARK = 33;
      const NUMBERSIGN = 35;
      const DOLLARSIGN = 36;
      const AMPERSAND = 38;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const SOLIDUS = 47;
      function consumeValueRaw(startToken) {
        return this.Raw(
          startToken,
          this.consumeUntilExclamationMarkOrSemicolon,
          true,
        );
      }
      function consumeCustomPropertyRaw(startToken) {
        return this.Raw(
          startToken,
          this.consumeUntilExclamationMarkOrSemicolon,
          false,
        );
      }
      function consumeValue() {
        const startValueToken = this.tokenIndex;
        const value = this.Value();
        if (
          value.type !== "Raw" &&
          this.eof === false &&
          this.tokenType !== types.Semicolon &&
          this.isDelim(EXCLAMATIONMARK) === false &&
          this.isBalanceEdge(startValueToken) === false
        ) {
          this.error();
        }
        return value;
      }
      const name = "Declaration";
      const walkContext = "declaration";
      const structure = {
        important: [Boolean, String],
        property: String,
        value: ["Value", "Raw"],
      };
      function parse() {
        const start = this.tokenStart;
        const startToken = this.tokenIndex;
        const property = readProperty.call(this);
        const customProperty = names.isCustomProperty(property);
        const parseValue = customProperty
          ? this.parseCustomProperty
          : this.parseValue;
        const consumeRaw = customProperty
          ? consumeCustomPropertyRaw
          : consumeValueRaw;
        let important = false;
        let value;
        this.skipSC();
        this.eat(types.Colon);
        const valueStart = this.tokenIndex;
        if (!customProperty) {
          this.skipSC();
        }
        if (parseValue) {
          value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
          value = consumeRaw.call(this, this.tokenIndex);
        }
        if (
          customProperty &&
          value.type === "Value" &&
          value.children.isEmpty
        ) {
          for (
            let offset = valueStart - this.tokenIndex;
            offset <= 0;
            offset++
          ) {
            if (this.lookupType(offset) === types.WhiteSpace) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " ",
              });
              break;
            }
          }
        }
        if (this.isDelim(EXCLAMATIONMARK)) {
          important = getImportant.call(this);
          this.skipSC();
        }
        if (
          this.eof === false &&
          this.tokenType !== types.Semicolon &&
          this.isBalanceEdge(startToken) === false
        ) {
          this.error();
        }
        return {
          type: "Declaration",
          loc: this.getLocation(start, this.tokenStart),
          important,
          property,
          value,
        };
      }
      function generate(node) {
        this.token(types.Ident, node.property);
        this.token(types.Colon, ":");
        this.node(node.value);
        if (node.important) {
          this.token(types.Delim, "!");
          this.token(
            types.Ident,
            node.important === true ? "important" : node.important,
          );
        }
      }
      function readProperty() {
        const start = this.tokenStart;
        if (this.tokenType === types.Delim) {
          switch (this.charCodeAt(this.tokenStart)) {
            case ASTERISK:
            case DOLLARSIGN:
            case PLUSSIGN:
            case NUMBERSIGN:
            case AMPERSAND:
              this.next();
              break;
            case SOLIDUS:
              this.next();
              if (this.isDelim(SOLIDUS)) {
                this.next();
              }
              break;
          }
        }
        if (this.tokenType === types.Hash) {
          this.eat(types.Hash);
        } else {
          this.eat(types.Ident);
        }
        return this.substrToCursor(start);
      }
      function getImportant() {
        this.eat(types.Delim);
        this.skipSC();
        const important = this.consume(types.Ident);
        return important === "important" ? true : important;
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    3705: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const AMPERSAND = 38;
      function consumeRaw(startToken) {
        return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
      }
      const name = "DeclarationList";
      const structure = { children: [["Declaration", "Atrule", "Rule"]] };
      function parse() {
        const children = this.createList();
        while (!this.eof) {
          switch (this.tokenType) {
            case types.WhiteSpace:
            case types.Comment:
            case types.Semicolon:
              this.next();
              break;
            case types.AtKeyword:
              children.push(
                this.parseWithFallback(
                  this.Atrule.bind(this, true),
                  consumeRaw,
                ),
              );
              break;
            default:
              if (this.isDelim(AMPERSAND)) {
                children.push(this.parseWithFallback(this.Rule, consumeRaw));
              } else {
                children.push(
                  this.parseWithFallback(this.Declaration, consumeRaw),
                );
              }
          }
        }
        return {
          type: "DeclarationList",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node, (prev) => {
          if (prev.type === "Declaration") {
            this.token(types.Semicolon, ";");
          }
        });
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    5559: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Dimension";
      const structure = { value: String, unit: String };
      function parse() {
        const start = this.tokenStart;
        const value = this.consumeNumber(types.Dimension);
        return {
          type: "Dimension",
          loc: this.getLocation(start, this.tokenStart),
          value,
          unit: this.substring(start + value.length, this.tokenStart),
        };
      }
      function generate(node) {
        this.token(types.Dimension, node.value + node.unit);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    914: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Function";
      const walkContext = "function";
      const structure = { name: String, children: [[]] };
      function parse(readSequence, recognizer) {
        const start = this.tokenStart;
        const name = this.consumeFunctionName();
        const nameLowerCase = name.toLowerCase();
        let children;
        children = recognizer.hasOwnProperty(nameLowerCase)
          ? recognizer[nameLowerCase].call(this, recognizer)
          : readSequence.call(this, recognizer);
        if (!this.eof) {
          this.eat(types.RightParenthesis);
        }
        return {
          type: "Function",
          loc: this.getLocation(start, this.tokenStart),
          name,
          children,
        };
      }
      function generate(node) {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    1325: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const xxx = "XXX";
      const name = "Hash";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        this.eat(types.Hash);
        return {
          type: "Hash",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substrToCursor(start + 1),
        };
      }
      function generate(node) {
        this.token(types.Hash, "#" + node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.xxx = xxx;
    },
    7484: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "IdSelector";
      const structure = { name: String };
      function parse() {
        const start = this.tokenStart;
        this.eat(types.Hash);
        return {
          type: "IdSelector",
          loc: this.getLocation(start, this.tokenStart),
          name: this.substrToCursor(start + 1),
        };
      }
      function generate(node) {
        this.token(types.Delim, "#" + node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2459: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Identifier";
      const structure = { name: String };
      function parse() {
        return {
          type: "Identifier",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          name: this.consume(types.Ident),
        };
      }
      function generate(node) {
        this.token(types.Ident, node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    1934: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "MediaFeature";
      const structure = {
        name: String,
        value: ["Identifier", "Number", "Dimension", "Ratio", null],
      };
      function parse() {
        const start = this.tokenStart;
        let name;
        let value = null;
        this.eat(types.LeftParenthesis);
        this.skipSC();
        name = this.consume(types.Ident);
        this.skipSC();
        if (this.tokenType !== types.RightParenthesis) {
          this.eat(types.Colon);
          this.skipSC();
          switch (this.tokenType) {
            case types.Number:
              if (this.lookupNonWSType(1) === types.Delim) {
                value = this.Ratio();
              } else {
                value = this.Number();
              }
              break;
            case types.Dimension:
              value = this.Dimension();
              break;
            case types.Ident:
              value = this.Identifier();
              break;
            default:
              this.error("Number, dimension, ratio or identifier is expected");
          }
          this.skipSC();
        }
        this.eat(types.RightParenthesis);
        return {
          type: "MediaFeature",
          loc: this.getLocation(start, this.tokenStart),
          name,
          value,
        };
      }
      function generate(node) {
        this.token(types.LeftParenthesis, "(");
        this.token(types.Ident, node.name);
        if (node.value !== null) {
          this.token(types.Colon, ":");
          this.node(node.value);
        }
        this.token(types.RightParenthesis, ")");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    7406: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "MediaQuery";
      const structure = {
        children: [["Identifier", "MediaFeature", "WhiteSpace"]],
      };
      function parse() {
        const children = this.createList();
        let child = null;
        this.skipSC();
        scan: while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.MediaFeature();
              break;
            default:
              break scan;
          }
          children.push(child);
        }
        if (child === null) {
          this.error("Identifier or parenthesis is expected");
        }
        return {
          type: "MediaQuery",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    7276: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "MediaQueryList";
      const structure = { children: [["MediaQuery"]] };
      function parse() {
        const children = this.createList();
        this.skipSC();
        while (!this.eof) {
          children.push(this.MediaQuery());
          if (this.tokenType !== types.Comma) {
            break;
          }
          this.next();
        }
        return {
          type: "MediaQueryList",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node, () => this.token(types.Comma, ","));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8481: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const AMPERSAND = 38;
      const name = "NestingSelector";
      const structure = {};
      function parse() {
        const start = this.tokenStart;
        this.eatDelim(AMPERSAND);
        return {
          type: "NestingSelector",
          loc: this.getLocation(start, this.tokenStart),
        };
      }
      function generate() {
        this.token(types.Delim, "&");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8374: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Nth";
      const structure = {
        nth: ["AnPlusB", "Identifier"],
        selector: ["SelectorList", null],
      };
      function parse() {
        this.skipSC();
        const start = this.tokenStart;
        let end = start;
        let selector = null;
        let nth;
        if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
          nth = this.Identifier();
        } else {
          nth = this.AnPlusB();
        }
        end = this.tokenStart;
        this.skipSC();
        if (this.lookupValue(0, "of")) {
          this.next();
          selector = this.SelectorList();
          end = this.tokenStart;
        }
        return {
          type: "Nth",
          loc: this.getLocation(start, end),
          nth,
          selector,
        };
      }
      function generate(node) {
        this.node(node.nth);
        if (node.selector !== null) {
          this.token(types.Ident, "of");
          this.node(node.selector);
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2293: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Number";
      const structure = { value: String };
      function parse() {
        return {
          type: "Number",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          value: this.consume(types.Number),
        };
      }
      function generate(node) {
        this.token(types.Number, node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    334: (__unused_webpack_module, exports) => {
      "use strict";
      const name = "Operator";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        this.next();
        return {
          type: "Operator",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substrToCursor(start),
        };
      }
      function generate(node) {
        this.tokenize(node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2955: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Parentheses";
      const structure = { children: [[]] };
      function parse(readSequence, recognizer) {
        const start = this.tokenStart;
        let children = null;
        this.eat(types.LeftParenthesis);
        children = readSequence.call(this, recognizer);
        if (!this.eof) {
          this.eat(types.RightParenthesis);
        }
        return {
          type: "Parentheses",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.token(types.LeftParenthesis, "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2912: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "Percentage";
      const structure = { value: String };
      function parse() {
        return {
          type: "Percentage",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          value: this.consumeNumber(types.Percentage),
        };
      }
      function generate(node) {
        this.token(types.Percentage, node.value + "%");
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    9927: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "PseudoClassSelector";
      const walkContext = "function";
      const structure = { name: String, children: [["Raw"], null] };
      function parse() {
        const start = this.tokenStart;
        let children = null;
        let name;
        let nameLowerCase;
        this.eat(types.Colon);
        if (this.tokenType === types.Function) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
          } else {
            children = this.createList();
            children.push(this.Raw(this.tokenIndex, null, false));
          }
          this.eat(types.RightParenthesis);
        } else {
          name = this.consume(types.Ident);
        }
        return {
          type: "PseudoClassSelector",
          loc: this.getLocation(start, this.tokenStart),
          name,
          children,
        };
      }
      function generate(node) {
        this.token(types.Colon, ":");
        if (node.children === null) {
          this.token(types.Ident, node.name);
        } else {
          this.token(types.Function, node.name + "(");
          this.children(node);
          this.token(types.RightParenthesis, ")");
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    8018: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "PseudoElementSelector";
      const walkContext = "function";
      const structure = { name: String, children: [["Raw"], null] };
      function parse() {
        const start = this.tokenStart;
        let children = null;
        let name;
        let nameLowerCase;
        this.eat(types.Colon);
        this.eat(types.Colon);
        if (this.tokenType === types.Function) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
          } else {
            children = this.createList();
            children.push(this.Raw(this.tokenIndex, null, false));
          }
          this.eat(types.RightParenthesis);
        } else {
          name = this.consume(types.Ident);
        }
        return {
          type: "PseudoElementSelector",
          loc: this.getLocation(start, this.tokenStart),
          name,
          children,
        };
      }
      function generate(node) {
        this.token(types.Colon, ":");
        this.token(types.Colon, ":");
        if (node.children === null) {
          this.token(types.Ident, node.name);
        } else {
          this.token(types.Function, node.name + "(");
          this.children(node);
          this.token(types.RightParenthesis, ")");
        }
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    1517: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const charCodeDefinitions = __nccwpck_require__(6001);
      const SOLIDUS = 47;
      const FULLSTOP = 46;
      function consumeNumber() {
        this.skipSC();
        const value = this.consume(types.Number);
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {
            this.error(
              "Unsigned number is expected",
              this.tokenStart - value.length + i,
            );
          }
        }
        if (Number(value) === 0) {
          this.error(
            "Zero number is not allowed",
            this.tokenStart - value.length,
          );
        }
        return value;
      }
      const name = "Ratio";
      const structure = { left: String, right: String };
      function parse() {
        const start = this.tokenStart;
        const left = consumeNumber.call(this);
        let right;
        this.skipSC();
        this.eatDelim(SOLIDUS);
        right = consumeNumber.call(this);
        return {
          type: "Ratio",
          loc: this.getLocation(start, this.tokenStart),
          left,
          right,
        };
      }
      function generate(node) {
        this.token(types.Number, node.left);
        this.token(types.Delim, "/");
        this.token(types.Number, node.right);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    7165: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      function getOffsetExcludeWS() {
        if (this.tokenIndex > 0) {
          if (this.lookupType(-1) === types.WhiteSpace) {
            return this.tokenIndex > 1
              ? this.getTokenStart(this.tokenIndex - 1)
              : this.firstCharOffset;
          }
        }
        return this.tokenStart;
      }
      const name = "Raw";
      const structure = { value: String };
      function parse(startToken, consumeUntil, excludeWhiteSpace) {
        const startOffset = this.getTokenStart(startToken);
        let endOffset;
        this.skipUntilBalanced(
          startToken,
          consumeUntil || this.consumeUntilBalanceEnd,
        );
        if (excludeWhiteSpace && this.tokenStart > startOffset) {
          endOffset = getOffsetExcludeWS.call(this);
        } else {
          endOffset = this.tokenStart;
        }
        return {
          type: "Raw",
          loc: this.getLocation(startOffset, endOffset),
          value: this.substring(startOffset, endOffset),
        };
      }
      function generate(node) {
        this.tokenize(node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    3002: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      function consumeRaw(startToken) {
        return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
      }
      function consumePrelude() {
        const prelude = this.SelectorList();
        if (
          prelude.type !== "Raw" &&
          this.eof === false &&
          this.tokenType !== types.LeftCurlyBracket
        ) {
          this.error();
        }
        return prelude;
      }
      const name = "Rule";
      const walkContext = "rule";
      const structure = { prelude: ["SelectorList", "Raw"], block: ["Block"] };
      function parse() {
        const startToken = this.tokenIndex;
        const startOffset = this.tokenStart;
        let prelude;
        let block;
        if (this.parseRulePrelude) {
          prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
          prelude = consumeRaw.call(this, startToken);
        }
        block = this.Block(true);
        return {
          type: "Rule",
          loc: this.getLocation(startOffset, this.tokenStart),
          prelude,
          block,
        };
      }
      function generate(node) {
        this.node(node.prelude);
        this.node(node.block);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    919: (__unused_webpack_module, exports) => {
      "use strict";
      const name = "Selector";
      const structure = {
        children: [
          [
            "TypeSelector",
            "IdSelector",
            "ClassSelector",
            "AttributeSelector",
            "PseudoClassSelector",
            "PseudoElementSelector",
            "Combinator",
            "WhiteSpace",
          ],
        ],
      };
      function parse() {
        const children = this.readSequence(this.scope.Selector);
        if (this.getFirstListNode(children) === null) {
          this.error("Selector is expected");
        }
        return {
          type: "Selector",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    8797: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const name = "SelectorList";
      const walkContext = "selector";
      const structure = { children: [["Selector", "Raw"]] };
      function parse() {
        const children = this.createList();
        while (!this.eof) {
          children.push(this.Selector());
          if (this.tokenType === types.Comma) {
            this.next();
            continue;
          }
          break;
        }
        return {
          type: "SelectorList",
          loc: this.getLocationFromList(children),
          children,
        };
      }
      function generate(node) {
        this.children(node, () => this.token(types.Comma, ","));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    8779: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const string = __nccwpck_require__(590);
      const types = __nccwpck_require__(8839);
      const name = "String";
      const structure = { value: String };
      function parse() {
        return {
          type: "String",
          loc: this.getLocation(this.tokenStart, this.tokenEnd),
          value: string.decode(this.consume(types.String)),
        };
      }
      function generate(node) {
        this.token(types.String, string.encode(node.value));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2273: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const EXCLAMATIONMARK = 33;
      function consumeRaw(startToken) {
        return this.Raw(startToken, null, false);
      }
      const name = "StyleSheet";
      const walkContext = "stylesheet";
      const structure = {
        children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]],
      };
      function parse() {
        const start = this.tokenStart;
        const children = this.createList();
        let child;
        while (!this.eof) {
          switch (this.tokenType) {
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Comment:
              if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
                this.next();
                continue;
              }
              child = this.Comment();
              break;
            case types.CDO:
              child = this.CDO();
              break;
            case types.CDC:
              child = this.CDC();
              break;
            case types.AtKeyword:
              child = this.parseWithFallback(this.Atrule, consumeRaw);
              break;
            default:
              child = this.parseWithFallback(this.Rule, consumeRaw);
          }
          children.push(child);
        }
        return {
          type: "StyleSheet",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
      exports.walkContext = walkContext;
    },
    9871: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const ASTERISK = 42;
      const VERTICALLINE = 124;
      function eatIdentifierOrAsterisk() {
        if (
          this.tokenType !== types.Ident &&
          this.isDelim(ASTERISK) === false
        ) {
          this.error("Identifier or asterisk is expected");
        }
        this.next();
      }
      const name = "TypeSelector";
      const structure = { name: String };
      function parse() {
        const start = this.tokenStart;
        if (this.isDelim(VERTICALLINE)) {
          this.next();
          eatIdentifierOrAsterisk.call(this);
        } else {
          eatIdentifierOrAsterisk.call(this);
          if (this.isDelim(VERTICALLINE)) {
            this.next();
            eatIdentifierOrAsterisk.call(this);
          }
        }
        return {
          type: "TypeSelector",
          loc: this.getLocation(start, this.tokenStart),
          name: this.substrToCursor(start),
        };
      }
      function generate(node) {
        this.tokenize(node.name);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2711: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const charCodeDefinitions = __nccwpck_require__(6001);
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const QUESTIONMARK = 63;
      function eatHexSequence(offset, allowDash) {
        let len = 0;
        for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
          const code = this.charCodeAt(pos);
          if (code === HYPHENMINUS && allowDash && len !== 0) {
            eatHexSequence.call(this, offset + len + 1, false);
            return -1;
          }
          if (!charCodeDefinitions.isHexDigit(code)) {
            this.error(
              allowDash && len !== 0
                ? "Hyphen minus" +
                    (len < 6 ? " or hex digit" : "") +
                    " is expected"
                : len < 6
                  ? "Hex digit is expected"
                  : "Unexpected input",
              pos,
            );
          }
          if (++len > 6) {
            this.error("Too many hex digits", pos);
          }
        }
        this.next();
        return len;
      }
      function eatQuestionMarkSequence(max) {
        let count = 0;
        while (this.isDelim(QUESTIONMARK)) {
          if (++count > max) {
            this.error("Too many question marks");
          }
          this.next();
        }
      }
      function startsWith(code) {
        if (this.charCodeAt(this.tokenStart) !== code) {
          this.error(
            (code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected",
          );
        }
      }
      function scanUnicodeRange() {
        let hexLength = 0;
        switch (this.tokenType) {
          case types.Number:
            hexLength = eatHexSequence.call(this, 1, true);
            if (this.isDelim(QUESTIONMARK)) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
              break;
            }
            if (
              this.tokenType === types.Dimension ||
              this.tokenType === types.Number
            ) {
              startsWith.call(this, HYPHENMINUS);
              eatHexSequence.call(this, 1, false);
              break;
            }
            break;
          case types.Dimension:
            hexLength = eatHexSequence.call(this, 1, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            break;
          default:
            this.eatDelim(PLUSSIGN);
            if (this.tokenType === types.Ident) {
              hexLength = eatHexSequence.call(this, 0, true);
              if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
              }
              break;
            }
            if (this.isDelim(QUESTIONMARK)) {
              this.next();
              eatQuestionMarkSequence.call(this, 5);
              break;
            }
            this.error("Hex digit or question mark is expected");
        }
      }
      const name = "UnicodeRange";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        this.eatIdent("u");
        scanUnicodeRange.call(this);
        return {
          type: "UnicodeRange",
          loc: this.getLocation(start, this.tokenStart),
          value: this.substrToCursor(start),
        };
      }
      function generate(node) {
        this.tokenize(node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4446: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const url = __nccwpck_require__(5602);
      const string = __nccwpck_require__(590);
      const types = __nccwpck_require__(8839);
      const name = "Url";
      const structure = { value: String };
      function parse() {
        const start = this.tokenStart;
        let value;
        switch (this.tokenType) {
          case types.Url:
            value = url.decode(this.consume(types.Url));
            break;
          case types.Function:
            if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
              this.error("Function name must be `url`");
            }
            this.eat(types.Function);
            this.skipSC();
            value = string.decode(this.consume(types.String));
            this.skipSC();
            if (!this.eof) {
              this.eat(types.RightParenthesis);
            }
            break;
          default:
            this.error("Url or Function is expected");
        }
        return {
          type: "Url",
          loc: this.getLocation(start, this.tokenStart),
          value,
        };
      }
      function generate(node) {
        this.token(types.Url, url.encode(node.value));
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    2662: (__unused_webpack_module, exports) => {
      "use strict";
      const name = "Value";
      const structure = { children: [[]] };
      function parse() {
        const start = this.tokenStart;
        const children = this.readSequence(this.scope.Value);
        return {
          type: "Value",
          loc: this.getLocation(start, this.tokenStart),
          children,
        };
      }
      function generate(node) {
        this.children(node);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    6064: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const SPACE = Object.freeze({
        type: "WhiteSpace",
        loc: null,
        value: " ",
      });
      const name = "WhiteSpace";
      const structure = { value: String };
      function parse() {
        this.eat(types.WhiteSpace);
        return SPACE;
      }
      function generate(node) {
        this.token(types.WhiteSpace, node.value);
      }
      exports.generate = generate;
      exports.name = name;
      exports.parse = parse;
      exports.structure = structure;
    },
    4343: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const AnPlusB = __nccwpck_require__(4719);
      const Atrule = __nccwpck_require__(60);
      const AtrulePrelude = __nccwpck_require__(4449);
      const AttributeSelector = __nccwpck_require__(7909);
      const Block = __nccwpck_require__(3129);
      const Brackets = __nccwpck_require__(9567);
      const CDC = __nccwpck_require__(7107);
      const CDO = __nccwpck_require__(566);
      const ClassSelector = __nccwpck_require__(4e3);
      const Combinator = __nccwpck_require__(6358);
      const Comment = __nccwpck_require__(2924);
      const Declaration = __nccwpck_require__(9283);
      const DeclarationList = __nccwpck_require__(3705);
      const Dimension = __nccwpck_require__(5559);
      const Function = __nccwpck_require__(914);
      const Hash = __nccwpck_require__(1325);
      const Identifier = __nccwpck_require__(2459);
      const IdSelector = __nccwpck_require__(7484);
      const MediaFeature = __nccwpck_require__(1934);
      const MediaQuery = __nccwpck_require__(7406);
      const MediaQueryList = __nccwpck_require__(7276);
      const NestingSelector = __nccwpck_require__(8481);
      const Nth = __nccwpck_require__(8374);
      const Number = __nccwpck_require__(2293);
      const Operator = __nccwpck_require__(334);
      const Parentheses = __nccwpck_require__(2955);
      const Percentage = __nccwpck_require__(2912);
      const PseudoClassSelector = __nccwpck_require__(9927);
      const PseudoElementSelector = __nccwpck_require__(8018);
      const Ratio = __nccwpck_require__(1517);
      const Raw = __nccwpck_require__(7165);
      const Rule = __nccwpck_require__(3002);
      const Selector = __nccwpck_require__(919);
      const SelectorList = __nccwpck_require__(8797);
      const String = __nccwpck_require__(8779);
      const StyleSheet = __nccwpck_require__(2273);
      const TypeSelector = __nccwpck_require__(9871);
      const UnicodeRange = __nccwpck_require__(2711);
      const Url = __nccwpck_require__(4446);
      const Value = __nccwpck_require__(2662);
      const WhiteSpace = __nccwpck_require__(6064);
      exports.AnPlusB = AnPlusB.parse;
      exports.Atrule = Atrule.parse;
      exports.AtrulePrelude = AtrulePrelude.parse;
      exports.AttributeSelector = AttributeSelector.parse;
      exports.Block = Block.parse;
      exports.Brackets = Brackets.parse;
      exports.CDC = CDC.parse;
      exports.CDO = CDO.parse;
      exports.ClassSelector = ClassSelector.parse;
      exports.Combinator = Combinator.parse;
      exports.Comment = Comment.parse;
      exports.Declaration = Declaration.parse;
      exports.DeclarationList = DeclarationList.parse;
      exports.Dimension = Dimension.parse;
      exports.Function = Function.parse;
      exports.Hash = Hash.parse;
      exports.Identifier = Identifier.parse;
      exports.IdSelector = IdSelector.parse;
      exports.MediaFeature = MediaFeature.parse;
      exports.MediaQuery = MediaQuery.parse;
      exports.MediaQueryList = MediaQueryList.parse;
      exports.NestingSelector = NestingSelector.parse;
      exports.Nth = Nth.parse;
      exports.Number = Number.parse;
      exports.Operator = Operator.parse;
      exports.Parentheses = Parentheses.parse;
      exports.Percentage = Percentage.parse;
      exports.PseudoClassSelector = PseudoClassSelector.parse;
      exports.PseudoElementSelector = PseudoElementSelector.parse;
      exports.Ratio = Ratio.parse;
      exports.Raw = Raw.parse;
      exports.Rule = Rule.parse;
      exports.Selector = Selector.parse;
      exports.SelectorList = SelectorList.parse;
      exports.String = String.parse;
      exports.StyleSheet = StyleSheet.parse;
      exports.TypeSelector = TypeSelector.parse;
      exports.UnicodeRange = UnicodeRange.parse;
      exports.Url = Url.parse;
      exports.Value = Value.parse;
      exports.WhiteSpace = WhiteSpace.parse;
    },
    2853: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const AnPlusB = __nccwpck_require__(4719);
      const Atrule = __nccwpck_require__(60);
      const AtrulePrelude = __nccwpck_require__(4449);
      const AttributeSelector = __nccwpck_require__(7909);
      const Block = __nccwpck_require__(3129);
      const Brackets = __nccwpck_require__(9567);
      const CDC = __nccwpck_require__(7107);
      const CDO = __nccwpck_require__(566);
      const ClassSelector = __nccwpck_require__(4e3);
      const Combinator = __nccwpck_require__(6358);
      const Comment = __nccwpck_require__(2924);
      const Declaration = __nccwpck_require__(9283);
      const DeclarationList = __nccwpck_require__(3705);
      const Dimension = __nccwpck_require__(5559);
      const Function = __nccwpck_require__(914);
      const Hash = __nccwpck_require__(1325);
      const Identifier = __nccwpck_require__(2459);
      const IdSelector = __nccwpck_require__(7484);
      const MediaFeature = __nccwpck_require__(1934);
      const MediaQuery = __nccwpck_require__(7406);
      const MediaQueryList = __nccwpck_require__(7276);
      const NestingSelector = __nccwpck_require__(8481);
      const Nth = __nccwpck_require__(8374);
      const Number$1 = __nccwpck_require__(2293);
      const Operator = __nccwpck_require__(334);
      const Parentheses = __nccwpck_require__(2955);
      const Percentage = __nccwpck_require__(2912);
      const PseudoClassSelector = __nccwpck_require__(9927);
      const PseudoElementSelector = __nccwpck_require__(8018);
      const Ratio = __nccwpck_require__(1517);
      const Raw = __nccwpck_require__(7165);
      const Rule = __nccwpck_require__(3002);
      const Selector = __nccwpck_require__(919);
      const SelectorList = __nccwpck_require__(8797);
      const String$1 = __nccwpck_require__(8779);
      const StyleSheet = __nccwpck_require__(2273);
      const TypeSelector = __nccwpck_require__(9871);
      const UnicodeRange = __nccwpck_require__(2711);
      const Url = __nccwpck_require__(4446);
      const Value = __nccwpck_require__(2662);
      const WhiteSpace = __nccwpck_require__(6064);
      exports.AnPlusB = AnPlusB;
      exports.Atrule = Atrule;
      exports.AtrulePrelude = AtrulePrelude;
      exports.AttributeSelector = AttributeSelector;
      exports.Block = Block;
      exports.Brackets = Brackets;
      exports.CDC = CDC;
      exports.CDO = CDO;
      exports.ClassSelector = ClassSelector;
      exports.Combinator = Combinator;
      exports.Comment = Comment;
      exports.Declaration = Declaration;
      exports.DeclarationList = DeclarationList;
      exports.Dimension = Dimension;
      exports.Function = Function;
      exports.Hash = Hash;
      exports.Identifier = Identifier;
      exports.IdSelector = IdSelector;
      exports.MediaFeature = MediaFeature;
      exports.MediaQuery = MediaQuery;
      exports.MediaQueryList = MediaQueryList;
      exports.NestingSelector = NestingSelector;
      exports.Nth = Nth;
      exports.Number = Number$1;
      exports.Operator = Operator;
      exports.Parentheses = Parentheses;
      exports.Percentage = Percentage;
      exports.PseudoClassSelector = PseudoClassSelector;
      exports.PseudoElementSelector = PseudoElementSelector;
      exports.Ratio = Ratio;
      exports.Raw = Raw;
      exports.Rule = Rule;
      exports.Selector = Selector;
      exports.SelectorList = SelectorList;
      exports.String = String$1;
      exports.StyleSheet = StyleSheet;
      exports.TypeSelector = TypeSelector;
      exports.UnicodeRange = UnicodeRange;
      exports.Url = Url;
      exports.Value = Value;
      exports.WhiteSpace = WhiteSpace;
    },
    6658: (module) => {
      "use strict";
      const selectorList = {
        parse() {
          return this.createSingleNodeList(this.SelectorList());
        },
      };
      const selector = {
        parse() {
          return this.createSingleNodeList(this.Selector());
        },
      };
      const identList = {
        parse() {
          return this.createSingleNodeList(this.Identifier());
        },
      };
      const nth = {
        parse() {
          return this.createSingleNodeList(this.Nth());
        },
      };
      const pseudo = {
        dir: identList,
        has: selectorList,
        lang: identList,
        matches: selectorList,
        is: selectorList,
        "-moz-any": selectorList,
        "-webkit-any": selectorList,
        where: selectorList,
        not: selectorList,
        "nth-child": nth,
        "nth-last-child": nth,
        "nth-last-of-type": nth,
        "nth-of-type": nth,
        slotted: selector,
        host: selector,
        "host-context": selector,
      };
      module.exports = pseudo;
    },
    6455: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const _default = __nccwpck_require__(8512);
      const atrulePrelude = { getNode: _default };
      module.exports = atrulePrelude;
    },
    8512: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const NUMBERSIGN = 35;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const HYPHENMINUS = 45;
      const SOLIDUS = 47;
      const U = 117;
      function defaultRecognizer(context) {
        switch (this.tokenType) {
          case types.Hash:
            return this.Hash();
          case types.Comma:
            return this.Operator();
          case types.LeftParenthesis:
            return this.Parentheses(this.readSequence, context.recognizer);
          case types.LeftSquareBracket:
            return this.Brackets(this.readSequence, context.recognizer);
          case types.String:
            return this.String();
          case types.Dimension:
            return this.Dimension();
          case types.Percentage:
            return this.Percentage();
          case types.Number:
            return this.Number();
          case types.Function:
            return this.cmpStr(this.tokenStart, this.tokenEnd, "url(")
              ? this.Url()
              : this.Function(this.readSequence, context.recognizer);
          case types.Url:
            return this.Url();
          case types.Ident:
            if (
              this.cmpChar(this.tokenStart, U) &&
              this.cmpChar(this.tokenStart + 1, PLUSSIGN)
            ) {
              return this.UnicodeRange();
            } else {
              return this.Identifier();
            }
          case types.Delim: {
            const code = this.charCodeAt(this.tokenStart);
            if (
              code === SOLIDUS ||
              code === ASTERISK ||
              code === PLUSSIGN ||
              code === HYPHENMINUS
            ) {
              return this.Operator();
            }
            if (code === NUMBERSIGN) {
              this.error("Hex or identifier is expected", this.tokenStart + 1);
            }
            break;
          }
        }
      }
      module.exports = defaultRecognizer;
    },
    1735: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const atrulePrelude = __nccwpck_require__(6455);
      const selector = __nccwpck_require__(68);
      const value = __nccwpck_require__(421);
      exports.AtrulePrelude = atrulePrelude;
      exports.Selector = selector;
      exports.Value = value;
    },
    68: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const NUMBERSIGN = 35;
      const AMPERSAND = 38;
      const ASTERISK = 42;
      const PLUSSIGN = 43;
      const SOLIDUS = 47;
      const FULLSTOP = 46;
      const GREATERTHANSIGN = 62;
      const VERTICALLINE = 124;
      const TILDE = 126;
      function onWhiteSpace(next, children) {
        if (
          children.last !== null &&
          children.last.type !== "Combinator" &&
          next !== null &&
          next.type !== "Combinator"
        ) {
          children.push({ type: "Combinator", loc: null, name: " " });
        }
      }
      function getNode() {
        switch (this.tokenType) {
          case types.LeftSquareBracket:
            return this.AttributeSelector();
          case types.Hash:
            return this.IdSelector();
          case types.Colon:
            if (this.lookupType(1) === types.Colon) {
              return this.PseudoElementSelector();
            } else {
              return this.PseudoClassSelector();
            }
          case types.Ident:
            return this.TypeSelector();
          case types.Number:
          case types.Percentage:
            return this.Percentage();
          case types.Dimension:
            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
              this.error("Identifier is expected", this.tokenStart + 1);
            }
            break;
          case types.Delim: {
            const code = this.charCodeAt(this.tokenStart);
            switch (code) {
              case PLUSSIGN:
              case GREATERTHANSIGN:
              case TILDE:
              case SOLIDUS:
                return this.Combinator();
              case FULLSTOP:
                return this.ClassSelector();
              case ASTERISK:
              case VERTICALLINE:
                return this.TypeSelector();
              case NUMBERSIGN:
                return this.IdSelector();
              case AMPERSAND:
                return this.NestingSelector();
            }
            break;
          }
        }
      }
      const Selector = { onWhiteSpace, getNode };
      module.exports = Selector;
    },
    421: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const _default = __nccwpck_require__(8512);
      const expression = __nccwpck_require__(6855);
      const _var = __nccwpck_require__(2839);
      function isPlusMinusOperator(node) {
        return (
          node !== null &&
          node.type === "Operator" &&
          (node.value[node.value.length - 1] === "-" ||
            node.value[node.value.length - 1] === "+")
        );
      }
      const value = {
        getNode: _default,
        onWhiteSpace(next, children) {
          if (isPlusMinusOperator(next)) {
            next.value = " " + next.value;
          }
          if (isPlusMinusOperator(children.last)) {
            children.last.value += " ";
          }
        },
        expression,
        var: _var,
      };
      module.exports = value;
    },
    5149: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const adoptBuffer = __nccwpck_require__(8147);
      const charCodeDefinitions = __nccwpck_require__(6001);
      const N = 10;
      const F = 12;
      const R = 13;
      function computeLinesAndColumns(host) {
        const source = host.source;
        const sourceLength = source.length;
        const startOffset =
          source.length > 0
            ? charCodeDefinitions.isBOM(source.charCodeAt(0))
            : 0;
        const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
        const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
        let line = host.startLine;
        let column = host.startColumn;
        for (let i = startOffset; i < sourceLength; i++) {
          const code = source.charCodeAt(i);
          lines[i] = line;
          columns[i] = column++;
          if (code === N || code === R || code === F) {
            if (
              code === R &&
              i + 1 < sourceLength &&
              source.charCodeAt(i + 1) === N
            ) {
              i++;
              lines[i] = line;
              columns[i] = column;
            }
            line++;
            column = 1;
          }
        }
        lines[sourceLength] = line;
        columns[sourceLength] = column;
        host.lines = lines;
        host.columns = columns;
        host.computed = true;
      }
      class OffsetToLocation {
        constructor() {
          this.lines = null;
          this.columns = null;
          this.computed = false;
        }
        setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
          this.source = source;
          this.startOffset = startOffset;
          this.startLine = startLine;
          this.startColumn = startColumn;
          this.computed = false;
        }
        getLocation(offset, filename) {
          if (!this.computed) {
            computeLinesAndColumns(this);
          }
          return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset],
          };
        }
        getLocationRange(start, end, filename) {
          if (!this.computed) {
            computeLinesAndColumns(this);
          }
          return {
            source: filename,
            start: {
              offset: this.startOffset + start,
              line: this.lines[start],
              column: this.columns[start],
            },
            end: {
              offset: this.startOffset + end,
              line: this.lines[end],
              column: this.columns[end],
            },
          };
        }
      }
      exports.OffsetToLocation = OffsetToLocation;
    },
    1843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const adoptBuffer = __nccwpck_require__(8147);
      const utils = __nccwpck_require__(1255);
      const names = __nccwpck_require__(9516);
      const types = __nccwpck_require__(8839);
      const OFFSET_MASK = 16777215;
      const TYPE_SHIFT = 24;
      const balancePair = new Map([
        [types.Function, types.RightParenthesis],
        [types.LeftParenthesis, types.RightParenthesis],
        [types.LeftSquareBracket, types.RightSquareBracket],
        [types.LeftCurlyBracket, types.RightCurlyBracket],
      ]);
      class TokenStream {
        constructor(source, tokenize) {
          this.setSource(source, tokenize);
        }
        reset() {
          this.eof = false;
          this.tokenIndex = -1;
          this.tokenType = 0;
          this.tokenStart = this.firstCharOffset;
          this.tokenEnd = this.firstCharOffset;
        }
        setSource(source = "", tokenize = () => {}) {
          source = String(source || "");
          const sourceLength = source.length;
          const offsetAndType = adoptBuffer.adoptBuffer(
            this.offsetAndType,
            source.length + 1,
          );
          const balance = adoptBuffer.adoptBuffer(
            this.balance,
            source.length + 1,
          );
          let tokenCount = 0;
          let balanceCloseType = 0;
          let balanceStart = 0;
          let firstCharOffset = -1;
          this.offsetAndType = null;
          this.balance = null;
          tokenize(source, (type, start, end) => {
            switch (type) {
              default:
                balance[tokenCount] = sourceLength;
                break;
              case balanceCloseType: {
                let balancePrev = balanceStart & OFFSET_MASK;
                balanceStart = balance[balancePrev];
                balanceCloseType = balanceStart >> TYPE_SHIFT;
                balance[tokenCount] = balancePrev;
                balance[balancePrev++] = tokenCount;
                for (; balancePrev < tokenCount; balancePrev++) {
                  if (balance[balancePrev] === sourceLength) {
                    balance[balancePrev] = tokenCount;
                  }
                }
                break;
              }
              case types.LeftParenthesis:
              case types.Function:
              case types.LeftSquareBracket:
              case types.LeftCurlyBracket:
                balance[tokenCount] = balanceStart;
                balanceCloseType = balancePair.get(type);
                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                break;
            }
            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;
            if (firstCharOffset === -1) {
              firstCharOffset = start;
            }
          });
          offsetAndType[tokenCount] = (types.EOF << TYPE_SHIFT) | sourceLength;
          balance[tokenCount] = sourceLength;
          balance[sourceLength] = sourceLength;
          while (balanceStart !== 0) {
            const balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balance[balancePrev] = sourceLength;
          }
          this.source = source;
          this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
          this.tokenCount = tokenCount;
          this.offsetAndType = offsetAndType;
          this.balance = balance;
          this.reset();
          this.next();
        }
        lookupType(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
          }
          return types.EOF;
        }
        lookupOffset(offset) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
          }
          return this.source.length;
        }
        lookupValue(offset, referenceStr) {
          offset += this.tokenIndex;
          if (offset < this.tokenCount) {
            return utils.cmpStr(
              this.source,
              this.offsetAndType[offset - 1] & OFFSET_MASK,
              this.offsetAndType[offset] & OFFSET_MASK,
              referenceStr,
            );
          }
          return false;
        }
        getTokenStart(tokenIndex) {
          if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
          }
          if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
              ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
              : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
          }
          return this.firstCharOffset;
        }
        substrToCursor(start) {
          return this.source.substring(start, this.tokenStart);
        }
        isBalanceEdge(pos) {
          return this.balance[this.tokenIndex] < pos;
        }
        isDelim(code, offset) {
          if (offset) {
            return (
              this.lookupType(offset) === types.Delim &&
              this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
          }
          return (
            this.tokenType === types.Delim &&
            this.source.charCodeAt(this.tokenStart) === code
          );
        }
        skip(tokenCount) {
          let next = this.tokenIndex + tokenCount;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.tokenIndex = this.tokenCount;
            this.next();
          }
        }
        next() {
          let next = this.tokenIndex + 1;
          if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
          } else {
            this.eof = true;
            this.tokenIndex = this.tokenCount;
            this.tokenType = types.EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
          }
        }
        skipSC() {
          while (
            this.tokenType === types.WhiteSpace ||
            this.tokenType === types.Comment
          ) {
            this.next();
          }
        }
        skipUntilBalanced(startToken, stopConsume) {
          let cursor = startToken;
          let balanceEnd;
          let offset;
          loop: for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            offset =
              cursor > 0
                ? this.offsetAndType[cursor - 1] & OFFSET_MASK
                : this.firstCharOffset;
            switch (stopConsume(this.source.charCodeAt(offset))) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
            }
          }
          this.skip(cursor - this.tokenIndex);
        }
        forEachToken(fn) {
          for (
            let i = 0, offset = this.firstCharOffset;
            i < this.tokenCount;
            i++
          ) {
            const start = offset;
            const item = this.offsetAndType[i];
            const end = item & OFFSET_MASK;
            const type = item >> TYPE_SHIFT;
            offset = end;
            fn(type, start, end, i);
          }
        }
        dump() {
          const tokens = new Array(this.tokenCount);
          this.forEachToken((type, start, end, index) => {
            tokens[index] = {
              idx: index,
              type: names[type],
              chunk: this.source.substring(start, end),
              balance: this.balance[index],
            };
          });
          return tokens;
        }
      }
      exports.TokenStream = TokenStream;
    },
    8147: (__unused_webpack_module, exports) => {
      "use strict";
      const MIN_SIZE = 16 * 1024;
      function adoptBuffer(buffer = null, size) {
        if (buffer === null || buffer.length < size) {
          return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
        }
        return buffer;
      }
      exports.adoptBuffer = adoptBuffer;
    },
    6001: (__unused_webpack_module, exports) => {
      "use strict";
      const EOF = 0;
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
      function isHexDigit(code) {
        return (
          isDigit(code) ||
          (code >= 65 && code <= 70) ||
          (code >= 97 && code <= 102)
        );
      }
      function isUppercaseLetter(code) {
        return code >= 65 && code <= 90;
      }
      function isLowercaseLetter(code) {
        return code >= 97 && code <= 122;
      }
      function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
      }
      function isNonAscii(code) {
        return code >= 128;
      }
      function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 95;
      }
      function isName(code) {
        return isNameStart(code) || isDigit(code) || code === 45;
      }
      function isNonPrintable(code) {
        return (
          (code >= 0 && code <= 8) ||
          code === 11 ||
          (code >= 14 && code <= 31) ||
          code === 127
        );
      }
      function isNewline(code) {
        return code === 10 || code === 13 || code === 12;
      }
      function isWhiteSpace(code) {
        return isNewline(code) || code === 32 || code === 9;
      }
      function isValidEscape(first, second) {
        if (first !== 92) {
          return false;
        }
        if (isNewline(second) || second === EOF) {
          return false;
        }
        return true;
      }
      function isIdentifierStart(first, second, third) {
        if (first === 45) {
          return (
            isNameStart(second) || second === 45 || isValidEscape(second, third)
          );
        }
        if (isNameStart(first)) {
          return true;
        }
        if (first === 92) {
          return isValidEscape(first, second);
        }
        return false;
      }
      function isNumberStart(first, second, third) {
        if (first === 43 || first === 45) {
          if (isDigit(second)) {
            return 2;
          }
          return second === 46 && isDigit(third) ? 3 : 0;
        }
        if (first === 46) {
          return isDigit(second) ? 2 : 0;
        }
        if (isDigit(first)) {
          return 1;
        }
        return 0;
      }
      function isBOM(code) {
        if (code === 65279) {
          return 1;
        }
        if (code === 65534) {
          return 1;
        }
        return 0;
      }
      const CATEGORY = new Array(128);
      const EofCategory = 128;
      const WhiteSpaceCategory = 130;
      const DigitCategory = 131;
      const NameStartCategory = 132;
      const NonPrintableCategory = 133;
      for (let i = 0; i < CATEGORY.length; i++) {
        CATEGORY[i] =
          (isWhiteSpace(i) && WhiteSpaceCategory) ||
          (isDigit(i) && DigitCategory) ||
          (isNameStart(i) && NameStartCategory) ||
          (isNonPrintable(i) && NonPrintableCategory) ||
          i ||
          EofCategory;
      }
      function charCodeCategory(code) {
        return code < 128 ? CATEGORY[code] : NameStartCategory;
      }
      exports.DigitCategory = DigitCategory;
      exports.EofCategory = EofCategory;
      exports.NameStartCategory = NameStartCategory;
      exports.NonPrintableCategory = NonPrintableCategory;
      exports.WhiteSpaceCategory = WhiteSpaceCategory;
      exports.charCodeCategory = charCodeCategory;
      exports.isBOM = isBOM;
      exports.isDigit = isDigit;
      exports.isHexDigit = isHexDigit;
      exports.isIdentifierStart = isIdentifierStart;
      exports.isLetter = isLetter;
      exports.isLowercaseLetter = isLowercaseLetter;
      exports.isName = isName;
      exports.isNameStart = isNameStart;
      exports.isNewline = isNewline;
      exports.isNonAscii = isNonAscii;
      exports.isNonPrintable = isNonPrintable;
      exports.isNumberStart = isNumberStart;
      exports.isUppercaseLetter = isUppercaseLetter;
      exports.isValidEscape = isValidEscape;
      exports.isWhiteSpace = isWhiteSpace;
    },
    7324: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const types = __nccwpck_require__(8839);
      const charCodeDefinitions = __nccwpck_require__(6001);
      const utils = __nccwpck_require__(1255);
      const names = __nccwpck_require__(9516);
      const OffsetToLocation = __nccwpck_require__(5149);
      const TokenStream = __nccwpck_require__(1843);
      function tokenize(source, onToken) {
        function getCharCode(offset) {
          return offset < sourceLength ? source.charCodeAt(offset) : 0;
        }
        function consumeNumericToken() {
          offset = utils.consumeNumber(source, offset);
          if (
            charCodeDefinitions.isIdentifierStart(
              getCharCode(offset),
              getCharCode(offset + 1),
              getCharCode(offset + 2),
            )
          ) {
            type = types.Dimension;
            offset = utils.consumeName(source, offset);
            return;
          }
          if (getCharCode(offset) === 37) {
            type = types.Percentage;
            offset++;
            return;
          }
          type = types.Number;
        }
        function consumeIdentLikeToken() {
          const nameStartOffset = offset;
          offset = utils.consumeName(source, offset);
          if (
            utils.cmpStr(source, nameStartOffset, offset, "url") &&
            getCharCode(offset) === 40
          ) {
            offset = utils.findWhiteSpaceEnd(source, offset + 1);
            if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
              type = types.Function;
              offset = nameStartOffset + 4;
              return;
            }
            consumeUrlToken();
            return;
          }
          if (getCharCode(offset) === 40) {
            type = types.Function;
            offset++;
            return;
          }
          type = types.Ident;
        }
        function consumeStringToken(endingCodePoint) {
          if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
          }
          type = types.String;
          for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);
            switch (charCodeDefinitions.charCodeCategory(code)) {
              case endingCodePoint:
                offset++;
                return;
              case charCodeDefinitions.WhiteSpaceCategory:
                if (charCodeDefinitions.isNewline(code)) {
                  offset += utils.getNewlineLength(source, offset, code);
                  type = types.BadString;
                  return;
                }
                break;
              case 92:
                if (offset === source.length - 1) {
                  break;
                }
                const nextCode = getCharCode(offset + 1);
                if (charCodeDefinitions.isNewline(nextCode)) {
                  offset += utils.getNewlineLength(
                    source,
                    offset + 1,
                    nextCode,
                  );
                } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
                  offset = utils.consumeEscaped(source, offset) - 1;
                }
                break;
            }
          }
        }
        function consumeUrlToken() {
          type = types.Url;
          offset = utils.findWhiteSpaceEnd(source, offset);
          for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);
            switch (charCodeDefinitions.charCodeCategory(code)) {
              case 41:
                offset++;
                return;
              case charCodeDefinitions.WhiteSpaceCategory:
                offset = utils.findWhiteSpaceEnd(source, offset);
                if (getCharCode(offset) === 41 || offset >= source.length) {
                  if (offset < source.length) {
                    offset++;
                  }
                  return;
                }
                offset = utils.consumeBadUrlRemnants(source, offset);
                type = types.BadUrl;
                return;
              case 34:
              case 39:
              case 40:
              case charCodeDefinitions.NonPrintableCategory:
                offset = utils.consumeBadUrlRemnants(source, offset);
                type = types.BadUrl;
                return;
              case 92:
                if (
                  charCodeDefinitions.isValidEscape(
                    code,
                    getCharCode(offset + 1),
                  )
                ) {
                  offset = utils.consumeEscaped(source, offset) - 1;
                  break;
                }
                offset = utils.consumeBadUrlRemnants(source, offset);
                type = types.BadUrl;
                return;
            }
          }
        }
        source = String(source || "");
        const sourceLength = source.length;
        let start = charCodeDefinitions.isBOM(getCharCode(0));
        let offset = start;
        let type;
        while (offset < sourceLength) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            case charCodeDefinitions.WhiteSpaceCategory:
              type = types.WhiteSpace;
              offset = utils.findWhiteSpaceEnd(source, offset + 1);
              break;
            case 34:
              consumeStringToken();
              break;
            case 35:
              if (
                charCodeDefinitions.isName(getCharCode(offset + 1)) ||
                charCodeDefinitions.isValidEscape(
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                type = types.Hash;
                offset = utils.consumeName(source, offset + 1);
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 39:
              consumeStringToken();
              break;
            case 40:
              type = types.LeftParenthesis;
              offset++;
              break;
            case 41:
              type = types.RightParenthesis;
              offset++;
              break;
            case 43:
              if (
                charCodeDefinitions.isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 44:
              type = types.Comma;
              offset++;
              break;
            case 45:
              if (
                charCodeDefinitions.isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                if (
                  getCharCode(offset + 1) === 45 &&
                  getCharCode(offset + 2) === 62
                ) {
                  type = types.CDC;
                  offset = offset + 3;
                } else {
                  if (
                    charCodeDefinitions.isIdentifierStart(
                      code,
                      getCharCode(offset + 1),
                      getCharCode(offset + 2),
                    )
                  ) {
                    consumeIdentLikeToken();
                  } else {
                    type = types.Delim;
                    offset++;
                  }
                }
              }
              break;
            case 46:
              if (
                charCodeDefinitions.isNumberStart(
                  code,
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                )
              ) {
                consumeNumericToken();
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 47:
              if (getCharCode(offset + 1) === 42) {
                type = types.Comment;
                offset = source.indexOf("*/", offset + 2);
                offset = offset === -1 ? source.length : offset + 2;
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 58:
              type = types.Colon;
              offset++;
              break;
            case 59:
              type = types.Semicolon;
              offset++;
              break;
            case 60:
              if (
                getCharCode(offset + 1) === 33 &&
                getCharCode(offset + 2) === 45 &&
                getCharCode(offset + 3) === 45
              ) {
                type = types.CDO;
                offset = offset + 4;
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 64:
              if (
                charCodeDefinitions.isIdentifierStart(
                  getCharCode(offset + 1),
                  getCharCode(offset + 2),
                  getCharCode(offset + 3),
                )
              ) {
                type = types.AtKeyword;
                offset = utils.consumeName(source, offset + 1);
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 91:
              type = types.LeftSquareBracket;
              offset++;
              break;
            case 92:
              if (
                charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))
              ) {
                consumeIdentLikeToken();
              } else {
                type = types.Delim;
                offset++;
              }
              break;
            case 93:
              type = types.RightSquareBracket;
              offset++;
              break;
            case 123:
              type = types.LeftCurlyBracket;
              offset++;
              break;
            case 125:
              type = types.RightCurlyBracket;
              offset++;
              break;
            case charCodeDefinitions.DigitCategory:
              consumeNumericToken();
              break;
            case charCodeDefinitions.NameStartCategory:
              consumeIdentLikeToken();
              break;
            default:
              type = types.Delim;
              offset++;
          }
          onToken(type, start, (start = offset));
        }
      }
      exports.AtKeyword = types.AtKeyword;
      exports.BadString = types.BadString;
      exports.BadUrl = types.BadUrl;
      exports.CDC = types.CDC;
      exports.CDO = types.CDO;
      exports.Colon = types.Colon;
      exports.Comma = types.Comma;
      exports.Comment = types.Comment;
      exports.Delim = types.Delim;
      exports.Dimension = types.Dimension;
      exports.EOF = types.EOF;
      exports.Function = types.Function;
      exports.Hash = types.Hash;
      exports.Ident = types.Ident;
      exports.LeftCurlyBracket = types.LeftCurlyBracket;
      exports.LeftParenthesis = types.LeftParenthesis;
      exports.LeftSquareBracket = types.LeftSquareBracket;
      exports.Number = types.Number;
      exports.Percentage = types.Percentage;
      exports.RightCurlyBracket = types.RightCurlyBracket;
      exports.RightParenthesis = types.RightParenthesis;
      exports.RightSquareBracket = types.RightSquareBracket;
      exports.Semicolon = types.Semicolon;
      exports.String = types.String;
      exports.Url = types.Url;
      exports.WhiteSpace = types.WhiteSpace;
      exports.tokenTypes = types;
      exports.DigitCategory = charCodeDefinitions.DigitCategory;
      exports.EofCategory = charCodeDefinitions.EofCategory;
      exports.NameStartCategory = charCodeDefinitions.NameStartCategory;
      exports.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
      exports.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
      exports.charCodeCategory = charCodeDefinitions.charCodeCategory;
      exports.isBOM = charCodeDefinitions.isBOM;
      exports.isDigit = charCodeDefinitions.isDigit;
      exports.isHexDigit = charCodeDefinitions.isHexDigit;
      exports.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
      exports.isLetter = charCodeDefinitions.isLetter;
      exports.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
      exports.isName = charCodeDefinitions.isName;
      exports.isNameStart = charCodeDefinitions.isNameStart;
      exports.isNewline = charCodeDefinitions.isNewline;
      exports.isNonAscii = charCodeDefinitions.isNonAscii;
      exports.isNonPrintable = charCodeDefinitions.isNonPrintable;
      exports.isNumberStart = charCodeDefinitions.isNumberStart;
      exports.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
      exports.isValidEscape = charCodeDefinitions.isValidEscape;
      exports.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
      exports.cmpChar = utils.cmpChar;
      exports.cmpStr = utils.cmpStr;
      exports.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
      exports.consumeEscaped = utils.consumeEscaped;
      exports.consumeName = utils.consumeName;
      exports.consumeNumber = utils.consumeNumber;
      exports.decodeEscaped = utils.decodeEscaped;
      exports.findDecimalNumberEnd = utils.findDecimalNumberEnd;
      exports.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
      exports.findWhiteSpaceStart = utils.findWhiteSpaceStart;
      exports.getNewlineLength = utils.getNewlineLength;
      exports.tokenNames = names;
      exports.OffsetToLocation = OffsetToLocation.OffsetToLocation;
      exports.TokenStream = TokenStream.TokenStream;
      exports.tokenize = tokenize;
    },
    9516: (module) => {
      "use strict";
      const tokenNames = [
        "EOF-token",
        "ident-token",
        "function-token",
        "at-keyword-token",
        "hash-token",
        "string-token",
        "bad-string-token",
        "url-token",
        "bad-url-token",
        "delim-token",
        "number-token",
        "percentage-token",
        "dimension-token",
        "whitespace-token",
        "CDO-token",
        "CDC-token",
        "colon-token",
        "semicolon-token",
        "comma-token",
        "[-token",
        "]-token",
        "(-token",
        ")-token",
        "{-token",
        "}-token",
      ];
      module.exports = tokenNames;
    },
    8839: (__unused_webpack_module, exports) => {
      "use strict";
      const EOF = 0;
      const Ident = 1;
      const Function = 2;
      const AtKeyword = 3;
      const Hash = 4;
      const String = 5;
      const BadString = 6;
      const Url = 7;
      const BadUrl = 8;
      const Delim = 9;
      const Number = 10;
      const Percentage = 11;
      const Dimension = 12;
      const WhiteSpace = 13;
      const CDO = 14;
      const CDC = 15;
      const Colon = 16;
      const Semicolon = 17;
      const Comma = 18;
      const LeftSquareBracket = 19;
      const RightSquareBracket = 20;
      const LeftParenthesis = 21;
      const RightParenthesis = 22;
      const LeftCurlyBracket = 23;
      const RightCurlyBracket = 24;
      const Comment = 25;
      exports.AtKeyword = AtKeyword;
      exports.BadString = BadString;
      exports.BadUrl = BadUrl;
      exports.CDC = CDC;
      exports.CDO = CDO;
      exports.Colon = Colon;
      exports.Comma = Comma;
      exports.Comment = Comment;
      exports.Delim = Delim;
      exports.Dimension = Dimension;
      exports.EOF = EOF;
      exports.Function = Function;
      exports.Hash = Hash;
      exports.Ident = Ident;
      exports.LeftCurlyBracket = LeftCurlyBracket;
      exports.LeftParenthesis = LeftParenthesis;
      exports.LeftSquareBracket = LeftSquareBracket;
      exports.Number = Number;
      exports.Percentage = Percentage;
      exports.RightCurlyBracket = RightCurlyBracket;
      exports.RightParenthesis = RightParenthesis;
      exports.RightSquareBracket = RightSquareBracket;
      exports.Semicolon = Semicolon;
      exports.String = String;
      exports.Url = Url;
      exports.WhiteSpace = WhiteSpace;
    },
    1255: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(6001);
      function getCharCode(source, offset) {
        return offset < source.length ? source.charCodeAt(offset) : 0;
      }
      function getNewlineLength(source, offset, code) {
        if (code === 13 && getCharCode(source, offset + 1) === 10) {
          return 2;
        }
        return 1;
      }
      function cmpChar(testStr, offset, referenceCode) {
        let code = testStr.charCodeAt(offset);
        if (charCodeDefinitions.isUppercaseLetter(code)) {
          code = code | 32;
        }
        return code === referenceCode;
      }
      function cmpStr(testStr, start, end, referenceStr) {
        if (end - start !== referenceStr.length) {
          return false;
        }
        if (start < 0 || end > testStr.length) {
          return false;
        }
        for (let i = start; i < end; i++) {
          const referenceCode = referenceStr.charCodeAt(i - start);
          let testCode = testStr.charCodeAt(i);
          if (charCodeDefinitions.isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
          }
          if (testCode !== referenceCode) {
            return false;
          }
        }
        return true;
      }
      function findWhiteSpaceStart(source, offset) {
        for (; offset >= 0; offset--) {
          if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset + 1;
      }
      function findWhiteSpaceEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function findDecimalNumberEnd(source, offset) {
        for (; offset < source.length; offset++) {
          if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
            break;
          }
        }
        return offset;
      }
      function consumeEscaped(source, offset) {
        offset += 2;
        if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
          for (
            const maxOffset = Math.min(source.length, offset + 5);
            offset < maxOffset;
            offset++
          ) {
            if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
              break;
            }
          }
          const code = getCharCode(source, offset);
          if (charCodeDefinitions.isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
          }
        }
        return offset;
      }
      function consumeName(source, offset) {
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          if (charCodeDefinitions.isName(code)) {
            continue;
          }
          if (
            charCodeDefinitions.isValidEscape(
              code,
              getCharCode(source, offset + 1),
            )
          ) {
            offset = consumeEscaped(source, offset) - 1;
            continue;
          }
          break;
        }
        return offset;
      }
      function consumeNumber(source, offset) {
        let code = source.charCodeAt(offset);
        if (code === 43 || code === 45) {
          code = source.charCodeAt((offset += 1));
        }
        if (charCodeDefinitions.isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1);
          code = source.charCodeAt(offset);
        }
        if (
          code === 46 &&
          charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))
        ) {
          offset += 2;
          offset = findDecimalNumberEnd(source, offset);
        }
        if (cmpChar(source, offset, 101)) {
          let sign = 0;
          code = source.charCodeAt(offset + 1);
          if (code === 45 || code === 43) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
          }
          if (charCodeDefinitions.isDigit(code)) {
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
          }
        }
        return offset;
      }
      function consumeBadUrlRemnants(source, offset) {
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          if (code === 41) {
            offset++;
            break;
          }
          if (
            charCodeDefinitions.isValidEscape(
              code,
              getCharCode(source, offset + 1),
            )
          ) {
            offset = consumeEscaped(source, offset);
          }
        }
        return offset;
      }
      function decodeEscaped(escaped) {
        if (
          escaped.length === 1 &&
          !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))
        ) {
          return escaped[0];
        }
        let code = parseInt(escaped, 16);
        if (code === 0 || (code >= 55296 && code <= 57343) || code > 1114111) {
          code = 65533;
        }
        return String.fromCodePoint(code);
      }
      exports.cmpChar = cmpChar;
      exports.cmpStr = cmpStr;
      exports.consumeBadUrlRemnants = consumeBadUrlRemnants;
      exports.consumeEscaped = consumeEscaped;
      exports.consumeName = consumeName;
      exports.consumeNumber = consumeNumber;
      exports.decodeEscaped = decodeEscaped;
      exports.findDecimalNumberEnd = findDecimalNumberEnd;
      exports.findWhiteSpaceEnd = findWhiteSpaceEnd;
      exports.findWhiteSpaceStart = findWhiteSpaceStart;
      exports.getNewlineLength = getNewlineLength;
    },
    6929: (__unused_webpack_module, exports) => {
      "use strict";
      let releasedCursors = null;
      class List {
        static createItem(data) {
          return { prev: null, next: null, data };
        }
        constructor() {
          this.head = null;
          this.tail = null;
          this.cursor = null;
        }
        createItem(data) {
          return List.createItem(data);
        }
        allocateCursor(prev, next) {
          let cursor;
          if (releasedCursors !== null) {
            cursor = releasedCursors;
            releasedCursors = releasedCursors.cursor;
            cursor.prev = prev;
            cursor.next = next;
            cursor.cursor = this.cursor;
          } else {
            cursor = { prev, next, cursor: this.cursor };
          }
          this.cursor = cursor;
          return cursor;
        }
        releaseCursor() {
          const { cursor } = this;
          this.cursor = cursor.cursor;
          cursor.prev = null;
          cursor.next = null;
          cursor.cursor = releasedCursors;
          releasedCursors = cursor;
        }
        updateCursors(prevOld, prevNew, nextOld, nextNew) {
          let { cursor } = this;
          while (cursor !== null) {
            if (cursor.prev === prevOld) {
              cursor.prev = prevNew;
            }
            if (cursor.next === nextOld) {
              cursor.next = nextNew;
            }
            cursor = cursor.cursor;
          }
        }
        *[Symbol.iterator]() {
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            yield cursor.data;
          }
        }
        get size() {
          let size = 0;
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            size++;
          }
          return size;
        }
        get isEmpty() {
          return this.head === null;
        }
        get first() {
          return this.head && this.head.data;
        }
        get last() {
          return this.tail && this.tail.data;
        }
        fromArray(array) {
          let cursor = null;
          this.head = null;
          for (let data of array) {
            const item = List.createItem(data);
            if (cursor !== null) {
              cursor.next = item;
            } else {
              this.head = item;
            }
            item.prev = cursor;
            cursor = item;
          }
          this.tail = cursor;
          return this;
        }
        toArray() {
          return [...this];
        }
        toJSON() {
          return [...this];
        }
        forEach(fn, thisArg = this) {
          const cursor = this.allocateCursor(null, this.head);
          while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            fn.call(thisArg, item.data, item, this);
          }
          this.releaseCursor();
        }
        forEachRight(fn, thisArg = this) {
          const cursor = this.allocateCursor(this.tail, null);
          while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            fn.call(thisArg, item.data, item, this);
          }
          this.releaseCursor();
        }
        reduce(fn, initialValue, thisArg = this) {
          let cursor = this.allocateCursor(null, this.head);
          let acc = initialValue;
          let item;
          while (cursor.next !== null) {
            item = cursor.next;
            cursor.next = item.next;
            acc = fn.call(thisArg, acc, item.data, item, this);
          }
          this.releaseCursor();
          return acc;
        }
        reduceRight(fn, initialValue, thisArg = this) {
          let cursor = this.allocateCursor(this.tail, null);
          let acc = initialValue;
          let item;
          while (cursor.prev !== null) {
            item = cursor.prev;
            cursor.prev = item.prev;
            acc = fn.call(thisArg, acc, item.data, item, this);
          }
          this.releaseCursor();
          return acc;
        }
        some(fn, thisArg = this) {
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
              return true;
            }
          }
          return false;
        }
        map(fn, thisArg = this) {
          const result = new List();
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            result.appendData(fn.call(thisArg, cursor.data, cursor, this));
          }
          return result;
        }
        filter(fn, thisArg = this) {
          const result = new List();
          for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
              result.appendData(cursor.data);
            }
          }
          return result;
        }
        nextUntil(start, fn, thisArg = this) {
          if (start === null) {
            return;
          }
          const cursor = this.allocateCursor(null, start);
          while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            if (fn.call(thisArg, item.data, item, this)) {
              break;
            }
          }
          this.releaseCursor();
        }
        prevUntil(start, fn, thisArg = this) {
          if (start === null) {
            return;
          }
          const cursor = this.allocateCursor(start, null);
          while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            if (fn.call(thisArg, item.data, item, this)) {
              break;
            }
          }
          this.releaseCursor();
        }
        clear() {
          this.head = null;
          this.tail = null;
        }
        copy() {
          const result = new List();
          for (let data of this) {
            result.appendData(data);
          }
          return result;
        }
        prepend(item) {
          this.updateCursors(null, item, this.head, item);
          if (this.head !== null) {
            this.head.prev = item;
            item.next = this.head;
          } else {
            this.tail = item;
          }
          this.head = item;
          return this;
        }
        prependData(data) {
          return this.prepend(List.createItem(data));
        }
        append(item) {
          return this.insert(item);
        }
        appendData(data) {
          return this.insert(List.createItem(data));
        }
        insert(item, before = null) {
          if (before !== null) {
            this.updateCursors(before.prev, item, before, item);
            if (before.prev === null) {
              if (this.head !== before) {
                throw new Error("before doesn't belong to list");
              }
              this.head = item;
              before.prev = item;
              item.next = before;
              this.updateCursors(null, item);
            } else {
              before.prev.next = item;
              item.prev = before.prev;
              before.prev = item;
              item.next = before;
            }
          } else {
            this.updateCursors(this.tail, item, null, item);
            if (this.tail !== null) {
              this.tail.next = item;
              item.prev = this.tail;
            } else {
              this.head = item;
            }
            this.tail = item;
          }
          return this;
        }
        insertData(data, before) {
          return this.insert(List.createItem(data), before);
        }
        remove(item) {
          this.updateCursors(item, item.prev, item, item.next);
          if (item.prev !== null) {
            item.prev.next = item.next;
          } else {
            if (this.head !== item) {
              throw new Error("item doesn't belong to list");
            }
            this.head = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          } else {
            if (this.tail !== item) {
              throw new Error("item doesn't belong to list");
            }
            this.tail = item.prev;
          }
          item.prev = null;
          item.next = null;
          return item;
        }
        push(data) {
          this.insert(List.createItem(data));
        }
        pop() {
          return this.tail !== null ? this.remove(this.tail) : null;
        }
        unshift(data) {
          this.prepend(List.createItem(data));
        }
        shift() {
          return this.head !== null ? this.remove(this.head) : null;
        }
        prependList(list) {
          return this.insertList(list, this.head);
        }
        appendList(list) {
          return this.insertList(list);
        }
        insertList(list, before) {
          if (list.head === null) {
            return this;
          }
          if (before !== undefined && before !== null) {
            this.updateCursors(before.prev, list.tail, before, list.head);
            if (before.prev !== null) {
              before.prev.next = list.head;
              list.head.prev = before.prev;
            } else {
              this.head = list.head;
            }
            before.prev = list.tail;
            list.tail.next = before;
          } else {
            this.updateCursors(this.tail, list.tail, null, list.head);
            if (this.tail !== null) {
              this.tail.next = list.head;
              list.head.prev = this.tail;
            } else {
              this.head = list.head;
            }
            this.tail = list.tail;
          }
          list.head = null;
          list.tail = null;
          return this;
        }
        replace(oldItem, newItemOrList) {
          if ("head" in newItemOrList) {
            this.insertList(newItemOrList, oldItem);
          } else {
            this.insert(newItemOrList, oldItem);
          }
          this.remove(oldItem);
        }
      }
      exports.List = List;
    },
    6231: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const List = __nccwpck_require__(6929);
      function clone(node) {
        const result = {};
        for (const key in node) {
          let value = node[key];
          if (value) {
            if (Array.isArray(value) || value instanceof List.List) {
              value = value.map(clone);
            } else if (value.constructor === Object) {
              value = clone(value);
            }
          }
          result[key] = value;
        }
        return result;
      }
      exports.clone = clone;
    },
    5850: (__unused_webpack_module, exports) => {
      "use strict";
      function createCustomError(name, message) {
        const error = Object.create(SyntaxError.prototype);
        const errorStack = new Error();
        return Object.assign(error, {
          name,
          message,
          get stack() {
            return (errorStack.stack || "").replace(
              /^(.+\n){1,3}/,
              `${name}: ${message}\n`,
            );
          },
        });
      }
      exports.createCustomError = createCustomError;
    },
    1811: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(6001);
      const utils = __nccwpck_require__(1255);
      const REVERSE_SOLIDUS = 92;
      function decode(str) {
        const end = str.length - 1;
        let decoded = "";
        for (let i = 0; i < str.length; i++) {
          let code = str.charCodeAt(i);
          if (code === REVERSE_SOLIDUS) {
            if (i === end) {
              break;
            }
            code = str.charCodeAt(++i);
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
              const escapeStart = i - 1;
              const escapeEnd = utils.consumeEscaped(str, escapeStart);
              i = escapeEnd - 1;
              decoded += utils.decodeEscaped(
                str.substring(escapeStart + 1, escapeEnd),
              );
            } else {
              if (code === 13 && str.charCodeAt(i + 1) === 10) {
                i++;
              }
            }
          } else {
            decoded += str[i];
          }
        }
        return decoded;
      }
      function encode(str) {
        let encoded = "";
        if (str.length === 1 && str.charCodeAt(0) === 45) {
          return "\\-";
        }
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code === 0) {
            encoded += "�";
            continue;
          }
          if (
            code <= 31 ||
            code === 127 ||
            (code >= 48 &&
              code <= 57 &&
              (i === 0 || (i === 1 && str.charCodeAt(0) === 45)))
          ) {
            encoded += "\\" + code.toString(16) + " ";
            continue;
          }
          if (charCodeDefinitions.isName(code)) {
            encoded += str.charAt(i);
          } else {
            encoded += "\\" + str.charAt(i);
          }
        }
        return encoded;
      }
      exports.decode = decode;
      exports.encode = encode;
    },
    4195: (__unused_webpack_module, exports) => {
      "use strict";
      const keywords = new Map();
      const properties = new Map();
      const HYPHENMINUS = 45;
      const keyword = getKeywordDescriptor;
      const property = getPropertyDescriptor;
      const vendorPrefix = getVendorPrefix;
      function isCustomProperty(str, offset) {
        offset = offset || 0;
        return (
          str.length - offset >= 2 &&
          str.charCodeAt(offset) === HYPHENMINUS &&
          str.charCodeAt(offset + 1) === HYPHENMINUS
        );
      }
      function getVendorPrefix(str, offset) {
        offset = offset || 0;
        if (str.length - offset >= 3) {
          if (
            str.charCodeAt(offset) === HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS
          ) {
            const secondDashIndex = str.indexOf("-", offset + 2);
            if (secondDashIndex !== -1) {
              return str.substring(offset, secondDashIndex + 1);
            }
          }
        }
        return "";
      }
      function getKeywordDescriptor(keyword) {
        if (keywords.has(keyword)) {
          return keywords.get(keyword);
        }
        const name = keyword.toLowerCase();
        let descriptor = keywords.get(name);
        if (descriptor === undefined) {
          const custom = isCustomProperty(name, 0);
          const vendor = !custom ? getVendorPrefix(name, 0) : "";
          descriptor = Object.freeze({
            basename: name.substr(vendor.length),
            name,
            prefix: vendor,
            vendor,
            custom,
          });
        }
        keywords.set(keyword, descriptor);
        return descriptor;
      }
      function getPropertyDescriptor(property) {
        if (properties.has(property)) {
          return properties.get(property);
        }
        let name = property;
        let hack = property[0];
        if (hack === "/") {
          hack = property[1] === "/" ? "//" : "/";
        } else if (
          hack !== "_" &&
          hack !== "*" &&
          hack !== "$" &&
          hack !== "#" &&
          hack !== "+" &&
          hack !== "&"
        ) {
          hack = "";
        }
        const custom = isCustomProperty(name, hack.length);
        if (!custom) {
          name = name.toLowerCase();
          if (properties.has(name)) {
            const descriptor = properties.get(name);
            properties.set(property, descriptor);
            return descriptor;
          }
        }
        const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
        const prefix = name.substr(0, hack.length + vendor.length);
        const descriptor = Object.freeze({
          basename: name.substr(prefix.length),
          name: name.substr(hack.length),
          hack,
          vendor,
          prefix,
          custom,
        });
        properties.set(property, descriptor);
        return descriptor;
      }
      exports.isCustomProperty = isCustomProperty;
      exports.keyword = keyword;
      exports.property = property;
      exports.vendorPrefix = vendorPrefix;
    },
    590: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(6001);
      const utils = __nccwpck_require__(1255);
      const REVERSE_SOLIDUS = 92;
      const QUOTATION_MARK = 34;
      const APOSTROPHE = 39;
      function decode(str) {
        const len = str.length;
        const firstChar = str.charCodeAt(0);
        const start =
          firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
        const end =
          start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar
            ? len - 2
            : len - 1;
        let decoded = "";
        for (let i = start; i <= end; i++) {
          let code = str.charCodeAt(i);
          if (code === REVERSE_SOLIDUS) {
            if (i === end) {
              if (i !== len - 1) {
                decoded = str.substr(i + 1);
              }
              break;
            }
            code = str.charCodeAt(++i);
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
              const escapeStart = i - 1;
              const escapeEnd = utils.consumeEscaped(str, escapeStart);
              i = escapeEnd - 1;
              decoded += utils.decodeEscaped(
                str.substring(escapeStart + 1, escapeEnd),
              );
            } else {
              if (code === 13 && str.charCodeAt(i + 1) === 10) {
                i++;
              }
            }
          } else {
            decoded += str[i];
          }
        }
        return decoded;
      }
      function encode(str, apostrophe) {
        const quote = apostrophe ? "'" : '"';
        const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
        let encoded = "";
        let wsBeforeHexIsNeeded = false;
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code === 0) {
            encoded += "�";
            continue;
          }
          if (code <= 31 || code === 127) {
            encoded += "\\" + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
          }
          if (code === quoteCode || code === REVERSE_SOLIDUS) {
            encoded += "\\" + str.charAt(i);
            wsBeforeHexIsNeeded = false;
          } else {
            if (
              wsBeforeHexIsNeeded &&
              (charCodeDefinitions.isHexDigit(code) ||
                charCodeDefinitions.isWhiteSpace(code))
            ) {
              encoded += " ";
            }
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
          }
        }
        return quote + encoded + quote;
      }
      exports.decode = decode;
      exports.encode = encode;
    },
    5602: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const charCodeDefinitions = __nccwpck_require__(6001);
      const utils = __nccwpck_require__(1255);
      const SPACE = 32;
      const REVERSE_SOLIDUS = 92;
      const QUOTATION_MARK = 34;
      const APOSTROPHE = 39;
      const LEFTPARENTHESIS = 40;
      const RIGHTPARENTHESIS = 41;
      function decode(str) {
        const len = str.length;
        let start = 4;
        let end =
          str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
        let decoded = "";
        while (
          start < end &&
          charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))
        ) {
          start++;
        }
        while (
          start < end &&
          charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))
        ) {
          end--;
        }
        for (let i = start; i <= end; i++) {
          let code = str.charCodeAt(i);
          if (code === REVERSE_SOLIDUS) {
            if (i === end) {
              if (i !== len - 1) {
                decoded = str.substr(i + 1);
              }
              break;
            }
            code = str.charCodeAt(++i);
            if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
              const escapeStart = i - 1;
              const escapeEnd = utils.consumeEscaped(str, escapeStart);
              i = escapeEnd - 1;
              decoded += utils.decodeEscaped(
                str.substring(escapeStart + 1, escapeEnd),
              );
            } else {
              if (code === 13 && str.charCodeAt(i + 1) === 10) {
                i++;
              }
            }
          } else {
            decoded += str[i];
          }
        }
        return decoded;
      }
      function encode(str) {
        let encoded = "";
        let wsBeforeHexIsNeeded = false;
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (code === 0) {
            encoded += "�";
            continue;
          }
          if (code <= 31 || code === 127) {
            encoded += "\\" + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
          }
          if (
            code === SPACE ||
            code === REVERSE_SOLIDUS ||
            code === QUOTATION_MARK ||
            code === APOSTROPHE ||
            code === LEFTPARENTHESIS ||
            code === RIGHTPARENTHESIS
          ) {
            encoded += "\\" + str.charAt(i);
            wsBeforeHexIsNeeded = false;
          } else {
            if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
              encoded += " ";
            }
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
          }
        }
        return "url(" + encoded + ")";
      }
      exports.decode = decode;
      exports.encode = encode;
    },
    2789: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { version } = __nccwpck_require__(3684);
      exports.version = version;
    },
    1655: (__unused_webpack_module, exports) => {
      "use strict";
      const { hasOwnProperty } = Object.prototype;
      const noop = function () {};
      function ensureFunction(value) {
        return typeof value === "function" ? value : noop;
      }
      function invokeForType(fn, type) {
        return function (node, item, list) {
          if (node.type === type) {
            fn.call(this, node, item, list);
          }
        };
      }
      function getWalkersFromStructure(name, nodeType) {
        const structure = nodeType.structure;
        const walkers = [];
        for (const key in structure) {
          if (hasOwnProperty.call(structure, key) === false) {
            continue;
          }
          let fieldTypes = structure[key];
          const walker = { name: key, type: false, nullable: false };
          if (!Array.isArray(fieldTypes)) {
            fieldTypes = [fieldTypes];
          }
          for (const fieldType of fieldTypes) {
            if (fieldType === null) {
              walker.nullable = true;
            } else if (typeof fieldType === "string") {
              walker.type = "node";
            } else if (Array.isArray(fieldType)) {
              walker.type = "list";
            }
          }
          if (walker.type) {
            walkers.push(walker);
          }
        }
        if (walkers.length) {
          return { context: nodeType.walkContext, fields: walkers };
        }
        return null;
      }
      function getTypesFromConfig(config) {
        const types = {};
        for (const name in config.node) {
          if (hasOwnProperty.call(config.node, name)) {
            const nodeType = config.node[name];
            if (!nodeType.structure) {
              throw new Error(
                "Missed `structure` field in `" +
                  name +
                  "` node type definition",
              );
            }
            types[name] = getWalkersFromStructure(name, nodeType);
          }
        }
        return types;
      }
      function createTypeIterator(config, reverse) {
        const fields = config.fields.slice();
        const contextName = config.context;
        const useContext = typeof contextName === "string";
        if (reverse) {
          fields.reverse();
        }
        return function (node, context, walk, walkReducer) {
          let prevContextValue;
          if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
          }
          for (const field of fields) {
            const ref = node[field.name];
            if (!field.nullable || ref) {
              if (field.type === "list") {
                const breakWalk = reverse
                  ? ref.reduceRight(walkReducer, false)
                  : ref.reduce(walkReducer, false);
                if (breakWalk) {
                  return true;
                }
              } else if (walk(ref)) {
                return true;
              }
            }
          }
          if (useContext) {
            context[contextName] = prevContextValue;
          }
        };
      }
      function createFastTraveralMap({
        StyleSheet,
        Atrule,
        Rule,
        Block,
        DeclarationList,
      }) {
        return {
          Atrule: { StyleSheet, Atrule, Rule, Block },
          Rule: { StyleSheet, Atrule, Rule, Block },
          Declaration: { StyleSheet, Atrule, Rule, Block, DeclarationList },
        };
      }
      function createWalker(config) {
        const types = getTypesFromConfig(config);
        const iteratorsNatural = {};
        const iteratorsReverse = {};
        const breakWalk = Symbol("break-walk");
        const skipNode = Symbol("skip-node");
        for (const name in types) {
          if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
          }
        }
        const fastTraversalIteratorsNatural =
          createFastTraveralMap(iteratorsNatural);
        const fastTraversalIteratorsReverse =
          createFastTraveralMap(iteratorsReverse);
        const walk = function (root, options) {
          function walkNode(node, item, list) {
            const enterRet = enter.call(context, node, item, list);
            if (enterRet === breakWalk) {
              return true;
            }
            if (enterRet === skipNode) {
              return false;
            }
            if (iterators.hasOwnProperty(node.type)) {
              if (iterators[node.type](node, context, walkNode, walkReducer)) {
                return true;
              }
            }
            if (leave.call(context, node, item, list) === breakWalk) {
              return true;
            }
            return false;
          }
          let enter = noop;
          let leave = noop;
          let iterators = iteratorsNatural;
          let walkReducer = (ret, data, item, list) =>
            ret || walkNode(data, item, list);
          const context = {
            break: breakWalk,
            skip: skipNode,
            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null,
          };
          if (typeof options === "function") {
            enter = options;
          } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);
            if (options.reverse) {
              iterators = iteratorsReverse;
            }
            if (options.visit) {
              if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                iterators = options.reverse
                  ? fastTraversalIteratorsReverse[options.visit]
                  : fastTraversalIteratorsNatural[options.visit];
              } else if (!types.hasOwnProperty(options.visit)) {
                throw new Error(
                  "Bad value `" +
                    options.visit +
                    "` for `visit` option (should be: " +
                    Object.keys(types).sort().join(", ") +
                    ")",
                );
              }
              enter = invokeForType(enter, options.visit);
              leave = invokeForType(leave, options.visit);
            }
          }
          if (enter === noop && leave === noop) {
            throw new Error(
              "Neither `enter` nor `leave` walker handler is set or both aren't a function",
            );
          }
          walkNode(root);
        };
        walk.break = breakWalk;
        walk.skip = skipNode;
        walk.find = function (ast, fn) {
          let found = null;
          walk(ast, function (node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          });
          return found;
        };
        walk.findLast = function (ast, fn) {
          let found = null;
          walk(ast, {
            reverse: true,
            enter(node, item, list) {
              if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
              }
            },
          });
          return found;
        };
        walk.findAll = function (ast, fn) {
          const found = [];
          walk(ast, function (node, item, list) {
            if (fn.call(this, node, item, list)) {
              found.push(node);
            }
          });
          return found;
        };
        return walk;
      }
      exports.createWalker = createWalker;
    },
    2892: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const utils = __nccwpck_require__(4509);
      function cleanAtrule(node, item, list) {
        if (node.block) {
          if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
          }
          if (utils.hasNoChildren(node.block)) {
            list.remove(item);
            return;
          }
        }
        switch (node.name) {
          case "charset":
            if (utils.hasNoChildren(node.prelude)) {
              list.remove(item);
              return;
            }
            if (item.prev) {
              list.remove(item);
              return;
            }
            break;
          case "import":
            if (
              this.stylesheet === null ||
              !this.stylesheet.firstAtrulesAllowed
            ) {
              list.remove(item);
              return;
            }
            list.prevUntil(
              item.prev,
              function (rule) {
                if (rule.type === "Atrule") {
                  if (rule.name === "import" || rule.name === "charset") {
                    return;
                  }
                }
                this.root.firstAtrulesAllowed = false;
                list.remove(item);
                return true;
              },
              this,
            );
            break;
          default: {
            const name = cssTree.keyword(node.name).basename;
            if (
              name === "keyframes" ||
              name === "media" ||
              name === "supports"
            ) {
              if (
                utils.hasNoChildren(node.prelude) ||
                utils.hasNoChildren(node.block)
              ) {
                list.remove(item);
              }
            }
          }
        }
      }
      module.exports = cleanAtrule;
    },
    2104: (module) => {
      "use strict";
      function cleanComment(data, item, list) {
        list.remove(item);
      }
      module.exports = cleanComment;
    },
    3952: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      function cleanDeclartion(node, item, list) {
        if (node.value.children && node.value.children.isEmpty) {
          list.remove(item);
          return;
        }
        if (cssTree.property(node.property).custom) {
          if (/\S/.test(node.value.value)) {
            node.value.value = node.value.value.trim();
          }
        }
      }
      module.exports = cleanDeclartion;
    },
    4726: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const utils = __nccwpck_require__(4509);
      function cleanRaw(node, item, list) {
        if (
          utils.isNodeChildrenList(this.stylesheet, list) ||
          utils.isNodeChildrenList(this.block, list)
        ) {
          list.remove(item);
        }
      }
      module.exports = cleanRaw;
    },
    5463: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const utils = __nccwpck_require__(4509);
      const { hasOwnProperty } = Object.prototype;
      const skipUsageFilteringAtrule = new Set(["keyframes"]);
      function cleanUnused(selectorList, usageData) {
        selectorList.children.forEach((selector, item, list) => {
          let shouldRemove = false;
          cssTree.walk(selector, function (node) {
            if (this.selector === null || this.selector === selectorList) {
              switch (node.type) {
                case "SelectorList":
                  if (
                    this.function === null ||
                    this.function.name.toLowerCase() !== "not"
                  ) {
                    if (cleanUnused(node, usageData)) {
                      shouldRemove = true;
                    }
                  }
                  break;
                case "ClassSelector":
                  if (
                    usageData.whitelist !== null &&
                    usageData.whitelist.classes !== null &&
                    !hasOwnProperty.call(usageData.whitelist.classes, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  if (
                    usageData.blacklist !== null &&
                    usageData.blacklist.classes !== null &&
                    hasOwnProperty.call(usageData.blacklist.classes, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  break;
                case "IdSelector":
                  if (
                    usageData.whitelist !== null &&
                    usageData.whitelist.ids !== null &&
                    !hasOwnProperty.call(usageData.whitelist.ids, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  if (
                    usageData.blacklist !== null &&
                    usageData.blacklist.ids !== null &&
                    hasOwnProperty.call(usageData.blacklist.ids, node.name)
                  ) {
                    shouldRemove = true;
                  }
                  break;
                case "TypeSelector":
                  if (node.name.charAt(node.name.length - 1) !== "*") {
                    if (
                      usageData.whitelist !== null &&
                      usageData.whitelist.tags !== null &&
                      !hasOwnProperty.call(
                        usageData.whitelist.tags,
                        node.name.toLowerCase(),
                      )
                    ) {
                      shouldRemove = true;
                    }
                    if (
                      usageData.blacklist !== null &&
                      usageData.blacklist.tags !== null &&
                      hasOwnProperty.call(
                        usageData.blacklist.tags,
                        node.name.toLowerCase(),
                      )
                    ) {
                      shouldRemove = true;
                    }
                  }
                  break;
              }
            }
          });
          if (shouldRemove) {
            list.remove(item);
          }
        });
        return selectorList.children.isEmpty;
      }
      function cleanRule(node, item, list, options) {
        if (
          utils.hasNoChildren(node.prelude) ||
          utils.hasNoChildren(node.block)
        ) {
          list.remove(item);
          return;
        }
        if (
          this.atrule &&
          skipUsageFilteringAtrule.has(
            cssTree.keyword(this.atrule.name).basename,
          )
        ) {
          return;
        }
        const { usage } = options;
        if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
          cleanUnused(node.prelude, usage);
          if (utils.hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
          }
        }
      }
      module.exports = cleanRule;
    },
    1755: (module) => {
      "use strict";
      function cleanTypeSelector(node, item, list) {
        const name = item.data.name;
        if (name !== "*") {
          return;
        }
        const nextType = item.next && item.next.data.type;
        if (
          nextType === "IdSelector" ||
          nextType === "ClassSelector" ||
          nextType === "AttributeSelector" ||
          nextType === "PseudoClassSelector" ||
          nextType === "PseudoElementSelector"
        ) {
          list.remove(item);
        }
      }
      module.exports = cleanTypeSelector;
    },
    544: (module) => {
      "use strict";
      function cleanWhitespace(node, item, list) {
        list.remove(item);
      }
      module.exports = cleanWhitespace;
    },
    7489: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const Atrule = __nccwpck_require__(2892);
      const Comment = __nccwpck_require__(2104);
      const Declaration = __nccwpck_require__(3952);
      const Raw = __nccwpck_require__(4726);
      const Rule = __nccwpck_require__(5463);
      const TypeSelector = __nccwpck_require__(1755);
      const WhiteSpace = __nccwpck_require__(544);
      const handlers = {
        Atrule,
        Comment,
        Declaration,
        Raw,
        Rule,
        TypeSelector,
        WhiteSpace,
      };
      function clean(ast, options) {
        cssTree.walk(ast, {
          leave(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
              handlers[node.type].call(this, node, item, list, options);
            }
          },
        });
      }
      module.exports = clean;
    },
    4509: (__unused_webpack_module, exports) => {
      "use strict";
      function hasNoChildren(node) {
        return !node || !node.children || node.children.isEmpty;
      }
      function isNodeChildrenList(node, list) {
        return node !== null && node.children === list;
      }
      exports.hasNoChildren = hasNoChildren;
      exports.isNodeChildrenList = isNodeChildrenList;
    },
    5072: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const usage = __nccwpck_require__(2192);
      const index = __nccwpck_require__(7489);
      const index$1 = __nccwpck_require__(9436);
      const index$2 = __nccwpck_require__(618);
      function readChunk(input, specialComments) {
        const children = new cssTree.List();
        let nonSpaceTokenInBuffer = false;
        let protectedComment;
        input.nextUntil(input.head, (node, item, list) => {
          if (node.type === "Comment") {
            if (!specialComments || node.value.charAt(0) !== "!") {
              list.remove(item);
              return;
            }
            if (nonSpaceTokenInBuffer || protectedComment) {
              return true;
            }
            list.remove(item);
            protectedComment = node;
            return;
          }
          if (node.type !== "WhiteSpace") {
            nonSpaceTokenInBuffer = true;
          }
          children.insert(list.remove(item));
        });
        return {
          comment: protectedComment,
          stylesheet: { type: "StyleSheet", loc: null, children },
        };
      }
      function compressChunk(ast, firstAtrulesAllowed, num, options) {
        options.logger(`Compress block #${num}`, null, true);
        let seed = 1;
        if (ast.type === "StyleSheet") {
          ast.firstAtrulesAllowed = firstAtrulesAllowed;
          ast.id = seed++;
        }
        cssTree.walk(ast, {
          visit: "Atrule",
          enter(node) {
            if (node.block !== null) {
              node.block.id = seed++;
            }
          },
        });
        options.logger("init", ast);
        index(ast, options);
        options.logger("clean", ast);
        index$1(ast);
        options.logger("replace", ast);
        if (options.restructuring) {
          index$2(ast, options);
        }
        return ast;
      }
      function getCommentsOption(options) {
        let comments = "comments" in options ? options.comments : "exclamation";
        if (typeof comments === "boolean") {
          comments = comments ? "exclamation" : false;
        } else if (
          comments !== "exclamation" &&
          comments !== "first-exclamation"
        ) {
          comments = false;
        }
        return comments;
      }
      function getRestructureOption(options) {
        if ("restructure" in options) {
          return options.restructure;
        }
        return "restructuring" in options ? options.restructuring : true;
      }
      function wrapBlock(block) {
        return new cssTree.List().appendData({
          type: "Rule",
          loc: null,
          prelude: {
            type: "SelectorList",
            loc: null,
            children: new cssTree.List().appendData({
              type: "Selector",
              loc: null,
              children: new cssTree.List().appendData({
                type: "TypeSelector",
                loc: null,
                name: "x",
              }),
            }),
          },
          block,
        });
      }
      function compress(ast, options) {
        ast = ast || {
          type: "StyleSheet",
          loc: null,
          children: new cssTree.List(),
        };
        options = options || {};
        const compressOptions = {
          logger:
            typeof options.logger === "function"
              ? options.logger
              : function () {},
          restructuring: getRestructureOption(options),
          forceMediaMerge: Boolean(options.forceMediaMerge),
          usage: options.usage ? usage.buildIndex(options.usage) : false,
        };
        const output = new cssTree.List();
        let specialComments = getCommentsOption(options);
        let firstAtrulesAllowed = true;
        let input;
        let chunk;
        let chunkNum = 1;
        let chunkChildren;
        if (options.clone) {
          ast = cssTree.clone(ast);
        }
        if (ast.type === "StyleSheet") {
          input = ast.children;
          ast.children = output;
        } else {
          input = wrapBlock(ast);
        }
        do {
          chunk = readChunk(input, Boolean(specialComments));
          compressChunk(
            chunk.stylesheet,
            firstAtrulesAllowed,
            chunkNum++,
            compressOptions,
          );
          chunkChildren = chunk.stylesheet.children;
          if (chunk.comment) {
            if (!output.isEmpty) {
              output.insert(
                cssTree.List.createItem({ type: "Raw", value: "\n" }),
              );
            }
            output.insert(cssTree.List.createItem(chunk.comment));
            if (!chunkChildren.isEmpty) {
              output.insert(
                cssTree.List.createItem({ type: "Raw", value: "\n" }),
              );
            }
          }
          if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
            const lastRule = chunkChildren.last;
            if (
              lastRule.type !== "Atrule" ||
              (lastRule.name !== "import" && lastRule.name !== "charset")
            ) {
              firstAtrulesAllowed = false;
            }
          }
          if (specialComments !== "exclamation") {
            specialComments = false;
          }
          output.appendList(chunkChildren);
        } while (!input.isEmpty);
        return { ast };
      }
      module.exports = compress;
    },
    6846: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const version = __nccwpck_require__(2045);
      const syntax = __nccwpck_require__(3289);
      const utils = __nccwpck_require__(856);
      const { parse, generate, compress } = syntax;
      function debugOutput(name, options, startTime, data) {
        if (options.debug) {
          console.error(`## ${name} done in %d ms\n`, Date.now() - startTime);
        }
        return data;
      }
      function createDefaultLogger(level) {
        let lastDebug;
        return function logger(title, ast) {
          let line = title;
          if (ast) {
            line = `[${((Date.now() - lastDebug) / 1e3).toFixed(3)}s] ${line}`;
          }
          if (level > 1 && ast) {
            let css = generate(ast);
            if (level === 2 && css.length > 256) {
              css = css.substr(0, 256) + "...";
            }
            line += `\n  ${css}\n`;
          }
          console.error(line);
          lastDebug = Date.now();
        };
      }
      function buildCompressOptions(options) {
        options = { ...options };
        if (typeof options.logger !== "function" && options.debug) {
          options.logger = createDefaultLogger(options.debug);
        }
        return options;
      }
      function runHandler(ast, options, handlers) {
        if (!Array.isArray(handlers)) {
          handlers = [handlers];
        }
        handlers.forEach((fn) => fn(ast, options));
      }
      function minify(context, source, options) {
        options = options || {};
        const filename = options.filename || "<unknown>";
        let result;
        const ast = debugOutput(
          "parsing",
          options,
          Date.now(),
          parse(source, {
            context,
            filename,
            positions: Boolean(options.sourceMap),
          }),
        );
        if (options.beforeCompress) {
          debugOutput(
            "beforeCompress",
            options,
            Date.now(),
            runHandler(ast, options, options.beforeCompress),
          );
        }
        const compressResult = debugOutput(
          "compress",
          options,
          Date.now(),
          compress(ast, buildCompressOptions(options)),
        );
        if (options.afterCompress) {
          debugOutput(
            "afterCompress",
            options,
            Date.now(),
            runHandler(compressResult, options, options.afterCompress),
          );
        }
        if (options.sourceMap) {
          result = debugOutput(
            "generate(sourceMap: true)",
            options,
            Date.now(),
            (() => {
              const tmp = generate(compressResult.ast, { sourceMap: true });
              tmp.map._file = filename;
              tmp.map.setSourceContent(filename, source);
              return tmp;
            })(),
          );
        } else {
          result = debugOutput("generate", options, Date.now(), {
            css: generate(compressResult.ast),
            map: null,
          });
        }
        return result;
      }
      function minifyStylesheet(source, options) {
        return minify("stylesheet", source, options);
      }
      function minifyBlock(source, options) {
        return minify("declarationList", source, options);
      }
      exports.version = version.version;
      exports.syntax = syntax;
      exports.utils = utils;
      exports.minify = minifyStylesheet;
      exports.minifyBlock = minifyBlock;
    },
    3669: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const keyframes = __nccwpck_require__(1619);
      function Atrule(node) {
        if (cssTree.keyword(node.name).basename === "keyframes") {
          keyframes(node);
        }
      }
      module.exports = Atrule;
    },
    7622: (module) => {
      "use strict";
      const blockUnquoteRx =
        /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
      function canUnquote(value) {
        if (value === "" || value === "-") {
          return false;
        }
        return !blockUnquoteRx.test(value);
      }
      function AttributeSelector(node) {
        const attrValue = node.value;
        if (!attrValue || attrValue.type !== "String") {
          return;
        }
        if (canUnquote(attrValue.value)) {
          node.value = {
            type: "Identifier",
            loc: attrValue.loc,
            name: attrValue.value,
          };
        }
      }
      module.exports = AttributeSelector;
    },
    4234: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const _Number = __nccwpck_require__(8383);
      const MATH_FUNCTIONS = new Set(["calc", "min", "max", "clamp"]);
      const LENGTH_UNIT = new Set([
        "px",
        "mm",
        "cm",
        "in",
        "pt",
        "pc",
        "em",
        "ex",
        "ch",
        "rem",
        "vh",
        "vw",
        "vmin",
        "vmax",
        "vm",
      ]);
      function compressDimension(node, item) {
        const value = _Number.packNumber(node.value);
        node.value = value;
        if (
          value === "0" &&
          this.declaration !== null &&
          this.atrulePrelude === null
        ) {
          const unit = node.unit.toLowerCase();
          if (!LENGTH_UNIT.has(unit)) {
            return;
          }
          if (
            this.declaration.property === "-ms-flex" ||
            this.declaration.property === "flex"
          ) {
            return;
          }
          if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
            return;
          }
          item.data = { type: "Number", loc: node.loc, value };
        }
      }
      module.exports = compressDimension;
    },
    8383: (__unused_webpack_module, exports) => {
      "use strict";
      const OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
      const KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
      const unsafeToRemovePlusSignAfter = new Set([
        "Dimension",
        "Hash",
        "Identifier",
        "Number",
        "Raw",
        "UnicodeRange",
      ]);
      function packNumber(value, item) {
        const regexp =
          item &&
          item.prev !== null &&
          unsafeToRemovePlusSignAfter.has(item.prev.data.type)
            ? KEEP_PLUSSIGN
            : OMIT_PLUSSIGN;
        value = String(value).replace(regexp, "$1$2$3");
        if (value === "" || value === "-") {
          value = "0";
        }
        return value;
      }
      function Number(node) {
        node.value = packNumber(node.value);
      }
      exports.Number = Number;
      exports.packNumber = packNumber;
    },
    2596: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const _Number = __nccwpck_require__(8383);
      const blacklist = new Set([
        "width",
        "min-width",
        "max-width",
        "height",
        "min-height",
        "max-height",
        "flex",
        "-ms-flex",
      ]);
      function compressPercentage(node, item) {
        node.value = _Number.packNumber(node.value);
        if (
          node.value === "0" &&
          this.declaration &&
          !blacklist.has(this.declaration.property)
        ) {
          item.data = { type: "Number", loc: node.loc, value: node.value };
          if (
            !cssTree.lexer
              .matchDeclaration(this.declaration)
              .isType(item.data, "length")
          ) {
            item.data = node;
          }
        }
      }
      module.exports = compressPercentage;
    },
    8001: (module) => {
      "use strict";
      function Url(node) {
        node.value = node.value.replace(/\\/g, "/");
      }
      module.exports = Url;
    },
    8833: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const font = __nccwpck_require__(6442);
      const fontWeight = __nccwpck_require__(358);
      const background = __nccwpck_require__(7388);
      const border = __nccwpck_require__(2064);
      const handlers = {
        font,
        "font-weight": fontWeight,
        background,
        border,
        outline: border,
      };
      function compressValue(node) {
        if (!this.declaration) {
          return;
        }
        const property = cssTree.property(this.declaration.property);
        if (handlers.hasOwnProperty(property.basename)) {
          handlers[property.basename](node);
        }
      }
      module.exports = compressValue;
    },
    1619: (module) => {
      "use strict";
      function compressKeyframes(node) {
        node.block.children.forEach((rule) => {
          rule.prelude.children.forEach((simpleselector) => {
            simpleselector.children.forEach((data, item) => {
              if (data.type === "Percentage" && data.value === "100") {
                item.data = { type: "TypeSelector", loc: data.loc, name: "to" };
              } else if (data.type === "TypeSelector" && data.name === "from") {
                item.data = { type: "Percentage", loc: data.loc, value: "0" };
              }
            });
          });
        });
      }
      module.exports = compressKeyframes;
    },
    3914: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const _Number = __nccwpck_require__(8383);
      const NAME_TO_HEX = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgrey: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        grey: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "639",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32",
      };
      const HEX_TO_NAME = {
        8e5: "maroon",
        800080: "purple",
        808e3: "olive",
        808080: "gray",
        "00ffff": "cyan",
        f0ffff: "azure",
        f5f5dc: "beige",
        ffe4c4: "bisque",
        "000000": "black",
        "0000ff": "blue",
        a52a2a: "brown",
        ff7f50: "coral",
        ffd700: "gold",
        "008000": "green",
        "4b0082": "indigo",
        fffff0: "ivory",
        f0e68c: "khaki",
        "00ff00": "lime",
        faf0e6: "linen",
        "000080": "navy",
        ffa500: "orange",
        da70d6: "orchid",
        cd853f: "peru",
        ffc0cb: "pink",
        dda0dd: "plum",
        f00: "red",
        ff0000: "red",
        fa8072: "salmon",
        a0522d: "sienna",
        c0c0c0: "silver",
        fffafa: "snow",
        d2b48c: "tan",
        "008080": "teal",
        ff6347: "tomato",
        ee82ee: "violet",
        f5deb3: "wheat",
        ffffff: "white",
        ffff00: "yellow",
      };
      function hueToRgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      }
      function hslToRgb(h, s, l, a) {
        let r;
        let g;
        let b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hueToRgb(p, q, h + 1 / 3);
          g = hueToRgb(p, q, h);
          b = hueToRgb(p, q, h - 1 / 3);
        }
        return [
          Math.round(r * 255),
          Math.round(g * 255),
          Math.round(b * 255),
          a,
        ];
      }
      function toHex(value) {
        value = value.toString(16);
        return value.length === 1 ? "0" + value : value;
      }
      function parseFunctionArgs(functionArgs, count, rgb) {
        let cursor = functionArgs.head;
        let args = [];
        let wasValue = false;
        while (cursor !== null) {
          const { type, value } = cursor.data;
          switch (type) {
            case "Number":
            case "Percentage":
              if (wasValue) {
                return;
              }
              wasValue = true;
              args.push({ type, value: Number(value) });
              break;
            case "Operator":
              if (value === ",") {
                if (!wasValue) {
                  return;
                }
                wasValue = false;
              } else if (wasValue || value !== "+") {
                return;
              }
              break;
            default:
              return;
          }
          cursor = cursor.next;
        }
        if (args.length !== count) {
          return;
        }
        if (args.length === 4) {
          if (args[3].type !== "Number") {
            return;
          }
          args[3].type = "Alpha";
        }
        if (rgb) {
          if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            return;
          }
        } else {
          if (
            args[0].type !== "Number" ||
            args[1].type !== "Percentage" ||
            args[2].type !== "Percentage"
          ) {
            return;
          }
          args[0].type = "Angle";
        }
        return args.map(function (arg) {
          let value = Math.max(0, arg.value);
          switch (arg.type) {
            case "Number":
              value = Math.min(value, 255);
              break;
            case "Percentage":
              value = Math.min(value, 100) / 100;
              if (!rgb) {
                return value;
              }
              value = 255 * value;
              break;
            case "Angle":
              return (((value % 360) + 360) % 360) / 360;
            case "Alpha":
              return Math.min(value, 1);
          }
          return Math.round(value);
        });
      }
      function compressFunction(node, item) {
        let functionName = node.name;
        let args;
        if (functionName === "rgba" || functionName === "hsla") {
          args = parseFunctionArgs(node.children, 4, functionName === "rgba");
          if (!args) {
            return;
          }
          if (functionName === "hsla") {
            args = hslToRgb(...args);
            node.name = "rgba";
          }
          if (args[3] === 0) {
            const scopeFunctionName = this.function && this.function.name;
            if (
              (args[0] === 0 && args[1] === 0 && args[2] === 0) ||
              !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)
            ) {
              item.data = {
                type: "Identifier",
                loc: node.loc,
                name: "transparent",
              };
              return;
            }
          }
          if (args[3] !== 1) {
            node.children.forEach((node, item, list) => {
              if (node.type === "Operator") {
                if (node.value !== ",") {
                  list.remove(item);
                }
                return;
              }
              item.data = {
                type: "Number",
                loc: node.loc,
                value: _Number.packNumber(args.shift()),
              };
            });
            return;
          }
          functionName = "rgb";
        }
        if (functionName === "hsl") {
          args = args || parseFunctionArgs(node.children, 3, false);
          if (!args) {
            return;
          }
          args = hslToRgb(...args);
          functionName = "rgb";
        }
        if (functionName === "rgb") {
          args = args || parseFunctionArgs(node.children, 3, true);
          if (!args) {
            return;
          }
          item.data = {
            type: "Hash",
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2]),
          };
          compressHex(item.data, item);
        }
      }
      function compressIdent(node, item) {
        if (this.declaration === null) {
          return;
        }
        let color = node.name.toLowerCase();
        if (
          NAME_TO_HEX.hasOwnProperty(color) &&
          cssTree.lexer.matchDeclaration(this.declaration).isType(node, "color")
        ) {
          const hex = NAME_TO_HEX[color];
          if (hex.length + 1 <= color.length) {
            item.data = { type: "Hash", loc: node.loc, value: hex };
          } else {
            if (color === "grey") {
              color = "gray";
            }
            node.name = color;
          }
        }
      }
      function compressHex(node, item) {
        let color = node.value.toLowerCase();
        if (
          color.length === 6 &&
          color[0] === color[1] &&
          color[2] === color[3] &&
          color[4] === color[5]
        ) {
          color = color[0] + color[2] + color[4];
        }
        if (HEX_TO_NAME[color]) {
          item.data = {
            type: "Identifier",
            loc: node.loc,
            name: HEX_TO_NAME[color],
          };
        } else {
          node.value = color;
        }
      }
      exports.compressFunction = compressFunction;
      exports.compressHex = compressHex;
      exports.compressIdent = compressIdent;
    },
    9436: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const Atrule = __nccwpck_require__(3669);
      const AttributeSelector = __nccwpck_require__(7622);
      const Value = __nccwpck_require__(8833);
      const Dimension = __nccwpck_require__(4234);
      const Percentage = __nccwpck_require__(2596);
      const _Number = __nccwpck_require__(8383);
      const Url = __nccwpck_require__(8001);
      const color = __nccwpck_require__(3914);
      const handlers = {
        Atrule,
        AttributeSelector,
        Value,
        Dimension,
        Percentage,
        Number: _Number.Number,
        Url,
        Hash: color.compressHex,
        Identifier: color.compressIdent,
        Function: color.compressFunction,
      };
      function replace(ast) {
        cssTree.walk(ast, {
          leave(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
              handlers[node.type].call(this, node, item, list);
            }
          },
        });
      }
      module.exports = replace;
    },
    7388: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      function compressBackground(node) {
        function flush() {
          if (!buffer.length) {
            buffer.unshift(
              { type: "Number", loc: null, value: "0" },
              { type: "Number", loc: null, value: "0" },
            );
          }
          newValue.push.apply(newValue, buffer);
          buffer = [];
        }
        let newValue = [];
        let buffer = [];
        node.children.forEach((node) => {
          if (node.type === "Operator" && node.value === ",") {
            flush();
            newValue.push(node);
            return;
          }
          if (node.type === "Identifier") {
            if (
              node.name === "transparent" ||
              node.name === "none" ||
              node.name === "repeat" ||
              node.name === "scroll"
            ) {
              return;
            }
          }
          buffer.push(node);
        });
        flush();
        node.children = new cssTree.List().fromArray(newValue);
      }
      module.exports = compressBackground;
    },
    2064: (module) => {
      "use strict";
      function compressBorder(node) {
        node.children.forEach((node, item, list) => {
          if (
            node.type === "Identifier" &&
            node.name.toLowerCase() === "none"
          ) {
            if (list.head === list.tail) {
              item.data = { type: "Number", loc: node.loc, value: "0" };
            } else {
              list.remove(item);
            }
          }
        });
      }
      module.exports = compressBorder;
    },
    358: (module) => {
      "use strict";
      function compressFontWeight(node) {
        const value = node.children.head.data;
        if (value.type === "Identifier") {
          switch (value.name) {
            case "normal":
              node.children.head.data = {
                type: "Number",
                loc: value.loc,
                value: "400",
              };
              break;
            case "bold":
              node.children.head.data = {
                type: "Number",
                loc: value.loc,
                value: "700",
              };
              break;
          }
        }
      }
      module.exports = compressFontWeight;
    },
    6442: (module) => {
      "use strict";
      function compressFont(node) {
        const list = node.children;
        list.forEachRight(function (node, item) {
          if (node.type === "Identifier") {
            if (node.name === "bold") {
              item.data = { type: "Number", loc: node.loc, value: "700" };
            } else if (node.name === "normal") {
              const prev = item.prev;
              if (
                prev &&
                prev.data.type === "Operator" &&
                prev.data.value === "/"
              ) {
                this.remove(prev);
              }
              this.remove(item);
            }
          }
        });
        if (list.isEmpty) {
          list.insert(list.createItem({ type: "Identifier", name: "normal" }));
        }
      }
      module.exports = compressFont;
    },
    8618: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const { hasOwnProperty } = Object.prototype;
      function addRuleToMap(map, item, list, single) {
        const node = item.data;
        const name = cssTree.keyword(node.name).basename;
        const id =
          node.name.toLowerCase() +
          "/" +
          (node.prelude ? node.prelude.id : null);
        if (!hasOwnProperty.call(map, name)) {
          map[name] = Object.create(null);
        }
        if (single) {
          delete map[name][id];
        }
        if (!hasOwnProperty.call(map[name], id)) {
          map[name][id] = new cssTree.List();
        }
        map[name][id].append(list.remove(item));
      }
      function relocateAtrules(ast, options) {
        const collected = Object.create(null);
        let topInjectPoint = null;
        ast.children.forEach(function (node, item, list) {
          if (node.type === "Atrule") {
            const name = cssTree.keyword(node.name).basename;
            switch (name) {
              case "keyframes":
                addRuleToMap(collected, item, list, true);
                return;
              case "media":
                if (options.forceMediaMerge) {
                  addRuleToMap(collected, item, list, false);
                  return;
                }
                break;
            }
            if (
              topInjectPoint === null &&
              name !== "charset" &&
              name !== "import"
            ) {
              topInjectPoint = item;
            }
          } else {
            if (topInjectPoint === null) {
              topInjectPoint = item;
            }
          }
        });
        for (const atrule in collected) {
          for (const id in collected[atrule]) {
            ast.children.insertList(
              collected[atrule][id],
              atrule === "media" ? null : topInjectPoint,
            );
          }
        }
      }
      function isMediaRule(node) {
        return node.type === "Atrule" && node.name === "media";
      }
      function processAtrule(node, item, list) {
        if (!isMediaRule(node)) {
          return;
        }
        const prev = item.prev && item.prev.data;
        if (!prev || !isMediaRule(prev)) {
          return;
        }
        if (
          node.prelude &&
          prev.prelude &&
          node.prelude.id === prev.prelude.id
        ) {
          prev.block.children.appendList(node.block.children);
          list.remove(item);
        }
      }
      function rejoinAtrule(ast, options) {
        relocateAtrules(ast, options);
        cssTree.walk(ast, {
          visit: "Atrule",
          reverse: true,
          enter: processAtrule,
        });
      }
      module.exports = rejoinAtrule;
    },
    9580: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const utils = __nccwpck_require__(1710);
      function processRule(node, item, list) {
        const selectors = node.prelude.children;
        const declarations = node.block.children;
        list.prevUntil(item.prev, function (prev) {
          if (prev.type !== "Rule") {
            return utils.unsafeToSkipNode.call(selectors, prev);
          }
          const prevSelectors = prev.prelude.children;
          const prevDeclarations = prev.block.children;
          if (node.pseudoSignature === prev.pseudoSignature) {
            if (utils.isEqualSelectors(prevSelectors, selectors)) {
              prevDeclarations.appendList(declarations);
              list.remove(item);
              return true;
            }
            if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
              utils.addSelectors(prevSelectors, selectors);
              list.remove(item);
              return true;
            }
          }
          return utils.hasSimilarSelectors(selectors, prevSelectors);
        });
      }
      function initialMergeRule(ast) {
        cssTree.walk(ast, { visit: "Rule", enter: processRule });
      }
      module.exports = initialMergeRule;
    },
    2506: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      function processRule(node, item, list) {
        const selectors = node.prelude.children;
        while (selectors.head !== selectors.tail) {
          const newSelectors = new cssTree.List();
          newSelectors.insert(selectors.remove(selectors.head));
          list.insert(
            list.createItem({
              type: "Rule",
              loc: node.loc,
              prelude: {
                type: "SelectorList",
                loc: node.prelude.loc,
                children: newSelectors,
              },
              block: {
                type: "Block",
                loc: node.block.loc,
                children: node.block.children.copy(),
              },
              pseudoSignature: node.pseudoSignature,
            }),
            item,
          );
        }
      }
      function disjoinRule(ast) {
        cssTree.walk(ast, { visit: "Rule", reverse: true, enter: processRule });
      }
      module.exports = disjoinRule;
    },
    9944: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const REPLACE = 1;
      const REMOVE = 2;
      const TOP = 0;
      const RIGHT = 1;
      const BOTTOM = 2;
      const LEFT = 3;
      const SIDES = ["top", "right", "bottom", "left"];
      const SIDE = {
        "margin-top": "top",
        "margin-right": "right",
        "margin-bottom": "bottom",
        "margin-left": "left",
        "padding-top": "top",
        "padding-right": "right",
        "padding-bottom": "bottom",
        "padding-left": "left",
        "border-top-color": "top",
        "border-right-color": "right",
        "border-bottom-color": "bottom",
        "border-left-color": "left",
        "border-top-width": "top",
        "border-right-width": "right",
        "border-bottom-width": "bottom",
        "border-left-width": "left",
        "border-top-style": "top",
        "border-right-style": "right",
        "border-bottom-style": "bottom",
        "border-left-style": "left",
      };
      const MAIN_PROPERTY = {
        margin: "margin",
        "margin-top": "margin",
        "margin-right": "margin",
        "margin-bottom": "margin",
        "margin-left": "margin",
        padding: "padding",
        "padding-top": "padding",
        "padding-right": "padding",
        "padding-bottom": "padding",
        "padding-left": "padding",
        "border-color": "border-color",
        "border-top-color": "border-color",
        "border-right-color": "border-color",
        "border-bottom-color": "border-color",
        "border-left-color": "border-color",
        "border-width": "border-width",
        "border-top-width": "border-width",
        "border-right-width": "border-width",
        "border-bottom-width": "border-width",
        "border-left-width": "border-width",
        "border-style": "border-style",
        "border-top-style": "border-style",
        "border-right-style": "border-style",
        "border-bottom-style": "border-style",
        "border-left-style": "border-style",
      };
      class TRBL {
        constructor(name) {
          this.name = name;
          this.loc = null;
          this.iehack = undefined;
          this.sides = { top: null, right: null, bottom: null, left: null };
        }
        getValueSequence(declaration, count) {
          const values = [];
          let iehack = "";
          const hasBadValues =
            declaration.value.type !== "Value" ||
            declaration.value.children.some(function (child) {
              let special = false;
              switch (child.type) {
                case "Identifier":
                  switch (child.name) {
                    case "\\0":
                    case "\\9":
                      iehack = child.name;
                      return;
                    case "inherit":
                    case "initial":
                    case "unset":
                    case "revert":
                      special = child.name;
                      break;
                  }
                  break;
                case "Dimension":
                  switch (child.unit) {
                    case "rem":
                    case "vw":
                    case "vh":
                    case "vmin":
                    case "vmax":
                    case "vm":
                      special = child.unit;
                      break;
                  }
                  break;
                case "Hash":
                case "Number":
                case "Percentage":
                  break;
                case "Function":
                  if (child.name === "var") {
                    return true;
                  }
                  special = child.name;
                  break;
                default:
                  return true;
              }
              values.push({
                node: child,
                special,
                important: declaration.important,
              });
            });
          if (hasBadValues || values.length > count) {
            return false;
          }
          if (typeof this.iehack === "string" && this.iehack !== iehack) {
            return false;
          }
          this.iehack = iehack;
          return values;
        }
        canOverride(side, value) {
          const currentValue = this.sides[side];
          return !currentValue || (value.important && !currentValue.important);
        }
        add(name, declaration) {
          function attemptToAdd() {
            const sides = this.sides;
            const side = SIDE[name];
            if (side) {
              if (side in sides === false) {
                return false;
              }
              const values = this.getValueSequence(declaration, 1);
              if (!values || !values.length) {
                return false;
              }
              for (const key in sides) {
                if (
                  sides[key] !== null &&
                  sides[key].special !== values[0].special
                ) {
                  return false;
                }
              }
              if (!this.canOverride(side, values[0])) {
                return true;
              }
              sides[side] = values[0];
              return true;
            } else if (name === this.name) {
              const values = this.getValueSequence(declaration, 4);
              if (!values || !values.length) {
                return false;
              }
              switch (values.length) {
                case 1:
                  values[RIGHT] = values[TOP];
                  values[BOTTOM] = values[TOP];
                  values[LEFT] = values[TOP];
                  break;
                case 2:
                  values[BOTTOM] = values[TOP];
                  values[LEFT] = values[RIGHT];
                  break;
                case 3:
                  values[LEFT] = values[RIGHT];
                  break;
              }
              for (let i = 0; i < 4; i++) {
                for (const key in sides) {
                  if (
                    sides[key] !== null &&
                    sides[key].special !== values[i].special
                  ) {
                    return false;
                  }
                }
              }
              for (let i = 0; i < 4; i++) {
                if (this.canOverride(SIDES[i], values[i])) {
                  sides[SIDES[i]] = values[i];
                }
              }
              return true;
            }
          }
          if (!attemptToAdd.call(this)) {
            return false;
          }
          if (!this.loc) {
            this.loc = declaration.loc;
          }
          return true;
        }
        isOkToMinimize() {
          const top = this.sides.top;
          const right = this.sides.right;
          const bottom = this.sides.bottom;
          const left = this.sides.left;
          if (top && right && bottom && left) {
            const important =
              top.important +
              right.important +
              bottom.important +
              left.important;
            return important === 0 || important === 4;
          }
          return false;
        }
        getValue() {
          const result = new cssTree.List();
          const sides = this.sides;
          const values = [sides.top, sides.right, sides.bottom, sides.left];
          const stringValues = [
            cssTree.generate(sides.top.node),
            cssTree.generate(sides.right.node),
            cssTree.generate(sides.bottom.node),
            cssTree.generate(sides.left.node),
          ];
          if (stringValues[LEFT] === stringValues[RIGHT]) {
            values.pop();
            if (stringValues[BOTTOM] === stringValues[TOP]) {
              values.pop();
              if (stringValues[RIGHT] === stringValues[TOP]) {
                values.pop();
              }
            }
          }
          for (let i = 0; i < values.length; i++) {
            result.appendData(values[i].node);
          }
          if (this.iehack) {
            result.appendData({
              type: "Identifier",
              loc: null,
              name: this.iehack,
            });
          }
          return { type: "Value", loc: null, children: result };
        }
        getDeclaration() {
          return {
            type: "Declaration",
            loc: this.loc,
            important: this.sides.top.important,
            property: this.name,
            value: this.getValue(),
          };
        }
      }
      function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
        const declarations = rule.block.children;
        const selector = rule.prelude.children.first.id;
        rule.block.children.forEachRight(function (declaration, item) {
          const property = declaration.property;
          if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
          }
          const key = MAIN_PROPERTY[property];
          let shorthand;
          let operation;
          if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
              operation = REMOVE;
              shorthand = shorts[key];
            }
          }
          if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);
            if (!shorthand.add(property, declaration)) {
              lastShortSelector = null;
              return;
            }
          }
          shorts[key] = shorthand;
          shortDeclarations.push({
            operation,
            block: declarations,
            item,
            shorthand,
          });
          lastShortSelector = selector;
        });
        return lastShortSelector;
      }
      function processShorthands(shortDeclarations, markDeclaration) {
        shortDeclarations.forEach(function (item) {
          const shorthand = item.shorthand;
          if (!shorthand.isOkToMinimize()) {
            return;
          }
          if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
          } else {
            item.block.remove(item.item);
          }
        });
      }
      function restructBlock(ast, indexer) {
        const stylesheetMap = {};
        const shortDeclarations = [];
        cssTree.walk(ast, {
          visit: "Rule",
          reverse: true,
          enter(node) {
            const stylesheet = this.block || this.stylesheet;
            const ruleId =
              (node.pseudoSignature || "") +
              "|" +
              node.prelude.children.first.id;
            let ruleMap;
            let shorts;
            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
              ruleMap = { lastShortSelector: null };
              stylesheetMap[stylesheet.id] = ruleMap;
            } else {
              ruleMap = stylesheetMap[stylesheet.id];
            }
            if (ruleMap.hasOwnProperty(ruleId)) {
              shorts = ruleMap[ruleId];
            } else {
              shorts = {};
              ruleMap[ruleId] = shorts;
            }
            ruleMap.lastShortSelector = processRule.call(
              this,
              node,
              shorts,
              shortDeclarations,
              ruleMap.lastShortSelector,
            );
          },
        });
        processShorthands(shortDeclarations, indexer.declaration);
      }
      module.exports = restructBlock;
    },
    8228: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      let fingerprintId = 1;
      const dontRestructure = new Set(["src"]);
      const DONT_MIX_VALUE = {
        display: /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
        "text-align": /^(start|end|match-parent|justify-all)$/i,
      };
      const SAFE_VALUES = {
        cursor: [
          "auto",
          "crosshair",
          "default",
          "move",
          "text",
          "wait",
          "help",
          "n-resize",
          "e-resize",
          "s-resize",
          "w-resize",
          "ne-resize",
          "nw-resize",
          "se-resize",
          "sw-resize",
          "pointer",
          "progress",
          "not-allowed",
          "no-drop",
          "vertical-text",
          "all-scroll",
          "col-resize",
          "row-resize",
        ],
        overflow: ["hidden", "visible", "scroll", "auto"],
        position: ["static", "relative", "absolute", "fixed"],
      };
      const NEEDLESS_TABLE = {
        "border-width": ["border"],
        "border-style": ["border"],
        "border-color": ["border"],
        "border-top": ["border"],
        "border-right": ["border"],
        "border-bottom": ["border"],
        "border-left": ["border"],
        "border-top-width": ["border-top", "border-width", "border"],
        "border-right-width": ["border-right", "border-width", "border"],
        "border-bottom-width": ["border-bottom", "border-width", "border"],
        "border-left-width": ["border-left", "border-width", "border"],
        "border-top-style": ["border-top", "border-style", "border"],
        "border-right-style": ["border-right", "border-style", "border"],
        "border-bottom-style": ["border-bottom", "border-style", "border"],
        "border-left-style": ["border-left", "border-style", "border"],
        "border-top-color": ["border-top", "border-color", "border"],
        "border-right-color": ["border-right", "border-color", "border"],
        "border-bottom-color": ["border-bottom", "border-color", "border"],
        "border-left-color": ["border-left", "border-color", "border"],
        "margin-top": ["margin"],
        "margin-right": ["margin"],
        "margin-bottom": ["margin"],
        "margin-left": ["margin"],
        "padding-top": ["padding"],
        "padding-right": ["padding"],
        "padding-bottom": ["padding"],
        "padding-left": ["padding"],
        "font-style": ["font"],
        "font-variant": ["font"],
        "font-weight": ["font"],
        "font-size": ["font"],
        "font-family": ["font"],
        "list-style-type": ["list-style"],
        "list-style-position": ["list-style"],
        "list-style-image": ["list-style"],
      };
      function getPropertyFingerprint(propertyName, declaration, fingerprints) {
        const realName = cssTree.property(propertyName).basename;
        if (realName === "background") {
          return propertyName + ":" + cssTree.generate(declaration.value);
        }
        const declarationId = declaration.id;
        let fingerprint = fingerprints[declarationId];
        if (!fingerprint) {
          switch (declaration.value.type) {
            case "Value":
              const special = {};
              let vendorId = "";
              let iehack = "";
              let raw = false;
              declaration.value.children.forEach(function walk(node) {
                switch (node.type) {
                  case "Value":
                  case "Brackets":
                  case "Parentheses":
                    node.children.forEach(walk);
                    break;
                  case "Raw":
                    raw = true;
                    break;
                  case "Identifier": {
                    const { name } = node;
                    if (!vendorId) {
                      vendorId = cssTree.keyword(name).vendor;
                    }
                    if (/\\[09]/.test(name)) {
                      iehack = RegExp.lastMatch;
                    }
                    if (SAFE_VALUES.hasOwnProperty(realName)) {
                      if (SAFE_VALUES[realName].indexOf(name) === -1) {
                        special[name] = true;
                      }
                    } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                      if (DONT_MIX_VALUE[realName].test(name)) {
                        special[name] = true;
                      }
                    }
                    break;
                  }
                  case "Function": {
                    let { name } = node;
                    if (!vendorId) {
                      vendorId = cssTree.keyword(name).vendor;
                    }
                    if (name === "rect") {
                      const hasComma = node.children.some(
                        (node) =>
                          node.type === "Operator" && node.value === ",",
                      );
                      if (!hasComma) {
                        name = "rect-backward";
                      }
                    }
                    special[name + "()"] = true;
                    node.children.forEach(walk);
                    break;
                  }
                  case "Dimension": {
                    const { unit } = node;
                    if (/\\[09]/.test(unit)) {
                      iehack = RegExp.lastMatch;
                    }
                    switch (unit) {
                      case "rem":
                      case "vw":
                      case "vh":
                      case "vmin":
                      case "vmax":
                      case "vm":
                        special[unit] = true;
                        break;
                    }
                    break;
                  }
                }
              });
              fingerprint = raw
                ? "!" + fingerprintId++
                : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
              break;
            case "Raw":
              fingerprint = "!" + declaration.value.value;
              break;
            default:
              fingerprint = cssTree.generate(declaration.value);
          }
          fingerprints[declarationId] = fingerprint;
        }
        return propertyName + fingerprint;
      }
      function needless(props, declaration, fingerprints) {
        const property = cssTree.property(declaration.property);
        if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
          const table = NEEDLESS_TABLE[property.basename];
          for (const entry of table) {
            const ppre = getPropertyFingerprint(
              property.prefix + entry,
              declaration,
              fingerprints,
            );
            const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
            if (prev && (!declaration.important || prev.item.data.important)) {
              return prev;
            }
          }
        }
      }
      function processRule(rule, item, list, props, fingerprints) {
        const declarations = rule.block.children;
        declarations.forEachRight(function (declaration, declarationItem) {
          const { property } = declaration;
          const fingerprint = getPropertyFingerprint(
            property,
            declaration,
            fingerprints,
          );
          const prev = props[fingerprint];
          if (prev && !dontRestructure.has(property)) {
            if (declaration.important && !prev.item.data.important) {
              props[fingerprint] = {
                block: declarations,
                item: declarationItem,
              };
              prev.block.remove(prev.item);
            } else {
              declarations.remove(declarationItem);
            }
          } else {
            const prev = needless(props, declaration, fingerprints);
            if (prev) {
              declarations.remove(declarationItem);
            } else {
              declaration.fingerprint = fingerprint;
              props[fingerprint] = {
                block: declarations,
                item: declarationItem,
              };
            }
          }
        });
        if (declarations.isEmpty) {
          list.remove(item);
        }
      }
      function restructBlock(ast) {
        const stylesheetMap = {};
        const fingerprints = Object.create(null);
        cssTree.walk(ast, {
          visit: "Rule",
          reverse: true,
          enter(node, item, list) {
            const stylesheet = this.block || this.stylesheet;
            const ruleId =
              (node.pseudoSignature || "") +
              "|" +
              node.prelude.children.first.id;
            let ruleMap;
            let props;
            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
              ruleMap = {};
              stylesheetMap[stylesheet.id] = ruleMap;
            } else {
              ruleMap = stylesheetMap[stylesheet.id];
            }
            if (ruleMap.hasOwnProperty(ruleId)) {
              props = ruleMap[ruleId];
            } else {
              props = {};
              ruleMap[ruleId] = props;
            }
            processRule.call(this, node, item, list, props, fingerprints);
          },
        });
      }
      module.exports = restructBlock;
    },
    4678: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const utils = __nccwpck_require__(1710);
      function processRule(node, item, list) {
        const selectors = node.prelude.children;
        const declarations = node.block.children;
        const nodeCompareMarker = selectors.first.compareMarker;
        const skippedCompareMarkers = {};
        list.nextUntil(item.next, function (next, nextItem) {
          if (next.type !== "Rule") {
            return utils.unsafeToSkipNode.call(selectors, next);
          }
          if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
          }
          const nextFirstSelector = next.prelude.children.head;
          const nextDeclarations = next.block.children;
          const nextCompareMarker = nextFirstSelector.data.compareMarker;
          if (nextCompareMarker in skippedCompareMarkers) {
            return true;
          }
          if (selectors.head === selectors.tail) {
            if (selectors.first.id === nextFirstSelector.data.id) {
              declarations.appendList(nextDeclarations);
              list.remove(nextItem);
              return;
            }
          }
          if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
            const nextStr = nextFirstSelector.data.id;
            selectors.some((data, item) => {
              const curStr = data.id;
              if (nextStr < curStr) {
                selectors.insert(nextFirstSelector, item);
                return true;
              }
              if (!item.next) {
                selectors.insert(nextFirstSelector);
                return true;
              }
            });
            list.remove(nextItem);
            return;
          }
          if (nextCompareMarker === nodeCompareMarker) {
            return true;
          }
          skippedCompareMarkers[nextCompareMarker] = true;
        });
      }
      function mergeRule(ast) {
        cssTree.walk(ast, { visit: "Rule", enter: processRule });
      }
      module.exports = mergeRule;
    },
    5423: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const utils = __nccwpck_require__(1710);
      function calcSelectorLength(list) {
        return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
      }
      function calcDeclarationsLength(tokens) {
        let length = 0;
        for (const token of tokens) {
          length += token.length;
        }
        return length + tokens.length - 1;
      }
      function processRule(node, item, list) {
        const avoidRulesMerge =
          this.block !== null ? this.block.avoidRulesMerge : false;
        const selectors = node.prelude.children;
        const block = node.block;
        const disallowDownMarkers = Object.create(null);
        let allowMergeUp = true;
        let allowMergeDown = true;
        list.prevUntil(item.prev, function (prev, prevItem) {
          const prevBlock = prev.block;
          const prevType = prev.type;
          if (prevType !== "Rule") {
            const unsafe = utils.unsafeToSkipNode.call(selectors, prev);
            if (!unsafe && prevType === "Atrule" && prevBlock) {
              cssTree.walk(prevBlock, {
                visit: "Rule",
                enter(node) {
                  node.prelude.children.forEach((data) => {
                    disallowDownMarkers[data.compareMarker] = true;
                  });
                },
              });
            }
            return unsafe;
          }
          if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
          }
          const prevSelectors = prev.prelude.children;
          allowMergeDown = !prevSelectors.some(
            (selector) => selector.compareMarker in disallowDownMarkers,
          );
          if (!allowMergeDown && !allowMergeUp) {
            return true;
          }
          if (
            allowMergeUp &&
            utils.isEqualSelectors(prevSelectors, selectors)
          ) {
            prevBlock.children.appendList(block.children);
            list.remove(item);
            return true;
          }
          const diff = utils.compareDeclarations(
            block.children,
            prevBlock.children,
          );
          if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
              if (allowMergeDown) {
                utils.addSelectors(selectors, prevSelectors);
                list.remove(prevItem);
              }
              return true;
            } else if (!avoidRulesMerge) {
              if (diff.ne1.length && !diff.ne2.length) {
                const selectorLength = calcSelectorLength(selectors);
                const blockLength = calcDeclarationsLength(diff.eq);
                if (allowMergeUp && selectorLength < blockLength) {
                  utils.addSelectors(prevSelectors, selectors);
                  block.children.fromArray(diff.ne1);
                }
              } else if (!diff.ne1.length && diff.ne2.length) {
                const selectorLength = calcSelectorLength(prevSelectors);
                const blockLength = calcDeclarationsLength(diff.eq);
                if (allowMergeDown && selectorLength < blockLength) {
                  utils.addSelectors(selectors, prevSelectors);
                  prevBlock.children.fromArray(diff.ne2);
                }
              } else {
                const newSelector = {
                  type: "SelectorList",
                  loc: null,
                  children: utils.addSelectors(prevSelectors.copy(), selectors),
                };
                const newBlockLength =
                  calcSelectorLength(newSelector.children) + 2;
                const blockLength = calcDeclarationsLength(diff.eq);
                if (blockLength >= newBlockLength) {
                  const newItem = list.createItem({
                    type: "Rule",
                    loc: null,
                    prelude: newSelector,
                    block: {
                      type: "Block",
                      loc: null,
                      children: new cssTree.List().fromArray(diff.eq),
                    },
                    pseudoSignature: node.pseudoSignature,
                  });
                  block.children.fromArray(diff.ne1);
                  prevBlock.children.fromArray(diff.ne2overrided);
                  if (allowMergeUp) {
                    list.insert(newItem, prevItem);
                  } else {
                    list.insert(newItem, item);
                  }
                  return true;
                }
              }
            }
          }
          if (allowMergeUp) {
            allowMergeUp = !prevSelectors.some((prevSelector) =>
              selectors.some(
                (selector) =>
                  selector.compareMarker === prevSelector.compareMarker,
              ),
            );
          }
          prevSelectors.forEach((data) => {
            disallowDownMarkers[data.compareMarker] = true;
          });
        });
      }
      function restructRule(ast) {
        cssTree.walk(ast, { visit: "Rule", reverse: true, enter: processRule });
      }
      module.exports = restructRule;
    },
    618: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const index = __nccwpck_require__(8692);
      const _1MergeAtrule = __nccwpck_require__(8618);
      const _2InitialMergeRuleset = __nccwpck_require__(9580);
      const _3DisjoinRuleset = __nccwpck_require__(2506);
      const _4RestructShorthand = __nccwpck_require__(9944);
      const _6RestructBlock = __nccwpck_require__(8228);
      const _7MergeRuleset = __nccwpck_require__(4678);
      const _8RestructRuleset = __nccwpck_require__(5423);
      function restructure(ast, options) {
        const indexer = index(ast, options);
        options.logger("prepare", ast);
        _1MergeAtrule(ast, options);
        options.logger("mergeAtrule", ast);
        _2InitialMergeRuleset(ast);
        options.logger("initialMergeRuleset", ast);
        _3DisjoinRuleset(ast);
        options.logger("disjoinRuleset", ast);
        _4RestructShorthand(ast, indexer);
        options.logger("restructShorthand", ast);
        _6RestructBlock(ast);
        options.logger("restructBlock", ast);
        _7MergeRuleset(ast);
        options.logger("mergeRuleset", ast);
        _8RestructRuleset(ast);
        options.logger("restructRuleset", ast);
      }
      module.exports = restructure;
    },
    5225: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      class Index {
        constructor() {
          this.map = new Map();
        }
        resolve(str) {
          let index = this.map.get(str);
          if (index === undefined) {
            index = this.map.size + 1;
            this.map.set(str, index);
          }
          return index;
        }
      }
      function createDeclarationIndexer() {
        const ids = new Index();
        return function markDeclaration(node) {
          const id = cssTree.generate(node);
          node.id = ids.resolve(id);
          node.length = id.length;
          node.fingerprint = null;
          return node;
        };
      }
      module.exports = createDeclarationIndexer;
    },
    8692: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const createDeclarationIndexer = __nccwpck_require__(5225);
      const processSelector = __nccwpck_require__(6944);
      function prepare(ast, options) {
        const markDeclaration = createDeclarationIndexer();
        cssTree.walk(ast, {
          visit: "Rule",
          enter(node) {
            node.block.children.forEach(markDeclaration);
            processSelector(node, options.usage);
          },
        });
        cssTree.walk(ast, {
          visit: "Atrule",
          enter(node) {
            if (node.prelude) {
              node.prelude.id = null;
              node.prelude.id = cssTree.generate(node.prelude);
            }
            if (cssTree.keyword(node.name).basename === "keyframes") {
              node.block.avoidRulesMerge = true;
              node.block.children.forEach(function (rule) {
                rule.prelude.children.forEach(function (simpleselector) {
                  simpleselector.compareMarker = simpleselector.id;
                });
              });
            }
          },
        });
        return { declaration: markDeclaration };
      }
      module.exports = prepare;
    },
    6944: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const specificity = __nccwpck_require__(5915);
      const nonFreezePseudoElements = new Set([
        "first-letter",
        "first-line",
        "after",
        "before",
      ]);
      const nonFreezePseudoClasses = new Set([
        "link",
        "visited",
        "hover",
        "active",
        "first-letter",
        "first-line",
        "after",
        "before",
      ]);
      function processSelector(node, usageData) {
        const pseudos = new Set();
        node.prelude.children.forEach(function (simpleSelector) {
          let tagName = "*";
          let scope = 0;
          simpleSelector.children.forEach(function (node) {
            switch (node.type) {
              case "ClassSelector":
                if (usageData && usageData.scopes) {
                  const classScope = usageData.scopes[node.name] || 0;
                  if (scope !== 0 && classScope !== scope) {
                    throw new Error(
                      "Selector can't has classes from different scopes: " +
                        cssTree.generate(simpleSelector),
                    );
                  }
                  scope = classScope;
                }
                break;
              case "PseudoClassSelector": {
                const name = node.name.toLowerCase();
                if (!nonFreezePseudoClasses.has(name)) {
                  pseudos.add(`:${name}`);
                }
                break;
              }
              case "PseudoElementSelector": {
                const name = node.name.toLowerCase();
                if (!nonFreezePseudoElements.has(name)) {
                  pseudos.add(`::${name}`);
                }
                break;
              }
              case "TypeSelector":
                tagName = node.name.toLowerCase();
                break;
              case "AttributeSelector":
                if (node.flags) {
                  pseudos.add(`[${node.flags.toLowerCase()}]`);
                }
                break;
              case "Combinator":
                tagName = "*";
                break;
            }
          });
          simpleSelector.compareMarker = specificity(simpleSelector).toString();
          simpleSelector.id = null;
          simpleSelector.id = cssTree.generate(simpleSelector);
          if (scope) {
            simpleSelector.compareMarker += ":" + scope;
          }
          if (tagName !== "*") {
            simpleSelector.compareMarker += "," + tagName;
          }
        });
        node.pseudoSignature =
          pseudos.size > 0 ? [...pseudos].sort().join(",") : false;
      }
      module.exports = processSelector;
    },
    5915: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      function ensureSelectorList(node) {
        if (node.type === "Raw") {
          return cssTree.parse(node.value, { context: "selectorList" });
        }
        return node;
      }
      function maxSpecificity(a, b) {
        for (let i = 0; i < 3; i++) {
          if (a[i] !== b[i]) {
            return a[i] > b[i] ? a : b;
          }
        }
        return a;
      }
      function maxSelectorListSpecificity(selectorList) {
        return ensureSelectorList(selectorList).children.reduce(
          (result, node) => maxSpecificity(specificity(node), result),
          [0, 0, 0],
        );
      }
      function specificity(simpleSelector) {
        let A = 0;
        let B = 0;
        let C = 0;
        simpleSelector.children.forEach((node) => {
          switch (node.type) {
            case "IdSelector":
              A++;
              break;
            case "ClassSelector":
            case "AttributeSelector":
              B++;
              break;
            case "PseudoClassSelector":
              switch (node.name.toLowerCase()) {
                case "not":
                case "has":
                case "is":
                case "matches":
                case "-webkit-any":
                case "-moz-any": {
                  const [a, b, c] = maxSelectorListSpecificity(
                    node.children.first,
                  );
                  A += a;
                  B += b;
                  C += c;
                  break;
                }
                case "nth-child":
                case "nth-last-child": {
                  const arg = node.children.first;
                  if (arg.type === "Nth" && arg.selector) {
                    const [a, b, c] = maxSelectorListSpecificity(arg.selector);
                    A += a;
                    B += b + 1;
                    C += c;
                  } else {
                    B++;
                  }
                  break;
                }
                case "where":
                  break;
                case "before":
                case "after":
                case "first-line":
                case "first-letter":
                  C++;
                  break;
                default:
                  B++;
              }
              break;
            case "TypeSelector":
              if (!node.name.endsWith("*")) {
                C++;
              }
              break;
            case "PseudoElementSelector":
              C++;
              break;
          }
        });
        return [A, B, C];
      }
      module.exports = specificity;
    },
    1710: (__unused_webpack_module, exports) => {
      "use strict";
      const { hasOwnProperty } = Object.prototype;
      function isEqualSelectors(a, b) {
        let cursor1 = a.head;
        let cursor2 = b.head;
        while (
          cursor1 !== null &&
          cursor2 !== null &&
          cursor1.data.id === cursor2.data.id
        ) {
          cursor1 = cursor1.next;
          cursor2 = cursor2.next;
        }
        return cursor1 === null && cursor2 === null;
      }
      function isEqualDeclarations(a, b) {
        let cursor1 = a.head;
        let cursor2 = b.head;
        while (
          cursor1 !== null &&
          cursor2 !== null &&
          cursor1.data.id === cursor2.data.id
        ) {
          cursor1 = cursor1.next;
          cursor2 = cursor2.next;
        }
        return cursor1 === null && cursor2 === null;
      }
      function compareDeclarations(declarations1, declarations2) {
        const result = { eq: [], ne1: [], ne2: [], ne2overrided: [] };
        const fingerprints = Object.create(null);
        const declarations2hash = Object.create(null);
        for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
          declarations2hash[cursor.data.id] = true;
        }
        for (let cursor = declarations1.head; cursor; cursor = cursor.next) {
          const data = cursor.data;
          if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
          }
          if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
          } else {
            result.ne1.push(data);
          }
        }
        for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
          const data = cursor.data;
          if (declarations2hash[data.id]) {
            if (
              !hasOwnProperty.call(fingerprints, data.fingerprint) ||
              (!fingerprints[data.fingerprint] && data.important)
            ) {
              result.ne2.push(data);
            }
            result.ne2overrided.push(data);
          }
        }
        return result;
      }
      function addSelectors(dest, source) {
        source.forEach((sourceData) => {
          const newStr = sourceData.id;
          let cursor = dest.head;
          while (cursor) {
            const nextStr = cursor.data.id;
            if (nextStr === newStr) {
              return;
            }
            if (nextStr > newStr) {
              break;
            }
            cursor = cursor.next;
          }
          dest.insert(dest.createItem(sourceData), cursor);
        });
        return dest;
      }
      function hasSimilarSelectors(selectors1, selectors2) {
        let cursor1 = selectors1.head;
        while (cursor1 !== null) {
          let cursor2 = selectors2.head;
          while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
              return true;
            }
            cursor2 = cursor2.next;
          }
          cursor1 = cursor1.next;
        }
        return false;
      }
      function unsafeToSkipNode(node) {
        switch (node.type) {
          case "Rule":
            return hasSimilarSelectors(node.prelude.children, this);
          case "Atrule":
            if (node.block) {
              return node.block.children.some(unsafeToSkipNode, this);
            }
            break;
          case "Declaration":
            return false;
        }
        return true;
      }
      exports.addSelectors = addSelectors;
      exports.compareDeclarations = compareDeclarations;
      exports.hasSimilarSelectors = hasSimilarSelectors;
      exports.isEqualDeclarations = isEqualDeclarations;
      exports.isEqualSelectors = isEqualSelectors;
      exports.unsafeToSkipNode = unsafeToSkipNode;
    },
    3289: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const cssTree = __nccwpck_require__(4884);
      const compress = __nccwpck_require__(5072);
      const specificity = __nccwpck_require__(5915);
      function encodeString(value) {
        const stringApostrophe = cssTree.string.encode(value, true);
        const stringQuote = cssTree.string.encode(value);
        return stringApostrophe.length < stringQuote.length
          ? stringApostrophe
          : stringQuote;
      }
      const {
        lexer,
        tokenize,
        parse,
        generate,
        walk,
        find,
        findLast,
        findAll,
        fromPlainObject,
        toPlainObject,
      } = cssTree.fork({
        node: {
          String: {
            generate(node) {
              this.token(cssTree.tokenTypes.String, encodeString(node.value));
            },
          },
          Url: {
            generate(node) {
              const encodedUrl = cssTree.url.encode(node.value);
              const string = encodeString(node.value);
              this.token(
                cssTree.tokenTypes.Url,
                encodedUrl.length <= string.length + 5
                  ? encodedUrl
                  : "url(" + string + ")",
              );
            },
          },
        },
      });
      exports.compress = compress;
      exports.specificity = specificity;
      exports.find = find;
      exports.findAll = findAll;
      exports.findLast = findLast;
      exports.fromPlainObject = fromPlainObject;
      exports.generate = generate;
      exports.lexer = lexer;
      exports.parse = parse;
      exports.toPlainObject = toPlainObject;
      exports.tokenize = tokenize;
      exports.walk = walk;
    },
    2192: (__unused_webpack_module, exports) => {
      "use strict";
      const { hasOwnProperty } = Object.prototype;
      function buildMap(list, caseInsensitive) {
        const map = Object.create(null);
        if (!Array.isArray(list)) {
          return null;
        }
        for (let name of list) {
          if (caseInsensitive) {
            name = name.toLowerCase();
          }
          map[name] = true;
        }
        return map;
      }
      function buildList(data) {
        if (!data) {
          return null;
        }
        const tags = buildMap(data.tags, true);
        const ids = buildMap(data.ids);
        const classes = buildMap(data.classes);
        if (tags === null && ids === null && classes === null) {
          return null;
        }
        return { tags, ids, classes };
      }
      function buildIndex(data) {
        let scopes = false;
        if (data.scopes && Array.isArray(data.scopes)) {
          scopes = Object.create(null);
          for (let i = 0; i < data.scopes.length; i++) {
            const list = data.scopes[i];
            if (!list || !Array.isArray(list)) {
              throw new Error("Wrong usage format");
            }
            for (const name of list) {
              if (hasOwnProperty.call(scopes, name)) {
                throw new Error(
                  `Class can't be used for several scopes: ${name}`,
                );
              }
              scopes[name] = i + 1;
            }
          }
        }
        return {
          whitelist: buildList(data),
          blacklist: buildList(data.blacklist),
          scopes,
        };
      }
      exports.buildIndex = buildIndex;
    },
    856: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const processSelector = __nccwpck_require__(6944);
      const utils$1 = __nccwpck_require__(1710);
      exports.processSelector = processSelector;
      exports.addSelectors = utils$1.addSelectors;
      exports.compareDeclarations = utils$1.compareDeclarations;
      exports.hasSimilarSelectors = utils$1.hasSimilarSelectors;
      exports.isEqualDeclarations = utils$1.isEqualDeclarations;
      exports.isEqualSelectors = utils$1.isEqualSelectors;
      exports.unsafeToSkipNode = utils$1.unsafeToSkipNode;
    },
    2045: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const { version } = __nccwpck_require__(3684);
      exports.version = version;
    },
    1835: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"atrules":{"charset":{"prelude":"<string>"},"font-face":{"descriptors":{"unicode-range":{"comment":"replaces <unicode-range>, an old production name","syntax":"<urange>#"}}}},"properties":{"-moz-background-clip":{"comment":"deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip","syntax":"padding | border"},"-moz-border-radius-bottomleft":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius","syntax":"<\'border-bottom-left-radius\'>"},"-moz-border-radius-bottomright":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius","syntax":"<\'border-bottom-right-radius\'>"},"-moz-border-radius-topleft":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius","syntax":"<\'border-top-left-radius\'>"},"-moz-border-radius-topright":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius","syntax":"<\'border-bottom-right-radius\'>"},"-moz-control-character-visibility":{"comment":"firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588","syntax":"visible | hidden"},"-moz-osx-font-smoothing":{"comment":"misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth","syntax":"auto | grayscale"},"-moz-user-select":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select","syntax":"none | text | all | -moz-none"},"-ms-flex-align":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align","syntax":"start | end | center | baseline | stretch"},"-ms-flex-item-align":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align","syntax":"auto | start | end | center | baseline | stretch"},"-ms-flex-line-pack":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack","syntax":"start | end | center | justify | distribute | stretch"},"-ms-flex-negative":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-shrink\'>"},"-ms-flex-pack":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack","syntax":"start | end | center | justify | distribute"},"-ms-flex-order":{"comment":"misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx","syntax":"<integer>"},"-ms-flex-positive":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-grow\'>"},"-ms-flex-preferred-size":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-basis\'>"},"-ms-interpolation-mode":{"comment":"https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx","syntax":"nearest-neighbor | bicubic"},"-ms-grid-column-align":{"comment":"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx","syntax":"start | end | center | stretch"},"-ms-grid-row-align":{"comment":"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx","syntax":"start | end | center | stretch"},"-ms-hyphenate-limit-last":{"comment":"misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits","syntax":"none | always | column | page | spread"},"-webkit-appearance":{"comment":"webkit specific keywords","references":["http://css-infos.net/property/-webkit-appearance"],"syntax":"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"},"-webkit-background-clip":{"comment":"https://developer.mozilla.org/en/docs/Web/CSS/background-clip","syntax":"[ <box> | border | padding | content | text ]#"},"-webkit-column-break-after":{"comment":"added, http://help.dottoro.com/lcrthhhv.php","syntax":"always | auto | avoid"},"-webkit-column-break-before":{"comment":"added, http://help.dottoro.com/lcxquvkf.php","syntax":"always | auto | avoid"},"-webkit-column-break-inside":{"comment":"added, http://help.dottoro.com/lclhnthl.php","syntax":"always | auto | avoid"},"-webkit-font-smoothing":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth","syntax":"auto | none | antialiased | subpixel-antialiased"},"-webkit-mask-box-image":{"comment":"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image","syntax":"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"},"-webkit-print-color-adjust":{"comment":"missed","references":["https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"],"syntax":"economy | exact"},"-webkit-text-security":{"comment":"missed; http://help.dottoro.com/lcbkewgt.php","syntax":"none | circle | disc | square"},"-webkit-user-drag":{"comment":"missed; http://help.dottoro.com/lcbixvwm.php","syntax":"none | element | auto"},"-webkit-user-select":{"comment":"auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select","syntax":"auto | none | text | all"},"alignment-baseline":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"],"syntax":"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"},"background-clip":{"comment":"used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values","references":["https://github.com/csstree/csstree/issues/190"],"syntax":"<bg-clip>#"},"baseline-shift":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"],"syntax":"baseline | sub | super | <svg-length>"},"behavior":{"comment":"added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx","syntax":"<url>+"},"clip-rule":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"],"syntax":"nonzero | evenodd"},"cue":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'cue-before\'> <\'cue-after\'>?"},"cue-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<url> <decibel>? | none"},"cue-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<url> <decibel>? | none"},"cursor":{"comment":"added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out","references":["https://www.sitepoint.com/css3-cursor-styles/"],"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"},"display":{"comment":"extended with -ms-flexbox","syntax":"| <-non-standard-display>"},"position":{"comment":"extended with -webkit-sticky","syntax":"| -webkit-sticky"},"dominant-baseline":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"],"syntax":"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"},"image-rendering":{"comment":"extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality","references":["https://developer.mozilla.org/en/docs/Web/CSS/image-rendering","https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"],"syntax":"| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"},"fill":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"<paint>"},"fill-opacity":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"<number-zero-one>"},"fill-rule":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"nonzero | evenodd"},"filter":{"comment":"extend with IE legacy syntaxes","syntax":"| <-ms-filter-function-list>"},"glyph-orientation-horizontal":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"],"syntax":"<angle>"},"glyph-orientation-vertical":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"],"syntax":"<angle>"},"kerning":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#KerningProperty"],"syntax":"auto | <svg-length>"},"letter-spacing":{"comment":"fix syntax <length> -> <length-percentage>","references":["https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"],"syntax":"normal | <length-percentage>"},"marker":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-end":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-mid":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-start":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"max-width":{"comment":"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width","syntax":"| <-non-standard-width>"},"width":{"references":["https://developer.mozilla.org/en-US/docs/Web/CSS/width","https://github.com/csstree/stylelint-validator/issues/29"],"syntax":"| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"},"min-width":{"comment":"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width","syntax":"| <-non-standard-width>"},"overflow":{"comment":"extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow","syntax":"| <-non-standard-overflow>"},"pause":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'pause-before\'> <\'pause-after\'>?"},"pause-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"pause-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"rest":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'rest-before\'> <\'rest-after\'>?"},"rest-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"rest-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"shape-rendering":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"],"syntax":"auto | optimizeSpeed | crispEdges | geometricPrecision"},"src":{"comment":"added @font-face\'s src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src","syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"},"speak":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"auto | none | normal"},"speak-as":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"},"stroke":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<paint>"},"stroke-dasharray":{"comment":"added SVG property; a list of comma and/or white space separated <length>s and <percentage>s","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"none | [ <svg-length>+ ]#"},"stroke-dashoffset":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<svg-length>"},"stroke-linecap":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"butt | round | square"},"stroke-linejoin":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"miter | round | bevel"},"stroke-miterlimit":{"comment":"added SVG property (<miterlimit> = <number-one-or-greater>) ","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<number-one-or-greater>"},"stroke-opacity":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<number-zero-one>"},"stroke-width":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<svg-length>"},"text-anchor":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"],"syntax":"start | middle | end"},"unicode-bidi":{"comment":"added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi","syntax":"| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"},"unicode-range":{"comment":"added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range","syntax":"<urange>#"},"voice-balance":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<number> | left | center | right | leftwards | rightwards"},"voice-duration":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"auto | <time>"},"voice-family":{"comment":"<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index","syntax":"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"},"voice-pitch":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"},"voice-range":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"},"voice-rate":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"},"voice-stress":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"normal | strong | moderate | none | reduced"},"voice-volume":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"},"writing-mode":{"comment":"extend with SVG keywords","syntax":"| <svg-writing-mode>"}},"types":{"-legacy-gradient":{"comment":"added collection of legacy gradient syntaxes","syntax":"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"},"-legacy-linear-gradient":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"},"-legacy-repeating-linear-gradient":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"},"-legacy-linear-gradient-arguments":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"[ <angle> | <side-or-corner> ]? , <color-stop-list>"},"-legacy-radial-gradient":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"},"-legacy-repeating-radial-gradient":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"},"-legacy-radial-gradient-arguments":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"},"-legacy-radial-gradient-size":{"comment":"before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize","syntax":"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"},"-legacy-radial-gradient-shape":{"comment":"define to double sure it doesn\'t extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape","syntax":"circle | ellipse"},"-non-standard-font":{"comment":"non standard fonts","references":["https://webkit.org/blog/3709/using-the-system-font-in-web-content/"],"syntax":"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"},"-non-standard-color":{"comment":"non standard colors","references":["http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html","https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"],"syntax":"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"},"-non-standard-image-rendering":{"comment":"non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html","syntax":"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"},"-non-standard-overflow":{"comment":"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow","syntax":"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"},"-non-standard-width":{"comment":"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width","syntax":"fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"},"-webkit-gradient()":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )","syntax":"-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"},"-webkit-gradient-color-stop":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"},"-webkit-gradient-point":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"},"-webkit-gradient-radius":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"<length> | <percentage>"},"-webkit-gradient-type":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"linear | radial"},"-webkit-mask-box-repeat":{"comment":"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image","syntax":"repeat | stretch | round"},"-webkit-mask-clip-style":{"comment":"missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working","syntax":"border | border-box | padding | padding-box | content | content-box | text"},"-ms-filter-function-list":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<-ms-filter-function>+"},"-ms-filter-function":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<-ms-filter-function-progid> | <-ms-filter-function-legacy>"},"-ms-filter-function-progid":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"\'progid:\' [ <ident-token> \'.\' ]* [ <ident-token> | <function-token> <any-value>? ) ]"},"-ms-filter-function-legacy":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<ident-token> | <function-token> <any-value>? )"},"-ms-filter":{"syntax":"<string>"},"age":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"child | young | old"},"attr-name":{"syntax":"<wq-name>"},"attr-fallback":{"syntax":"<any-value>"},"bg-clip":{"comment":"missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip","syntax":"<box> | border | text"},"border-radius":{"comment":"missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius","syntax":"<length-percentage>{1,2}"},"bottom":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"content-list":{"comment":"added attr(), see https://github.com/csstree/csstree/issues/201","syntax":"[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"},"element()":{"comment":"https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation","syntax":"element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"},"generic-voice":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"[ <age>? <gender> <integer>? ]"},"gender":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"male | female | neutral"},"generic-family":{"comment":"added -apple-system","references":["https://webkit.org/blog/3709/using-the-system-font-in-web-content/"],"syntax":"| -apple-system"},"gradient":{"comment":"added legacy syntaxes support","syntax":"| <-legacy-gradient>"},"lab()":{"comment":"missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch","syntax":"lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"},"lch()":{"comment":"missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch","syntax":"lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"},"left":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"mask-image":{"comment":"missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image","syntax":"<mask-reference>#"},"named-color":{"comment":"added non standard color names","syntax":"| <-non-standard-color>"},"paint":{"comment":"used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint","syntax":"none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"},"ratio":{"comment":"missed, https://drafts.csswg.org/css-values-4/#ratio-value","syntax":"<number [0,∞]> [ / <number [0,∞]> ]?"},"reversed-counter-name":{"comment":"missed; https://drafts.csswg.org/css-lists/#typedef-reversed-counter-name","syntax":"reversed( <counter-name> )"},"right":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"shape":{"comment":"missed spaces in function body and add backwards compatible syntax","syntax":"rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"},"svg-length":{"comment":"All coordinates and lengths in SVG can be specified with or without a unit identifier","references":["https://www.w3.org/TR/SVG11/coords.html#Units"],"syntax":"<percentage> | <length> | <number>"},"svg-writing-mode":{"comment":"SVG specific keywords (deprecated for CSS)","references":["https://developer.mozilla.org/en/docs/Web/CSS/writing-mode","https://www.w3.org/TR/SVG/text.html#WritingModeProperty"],"syntax":"lr-tb | rl-tb | tb-rl | lr | rl | tb"},"top":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"track-group":{"comment":"used by old grid-columns and grid-rows syntax v0","syntax":"\'(\' [ <string>* <track-minmax> <string>* ]+ \')\' [ \'[\' <positive-integer> \']\' ]? | <track-minmax>"},"track-list-v0":{"comment":"used by old grid-columns and grid-rows syntax v0","syntax":"[ <string>* <track-group> <string>* ]+ | none"},"track-minmax":{"comment":"used by old grid-columns and grid-rows syntax v0","syntax":"minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"},"x":{"comment":"missed; not sure we should add it, but no others except `cursor` is using it so it\'s ok for now; https://drafts.csswg.org/css-ui-3/#cursor","syntax":"<number>"},"y":{"comment":"missed; not sure we should add it, but no others except `cursor` is using so it\'s ok for now; https://drafts.csswg.org/css-ui-3/#cursor","syntax":"<number>"},"declaration":{"comment":"missed, restored by https://drafts.csswg.org/css-syntax","syntax":"<ident-token> : <declaration-value>? [ \'!\' important ]?"},"declaration-list":{"comment":"missed, restored by https://drafts.csswg.org/css-syntax","syntax":"[ <declaration>? \';\' ]* <declaration>?"},"url":{"comment":"https://drafts.csswg.org/css-values-4/#urls","syntax":"url( <string> <url-modifier>* ) | <url-token>"},"url-modifier":{"comment":"https://drafts.csswg.org/css-values-4/#typedef-url-modifier","syntax":"<ident> | <function-token> <any-value> )"},"number-zero-one":{"syntax":"<number [0,1]>"},"number-one-or-greater":{"syntax":"<number [1,∞]>"},"positive-integer":{"syntax":"<integer [0,∞]>"},"-non-standard-display":{"syntax":"-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"}}}',
      );
    },
    9750: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"atrules":{"charset":{"prelude":"<string>"},"font-face":{"descriptors":{"unicode-range":{"comment":"replaces <unicode-range>, an old production name","syntax":"<urange>#"}}},"nest":{"prelude":"<complex-selector-list>"}},"properties":{"-moz-background-clip":{"comment":"deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip","syntax":"padding | border"},"-moz-border-radius-bottomleft":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius","syntax":"<\'border-bottom-left-radius\'>"},"-moz-border-radius-bottomright":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius","syntax":"<\'border-bottom-right-radius\'>"},"-moz-border-radius-topleft":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius","syntax":"<\'border-top-left-radius\'>"},"-moz-border-radius-topright":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius","syntax":"<\'border-bottom-right-radius\'>"},"-moz-control-character-visibility":{"comment":"firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588","syntax":"visible | hidden"},"-moz-osx-font-smoothing":{"comment":"misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth","syntax":"auto | grayscale"},"-moz-user-select":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select","syntax":"none | text | all | -moz-none"},"-ms-flex-align":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align","syntax":"start | end | center | baseline | stretch"},"-ms-flex-item-align":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align","syntax":"auto | start | end | center | baseline | stretch"},"-ms-flex-line-pack":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack","syntax":"start | end | center | justify | distribute | stretch"},"-ms-flex-negative":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-shrink\'>"},"-ms-flex-pack":{"comment":"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack","syntax":"start | end | center | justify | distribute"},"-ms-flex-order":{"comment":"misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx","syntax":"<integer>"},"-ms-flex-positive":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-grow\'>"},"-ms-flex-preferred-size":{"comment":"misssed old syntax implemented in IE; TODO: find references for comfirmation","syntax":"<\'flex-basis\'>"},"-ms-interpolation-mode":{"comment":"https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx","syntax":"nearest-neighbor | bicubic"},"-ms-grid-column-align":{"comment":"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx","syntax":"start | end | center | stretch"},"-ms-grid-row-align":{"comment":"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx","syntax":"start | end | center | stretch"},"-ms-hyphenate-limit-last":{"comment":"misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits","syntax":"none | always | column | page | spread"},"-webkit-appearance":{"comment":"webkit specific keywords","references":["http://css-infos.net/property/-webkit-appearance"],"syntax":"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"},"-webkit-background-clip":{"comment":"https://developer.mozilla.org/en/docs/Web/CSS/background-clip","syntax":"[ <box> | border | padding | content | text ]#"},"-webkit-column-break-after":{"comment":"added, http://help.dottoro.com/lcrthhhv.php","syntax":"always | auto | avoid"},"-webkit-column-break-before":{"comment":"added, http://help.dottoro.com/lcxquvkf.php","syntax":"always | auto | avoid"},"-webkit-column-break-inside":{"comment":"added, http://help.dottoro.com/lclhnthl.php","syntax":"always | auto | avoid"},"-webkit-font-smoothing":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth","syntax":"auto | none | antialiased | subpixel-antialiased"},"-webkit-mask-box-image":{"comment":"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image","syntax":"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"},"-webkit-print-color-adjust":{"comment":"missed","references":["https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"],"syntax":"economy | exact"},"-webkit-text-security":{"comment":"missed; http://help.dottoro.com/lcbkewgt.php","syntax":"none | circle | disc | square"},"-webkit-user-drag":{"comment":"missed; http://help.dottoro.com/lcbixvwm.php","syntax":"none | element | auto"},"-webkit-user-select":{"comment":"auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select","syntax":"auto | none | text | all"},"alignment-baseline":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"],"syntax":"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"},"background-clip":{"comment":"used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values","references":["https://github.com/csstree/csstree/issues/190"],"syntax":"<bg-clip>#"},"baseline-shift":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"],"syntax":"baseline | sub | super | <svg-length>"},"behavior":{"comment":"added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx","syntax":"<url>+"},"clip-rule":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"],"syntax":"nonzero | evenodd"},"cue":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'cue-before\'> <\'cue-after\'>?"},"cue-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<url> <decibel>? | none"},"cue-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<url> <decibel>? | none"},"cursor":{"comment":"added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out","references":["https://www.sitepoint.com/css3-cursor-styles/"],"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"},"display":{"comment":"extended with -ms-flexbox","syntax":"| <-non-standard-display>"},"position":{"comment":"extended with -webkit-sticky","syntax":"| -webkit-sticky"},"dominant-baseline":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"],"syntax":"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"},"image-rendering":{"comment":"extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality","references":["https://developer.mozilla.org/en/docs/Web/CSS/image-rendering","https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"],"syntax":"| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"},"fill":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"<paint>"},"fill-opacity":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"<number-zero-one>"},"fill-rule":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#FillProperty"],"syntax":"nonzero | evenodd"},"filter":{"comment":"extend with IE legacy syntaxes","syntax":"| <-ms-filter-function-list>"},"glyph-orientation-horizontal":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"],"syntax":"<angle>"},"glyph-orientation-vertical":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"],"syntax":"<angle>"},"kerning":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#KerningProperty"],"syntax":"auto | <svg-length>"},"letter-spacing":{"comment":"fix syntax <length> -> <length-percentage>","references":["https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"],"syntax":"normal | <length-percentage>"},"marker":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-end":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-mid":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"marker-start":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#MarkerProperties"],"syntax":"none | <url>"},"max-width":{"comment":"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width","syntax":"| <-non-standard-width>"},"width":{"references":["https://developer.mozilla.org/en-US/docs/Web/CSS/width","https://github.com/csstree/stylelint-validator/issues/29"],"syntax":"| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"},"min-width":{"comment":"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width","syntax":"| <-non-standard-width>"},"overflow":{"comment":"extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow","syntax":"| <-non-standard-overflow>"},"pause":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'pause-before\'> <\'pause-after\'>?"},"pause-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"pause-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"rest":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<\'rest-before\'> <\'rest-after\'>?"},"rest-after":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"rest-before":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<time> | none | x-weak | weak | medium | strong | x-strong"},"shape-rendering":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"],"syntax":"auto | optimizeSpeed | crispEdges | geometricPrecision"},"src":{"comment":"added @font-face\'s src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src","syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"},"speak":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"auto | none | normal"},"speak-as":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"},"stroke":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<paint>"},"stroke-dasharray":{"comment":"added SVG property; a list of comma and/or white space separated <length>s and <percentage>s","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"none | [ <svg-length>+ ]#"},"stroke-dashoffset":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<svg-length>"},"stroke-linecap":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"butt | round | square"},"stroke-linejoin":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"miter | round | bevel"},"stroke-miterlimit":{"comment":"added SVG property (<miterlimit> = <number-one-or-greater>) ","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<number-one-or-greater>"},"stroke-opacity":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<number-zero-one>"},"stroke-width":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/painting.html#StrokeProperties"],"syntax":"<svg-length>"},"text-anchor":{"comment":"added SVG property","references":["https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"],"syntax":"start | middle | end"},"unicode-bidi":{"comment":"added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi","syntax":"| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"},"unicode-range":{"comment":"added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range","syntax":"<urange>#"},"voice-balance":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<number> | left | center | right | leftwards | rightwards"},"voice-duration":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"auto | <time>"},"voice-family":{"comment":"<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index","syntax":"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"},"voice-pitch":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"},"voice-range":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"},"voice-rate":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"},"voice-stress":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"normal | strong | moderate | none | reduced"},"voice-volume":{"comment":"https://www.w3.org/TR/css3-speech/#property-index","syntax":"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"},"writing-mode":{"comment":"extend with SVG keywords","syntax":"| <svg-writing-mode>"}},"types":{"-legacy-gradient":{"comment":"added collection of legacy gradient syntaxes","syntax":"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"},"-legacy-linear-gradient":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"},"-legacy-repeating-linear-gradient":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"},"-legacy-linear-gradient-arguments":{"comment":"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient","syntax":"[ <angle> | <side-or-corner> ]? , <color-stop-list>"},"-legacy-radial-gradient":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"},"-legacy-repeating-radial-gradient":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"},"-legacy-radial-gradient-arguments":{"comment":"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients","syntax":"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"},"-legacy-radial-gradient-size":{"comment":"before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize","syntax":"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"},"-legacy-radial-gradient-shape":{"comment":"define to double sure it doesn\'t extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape","syntax":"circle | ellipse"},"-non-standard-font":{"comment":"non standard fonts","references":["https://webkit.org/blog/3709/using-the-system-font-in-web-content/"],"syntax":"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"},"-non-standard-color":{"comment":"non standard colors","references":["http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html","https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"],"syntax":"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"},"-non-standard-image-rendering":{"comment":"non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html","syntax":"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"},"-non-standard-overflow":{"comment":"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow","syntax":"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"},"-non-standard-width":{"comment":"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width","syntax":"fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"},"-webkit-gradient()":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )","syntax":"-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"},"-webkit-gradient-color-stop":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"},"-webkit-gradient-point":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"},"-webkit-gradient-radius":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"<length> | <percentage>"},"-webkit-gradient-type":{"comment":"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/","syntax":"linear | radial"},"-webkit-mask-box-repeat":{"comment":"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image","syntax":"repeat | stretch | round"},"-webkit-mask-clip-style":{"comment":"missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working","syntax":"border | border-box | padding | padding-box | content | content-box | text"},"-ms-filter-function-list":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<-ms-filter-function>+"},"-ms-filter-function":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<-ms-filter-function-progid> | <-ms-filter-function-legacy>"},"-ms-filter-function-progid":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"\'progid:\' [ <ident-token> \'.\' ]* [ <ident-token> | <function-token> <any-value>? ) ]"},"-ms-filter-function-legacy":{"comment":"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter","syntax":"<ident-token> | <function-token> <any-value>? )"},"-ms-filter":{"syntax":"<string>"},"age":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"child | young | old"},"attr-name":{"syntax":"<wq-name>"},"attr-fallback":{"syntax":"<any-value>"},"bg-clip":{"comment":"missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip","syntax":"<box> | border | text"},"bottom":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"content-list":{"comment":"added attr(), see https://github.com/csstree/csstree/issues/201","syntax":"[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"},"element()":{"comment":"https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation","syntax":"element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"},"generic-voice":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"[ <age>? <gender> <integer>? ]"},"gender":{"comment":"https://www.w3.org/TR/css3-speech/#voice-family","syntax":"male | female | neutral"},"generic-family":{"comment":"added -apple-system","references":["https://webkit.org/blog/3709/using-the-system-font-in-web-content/"],"syntax":"| -apple-system"},"gradient":{"comment":"added legacy syntaxes support","syntax":"| <-legacy-gradient>"},"left":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"mask-image":{"comment":"missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image","syntax":"<mask-reference>#"},"named-color":{"comment":"added non standard color names","syntax":"| <-non-standard-color>"},"paint":{"comment":"used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint","syntax":"none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"},"right":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"shape":{"comment":"missed spaces in function body and add backwards compatible syntax","syntax":"rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"},"scroll-timeline-axis":{"comment":"missed definition","syntax":"block | inline | vertical | horizontal"},"scroll-timeline-name":{"comment":"missed definition","references":["https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name"],"syntax":"none | <custom-ident>"},"single-animation-composition":{"comment":"missed definition","references":["https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition"],"syntax":"replace | add | accumulate"},"svg-length":{"comment":"All coordinates and lengths in SVG can be specified with or without a unit identifier","references":["https://www.w3.org/TR/SVG11/coords.html#Units"],"syntax":"<percentage> | <length> | <number>"},"svg-writing-mode":{"comment":"SVG specific keywords (deprecated for CSS)","references":["https://developer.mozilla.org/en/docs/Web/CSS/writing-mode","https://www.w3.org/TR/SVG/text.html#WritingModeProperty"],"syntax":"lr-tb | rl-tb | tb-rl | lr | rl | tb"},"top":{"comment":"missed; not sure we should add it, but no others except `shape` is using it so it\'s ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect","syntax":"<length> | auto"},"x":{"comment":"missed; not sure we should add it, but no others except `cursor` is using it so it\'s ok for now; https://drafts.csswg.org/css-ui-3/#cursor","syntax":"<number>"},"y":{"comment":"missed; not sure we should add it, but no others except `cursor` is using so it\'s ok for now; https://drafts.csswg.org/css-ui-3/#cursor","syntax":"<number>"},"declaration":{"comment":"missed, restored by https://drafts.csswg.org/css-syntax","syntax":"<ident-token> : <declaration-value>? [ \'!\' important ]?"},"declaration-list":{"comment":"missed, restored by https://drafts.csswg.org/css-syntax","syntax":"[ <declaration>? \';\' ]* <declaration>?"},"url":{"comment":"https://drafts.csswg.org/css-values-4/#urls","syntax":"url( <string> <url-modifier>* ) | <url-token>"},"url-modifier":{"comment":"https://drafts.csswg.org/css-values-4/#typedef-url-modifier","syntax":"<ident> | <function-token> <any-value> )"},"number-zero-one":{"syntax":"<number [0,1]>"},"number-one-or-greater":{"syntax":"<number [1,∞]>"},"-non-standard-display":{"syntax":"-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"}}}',
      );
    },
    5260: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"@charset":{"syntax":"@charset \\"<charset>\\";","groups":["CSS Charsets"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@charset"},"@counter-style":{"syntax":"@counter-style <counter-style-name> {\\n  [ system: <counter-system>; ] ||\\n  [ symbols: <counter-symbols>; ] ||\\n  [ additive-symbols: <additive-symbols>; ] ||\\n  [ negative: <negative-symbol>; ] ||\\n  [ prefix: <prefix>; ] ||\\n  [ suffix: <suffix>; ] ||\\n  [ range: <range>; ] ||\\n  [ pad: <padding>; ] ||\\n  [ speak-as: <speak-as>; ] ||\\n  [ fallback: <counter-style-name>; ]\\n}","interfaces":["CSSCounterStyleRule"],"groups":["CSS Counter Styles"],"descriptors":{"additive-symbols":{"syntax":"[ <integer> && <symbol> ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"fallback":{"syntax":"<counter-style-name>","media":"all","initial":"decimal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"negative":{"syntax":"<symbol> <symbol>?","media":"all","initial":"\\"-\\" hyphen-minus","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"pad":{"syntax":"<integer> && <symbol>","media":"all","initial":"0 \\"\\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"prefix":{"syntax":"<symbol>","media":"all","initial":"\\"\\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"range":{"syntax":"[ [ <integer> | infinite ]{2} ]# | auto","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"speak-as":{"syntax":"auto | bullets | numbers | words | spell-out | <counter-style-name>","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"suffix":{"syntax":"<symbol>","media":"all","initial":"\\". \\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"symbols":{"syntax":"<symbol>+","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"system":{"syntax":"cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]","media":"all","initial":"symbolic","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@counter-style"},"@document":{"syntax":"@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule"],"groups":["CSS Conditional Rules"],"status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@document"},"@font-face":{"syntax":"@font-face {\\n  [ font-family: <family-name>; ] ||\\n  [ src: <src>; ] ||\\n  [ unicode-range: <unicode-range>; ] ||\\n  [ font-variant: <font-variant>; ] ||\\n  [ font-feature-settings: <font-feature-settings>; ] ||\\n  [ font-variation-settings: <font-variation-settings>; ] ||\\n  [ font-stretch: <font-stretch>; ] ||\\n  [ font-weight: <font-weight>; ] ||\\n  [ font-style: <font-style>; ] ||\\n  [ size-adjust: <size-adjust>; ] ||\\n  [ ascent-override: <ascent-override>; ] ||\\n  [ descent-override: <descent-override>; ] ||\\n  [ line-gap-override: <line-gap-override>; ]\\n}","interfaces":["CSSFontFaceRule"],"groups":["CSS Fonts"],"descriptors":{"ascent-override":{"syntax":"normal | <percentage>","media":"all","initial":"normal","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"descent-override":{"syntax":"normal | <percentage>","media":"all","initial":"normal","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"font-display":{"syntax":"[ auto | block | swap | fallback | optional ]","media":"visual","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"font-family":{"syntax":"<family-name>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-stretch":{"syntax":"<font-stretch-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-style":{"syntax":"normal | italic | oblique <angle>{0,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-weight":{"syntax":"<font-weight-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"line-gap-override":{"syntax":"normal | <percentage>","media":"all","initial":"normal","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"size-adjust":{"syntax":"<percentage>","media":"all","initial":"100%","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"src":{"syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"unicode-range":{"syntax":"<unicode-range>#","media":"all","initial":"U+0-10FFFF","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-face"},"@font-feature-values":{"syntax":"@font-feature-values <family-name># {\\n  <feature-value-block-list>\\n}","interfaces":["CSSFontFeatureValuesRule"],"groups":["CSS Fonts"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"},"@import":{"syntax":"@import [ <string> | <url> ]\\n        [ layer | layer(<layer-name>) ]?\\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\\n        <media-query-list>? ;","groups":["CSS Conditional Rules","Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@import"},"@keyframes":{"syntax":"@keyframes <keyframes-name> {\\n  <keyframe-block-list>\\n}","interfaces":["CSSKeyframeRule","CSSKeyframesRule"],"groups":["CSS Animations"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@keyframes"},"@layer":{"syntax":"@layer [ <layer-name># | <layer-name>?  {\\n  <stylesheet>\\n} ]","interfaces":["CSSLayerBlockRule","CSSLayerStatementRule"],"groups":["CSS Cascading and Inheritance"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@layer"},"@media":{"syntax":"@media <media-query-list> {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSMediaRule","CSSCustomMediaRule"],"groups":["CSS Conditional Rules","Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@media"},"@namespace":{"syntax":"@namespace <namespace-prefix>? [ <string> | <url> ];","groups":["CSS Namespaces"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@namespace"},"@page":{"syntax":"@page <page-selector-list> {\\n  <page-body>\\n}","interfaces":["CSSPageRule"],"groups":["CSS Pages"],"descriptors":{"bleed":{"syntax":"auto | <length>","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"marks":{"syntax":"none | [ crop || cross ]","media":["visual","paged"],"initial":"none","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"size":{"syntax":"<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@page"},"@property":{"syntax":"@property <custom-property-name> {\\n  <declaration-list>\\n}","interfaces":["CSS","CSSPropertyRule"],"groups":["CSS Houdini"],"descriptors":{"syntax":{"syntax":"<string>","media":"all","percentages":"no","initial":"n/a (required)","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"inherits":{"syntax":"true | false","media":"all","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"initial-value":{"syntax":"<string>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"experimental"}},"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@property"},"@scroll-timeline":{"syntax":"@scroll-timeline <timeline-name> { <declaration-list> }","interfaces":["ScrollTimeline"],"groups":["CSS Animations"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"},"@supports":{"syntax":"@supports <supports-condition> {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSSupportsRule"],"groups":["CSS Conditional Rules"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@supports"},"@viewport":{"syntax":"@viewport {\\n  <group-rule-body>\\n}","interfaces":["CSSViewportRule"],"groups":["CSS Device Adaptation"],"descriptors":{"height":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-height","max-height"],"percentages":["min-height","max-height"],"computed":["min-height","max-height"],"order":"orderOfAppearance","status":"standard"},"max-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"min-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"orientation":{"syntax":"auto | portrait | landscape","media":["visual","continuous"],"initial":"auto","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"user-zoom":{"syntax":"zoom | fixed","media":["visual","continuous"],"initial":"zoom","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"viewport-fit":{"syntax":"auto | contain | cover","media":["visual","continuous"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"width":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-width","max-width"],"percentages":["min-width","max-width"],"computed":["min-width","max-width"],"order":"orderOfAppearance","status":"standard"},"zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@viewport"}}',
      );
    },
    1005: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"--*":{"syntax":"<declaration-value>","media":"all","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Variables"],"initial":"seeProse","appliesto":"allElements","computed":"asSpecifiedWithVarsSubstituted","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/--*"},"-ms-accelerator":{"syntax":"false | true","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"false","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"},"-ms-block-progression":{"syntax":"tb | rl | bt | lr","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"tb","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"},"-ms-content-zoom-chaining":{"syntax":"none | chained","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"},"-ms-content-zooming":{"syntax":"none | zoom","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"zoomForTheTopLevelNoneForTheRest","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"},"-ms-content-zoom-limit":{"syntax":"<\'-ms-content-zoom-limit-min\'> <\'-ms-content-zoom-limit-max\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"},"-ms-content-zoom-limit-max":{"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"maxZoomFactor","groups":["Microsoft Extensions"],"initial":"400%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"},"-ms-content-zoom-limit-min":{"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"minZoomFactor","groups":["Microsoft Extensions"],"initial":"100%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"},"-ms-content-zoom-snap":{"syntax":"<\'-ms-content-zoom-snap-type\'> || <\'-ms-content-zoom-snap-points\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"},"-ms-content-zoom-snap-points":{"syntax":"snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0%, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"},"-ms-content-zoom-snap-type":{"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"},"-ms-filter":{"syntax":"<string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"\\"\\"","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-filter"},"-ms-flow-from":{"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"},"-ms-flow-into":{"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"iframeElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"},"-ms-grid-columns":{"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"},"-ms-grid-rows":{"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"},"-ms-high-contrast-adjust":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"},"-ms-hyphenate-limit-chars":{"syntax":"auto | <integer>{1,3}","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"},"-ms-hyphenate-limit-lines":{"syntax":"no-limit | <integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"no-limit","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"},"-ms-hyphenate-limit-zone":{"syntax":"<percentage> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToLineBoxWidth","groups":["Microsoft Extensions"],"initial":"0","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"},"-ms-ime-align":{"syntax":"auto | after","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"},"-ms-overflow-style":{"syntax":"auto | none | scrollbar | -ms-autohiding-scrollbar","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"},"-ms-scrollbar-3dlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"},"-ms-scrollbar-arrow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ButtonText","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"},"-ms-scrollbar-base-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"},"-ms-scrollbar-darkshadow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"},"-ms-scrollbar-face-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDFace","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"},"-ms-scrollbar-highlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDHighlight","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"},"-ms-scrollbar-shadow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"},"-ms-scrollbar-track-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"Scrollbar","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"},"-ms-scroll-chaining":{"syntax":"chained | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"chained","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"},"-ms-scroll-limit":{"syntax":"<\'-ms-scroll-limit-x-min\'> <\'-ms-scroll-limit-y-min\'> <\'-ms-scroll-limit-x-max\'> <\'-ms-scroll-limit-y-max\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"},"-ms-scroll-limit-x-max":{"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"},"-ms-scroll-limit-x-min":{"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"},"-ms-scroll-limit-y-max":{"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"},"-ms-scroll-limit-y-min":{"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"},"-ms-scroll-rails":{"syntax":"none | railed","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"railed","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"},"-ms-scroll-snap-points-x":{"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"},"-ms-scroll-snap-points-y":{"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"},"-ms-scroll-snap-type":{"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"},"-ms-scroll-snap-x":{"syntax":"<\'-ms-scroll-snap-type\'> <\'-ms-scroll-snap-points-x\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"},"-ms-scroll-snap-y":{"syntax":"<\'-ms-scroll-snap-type\'> <\'-ms-scroll-snap-points-y\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"},"-ms-scroll-translation":{"syntax":"none | vertical-to-horizontal","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"},"-ms-text-autospace":{"syntax":"none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"},"-ms-touch-select":{"syntax":"grippers | none","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"grippers","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"},"-ms-user-select":{"syntax":"none | element | text","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"text","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"},"-ms-wrap-flow":{"syntax":"auto | both | start | end | maximum | clear","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"},"-ms-wrap-margin":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"exclusionElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"},"-ms-wrap-through":{"syntax":"wrap | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"wrap","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"},"-moz-appearance":{"syntax":"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"-moz-binding":{"syntax":"<url> | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsExceptGeneratedContentOrPseudoElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-binding"},"-moz-border-bottom-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"},"-moz-border-left-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"},"-moz-border-right-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"},"-moz-border-top-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"},"-moz-context-properties":{"syntax":"none | [ fill | fill-opacity | stroke | stroke-opacity ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsThatCanReferenceImages","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"},"-moz-float-edge":{"syntax":"border-box | content-box | margin-box | padding-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"content-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"},"-moz-force-broken-image-icon":{"syntax":"0 | 1","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"0","appliesto":"images","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"},"-moz-image-region":{"syntax":"<shape> | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"xulImageElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"},"-moz-orient":{"syntax":"inline | block | horizontal | vertical","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"inline","appliesto":"anyElementEffectOnProgressAndMeter","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-orient"},"-moz-outline-radius":{"syntax":"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?","media":"visual","inherited":false,"animationType":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"percentages":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"groups":["Mozilla Extensions"],"initial":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"appliesto":"allElements","computed":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"},"-moz-outline-radius-bottomleft":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"},"-moz-outline-radius-bottomright":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"},"-moz-outline-radius-topleft":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"},"-moz-outline-radius-topright":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"},"-moz-stack-sizing":{"syntax":"ignore | stretch-to-fit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"stretch-to-fit","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"},"-moz-text-blink":{"syntax":"none | blink","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"},"-moz-user-focus":{"syntax":"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"},"-moz-user-input":{"syntax":"auto | none | enabled | disabled","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"},"-moz-user-modify":{"syntax":"read-only | read-write | write-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"},"-moz-window-dragging":{"syntax":"drag | no-drag","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"drag","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"},"-moz-window-shadow":{"syntax":"default | menu | tooltip | sheet | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"default","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"},"-webkit-appearance":{"syntax":"none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"-webkit-border-before":{"syntax":"<\'border-width\'> || <\'border-style\'> || <color>","media":"visual","inherited":true,"animationType":"discrete","percentages":["-webkit-border-before-width"],"groups":["WebKit Extensions"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","color"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"},"-webkit-border-before-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard"},"-webkit-border-before-style":{"syntax":"<\'border-style\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},"-webkit-border-before-width":{"syntax":"<\'border-width\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["WebKit Extensions"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"nonstandard"},"-webkit-box-reflect":{"syntax":"[ above | below | right | left ]? <length>? <image>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"},"-webkit-line-clamp":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["WebKit Extensions","CSS Overflow"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"},"-webkit-mask":{"syntax":"[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"appliesto":"allElements","computed":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},"-webkit-mask-attachment":{"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"},"-webkit-mask-clip":{"syntax":"[ <box> | border | padding | content | text ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"border","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},"-webkit-mask-composite":{"syntax":"<composite-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"source-over","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"},"-webkit-mask-image":{"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"absoluteURIOrNone","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},"-webkit-mask-origin":{"syntax":"[ <box> | border | padding | content ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"padding","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},"-webkit-mask-position":{"syntax":"<position>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0% 0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},"-webkit-mask-position-x":{"syntax":"[ <length-percentage> | left | center | right ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"},"-webkit-mask-position-y":{"syntax":"[ <length-percentage> | top | center | bottom ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"},"-webkit-mask-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},"-webkit-mask-repeat-x":{"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"},"-webkit-mask-repeat-y":{"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"},"-webkit-mask-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToBackgroundPositioningArea","groups":["WebKit Extensions"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},"-webkit-overflow-scrolling":{"syntax":"auto | touch","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"},"-webkit-tap-highlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"black","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"},"-webkit-text-fill-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"},"-webkit-text-stroke":{"syntax":"<length> || <color>","media":"visual","inherited":true,"animationType":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"appliesto":"allElements","computed":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"order":"canonicalOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"},"-webkit-text-stroke-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"},"-webkit-text-stroke-width":{"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"0","appliesto":"allElements","computed":"absoluteLength","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"},"-webkit-touch-callout":{"syntax":"default | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"default","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"},"-webkit-user-modify":{"syntax":"read-only | read-write | read-write-plaintext-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},"accent-color":{"syntax":"auto | <color>","media":"interactive","inherited":true,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asAutoOrColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/accent-color"},"align-content":{"syntax":"normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-content"},"align-items":{"syntax":"normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-items"},"align-self":{"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"flexItemsGridItemsAndAbsolutelyPositionedBoxes","computed":"autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-self"},"align-tracks":{"syntax":"[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirBlockAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-tracks"},"all":{"syntax":"initial | inherit | unset | revert | revert-layer","media":"noPracticalMedia","inherited":false,"animationType":"eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection","percentages":"no","groups":["CSS Miscellaneous"],"initial":"noPracticalInitialValue","appliesto":"allElements","computed":"asSpecifiedAppliesToEachProperty","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/all"},"animation":{"syntax":"<single-animation>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-iteration-count","animation-direction","animation-fill-mode","animation-play-state","animation-timeline"],"appliesto":"allElementsAndPseudos","computed":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-direction","animation-iteration-count","animation-fill-mode","animation-play-state","animation-timeline"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation"},"animation-delay":{"syntax":"<time>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-delay"},"animation-direction":{"syntax":"<single-animation-direction>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"normal","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-direction"},"animation-duration":{"syntax":"<time>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-duration"},"animation-fill-mode":{"syntax":"<single-animation-fill-mode>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"},"animation-iteration-count":{"syntax":"<single-animation-iteration-count>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"1","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"},"animation-name":{"syntax":"[ none | <keyframes-name> ]#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-name"},"animation-play-state":{"syntax":"<single-animation-play-state>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"running","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-play-state"},"animation-timing-function":{"syntax":"<easing-function>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"},"animation-timeline":{"syntax":"<single-animation-timeline>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"auto","appliesto":"allElements","computed":"listEachItemIdentifyerOrNoneAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-timeline"},"appearance":{"syntax":"none | auto | textfield | menulist-button | <compat-auto>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"aspect-ratio":{"syntax":"auto | <ratio>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"},"azimuth":{"syntax":"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards","media":"aural","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Speech"],"initial":"center","appliesto":"allElements","computed":"normalizedAngle","order":"orderOfAppearance","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/azimuth"},"backdrop-filter":{"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"},"backface-visibility":{"syntax":"visible | hidden","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"visible","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backface-visibility"},"background":{"syntax":"[ <bg-layer> , ]* <final-bg-layer>","media":"visual","inherited":false,"animationType":["background-color","background-image","background-clip","background-position","background-size","background-repeat","background-attachment"],"percentages":["background-position","background-size"],"groups":["CSS Backgrounds and Borders"],"initial":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"appliesto":"allElements","computed":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background"},"background-attachment":{"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-attachment"},"background-blend-mode":{"syntax":"<blend-mode>#","media":"none","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"},"background-clip":{"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"border-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-clip"},"background-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"transparent","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-color"},"background-image":{"syntax":"<bg-image>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-image"},"background-origin":{"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-origin"},"background-position":{"syntax":"<bg-position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize","groups":["CSS Backgrounds and Borders"],"initial":"0% 0%","appliesto":"allElements","computed":["background-position-x","background-position-y"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position"},"background-position-x":{"syntax":"[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"0%","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-x"},"background-position-y":{"syntax":"[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"0%","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-y"},"background-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"repeat","appliesto":"allElements","computed":"listEachItemHasTwoKeywordsOnePerDimension","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-repeat"},"background-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"relativeToBackgroundPositioningArea","groups":["CSS Backgrounds and Borders"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-size"},"block-overflow":{"syntax":"clip | ellipsis | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"clip","appliesto":"blockContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"block-size":{"syntax":"<\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/block-size"},"border":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-color","border-style","border-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-width","border-style","border-color"],"appliesto":"allElements","computed":["border-width","border-style","border-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border"},"border-block":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block"},"border-block-color":{"syntax":"<\'border-top-color\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-color"},"border-block-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-style"},"border-block-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-width"},"border-block-end":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-block-end-color","border-block-end-style","border-block-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end"},"border-block-end-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"},"border-block-end-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"},"border-block-end-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"},"border-block-start":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-block-start-color","border-block-start-style","border-block-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-block-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start"},"border-block-start-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"},"border-block-start-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"},"border-block-start-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"},"border-bottom":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-bottom-color","border-bottom-style","border-bottom-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-bottom-width","border-bottom-style","border-bottom-color"],"appliesto":"allElements","computed":["border-bottom-width","border-bottom-style","border-bottom-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom"},"border-bottom-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"},"border-bottom-left-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"},"border-bottom-right-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"},"border-bottom-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"},"border-bottom-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderBottomStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"},"border-collapse":{"syntax":"collapse | separate","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"separate","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-collapse"},"border-color":{"syntax":"<color>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-color","border-right-color","border-bottom-color","border-left-color"],"appliesto":"allElements","computed":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-color"},"border-end-end-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"},"border-end-start-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"},"border-image":{"syntax":"<\'border-image-source\'> || <\'border-image-slice\'> [ / <\'border-image-width\'> | / <\'border-image-width\'>? / <\'border-image-outset\'> ]? || <\'border-image-repeat\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["border-image-slice","border-image-width"],"groups":["CSS Backgrounds and Borders"],"initial":["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],"appliesto":"allElementsExceptTableElementsWhenCollapse","computed":["border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image"},"border-image-outset":{"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-outset"},"border-image-repeat":{"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"stretch","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"},"border-image-slice":{"syntax":"<number-percentage>{1,4} && fill?","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToSizeOfBorderImage","groups":["CSS Backgrounds and Borders"],"initial":"100%","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"oneToFourPercentagesOrAbsoluteLengthsPlusFill","order":"percentagesOrLengthsFollowedByFill","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-slice"},"border-image-source":{"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"noneOrImageWithAbsoluteURI","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-source"},"border-image-width":{"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToWidthOrHeightOfBorderImageArea","groups":["CSS Backgrounds and Borders"],"initial":"1","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-width"},"border-inline":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline"},"border-inline-end":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-inline-end-color","border-inline-end-style","border-inline-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-end-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end"},"border-inline-color":{"syntax":"<\'border-top-color\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-color"},"border-inline-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-style"},"border-inline-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-width"},"border-inline-end-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"},"border-inline-end-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"},"border-inline-end-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"},"border-inline-start":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-inline-start-color","border-inline-start-style","border-inline-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start"},"border-inline-start-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"},"border-inline-start-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"},"border-inline-start-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"},"border-left":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-left-color","border-left-style","border-left-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-left-width","border-left-style","border-left-color"],"appliesto":"allElements","computed":["border-left-width","border-left-style","border-left-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left"},"border-left-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-color"},"border-left-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-style"},"border-left-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderLeftStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-width"},"border-radius":{"syntax":"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?","media":"visual","inherited":false,"animationType":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-radius"},"border-right":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-right-color","border-right-style","border-right-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-right-width","border-right-style","border-right-color"],"appliesto":"allElements","computed":["border-right-width","border-right-style","border-right-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right"},"border-right-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-color"},"border-right-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-style"},"border-right-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderRightStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-width"},"border-spacing":{"syntax":"<length> <length>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"0","appliesto":"tableElements","computed":"twoAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-spacing"},"border-start-end-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"},"border-start-start-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"},"border-style":{"syntax":"<line-style>{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-style","border-right-style","border-bottom-style","border-left-style"],"appliesto":"allElements","computed":["border-bottom-style","border-left-style","border-right-style","border-top-style"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-style"},"border-top":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-top-color","border-top-style","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top"},"border-top-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-color"},"border-top-left-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"},"border-top-right-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"},"border-top-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-style"},"border-top-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderTopStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-width"},"border-width":{"syntax":"<line-width>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-right-width","border-bottom-width","border-left-width"],"appliesto":"allElements","computed":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-width"},"bottom":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/bottom"},"box-align":{"syntax":"start | center | end | baseline | stretch","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"stretch","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-align"},"box-decoration-break":{"syntax":"slice | clone","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"slice","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"},"box-direction":{"syntax":"normal | reverse | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"normal","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-direction"},"box-flex":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"0","appliesto":"directChildrenOfElementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex"},"box-flex-group":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"inFlowChildrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex-group"},"box-lines":{"syntax":"single | multiple","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"single","appliesto":"boxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-lines"},"box-ordinal-group":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"childrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"},"box-orient":{"syntax":"horizontal | vertical | inline-axis | block-axis | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"inlineAxisHorizontalInXUL","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-orient"},"box-pack":{"syntax":"start | center | end | justify","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"start","appliesto":"elementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-pack"},"box-shadow":{"syntax":"none | <shadow>#","media":"visual","inherited":false,"animationType":"shadowList","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"absoluteLengthsSpecifiedColorAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-shadow"},"box-sizing":{"syntax":"content-box | border-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"content-box","appliesto":"allElementsAcceptingWidthOrHeight","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-sizing"},"break-after":{"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-after"},"break-before":{"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-before"},"break-inside":{"syntax":"auto | avoid | avoid-page | avoid-column | avoid-region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-inside"},"caption-side":{"syntax":"top | bottom | block-start | block-end | inline-start | inline-end","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"top","appliesto":"tableCaptionElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caption-side"},"caret-color":{"syntax":"auto | <color>","media":"interactive","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asAutoOrColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caret-color"},"clear":{"syntax":"none | left | right | both | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clear"},"clip":{"syntax":"<shape> | auto","media":"visual","inherited":false,"animationType":"rectangle","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"absolutelyPositionedElements","computed":"autoOrRectangle","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip"},"clip-path":{"syntax":"<clip-source> | [ <basic-shape> || <geometry-box> ] | none","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"referToReferenceBoxWhenSpecifiedOtherwiseBorderBox","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip-path"},"color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Color"],"initial":"canvastext","appliesto":"allElementsAndText","computed":"computedColor","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color"},"print-color-adjust":{"syntax":"economy | exact","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Color"],"initial":"economy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"},"color-scheme":{"syntax":"normal | [ light | dark | <custom-ident> ]+ && only?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Color"],"initial":"normal","appliesto":"allElementsAndText","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color-scheme"},"column-count":{"syntax":"<integer> | auto","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-count"},"column-fill":{"syntax":"auto | balance | balance-all","media":"visualInContinuousMediaNoEffectInOverflowColumns","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"balance","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-fill"},"column-gap":{"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},"column-rule":{"syntax":"<\'column-rule-width\'> || <\'column-rule-style\'> || <\'column-rule-color\'>","media":"visual","inherited":false,"animationType":["column-rule-color","column-rule-style","column-rule-width"],"percentages":"no","groups":["CSS Columns"],"initial":["column-rule-width","column-rule-style","column-rule-color"],"appliesto":"multicolElements","computed":["column-rule-color","column-rule-style","column-rule-width"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule"},"column-rule-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Columns"],"initial":"currentcolor","appliesto":"multicolElements","computed":"computedColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-color"},"column-rule-style":{"syntax":"<\'border-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-style"},"column-rule-width":{"syntax":"<\'border-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"medium","appliesto":"multicolElements","computed":"absoluteLength0IfColumnRuleStyleNoneOrHidden","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-width"},"column-span":{"syntax":"none | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"inFlowBlockLevelElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-span"},"column-width":{"syntax":"<length> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"absoluteLengthZeroOrLarger","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-width"},"columns":{"syntax":"<\'column-width\'> || <\'column-count\'>","media":"visual","inherited":false,"animationType":["column-width","column-count"],"percentages":"no","groups":["CSS Columns"],"initial":["column-width","column-count"],"appliesto":"blockContainersExceptTableWrappers","computed":["column-width","column-count"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/columns"},"contain":{"syntax":"none | strict | content | [ size || layout || style || paint ]","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain"},"content":{"syntax":"normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"normal","appliesto":"allElementsTreeAbidingPseudoElementsPageMarginBoxes","computed":"normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/content"},"content-visibility":{"syntax":"visible | auto | hidden","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Containment"],"initial":"visible","appliesto":"elementsForWhichLayoutContainmentCanApply","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/content-visibility"},"counter-increment":{"syntax":"[ <counter-name> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-increment"},"counter-reset":{"syntax":"[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-reset"},"counter-set":{"syntax":"[ <counter-name> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-set"},"cursor":{"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]","media":["visual","interactive"],"inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/cursor"},"direction":{"syntax":"ltr | rtl","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"ltr","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/direction"},"display":{"syntax":"[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>","media":"all","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Display"],"initial":"inline","appliesto":"allElements","computed":"asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/display"},"empty-cells":{"syntax":"show | hide","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"show","appliesto":"tableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/empty-cells"},"filter":{"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/filter"},"flex":{"syntax":"none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]","media":"visual","inherited":false,"animationType":["flex-grow","flex-shrink","flex-basis"],"percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-grow","flex-shrink","flex-basis"],"appliesto":"flexItemsAndInFlowPseudos","computed":["flex-grow","flex-shrink","flex-basis"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex"},"flex-basis":{"syntax":"content | <\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToFlexContainersInnerMainSize","groups":["CSS Flexible Box Layout"],"initial":"auto","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-basis"},"flex-direction":{"syntax":"row | row-reverse | column | column-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"row","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-direction"},"flex-flow":{"syntax":"<\'flex-direction\'> || <\'flex-wrap\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-direction","flex-wrap"],"appliesto":"flexContainers","computed":["flex-direction","flex-wrap"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-flow"},"flex-grow":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-grow"},"flex-shrink":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"1","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-shrink"},"flex-wrap":{"syntax":"nowrap | wrap | wrap-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"nowrap","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-wrap"},"float":{"syntax":"left | right | none | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"allElementsNoEffectIfDisplayNone","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/float"},"font":{"syntax":"[ [ <\'font-style\'> || <font-variant-css21> || <\'font-weight\'> || <\'font-stretch\'> ]? <\'font-size\'> [ / <\'line-height\'> ]? <\'font-family\'> ] | caption | icon | menu | message-box | small-caption | status-bar","media":"visual","inherited":true,"animationType":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"percentages":["font-size","line-height"],"groups":["CSS Fonts"],"initial":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"appliesto":"allElements","computed":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font"},"font-family":{"syntax":"[ <family-name> | <generic-family> ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-family"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"},"font-kerning":{"syntax":"auto | normal | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-kerning"},"font-language-override":{"syntax":"normal | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-language-override"},"font-optical-sizing":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"visual","inherited":true,"animationType":"transform","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"},"font-size":{"syntax":"<absolute-size> | <relative-size> | <length-percentage>","media":"visual","inherited":true,"animationType":"length","percentages":"referToParentElementsFontSize","groups":["CSS Fonts"],"initial":"medium","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size"},"font-size-adjust":{"syntax":"none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]","media":"visual","inherited":true,"animationType":"number","percentages":"no","groups":["CSS Fonts"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"},"font-smooth":{"syntax":"auto | never | always | <absolute-size> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-smooth"},"font-stretch":{"syntax":"<font-stretch-absolute>","media":"visual","inherited":true,"animationType":"fontStretch","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-stretch"},"font-style":{"syntax":"normal | italic | oblique <angle>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-style"},"font-synthesis":{"syntax":"none | [ weight || style || small-caps ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"weight style","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-synthesis"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant"},"font-variant-alternates":{"syntax":"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"},"font-variant-caps":{"syntax":"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"},"font-variant-east-asian":{"syntax":"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"},"font-variant-ligatures":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"},"font-variant-numeric":{"syntax":"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"},"font-variant-position":{"syntax":"normal | sub | super","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-position"},"font-weight":{"syntax":"<font-weight-absolute> | bolder | lighter","media":"visual","inherited":true,"animationType":"fontWeight","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"keywordOrNumericalValueBolderLighterTransformedToRealValue","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-weight"},"forced-color-adjust":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["CSS Color"],"initial":"auto","appliesto":"allElementsAndText","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"},"gap":{"syntax":"<\'row-gap\'> <\'column-gap\'>?","media":"visual","inherited":false,"animationType":["row-gap","column-gap"],"percentages":"no","groups":["CSS Box Alignment"],"initial":["row-gap","column-gap"],"appliesto":"multiColumnElementsFlexContainersGridContainers","computed":["row-gap","column-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},"grid":{"syntax":"<\'grid-template\'> | <\'grid-template-rows\'> / [ auto-flow && dense? ] <\'grid-auto-columns\'>? | [ auto-flow && dense? ] <\'grid-auto-rows\'>? / <\'grid-template-columns\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-rows","grid-template-columns","grid-auto-rows","grid-auto-columns"],"groups":["CSS Grid Layout"],"initial":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"appliesto":"gridContainers","computed":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid"},"grid-area":{"syntax":"<grid-line> [ / <grid-line> ]{0,3}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-area"},"grid-auto-columns":{"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"},"grid-auto-flow":{"syntax":"[ row | column ] || dense","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"row","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"},"grid-auto-rows":{"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"},"grid-column":{"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-column-start","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-column-start","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column"},"grid-column-end":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-end"},"grid-column-gap":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},"grid-column-start":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-start"},"grid-gap":{"syntax":"<\'grid-row-gap\'> <\'grid-column-gap\'>?","media":"visual","inherited":false,"animationType":["grid-row-gap","grid-column-gap"],"percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-gap","grid-column-gap"],"appliesto":"gridContainers","computed":["grid-row-gap","grid-column-gap"],"order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},"grid-row":{"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-row-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-row-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row"},"grid-row-end":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-end"},"grid-row-gap":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},"grid-row-start":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-start"},"grid-template":{"syntax":"none | [ <\'grid-template-rows\'> / <\'grid-template-columns\'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-columns","grid-template-rows"],"groups":["CSS Grid Layout"],"initial":["grid-template-columns","grid-template-rows","grid-template-areas"],"appliesto":"gridContainers","computed":["grid-template-columns","grid-template-rows","grid-template-areas"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template"},"grid-template-areas":{"syntax":"none | <string>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"},"grid-template-columns":{"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"},"grid-template-rows":{"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"},"hanging-punctuation":{"syntax":"none | [ first || [ force-end | allow-end ] || last ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"},"height":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAutoOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/height"},"hyphenate-character":{"syntax":"auto | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"},"hyphens":{"syntax":"none | manual | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"manual","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hyphens"},"image-orientation":{"syntax":"from-image | <angle> | [ <angle>? flip ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"from-image","appliesto":"allElements","computed":"angleRoundedToNextQuarter","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-orientation"},"image-rendering":{"syntax":"auto | crisp-edges | pixelated","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-rendering"},"image-resolution":{"syntax":"[ from-image || <resolution> ] && snap?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"1dppx","appliesto":"allElements","computed":"asSpecifiedWithExceptionOfResolution","order":"uniqueOrder","status":"experimental"},"ime-mode":{"syntax":"auto | normal | active | inactive | disabled","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"textFields","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ime-mode"},"initial-letter":{"syntax":"normal | [ <number> <integer>? ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"normal","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter"},"initial-letter-align":{"syntax":"[ auto | alphabetic | hanging | ideographic ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"auto","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"},"inline-size":{"syntax":"<\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inline-size"},"input-security":{"syntax":"auto | none","media":"interactive","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"sensitiveTextInputs","computed":"asSpecified","order":"perGrammar","status":"standard"},"inset":{"syntax":"<\'top\'>{1,4}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOrWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset"},"inset-block":{"syntax":"<\'top\'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block"},"inset-block-end":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-end"},"inset-block-start":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-start"},"inset-inline":{"syntax":"<\'top\'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline"},"inset-inline-end":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"},"inset-inline-start":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"},"isolation":{"syntax":"auto | isolate","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"auto","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/isolation"},"justify-content":{"syntax":"normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-content"},"justify-items":{"syntax":"normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"legacy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-items"},"justify-self":{"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-self"},"justify-tracks":{"syntax":"[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirInlineAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-tracks"},"left":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/left"},"letter-spacing":{"syntax":"normal | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumValueOfAbsoluteLengthOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/letter-spacing"},"line-break":{"syntax":"auto | loose | normal | strict | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-break"},"line-clamp":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"line-height":{"syntax":"normal | <number> | <length> | <percentage>","media":"visual","inherited":true,"animationType":"numberOrLength","percentages":"referToElementFontSize","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"absoluteLengthOrAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height"},"line-height-step":{"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"0","appliesto":"blockContainers","computed":"absoluteLength","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height-step"},"list-style":{"syntax":"<\'list-style-type\'> || <\'list-style-position\'> || <\'list-style-image\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":["list-style-type","list-style-position","list-style-image"],"appliesto":"listItems","computed":["list-style-image","list-style-position","list-style-type"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style"},"list-style-image":{"syntax":"<image> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"none","appliesto":"listItems","computed":"theKeywordListStyleImageNoneOrComputedValue","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-image"},"list-style-position":{"syntax":"inside | outside","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"outside","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-position"},"list-style-type":{"syntax":"<counter-style> | <string> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"disc","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-type"},"margin":{"syntax":"[ <length> | <percentage> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["margin-bottom","margin-left","margin-right","margin-top"],"appliesto":"allElementsExceptTableDisplayTypes","computed":["margin-bottom","margin-left","margin-right","margin-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin"},"margin-block":{"syntax":"<\'margin-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block"},"margin-block-end":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-end"},"margin-block-start":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-start"},"margin-bottom":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-bottom"},"margin-inline":{"syntax":"<\'margin-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline"},"margin-inline-end":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"},"margin-inline-start":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"},"margin-left":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-left"},"margin-right":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-right"},"margin-top":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-top"},"margin-trim":{"syntax":"none | in-flow | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"none","appliesto":"blockContainersAndMultiColumnContainers","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line"],"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-trim"},"mask":{"syntax":"<mask-layer>#","media":"visual","inherited":false,"animationType":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"percentages":["mask-position"],"groups":["CSS Masking"],"initial":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"appliesto":"allElementsSVGContainerElements","computed":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},"mask-border":{"syntax":"<\'mask-border-source\'> || <\'mask-border-slice\'> [ / <\'mask-border-width\'>? [ / <\'mask-border-outset\'> ]? ]? || <\'mask-border-repeat\'> || <\'mask-border-mode\'>","media":"visual","inherited":false,"animationType":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"percentages":["mask-border-slice","mask-border-width"],"groups":["CSS Masking"],"initial":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"appliesto":"allElementsSVGContainerElements","computed":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border"},"mask-border-mode":{"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"alpha","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"},"mask-border-outset":{"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"},"mask-border-repeat":{"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"stretch","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"},"mask-border-slice":{"syntax":"<number-percentage>{1,4} fill?","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfMaskBorderImage","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"},"mask-border-source":{"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-source"},"mask-border-width":{"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToMaskBorderImageArea","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-width"},"mask-clip":{"syntax":"[ <geometry-box> | no-clip ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},"mask-composite":{"syntax":"<compositing-operator>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"add","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-composite"},"mask-image":{"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},"mask-mode":{"syntax":"<masking-mode>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"match-source","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-mode"},"mask-origin":{"syntax":"<geometry-box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},"mask-position":{"syntax":"<position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfMaskPaintingArea","groups":["CSS Masking"],"initial":"center","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoKeywordsForOriginAndOffsets","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},"mask-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"no-repeat","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoDimensionKeywords","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},"mask-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},"mask-type":{"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"luminance","appliesto":"maskElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-type"},"masonry-auto-flow":{"syntax":"[ pack | next ] || [ definite-first | ordered ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"pack","appliesto":"gridContainersWithMasonryLayout","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"},"math-style":{"syntax":"normal | compact","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["MathML"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/math-style"},"max-block-size":{"syntax":"<\'max-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"none","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-block-size"},"max-height":{"syntax":"none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesNone","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-height"},"max-inline-size":{"syntax":"<\'max-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"none","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-inline-size"},"max-lines":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"max-width":{"syntax":"none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-width"},"min-block-size":{"syntax":"<\'min-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-block-size"},"min-height":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentages0","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-height"},"min-inline-size":{"syntax":"<\'min-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-inline-size"},"min-width":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-width"},"mix-blend-mode":{"syntax":"<blend-mode> | plus-lighter","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"},"object-fit":{"syntax":"fill | contain | cover | none | scale-down","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"fill","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-fit"},"object-position":{"syntax":"<position>","media":"visual","inherited":true,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToWidthAndHeightOfElement","groups":["CSS Images"],"initial":"50% 50%","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-position"},"offset":{"syntax":"[ <\'offset-position\'>? [ <\'offset-path\'> [ <\'offset-distance\'> || <\'offset-rotate\'> ]? ]? ]! [ / <\'offset-anchor\'> ]?","media":"visual","inherited":false,"animationType":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"percentages":["offset-position","offset-distance","offset-anchor"],"groups":["CSS Motion Path"],"initial":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"appliesto":"transformableElements","computed":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset"},"offset-anchor":{"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"relativeToWidthAndHeight","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard"},"offset-distance":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToTotalPathLength","groups":["CSS Motion Path"],"initial":"0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-distance"},"offset-path":{"syntax":"none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-path"},"offset-position":{"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"referToSizeOfContainingBlock","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"experimental"},"offset-rotate":{"syntax":"[ auto | reverse ] || <angle>","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-rotate"},"opacity":{"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"mapToRange0To1","groups":["CSS Color"],"initial":"1","appliesto":"allElements","computed":"specifiedValueNumberClipped0To1","order":"perGrammar","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/opacity"},"order":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsGridItemsAbsolutelyPositionedContainerChildren","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/order"},"orphans":{"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/orphans"},"outline":{"syntax":"[ <\'outline-color\'> || <\'outline-style\'> || <\'outline-width\'> ]","media":["visual","interactive"],"inherited":false,"animationType":["outline-color","outline-width","outline-style"],"percentages":"no","groups":["CSS Basic User Interface"],"initial":["outline-color","outline-style","outline-width"],"appliesto":"allElements","computed":["outline-color","outline-width","outline-style"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline"},"outline-color":{"syntax":"<color> | invert","media":["visual","interactive"],"inherited":false,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"invertOrCurrentColor","appliesto":"allElements","computed":"invertForTranslucentColorRGBAOtherwiseRGB","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-color"},"outline-offset":{"syntax":"<length>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"0","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-offset"},"outline-style":{"syntax":"auto | <\'border-style\'>","media":["visual","interactive"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-style"},"outline-width":{"syntax":"<line-width>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"medium","appliesto":"allElements","computed":"absoluteLength0ForNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-width"},"overflow":{"syntax":"[ visible | hidden | clip | scroll | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":["overflow-x","overflow-y"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow"},"overflow-anchor":{"syntax":"auto | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Anchoring"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard"},"overflow-block":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},"overflow-clip-box":{"syntax":"padding-box | content-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"},"overflow-clip-margin":{"syntax":"<visual-box> || <length [0,∞]>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"0px","appliesto":"allElements","computed":"theComputedLength","order":"perGrammar","status":"standard"},"overflow-inline":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},"overflow-wrap":{"syntax":"normal | break-word | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},"overflow-x":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-x"},"overflow-y":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-y"},"overscroll-behavior":{"syntax":"[ contain | none | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["overscroll-behavior-x","overscroll-behavior-y"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"},"overscroll-behavior-block":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"},"overscroll-behavior-inline":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"},"overscroll-behavior-x":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"},"overscroll-behavior-y":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"},"padding":{"syntax":"[ <length> | <percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["padding-bottom","padding-left","padding-right","padding-top"],"appliesto":"allElementsExceptInternalTableDisplayTypes","computed":["padding-bottom","padding-left","padding-right","padding-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding"},"padding-block":{"syntax":"<\'padding-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block"},"padding-block-end":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-end"},"padding-block-start":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-start"},"padding-bottom":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-bottom"},"padding-inline":{"syntax":"<\'padding-left\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline"},"padding-inline-end":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"},"padding-inline-start":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"},"padding-left":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-left"},"padding-right":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-right"},"padding-top":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-top"},"page-break-after":{"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-after"},"page-break-before":{"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-before"},"page-break-inside":{"syntax":"auto | avoid","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-inside"},"paint-order":{"syntax":"normal | [ fill || stroke || markers ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/paint-order"},"perspective":{"syntax":"none | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"absoluteLengthOrNone","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective"},"perspective-origin":{"syntax":"<position>","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50%","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective-origin"},"place-content":{"syntax":"<\'align-content\'> <\'justify-content\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-content"},"place-items":{"syntax":"<\'align-items\'> <\'justify-items\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-items","justify-items"],"appliesto":"allElements","computed":["align-items","justify-items"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-items"},"place-self":{"syntax":"<\'align-self\'> <\'justify-self\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-self","justify-self"],"appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":["align-self","justify-self"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-self"},"pointer-events":{"syntax":"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/pointer-events"},"position":{"syntax":"static | relative | absolute | sticky | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"static","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/position"},"quotes":{"syntax":"none | auto | [ <string> <string> ]+","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/quotes"},"resize":{"syntax":"none | both | horizontal | vertical | block | inline","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"elementsWithOverflowNotVisibleAndReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/resize"},"right":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/right"},"rotate":{"syntax":"none | <angle> | [ x | y | z | <number>{3} ] && <angle>","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/rotate"},"row-gap":{"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},"ruby-align":{"syntax":"start | center | space-between | space-around","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"space-around","appliesto":"rubyBasesAnnotationsBaseAnnotationContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-align"},"ruby-merge":{"syntax":"separate | collapse | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"separate","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"ruby-position":{"syntax":"[ alternate || [ over | under ] ] | inter-character","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"alternate","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-position"},"scale":{"syntax":"none | <number>{1,3}","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scale"},"scrollbar-color":{"syntax":"auto | <color>{2}","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"},"scrollbar-gutter":{"syntax":"auto | stable && both-edges?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"},"scrollbar-width":{"syntax":"auto | thin | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"},"scroll-behavior":{"syntax":"auto | smooth","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSSOM View"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"},"scroll-margin":{"syntax":"<length>{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin"},"scroll-margin-block":{"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"},"scroll-margin-block-start":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"},"scroll-margin-block-end":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"},"scroll-margin-bottom":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"},"scroll-margin-inline":{"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"},"scroll-margin-inline-start":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"},"scroll-margin-inline-end":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"},"scroll-margin-left":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"},"scroll-margin-right":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"},"scroll-margin-top":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"},"scroll-padding":{"syntax":"[ auto | <length-percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding"},"scroll-padding-block":{"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"},"scroll-padding-block-start":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"},"scroll-padding-block-end":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"},"scroll-padding-bottom":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"},"scroll-padding-inline":{"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"},"scroll-padding-inline-start":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"},"scroll-padding-inline-end":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"},"scroll-padding-left":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"},"scroll-padding-right":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"},"scroll-padding-top":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"},"scroll-snap-align":{"syntax":"[ none | start | end | center ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"},"scroll-snap-coordinate":{"syntax":"none | <position>#","media":"interactive","inherited":false,"animationType":"position","percentages":"referToBorderBox","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"},"scroll-snap-destination":{"syntax":"<position>","media":"interactive","inherited":false,"animationType":"position","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"0px 0px","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"},"scroll-snap-points-x":{"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"},"scroll-snap-points-y":{"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"},"scroll-snap-stop":{"syntax":"normal | always","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"},"scroll-snap-type":{"syntax":"none | [ x | y | block | inline | both ] [ mandatory | proximity ]?","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"},"scroll-snap-type-x":{"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"},"scroll-snap-type-y":{"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"},"shape-image-threshold":{"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Shapes"],"initial":"0.0","appliesto":"floats","computed":"specifiedValueNumberClipped0To1","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"},"shape-margin":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Shapes"],"initial":"0","appliesto":"floats","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-margin"},"shape-outside":{"syntax":"none | [ <shape-box> || <basic-shape> ] | <image>","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"no","groups":["CSS Shapes"],"initial":"none","appliesto":"floats","computed":"asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-outside"},"tab-size":{"syntax":"<integer> | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"8","appliesto":"blockContainers","computed":"specifiedIntegerOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/tab-size"},"table-layout":{"syntax":"auto | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"auto","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/table-layout"},"text-align":{"syntax":"start | end | left | right | center | justify | match-parent","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"startOrNamelessValueIfLTRRightIfRTL","appliesto":"blockContainers","computed":"asSpecifiedExceptMatchParent","order":"orderOfAppearance","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align"},"text-align-last":{"syntax":"auto | start | end | left | right | center | justify","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"blockContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align-last"},"text-combine-upright":{"syntax":"none | all | [ digits <integer>? ]","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["CSS Writing Modes"],"initial":"none","appliesto":"nonReplacedInlineElements","computed":"keywordPlusIntegerIfDigits","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"},"text-decoration":{"syntax":"<\'text-decoration-line\'> || <\'text-decoration-style\'> || <\'text-decoration-color\'> || <\'text-decoration-thickness\'>","media":"visual","inherited":false,"animationType":["text-decoration-color","text-decoration-style","text-decoration-line","text-decoration-thickness"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-decoration-color","text-decoration-style","text-decoration-line"],"appliesto":"allElements","computed":["text-decoration-line","text-decoration-style","text-decoration-color","text-decoration-thickness"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration"},"text-decoration-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"},"text-decoration-line":{"syntax":"none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"},"text-decoration-skip":{"syntax":"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"objects","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"},"text-decoration-skip-ink":{"syntax":"auto | all | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"},"text-decoration-style":{"syntax":"solid | double | dotted | dashed | wavy","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"solid","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"},"text-decoration-thickness":{"syntax":"auto | from-font | <length> | <percentage> ","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"},"text-emphasis":{"syntax":"<\'text-emphasis-style\'> || <\'text-emphasis-color\'>","media":"visual","inherited":false,"animationType":["text-emphasis-color","text-emphasis-style"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-emphasis-style","text-emphasis-color"],"appliesto":"allElements","computed":["text-emphasis-style","text-emphasis-color"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis"},"text-emphasis-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"},"text-emphasis-position":{"syntax":"[ over | under ] && [ right | left ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"over right","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"},"text-emphasis-style":{"syntax":"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"},"text-indent":{"syntax":"<length-percentage> && hanging? && each-line?","media":"visual","inherited":true,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Text"],"initial":"0","appliesto":"blockContainers","computed":"percentageOrAbsoluteLengthPlusKeywords","order":"lengthOrPercentageBeforeKeywords","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-indent"},"text-justify":{"syntax":"auto | inter-character | inter-word | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"inlineLevelAndTableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-justify"},"text-orientation":{"syntax":"mixed | upright | sideways","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"mixed","appliesto":"allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-orientation"},"text-overflow":{"syntax":"[ clip | ellipsis | <string> ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"clip","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-overflow"},"text-rendering":{"syntax":"auto | optimizeSpeed | optimizeLegibility | geometricPrecision","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Miscellaneous"],"initial":"auto","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-rendering"},"text-shadow":{"syntax":"none | <shadow-t>#","media":"visual","inherited":true,"animationType":"shadowList","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"colorPlusThreeAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-shadow"},"text-size-adjust":{"syntax":"none | auto | <percentage>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToSizeOfFont","groups":["CSS Text"],"initial":"autoForSmartphoneBrowsersSupportingInflation","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"},"text-transform":{"syntax":"none | capitalize | uppercase | lowercase | full-width | full-size-kana","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-transform"},"text-underline-offset":{"syntax":"auto | <length> | <percentage> ","media":"visual","inherited":true,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"},"text-underline-position":{"syntax":"auto | from-font | [ under || [ left | right ] ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-position"},"top":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/top"},"touch-action":{"syntax":"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Pointer Events"],"initial":"auto","appliesto":"allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/touch-action"},"transform":{"syntax":"none | <transform-list>","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform"},"transform-box":{"syntax":"content-box | border-box | fill-box | stroke-box | view-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"view-box","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-box"},"transform-origin":{"syntax":"[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50% 0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-origin"},"transform-style":{"syntax":"flat | preserve-3d","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"flat","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-style"},"transition":{"syntax":"<single-transition>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":["transition-delay","transition-duration","transition-property","transition-timing-function"],"appliesto":"allElementsAndPseudos","computed":["transition-delay","transition-duration","transition-property","transition-timing-function"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition"},"transition-delay":{"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-delay"},"transition-duration":{"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-duration"},"transition-property":{"syntax":"none | <single-transition-property>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"all","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-property"},"transition-timing-function":{"syntax":"<easing-function>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"},"translate":{"syntax":"none | <length-percentage> [ <length-percentage> <length>? ]?","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/translate"},"unicode-bidi":{"syntax":"normal | embed | isolate | bidi-override | isolate-override | plaintext","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"normal","appliesto":"allElementsSomeValuesNoEffectOnNonInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"},"user-select":{"syntax":"auto | text | none | contain | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/user-select"},"vertical-align":{"syntax":"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"referToLineHeight","groups":["CSS Table"],"initial":"baseline","appliesto":"inlineLevelAndTableCellElements","computed":"absoluteLengthOrKeyword","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/vertical-align"},"visibility":{"syntax":"visible | hidden | collapse","media":"visual","inherited":true,"animationType":"visibility","percentages":"no","groups":["CSS Box Model"],"initial":"visible","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/visibility"},"white-space":{"syntax":"normal | pre | nowrap | pre-wrap | pre-line | break-spaces","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/white-space"},"widows":{"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/widows"},"width":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAutoOrAbsoluteLength","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/width"},"will-change":{"syntax":"auto | <animateable-feature>#","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Will Change"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/will-change"},"word-break":{"syntax":"normal | break-all | keep-all | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-break"},"word-spacing":{"syntax":"normal | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"referToWidthOfAffectedGlyph","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-spacing"},"word-wrap":{"syntax":"normal | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},"writing-mode":{"syntax":"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"horizontal-tb","appliesto":"allElementsExceptTableRowColumnGroupsTableRowsColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/writing-mode"},"z-index":{"syntax":"auto | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/z-index"},"zoom":{"syntax":"normal | reset | <number> | <percentage>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["Microsoft Extensions"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/zoom"}}',
      );
    },
    8022: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"absolute-size":{"syntax":"xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"},"alpha-value":{"syntax":"<number> | <percentage>"},"angle-percentage":{"syntax":"<angle> | <percentage>"},"angular-color-hint":{"syntax":"<angle-percentage>"},"angular-color-stop":{"syntax":"<color> && <color-stop-angle>?"},"angular-color-stop-list":{"syntax":"[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"},"animateable-feature":{"syntax":"scroll-position | contents | <custom-ident>"},"attachment":{"syntax":"scroll | fixed | local"},"attr()":{"syntax":"attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"},"attr-matcher":{"syntax":"[ \'~\' | \'|\' | \'^\' | \'$\' | \'*\' ]? \'=\'"},"attr-modifier":{"syntax":"i | s"},"attribute-selector":{"syntax":"\'[\' <wq-name> \']\' | \'[\' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? \']\'"},"auto-repeat":{"syntax":"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},"auto-track-list":{"syntax":"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"},"baseline-position":{"syntax":"[ first | last ]? baseline"},"basic-shape":{"syntax":"<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"},"bg-image":{"syntax":"none | <image>"},"bg-layer":{"syntax":"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},"bg-position":{"syntax":"[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"},"bg-size":{"syntax":"[ <length-percentage> | auto ]{1,2} | cover | contain"},"blur()":{"syntax":"blur( <length> )"},"blend-mode":{"syntax":"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"},"box":{"syntax":"border-box | padding-box | content-box"},"brightness()":{"syntax":"brightness( <number-percentage> )"},"calc()":{"syntax":"calc( <calc-sum> )"},"calc-sum":{"syntax":"<calc-product> [ [ \'+\' | \'-\' ] <calc-product> ]*"},"calc-product":{"syntax":"<calc-value> [ \'*\' <calc-value> | \'/\' <number> ]*"},"calc-value":{"syntax":"<number> | <dimension> | <percentage> | ( <calc-sum> )"},"cf-final-image":{"syntax":"<image> | <color>"},"cf-mixing-image":{"syntax":"<percentage>? && <image>"},"circle()":{"syntax":"circle( [ <shape-radius> ]? [ at <position> ]? )"},"clamp()":{"syntax":"clamp( <calc-sum>#{3} )"},"class-selector":{"syntax":"\'.\' <ident-token>"},"clip-source":{"syntax":"<url>"},"color":{"syntax":"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"},"color-stop":{"syntax":"<color-stop-length> | <color-stop-angle>"},"color-stop-angle":{"syntax":"<angle-percentage>{1,2}"},"color-stop-length":{"syntax":"<length-percentage>{1,2}"},"color-stop-list":{"syntax":"[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"},"combinator":{"syntax":"\'>\' | \'+\' | \'~\' | [ \'||\' ]"},"common-lig-values":{"syntax":"[ common-ligatures | no-common-ligatures ]"},"compat-auto":{"syntax":"searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"},"composite-style":{"syntax":"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"},"compositing-operator":{"syntax":"add | subtract | intersect | exclude"},"compound-selector":{"syntax":"[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"},"compound-selector-list":{"syntax":"<compound-selector>#"},"complex-selector":{"syntax":"<compound-selector> [ <combinator>? <compound-selector> ]*"},"complex-selector-list":{"syntax":"<complex-selector>#"},"conic-gradient()":{"syntax":"conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"},"contextual-alt-values":{"syntax":"[ contextual | no-contextual ]"},"content-distribution":{"syntax":"space-between | space-around | space-evenly | stretch"},"content-list":{"syntax":"[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"},"content-position":{"syntax":"center | start | end | flex-start | flex-end"},"content-replacement":{"syntax":"<image>"},"contrast()":{"syntax":"contrast( [ <number-percentage> ] )"},"counter":{"syntax":"<counter()> | <counters()>"},"counter()":{"syntax":"counter( <counter-name>, <counter-style>? )"},"counter-name":{"syntax":"<custom-ident>"},"counter-style":{"syntax":"<counter-style-name> | symbols()"},"counter-style-name":{"syntax":"<custom-ident>"},"counters()":{"syntax":"counters( <counter-name>, <string>, <counter-style>? )"},"cross-fade()":{"syntax":"cross-fade( <cf-mixing-image> , <cf-final-image>? )"},"cubic-bezier-timing-function":{"syntax":"ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"},"deprecated-system-color":{"syntax":"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"},"discretionary-lig-values":{"syntax":"[ discretionary-ligatures | no-discretionary-ligatures ]"},"display-box":{"syntax":"contents | none"},"display-inside":{"syntax":"flow | flow-root | table | flex | grid | ruby"},"display-internal":{"syntax":"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"},"display-legacy":{"syntax":"inline-block | inline-list-item | inline-table | inline-flex | inline-grid"},"display-listitem":{"syntax":"<display-outside>? && [ flow | flow-root ]? && list-item"},"display-outside":{"syntax":"block | inline | run-in"},"drop-shadow()":{"syntax":"drop-shadow( <length>{2,3} <color>? )"},"east-asian-variant-values":{"syntax":"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"},"east-asian-width-values":{"syntax":"[ full-width | proportional-width ]"},"element()":{"syntax":"element( <id-selector> )"},"ellipse()":{"syntax":"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"},"ending-shape":{"syntax":"circle | ellipse"},"env()":{"syntax":"env( <custom-ident> , <declaration-value>? )"},"explicit-track-list":{"syntax":"[ <line-names>? <track-size> ]+ <line-names>?"},"family-name":{"syntax":"<string> | <custom-ident>+"},"feature-tag-value":{"syntax":"<string> [ <integer> | on | off ]?"},"feature-type":{"syntax":"@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"},"feature-value-block":{"syntax":"<feature-type> \'{\' <feature-value-declaration-list> \'}\'"},"feature-value-block-list":{"syntax":"<feature-value-block>+"},"feature-value-declaration":{"syntax":"<custom-ident>: <integer>+;"},"feature-value-declaration-list":{"syntax":"<feature-value-declaration>"},"feature-value-name":{"syntax":"<custom-ident>"},"fill-rule":{"syntax":"nonzero | evenodd"},"filter-function":{"syntax":"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"},"filter-function-list":{"syntax":"[ <filter-function> | <url> ]+"},"final-bg-layer":{"syntax":"<\'background-color\'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},"fit-content()":{"syntax":"fit-content( [ <length> | <percentage> ] )"},"fixed-breadth":{"syntax":"<length-percentage>"},"fixed-repeat":{"syntax":"repeat( [ <integer [1,∞]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},"fixed-size":{"syntax":"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"},"font-stretch-absolute":{"syntax":"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"},"font-variant-css21":{"syntax":"[ normal | small-caps ]"},"font-weight-absolute":{"syntax":"normal | bold | <number [1,1000]>"},"frequency-percentage":{"syntax":"<frequency> | <percentage>"},"general-enclosed":{"syntax":"[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"},"generic-family":{"syntax":"serif | sans-serif | cursive | fantasy | monospace"},"generic-name":{"syntax":"serif | sans-serif | cursive | fantasy | monospace"},"geometry-box":{"syntax":"<shape-box> | fill-box | stroke-box | view-box"},"gradient":{"syntax":"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"},"grayscale()":{"syntax":"grayscale( <number-percentage> )"},"grid-line":{"syntax":"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"},"historical-lig-values":{"syntax":"[ historical-ligatures | no-historical-ligatures ]"},"hsl()":{"syntax":"hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"},"hsla()":{"syntax":"hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"},"hue":{"syntax":"<number> | <angle>"},"hue-rotate()":{"syntax":"hue-rotate( <angle> )"},"hwb()":{"syntax":"hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"},"id-selector":{"syntax":"<hash-token>"},"image":{"syntax":"<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"},"image()":{"syntax":"image( <image-tags>? [ <image-src>? , <color>? ]! )"},"image-set()":{"syntax":"image-set( <image-set-option># )"},"image-set-option":{"syntax":"[ <image> | <string> ] [ <resolution> || type(<string>) ]"},"image-src":{"syntax":"<url> | <string>"},"image-tags":{"syntax":"ltr | rtl"},"inflexible-breadth":{"syntax":"<length> | <percentage> | min-content | max-content | auto"},"inset()":{"syntax":"inset( <length-percentage>{1,4} [ round <\'border-radius\'> ]? )"},"invert()":{"syntax":"invert( <number-percentage> )"},"keyframes-name":{"syntax":"<custom-ident> | <string>"},"keyframe-block":{"syntax":"<keyframe-selector># {\\n  <declaration-list>\\n}"},"keyframe-block-list":{"syntax":"<keyframe-block>+"},"keyframe-selector":{"syntax":"from | to | <percentage>"},"layer()":{"syntax":"layer( <layer-name> )"},"layer-name":{"syntax":"<ident> [ \'.\' <ident> ]*"},"leader()":{"syntax":"leader( <leader-type> )"},"leader-type":{"syntax":"dotted | solid | space | <string>"},"length-percentage":{"syntax":"<length> | <percentage>"},"line-names":{"syntax":"\'[\' <custom-ident>* \']\'"},"line-name-list":{"syntax":"[ <line-names> | <name-repeat> ]+"},"line-style":{"syntax":"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"},"line-width":{"syntax":"<length> | thin | medium | thick"},"linear-color-hint":{"syntax":"<length-percentage>"},"linear-color-stop":{"syntax":"<color> <color-stop-length>?"},"linear-gradient()":{"syntax":"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},"mask-layer":{"syntax":"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"},"mask-position":{"syntax":"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"},"mask-reference":{"syntax":"none | <image> | <mask-source>"},"mask-source":{"syntax":"<url>"},"masking-mode":{"syntax":"alpha | luminance | match-source"},"matrix()":{"syntax":"matrix( <number>#{6} )"},"matrix3d()":{"syntax":"matrix3d( <number>#{16} )"},"max()":{"syntax":"max( <calc-sum># )"},"media-and":{"syntax":"<media-in-parens> [ and <media-in-parens> ]+"},"media-condition":{"syntax":"<media-not> | <media-and> | <media-or> | <media-in-parens>"},"media-condition-without-or":{"syntax":"<media-not> | <media-and> | <media-in-parens>"},"media-feature":{"syntax":"( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"},"media-in-parens":{"syntax":"( <media-condition> ) | <media-feature> | <general-enclosed>"},"media-not":{"syntax":"not <media-in-parens>"},"media-or":{"syntax":"<media-in-parens> [ or <media-in-parens> ]+"},"media-query":{"syntax":"<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"},"media-query-list":{"syntax":"<media-query>#"},"media-type":{"syntax":"<ident>"},"mf-boolean":{"syntax":"<mf-name>"},"mf-name":{"syntax":"<ident>"},"mf-plain":{"syntax":"<mf-name> : <mf-value>"},"mf-range":{"syntax":"<mf-name> [ \'<\' | \'>\' ]? \'=\'? <mf-value>\\n| <mf-value> [ \'<\' | \'>\' ]? \'=\'? <mf-name>\\n| <mf-value> \'<\' \'=\'? <mf-name> \'<\' \'=\'? <mf-value>\\n| <mf-value> \'>\' \'=\'? <mf-name> \'>\' \'=\'? <mf-value>"},"mf-value":{"syntax":"<number> | <dimension> | <ident> | <ratio>"},"min()":{"syntax":"min( <calc-sum># )"},"minmax()":{"syntax":"minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"},"name-repeat":{"syntax":"repeat( [ <integer [1,∞]> | auto-fill ], <line-names>+ )"},"named-color":{"syntax":"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"},"namespace-prefix":{"syntax":"<ident>"},"ns-prefix":{"syntax":"[ <ident-token> | \'*\' ]? \'|\'"},"number-percentage":{"syntax":"<number> | <percentage>"},"numeric-figure-values":{"syntax":"[ lining-nums | oldstyle-nums ]"},"numeric-fraction-values":{"syntax":"[ diagonal-fractions | stacked-fractions ]"},"numeric-spacing-values":{"syntax":"[ proportional-nums | tabular-nums ]"},"nth":{"syntax":"<an-plus-b> | even | odd"},"opacity()":{"syntax":"opacity( [ <number-percentage> ] )"},"overflow-position":{"syntax":"unsafe | safe"},"outline-radius":{"syntax":"<length> | <percentage>"},"page-body":{"syntax":"<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"},"page-margin-box":{"syntax":"<page-margin-box-type> \'{\' <declaration-list> \'}\'"},"page-margin-box-type":{"syntax":"@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"},"page-selector-list":{"syntax":"[ <page-selector># ]?"},"page-selector":{"syntax":"<pseudo-page>+ | <ident> <pseudo-page>*"},"page-size":{"syntax":"A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"},"path()":{"syntax":"path( [ <fill-rule>, ]? <string> )"},"paint()":{"syntax":"paint( <ident>, <declaration-value>? )"},"perspective()":{"syntax":"perspective( <length> )"},"polygon()":{"syntax":"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"},"position":{"syntax":"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"},"pseudo-class-selector":{"syntax":"\':\' <ident-token> | \':\' <function-token> <any-value> \')\'"},"pseudo-element-selector":{"syntax":"\':\' <pseudo-class-selector>"},"pseudo-page":{"syntax":": [ left | right | first | blank ]"},"quote":{"syntax":"open-quote | close-quote | no-open-quote | no-close-quote"},"radial-gradient()":{"syntax":"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},"relative-selector":{"syntax":"<combinator>? <complex-selector>"},"relative-selector-list":{"syntax":"<relative-selector>#"},"relative-size":{"syntax":"larger | smaller"},"repeat-style":{"syntax":"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"},"repeating-conic-gradient()":{"syntax":"repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"},"repeating-linear-gradient()":{"syntax":"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},"repeating-radial-gradient()":{"syntax":"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},"rgb()":{"syntax":"rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"},"rgba()":{"syntax":"rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"},"rotate()":{"syntax":"rotate( [ <angle> | <zero> ] )"},"rotate3d()":{"syntax":"rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"},"rotateX()":{"syntax":"rotateX( [ <angle> | <zero> ] )"},"rotateY()":{"syntax":"rotateY( [ <angle> | <zero> ] )"},"rotateZ()":{"syntax":"rotateZ( [ <angle> | <zero> ] )"},"saturate()":{"syntax":"saturate( <number-percentage> )"},"scale()":{"syntax":"scale( <number> , <number>? )"},"scale3d()":{"syntax":"scale3d( <number> , <number> , <number> )"},"scaleX()":{"syntax":"scaleX( <number> )"},"scaleY()":{"syntax":"scaleY( <number> )"},"scaleZ()":{"syntax":"scaleZ( <number> )"},"self-position":{"syntax":"center | start | end | self-start | self-end | flex-start | flex-end"},"shape-radius":{"syntax":"<length-percentage> | closest-side | farthest-side"},"skew()":{"syntax":"skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"},"skewX()":{"syntax":"skewX( [ <angle> | <zero> ] )"},"skewY()":{"syntax":"skewY( [ <angle> | <zero> ] )"},"sepia()":{"syntax":"sepia( <number-percentage> )"},"shadow":{"syntax":"inset? && <length>{2,4} && <color>?"},"shadow-t":{"syntax":"[ <length>{2,3} && <color>? ]"},"shape":{"syntax":"rect(<top>, <right>, <bottom>, <left>)"},"shape-box":{"syntax":"<box> | margin-box"},"side-or-corner":{"syntax":"[ left | right ] || [ top | bottom ]"},"single-animation":{"syntax":"<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"},"single-animation-direction":{"syntax":"normal | reverse | alternate | alternate-reverse"},"single-animation-fill-mode":{"syntax":"none | forwards | backwards | both"},"single-animation-iteration-count":{"syntax":"infinite | <number>"},"single-animation-play-state":{"syntax":"running | paused"},"single-animation-timeline":{"syntax":"auto | none | <timeline-name>"},"single-transition":{"syntax":"[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"},"single-transition-property":{"syntax":"all | <custom-ident>"},"size":{"syntax":"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"},"step-position":{"syntax":"jump-start | jump-end | jump-none | jump-both | start | end"},"step-timing-function":{"syntax":"step-start | step-end | steps(<integer>[, <step-position>]?)"},"subclass-selector":{"syntax":"<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"},"supports-condition":{"syntax":"not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"},"supports-in-parens":{"syntax":"( <supports-condition> ) | <supports-feature> | <general-enclosed>"},"supports-feature":{"syntax":"<supports-decl> | <supports-selector-fn>"},"supports-decl":{"syntax":"( <declaration> )"},"supports-selector-fn":{"syntax":"selector( <complex-selector> )"},"symbol":{"syntax":"<string> | <image> | <custom-ident>"},"target":{"syntax":"<target-counter()> | <target-counters()> | <target-text()>"},"target-counter()":{"syntax":"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"},"target-counters()":{"syntax":"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"},"target-text()":{"syntax":"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"},"time-percentage":{"syntax":"<time> | <percentage>"},"timeline-name":{"syntax":"<custom-ident> | <string>"},"easing-function":{"syntax":"linear | <cubic-bezier-timing-function> | <step-timing-function>"},"track-breadth":{"syntax":"<length-percentage> | <flex> | min-content | max-content | auto"},"track-list":{"syntax":"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"},"track-repeat":{"syntax":"repeat( [ <integer [1,∞]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"},"track-size":{"syntax":"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"},"transform-function":{"syntax":"<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"},"transform-list":{"syntax":"<transform-function>+"},"translate()":{"syntax":"translate( <length-percentage> , <length-percentage>? )"},"translate3d()":{"syntax":"translate3d( <length-percentage> , <length-percentage> , <length> )"},"translateX()":{"syntax":"translateX( <length-percentage> )"},"translateY()":{"syntax":"translateY( <length-percentage> )"},"translateZ()":{"syntax":"translateZ( <length> )"},"type-or-unit":{"syntax":"string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"},"type-selector":{"syntax":"<wq-name> | <ns-prefix>? \'*\'"},"var()":{"syntax":"var( <custom-property-name> , <declaration-value>? )"},"viewport-length":{"syntax":"auto | <length-percentage>"},"visual-box":{"syntax":"content-box | padding-box | border-box"},"wq-name":{"syntax":"<ns-prefix>? <ident-token>"}}',
      );
    },
    8072: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"@charset":{"syntax":"@charset \\"<charset>\\";","groups":["CSS Charsets"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@charset"},"@counter-style":{"syntax":"@counter-style <counter-style-name> {\\n  [ system: <counter-system>; ] ||\\n  [ symbols: <counter-symbols>; ] ||\\n  [ additive-symbols: <additive-symbols>; ] ||\\n  [ negative: <negative-symbol>; ] ||\\n  [ prefix: <prefix>; ] ||\\n  [ suffix: <suffix>; ] ||\\n  [ range: <range>; ] ||\\n  [ pad: <padding>; ] ||\\n  [ speak-as: <speak-as>; ] ||\\n  [ fallback: <counter-style-name>; ]\\n}","interfaces":["CSSCounterStyleRule"],"groups":["CSS Counter Styles"],"descriptors":{"additive-symbols":{"syntax":"[ <integer> && <symbol> ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"fallback":{"syntax":"<counter-style-name>","media":"all","initial":"decimal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"negative":{"syntax":"<symbol> <symbol>?","media":"all","initial":"\\"-\\" hyphen-minus","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"pad":{"syntax":"<integer> && <symbol>","media":"all","initial":"0 \\"\\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"prefix":{"syntax":"<symbol>","media":"all","initial":"\\"\\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"range":{"syntax":"[ [ <integer> | infinite ]{2} ]# | auto","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"speak-as":{"syntax":"auto | bullets | numbers | words | spell-out | <counter-style-name>","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"suffix":{"syntax":"<symbol>","media":"all","initial":"\\". \\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"symbols":{"syntax":"<symbol>+","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"system":{"syntax":"cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]","media":"all","initial":"symbolic","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@counter-style"},"@document":{"syntax":"@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule"],"groups":["CSS Conditional Rules"],"status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@document"},"@font-face":{"syntax":"@font-face {\\n  [ font-family: <family-name>; ] ||\\n  [ src: <src>; ] ||\\n  [ unicode-range: <unicode-range>; ] ||\\n  [ font-variant: <font-variant>; ] ||\\n  [ font-feature-settings: <font-feature-settings>; ] ||\\n  [ font-variation-settings: <font-variation-settings>; ] ||\\n  [ font-stretch: <font-stretch>; ] ||\\n  [ font-weight: <font-weight>; ] ||\\n  [ font-style: <font-style>; ] ||\\n  [ size-adjust: <size-adjust>; ] ||\\n  [ ascent-override: <ascent-override>; ] ||\\n  [ descent-override: <descent-override>; ] ||\\n  [ line-gap-override: <line-gap-override>; ]\\n}","interfaces":["CSSFontFaceRule"],"groups":["CSS Fonts"],"descriptors":{"ascent-override":{"syntax":"normal | <percentage>","media":"all","initial":"normal","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"descent-override":{"syntax":"normal | <percentage>","media":"all","initial":"normal","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"font-display":{"syntax":"[ auto | block | swap | fallback | optional ]","media":"visual","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"font-family":{"syntax":"<family-name>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-stretch":{"syntax":"<font-stretch-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-style":{"syntax":"normal | italic | oblique <angle>{0,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-weight":{"syntax":"<font-weight-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"line-gap-override":{"syntax":"normal | <percentage>","media":"all","initial":"normal","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"size-adjust":{"syntax":"<percentage>","media":"all","initial":"100%","percentages":"asSpecified","computed":"asSpecified","order":"orderOfAppearance","status":"experimental"},"src":{"syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"unicode-range":{"syntax":"<unicode-range>#","media":"all","initial":"U+0-10FFFF","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-face"},"@font-feature-values":{"syntax":"@font-feature-values <family-name># {\\n  <feature-value-block-list>\\n}","interfaces":["CSSFontFeatureValuesRule"],"groups":["CSS Fonts"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"},"@import":{"syntax":"@import [ <string> | <url> ]\\n        [ layer | layer(<layer-name>) ]?\\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\\n        <media-query-list>? ;","groups":["CSS Conditional Rules","Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@import"},"@keyframes":{"syntax":"@keyframes <keyframes-name> {\\n  <keyframe-block-list>\\n}","interfaces":["CSSKeyframeRule","CSSKeyframesRule"],"groups":["CSS Animations"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@keyframes"},"@layer":{"syntax":"@layer [ <layer-name># | <layer-name>?  {\\n  <stylesheet>\\n} ]","interfaces":["CSSLayerBlockRule","CSSLayerStatementRule"],"groups":["CSS Cascading and Inheritance"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@layer"},"@media":{"syntax":"@media <media-query-list> {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSMediaRule","CSSCustomMediaRule"],"groups":["CSS Conditional Rules","Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@media"},"@namespace":{"syntax":"@namespace <namespace-prefix>? [ <string> | <url> ];","groups":["CSS Namespaces"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@namespace"},"@page":{"syntax":"@page <page-selector-list> {\\n  <page-body>\\n}","interfaces":["CSSPageRule"],"groups":["CSS Pages"],"descriptors":{"bleed":{"syntax":"auto | <length>","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"marks":{"syntax":"none | [ crop || cross ]","media":["visual","paged"],"initial":"none","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"size":{"syntax":"<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@page"},"@property":{"syntax":"@property <custom-property-name> {\\n  <declaration-list>\\n}","interfaces":["CSS","CSSPropertyRule"],"groups":["CSS Houdini"],"descriptors":{"syntax":{"syntax":"<string>","media":"all","percentages":"no","initial":"n/a (required)","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"inherits":{"syntax":"true | false","media":"all","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"initial-value":{"syntax":"<string>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"experimental"}},"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@property"},"@scroll-timeline":{"syntax":"@scroll-timeline <timeline-name> { <declaration-list> }","interfaces":["ScrollTimeline"],"groups":["CSS Animations"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"},"@supports":{"syntax":"@supports <supports-condition> {\\n  <group-rule-body>\\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSSupportsRule"],"groups":["CSS Conditional Rules"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@supports"},"@viewport":{"syntax":"@viewport {\\n  <group-rule-body>\\n}","interfaces":["CSSViewportRule"],"groups":["CSS Device Adaptation"],"descriptors":{"height":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-height","max-height"],"percentages":["min-height","max-height"],"computed":["min-height","max-height"],"order":"orderOfAppearance","status":"standard"},"max-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"min-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"orientation":{"syntax":"auto | portrait | landscape","media":["visual","continuous"],"initial":"auto","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"user-zoom":{"syntax":"zoom | fixed","media":["visual","continuous"],"initial":"zoom","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"viewport-fit":{"syntax":"auto | contain | cover","media":["visual","continuous"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"width":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-width","max-width"],"percentages":["min-width","max-width"],"computed":["min-width","max-width"],"order":"orderOfAppearance","status":"standard"},"zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@viewport"}}',
      );
    },
    8837: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"--*":{"syntax":"<declaration-value>","media":"all","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Variables"],"initial":"seeProse","appliesto":"allElements","computed":"asSpecifiedWithVarsSubstituted","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/--*"},"-ms-accelerator":{"syntax":"false | true","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"false","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"},"-ms-block-progression":{"syntax":"tb | rl | bt | lr","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"tb","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"},"-ms-content-zoom-chaining":{"syntax":"none | chained","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"},"-ms-content-zooming":{"syntax":"none | zoom","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"zoomForTheTopLevelNoneForTheRest","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"},"-ms-content-zoom-limit":{"syntax":"<\'-ms-content-zoom-limit-min\'> <\'-ms-content-zoom-limit-max\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"},"-ms-content-zoom-limit-max":{"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"maxZoomFactor","groups":["Microsoft Extensions"],"initial":"400%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"},"-ms-content-zoom-limit-min":{"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"minZoomFactor","groups":["Microsoft Extensions"],"initial":"100%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"},"-ms-content-zoom-snap":{"syntax":"<\'-ms-content-zoom-snap-type\'> || <\'-ms-content-zoom-snap-points\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"},"-ms-content-zoom-snap-points":{"syntax":"snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0%, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"},"-ms-content-zoom-snap-type":{"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"},"-ms-filter":{"syntax":"<string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"\\"\\"","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-filter"},"-ms-flow-from":{"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"},"-ms-flow-into":{"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"iframeElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"},"-ms-grid-columns":{"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"},"-ms-grid-rows":{"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"},"-ms-high-contrast-adjust":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"},"-ms-hyphenate-limit-chars":{"syntax":"auto | <integer>{1,3}","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"},"-ms-hyphenate-limit-lines":{"syntax":"no-limit | <integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"no-limit","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"},"-ms-hyphenate-limit-zone":{"syntax":"<percentage> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToLineBoxWidth","groups":["Microsoft Extensions"],"initial":"0","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"},"-ms-ime-align":{"syntax":"auto | after","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"},"-ms-overflow-style":{"syntax":"auto | none | scrollbar | -ms-autohiding-scrollbar","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"},"-ms-scrollbar-3dlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"},"-ms-scrollbar-arrow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ButtonText","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"},"-ms-scrollbar-base-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"},"-ms-scrollbar-darkshadow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"},"-ms-scrollbar-face-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDFace","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"},"-ms-scrollbar-highlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDHighlight","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"},"-ms-scrollbar-shadow-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"},"-ms-scrollbar-track-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"Scrollbar","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"},"-ms-scroll-chaining":{"syntax":"chained | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"chained","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"},"-ms-scroll-limit":{"syntax":"<\'-ms-scroll-limit-x-min\'> <\'-ms-scroll-limit-y-min\'> <\'-ms-scroll-limit-x-max\'> <\'-ms-scroll-limit-y-max\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"},"-ms-scroll-limit-x-max":{"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"},"-ms-scroll-limit-x-min":{"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"},"-ms-scroll-limit-y-max":{"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"},"-ms-scroll-limit-y-min":{"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"},"-ms-scroll-rails":{"syntax":"none | railed","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"railed","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"},"-ms-scroll-snap-points-x":{"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"},"-ms-scroll-snap-points-y":{"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"},"-ms-scroll-snap-type":{"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"},"-ms-scroll-snap-x":{"syntax":"<\'-ms-scroll-snap-type\'> <\'-ms-scroll-snap-points-x\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"},"-ms-scroll-snap-y":{"syntax":"<\'-ms-scroll-snap-type\'> <\'-ms-scroll-snap-points-y\'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"},"-ms-scroll-translation":{"syntax":"none | vertical-to-horizontal","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"},"-ms-text-autospace":{"syntax":"none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"},"-ms-touch-select":{"syntax":"grippers | none","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"grippers","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"},"-ms-user-select":{"syntax":"none | element | text","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"text","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"},"-ms-wrap-flow":{"syntax":"auto | both | start | end | maximum | clear","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"},"-ms-wrap-margin":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"exclusionElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"},"-ms-wrap-through":{"syntax":"wrap | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"wrap","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"},"-moz-appearance":{"syntax":"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"-moz-binding":{"syntax":"<url> | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsExceptGeneratedContentOrPseudoElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-binding"},"-moz-border-bottom-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"},"-moz-border-left-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"},"-moz-border-right-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"},"-moz-border-top-colors":{"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"},"-moz-context-properties":{"syntax":"none | [ fill | fill-opacity | stroke | stroke-opacity ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsThatCanReferenceImages","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"},"-moz-float-edge":{"syntax":"border-box | content-box | margin-box | padding-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"content-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"},"-moz-force-broken-image-icon":{"syntax":"0 | 1","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"0","appliesto":"images","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"},"-moz-image-region":{"syntax":"<shape> | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"xulImageElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"},"-moz-orient":{"syntax":"inline | block | horizontal | vertical","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"inline","appliesto":"anyElementEffectOnProgressAndMeter","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-orient"},"-moz-outline-radius":{"syntax":"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?","media":"visual","inherited":false,"animationType":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"percentages":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"groups":["Mozilla Extensions"],"initial":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"appliesto":"allElements","computed":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"},"-moz-outline-radius-bottomleft":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"},"-moz-outline-radius-bottomright":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"},"-moz-outline-radius-topleft":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"},"-moz-outline-radius-topright":{"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"},"-moz-stack-sizing":{"syntax":"ignore | stretch-to-fit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"stretch-to-fit","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"},"-moz-text-blink":{"syntax":"none | blink","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"},"-moz-user-focus":{"syntax":"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"},"-moz-user-input":{"syntax":"auto | none | enabled | disabled","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"},"-moz-user-modify":{"syntax":"read-only | read-write | write-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"},"-moz-window-dragging":{"syntax":"drag | no-drag","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"drag","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"},"-moz-window-shadow":{"syntax":"default | menu | tooltip | sheet | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"default","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"},"-webkit-appearance":{"syntax":"none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"-webkit-border-before":{"syntax":"<\'border-width\'> || <\'border-style\'> || <color>","media":"visual","inherited":true,"animationType":"discrete","percentages":["-webkit-border-before-width"],"groups":["WebKit Extensions"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","color"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"},"-webkit-border-before-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard"},"-webkit-border-before-style":{"syntax":"<\'border-style\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},"-webkit-border-before-width":{"syntax":"<\'border-width\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["WebKit Extensions"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"nonstandard"},"-webkit-box-reflect":{"syntax":"[ above | below | right | left ]? <length>? <image>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"},"-webkit-line-clamp":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["WebKit Extensions","CSS Overflow"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"},"-webkit-mask":{"syntax":"[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"appliesto":"allElements","computed":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},"-webkit-mask-attachment":{"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"},"-webkit-mask-clip":{"syntax":"[ <box> | border | padding | content | text ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"border","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},"-webkit-mask-composite":{"syntax":"<composite-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"source-over","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"},"-webkit-mask-image":{"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"absoluteURIOrNone","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},"-webkit-mask-origin":{"syntax":"[ <box> | border | padding | content ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"padding","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},"-webkit-mask-position":{"syntax":"<position>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0% 0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},"-webkit-mask-position-x":{"syntax":"[ <length-percentage> | left | center | right ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"},"-webkit-mask-position-y":{"syntax":"[ <length-percentage> | top | center | bottom ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"},"-webkit-mask-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},"-webkit-mask-repeat-x":{"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"},"-webkit-mask-repeat-y":{"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"},"-webkit-mask-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToBackgroundPositioningArea","groups":["WebKit Extensions"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},"-webkit-overflow-scrolling":{"syntax":"auto | touch","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"},"-webkit-tap-highlight-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"black","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"},"-webkit-text-fill-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"},"-webkit-text-stroke":{"syntax":"<length> || <color>","media":"visual","inherited":true,"animationType":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"appliesto":"allElements","computed":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"order":"canonicalOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"},"-webkit-text-stroke-color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"},"-webkit-text-stroke-width":{"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"0","appliesto":"allElements","computed":"absoluteLength","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"},"-webkit-touch-callout":{"syntax":"default | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"default","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"},"-webkit-user-modify":{"syntax":"read-only | read-write | read-write-plaintext-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},"accent-color":{"syntax":"auto | <color>","media":"interactive","inherited":true,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asAutoOrColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/accent-color"},"align-content":{"syntax":"normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-content"},"align-items":{"syntax":"normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-items"},"align-self":{"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"flexItemsGridItemsAndAbsolutelyPositionedBoxes","computed":"autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-self"},"align-tracks":{"syntax":"[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirBlockAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-tracks"},"all":{"syntax":"initial | inherit | unset | revert | revert-layer","media":"noPracticalMedia","inherited":false,"animationType":"eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection","percentages":"no","groups":["CSS Miscellaneous"],"initial":"noPracticalInitialValue","appliesto":"allElements","computed":"asSpecifiedAppliesToEachProperty","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/all"},"animation":{"syntax":"<single-animation>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-iteration-count","animation-direction","animation-fill-mode","animation-play-state","animation-timeline"],"appliesto":"allElementsAndPseudos","computed":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-direction","animation-iteration-count","animation-fill-mode","animation-play-state","animation-timeline"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation"},"animation-composition":{"syntax":"<single-animation-composition>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"replace","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-composition"},"animation-delay":{"syntax":"<time>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-delay"},"animation-direction":{"syntax":"<single-animation-direction>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"normal","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-direction"},"animation-duration":{"syntax":"<time>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-duration"},"animation-fill-mode":{"syntax":"<single-animation-fill-mode>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"},"animation-iteration-count":{"syntax":"<single-animation-iteration-count>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"1","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"},"animation-name":{"syntax":"[ none | <keyframes-name> ]#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-name"},"animation-play-state":{"syntax":"<single-animation-play-state>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"running","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-play-state"},"animation-timing-function":{"syntax":"<easing-function>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"},"animation-timeline":{"syntax":"<single-animation-timeline>#","media":"visual","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"auto","appliesto":"allElements","computed":"listEachItemIdentifyerOrNoneAuto","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-timeline"},"appearance":{"syntax":"none | auto | textfield | menulist-button | <compat-auto>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},"aspect-ratio":{"syntax":"auto | <ratio>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"},"azimuth":{"syntax":"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards","media":"aural","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Speech"],"initial":"center","appliesto":"allElements","computed":"normalizedAngle","order":"orderOfAppearance","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/azimuth"},"backdrop-filter":{"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"},"backface-visibility":{"syntax":"visible | hidden","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"visible","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backface-visibility"},"background":{"syntax":"[ <bg-layer> , ]* <final-bg-layer>","media":"visual","inherited":false,"animationType":["background-color","background-image","background-clip","background-position","background-size","background-repeat","background-attachment"],"percentages":["background-position","background-size"],"groups":["CSS Backgrounds and Borders"],"initial":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"appliesto":"allElements","computed":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background"},"background-attachment":{"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-attachment"},"background-blend-mode":{"syntax":"<blend-mode>#","media":"none","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"},"background-clip":{"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"border-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-clip"},"background-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"transparent","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-color"},"background-image":{"syntax":"<bg-image>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-image"},"background-origin":{"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-origin"},"background-position":{"syntax":"<bg-position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize","groups":["CSS Backgrounds and Borders"],"initial":"0% 0%","appliesto":"allElements","computed":["background-position-x","background-position-y"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position"},"background-position-x":{"syntax":"[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"0%","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-x"},"background-position-y":{"syntax":"[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"0%","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-y"},"background-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"repeat","appliesto":"allElements","computed":"listEachItemHasTwoKeywordsOnePerDimension","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-repeat"},"background-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"relativeToBackgroundPositioningArea","groups":["CSS Backgrounds and Borders"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-size"},"block-overflow":{"syntax":"clip | ellipsis | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"clip","appliesto":"blockContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"block-size":{"syntax":"<\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/block-size"},"border":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-color","border-style","border-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-width","border-style","border-color"],"appliesto":"allElements","computed":["border-width","border-style","border-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border"},"border-block":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block"},"border-block-color":{"syntax":"<\'border-top-color\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-color"},"border-block-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-style"},"border-block-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-width"},"border-block-end":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-block-end-color","border-block-end-style","border-block-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end"},"border-block-end-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"},"border-block-end-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"},"border-block-end-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"},"border-block-start":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-block-start-color","border-block-start-style","border-block-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-block-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start"},"border-block-start-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"},"border-block-start-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"},"border-block-start-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"},"border-bottom":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-bottom-color","border-bottom-style","border-bottom-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-bottom-width","border-bottom-style","border-bottom-color"],"appliesto":"allElements","computed":["border-bottom-width","border-bottom-style","border-bottom-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom"},"border-bottom-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"},"border-bottom-left-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"},"border-bottom-right-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"},"border-bottom-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"},"border-bottom-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderBottomStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"},"border-collapse":{"syntax":"collapse | separate","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"separate","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-collapse"},"border-color":{"syntax":"<color>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-color","border-right-color","border-bottom-color","border-left-color"],"appliesto":"allElements","computed":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-color"},"border-end-end-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"},"border-end-start-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"},"border-image":{"syntax":"<\'border-image-source\'> || <\'border-image-slice\'> [ / <\'border-image-width\'> | / <\'border-image-width\'>? / <\'border-image-outset\'> ]? || <\'border-image-repeat\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["border-image-slice","border-image-width"],"groups":["CSS Backgrounds and Borders"],"initial":["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],"appliesto":"allElementsExceptTableElementsWhenCollapse","computed":["border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image"},"border-image-outset":{"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-outset"},"border-image-repeat":{"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"stretch","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"},"border-image-slice":{"syntax":"<number-percentage>{1,4} && fill?","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToSizeOfBorderImage","groups":["CSS Backgrounds and Borders"],"initial":"100%","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"oneToFourPercentagesOrAbsoluteLengthsPlusFill","order":"percentagesOrLengthsFollowedByFill","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-slice"},"border-image-source":{"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"noneOrImageWithAbsoluteURI","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-source"},"border-image-width":{"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToWidthOrHeightOfBorderImageArea","groups":["CSS Backgrounds and Borders"],"initial":"1","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-width"},"border-inline":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline"},"border-inline-end":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-inline-end-color","border-inline-end-style","border-inline-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-end-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end"},"border-inline-color":{"syntax":"<\'border-top-color\'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-color"},"border-inline-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-style"},"border-inline-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-width"},"border-inline-end-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"},"border-inline-end-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"},"border-inline-end-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"},"border-inline-start":{"syntax":"<\'border-top-width\'> || <\'border-top-style\'> || <color>","media":"visual","inherited":false,"animationType":["border-inline-start-color","border-inline-start-style","border-inline-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start"},"border-inline-start-color":{"syntax":"<\'border-top-color\'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"},"border-inline-start-style":{"syntax":"<\'border-top-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"},"border-inline-start-width":{"syntax":"<\'border-top-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"},"border-left":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-left-color","border-left-style","border-left-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-left-width","border-left-style","border-left-color"],"appliesto":"allElements","computed":["border-left-width","border-left-style","border-left-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left"},"border-left-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-color"},"border-left-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-style"},"border-left-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderLeftStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-width"},"border-radius":{"syntax":"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?","media":"visual","inherited":false,"animationType":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-radius"},"border-right":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-right-color","border-right-style","border-right-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-right-width","border-right-style","border-right-color"],"appliesto":"allElements","computed":["border-right-width","border-right-style","border-right-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right"},"border-right-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-color"},"border-right-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-style"},"border-right-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderRightStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-width"},"border-spacing":{"syntax":"<length> <length>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"0","appliesto":"tableElements","computed":"twoAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-spacing"},"border-start-end-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"},"border-start-start-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"},"border-style":{"syntax":"<line-style>{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-style","border-right-style","border-bottom-style","border-left-style"],"appliesto":"allElements","computed":["border-bottom-style","border-left-style","border-right-style","border-top-style"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-style"},"border-top":{"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-top-color","border-top-style","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top"},"border-top-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-color"},"border-top-left-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"},"border-top-right-radius":{"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"},"border-top-style":{"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-style"},"border-top-width":{"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderTopStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-width"},"border-width":{"syntax":"<line-width>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-right-width","border-bottom-width","border-left-width"],"appliesto":"allElements","computed":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-width"},"bottom":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/bottom"},"box-align":{"syntax":"start | center | end | baseline | stretch","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"stretch","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-align"},"box-decoration-break":{"syntax":"slice | clone","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"slice","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"},"box-direction":{"syntax":"normal | reverse | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"normal","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-direction"},"box-flex":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"0","appliesto":"directChildrenOfElementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex"},"box-flex-group":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"inFlowChildrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex-group"},"box-lines":{"syntax":"single | multiple","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"single","appliesto":"boxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-lines"},"box-ordinal-group":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"childrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"},"box-orient":{"syntax":"horizontal | vertical | inline-axis | block-axis | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"inlineAxisHorizontalInXUL","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-orient"},"box-pack":{"syntax":"start | center | end | justify","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"start","appliesto":"elementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-pack"},"box-shadow":{"syntax":"none | <shadow>#","media":"visual","inherited":false,"animationType":"shadowList","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"absoluteLengthsSpecifiedColorAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-shadow"},"box-sizing":{"syntax":"content-box | border-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"content-box","appliesto":"allElementsAcceptingWidthOrHeight","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-sizing"},"break-after":{"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-after"},"break-before":{"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-before"},"break-inside":{"syntax":"auto | avoid | avoid-page | avoid-column | avoid-region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-inside"},"caption-side":{"syntax":"top | bottom | block-start | block-end | inline-start | inline-end","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"top","appliesto":"tableCaptionElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caption-side"},"caret":{"syntax":"<\'caret-color\'> || <\'caret-shape\'>","media":"interactive","inherited":true,"animationType":["caret-color","caret-shape"],"percentages":"no","groups":["CSS Basic User Interface"],"initial":["caret-color","caret-shape"],"appliesto":"elementsThatAcceptInput","computed":["caret-color","caret-shape"],"order":"perGrammar","status":"standard"},"caret-color":{"syntax":"auto | <color>","media":"interactive","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asAutoOrColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caret-color"},"caret-shape":{"syntax":"auto | bar | block | underscore","media":"interactive","inherited":true,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"elementsThatAcceptInput","computed":"asSpecified","order":"perGrammar","status":"standard"},"clear":{"syntax":"none | left | right | both | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clear"},"clip":{"syntax":"<shape> | auto","media":"visual","inherited":false,"animationType":"rectangle","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"absolutelyPositionedElements","computed":"autoOrRectangle","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip"},"clip-path":{"syntax":"<clip-source> | [ <basic-shape> || <geometry-box> ] | none","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"referToReferenceBoxWhenSpecifiedOtherwiseBorderBox","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip-path"},"color":{"syntax":"<color>","media":"visual","inherited":true,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Color"],"initial":"canvastext","appliesto":"allElementsAndText","computed":"computedColor","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color"},"print-color-adjust":{"syntax":"economy | exact","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Color"],"initial":"economy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"},"color-scheme":{"syntax":"normal | [ light | dark | <custom-ident> ]+ && only?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Color"],"initial":"normal","appliesto":"allElementsAndText","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color-scheme"},"column-count":{"syntax":"<integer> | auto","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-count"},"column-fill":{"syntax":"auto | balance | balance-all","media":"visualInContinuousMediaNoEffectInOverflowColumns","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"balance","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-fill"},"column-gap":{"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},"column-rule":{"syntax":"<\'column-rule-width\'> || <\'column-rule-style\'> || <\'column-rule-color\'>","media":"visual","inherited":false,"animationType":["column-rule-color","column-rule-style","column-rule-width"],"percentages":"no","groups":["CSS Columns"],"initial":["column-rule-width","column-rule-style","column-rule-color"],"appliesto":"multicolElements","computed":["column-rule-color","column-rule-style","column-rule-width"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule"},"column-rule-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Columns"],"initial":"currentcolor","appliesto":"multicolElements","computed":"computedColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-color"},"column-rule-style":{"syntax":"<\'border-style\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-style"},"column-rule-width":{"syntax":"<\'border-width\'>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"medium","appliesto":"multicolElements","computed":"absoluteLength0IfColumnRuleStyleNoneOrHidden","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-width"},"column-span":{"syntax":"none | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"inFlowBlockLevelElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-span"},"column-width":{"syntax":"<length> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"absoluteLengthZeroOrLarger","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-width"},"columns":{"syntax":"<\'column-width\'> || <\'column-count\'>","media":"visual","inherited":false,"animationType":["column-width","column-count"],"percentages":"no","groups":["CSS Columns"],"initial":["column-width","column-count"],"appliesto":"blockContainersExceptTableWrappers","computed":["column-width","column-count"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/columns"},"contain":{"syntax":"none | strict | content | [ [ size || inline-size ] || layout || style || paint ]","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain"},"contain-intrinsic-size":{"syntax":"[ none | <length> | auto <length> ]{1,2}","media":"visual","inherited":false,"animationType":["contain-intrinsic-width","contain-intrinsic-height"],"percentages":["contain-intrinsic-width","contain-intrinsic-height"],"groups":["CSS Containment"],"initial":["contain-intrinsic-width","contain-intrinsic-height"],"appliesto":"elementsForWhichSizeContainmentCanApply","computed":["contain-intrinsic-width","contain-intrinsic-height"],"order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size"},"contain-intrinsic-block-size":{"syntax":"none | <length> | auto <length>","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"elementsForWhichSizeContainmentCanApply","computed":"asSpecifiedWithLengthValuesComputed","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size"},"contain-intrinsic-height":{"syntax":"none | <length> | auto <length>","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"elementsForWhichSizeContainmentCanApply","computed":"asSpecifiedWithLengthValuesComputed","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height"},"contain-intrinsic-inline-size":{"syntax":"none | <length> | auto <length>","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"elementsForWhichSizeContainmentCanApply","computed":"asSpecifiedWithLengthValuesComputed","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size"},"contain-intrinsic-width":{"syntax":"none | <length> | auto <length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"elementsForWhichSizeContainmentCanApply","computed":"asSpecifiedWithLengthValuesComputed","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width"},"content":{"syntax":"normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"normal","appliesto":"allElementsTreeAbidingPseudoElementsPageMarginBoxes","computed":"normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/content"},"content-visibility":{"syntax":"visible | auto | hidden","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Containment"],"initial":"visible","appliesto":"elementsForWhichLayoutContainmentCanApply","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/content-visibility"},"counter-increment":{"syntax":"[ <counter-name> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-increment"},"counter-reset":{"syntax":"[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-reset"},"counter-set":{"syntax":"[ <counter-name> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-set"},"cursor":{"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]","media":["visual","interactive"],"inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/cursor"},"direction":{"syntax":"ltr | rtl","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"ltr","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/direction"},"display":{"syntax":"[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>","media":"all","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Display"],"initial":"inline","appliesto":"allElements","computed":"asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/display"},"empty-cells":{"syntax":"show | hide","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"show","appliesto":"tableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/empty-cells"},"filter":{"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/filter"},"flex":{"syntax":"none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]","media":"visual","inherited":false,"animationType":["flex-grow","flex-shrink","flex-basis"],"percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-grow","flex-shrink","flex-basis"],"appliesto":"flexItemsAndInFlowPseudos","computed":["flex-grow","flex-shrink","flex-basis"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex"},"flex-basis":{"syntax":"content | <\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToFlexContainersInnerMainSize","groups":["CSS Flexible Box Layout"],"initial":"auto","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-basis"},"flex-direction":{"syntax":"row | row-reverse | column | column-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"row","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-direction"},"flex-flow":{"syntax":"<\'flex-direction\'> || <\'flex-wrap\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-direction","flex-wrap"],"appliesto":"flexContainers","computed":["flex-direction","flex-wrap"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-flow"},"flex-grow":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-grow"},"flex-shrink":{"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"1","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-shrink"},"flex-wrap":{"syntax":"nowrap | wrap | wrap-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"nowrap","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-wrap"},"float":{"syntax":"left | right | none | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"allElementsNoEffectIfDisplayNone","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/float"},"font":{"syntax":"[ [ <\'font-style\'> || <font-variant-css21> || <\'font-weight\'> || <\'font-stretch\'> ]? <\'font-size\'> [ / <\'line-height\'> ]? <\'font-family\'> ] | caption | icon | menu | message-box | small-caption | status-bar","media":"visual","inherited":true,"animationType":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"percentages":["font-size","line-height"],"groups":["CSS Fonts"],"initial":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"appliesto":"allElements","computed":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font"},"font-family":{"syntax":"[ <family-name> | <generic-family> ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-family"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"},"font-kerning":{"syntax":"auto | normal | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-kerning"},"font-language-override":{"syntax":"normal | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-language-override"},"font-optical-sizing":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"visual","inherited":true,"animationType":"transform","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"},"font-size":{"syntax":"<absolute-size> | <relative-size> | <length-percentage>","media":"visual","inherited":true,"animationType":"length","percentages":"referToParentElementsFontSize","groups":["CSS Fonts"],"initial":"medium","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size"},"font-size-adjust":{"syntax":"none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]","media":"visual","inherited":true,"animationType":"number","percentages":"no","groups":["CSS Fonts"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"},"font-smooth":{"syntax":"auto | never | always | <absolute-size> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-smooth"},"font-stretch":{"syntax":"<font-stretch-absolute>","media":"visual","inherited":true,"animationType":"fontStretch","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-stretch"},"font-style":{"syntax":"normal | italic | oblique <angle>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-style"},"font-synthesis":{"syntax":"none | [ weight || style || small-caps ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"weight style","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-synthesis"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant"},"font-variant-alternates":{"syntax":"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"},"font-variant-caps":{"syntax":"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"},"font-variant-east-asian":{"syntax":"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"},"font-variant-ligatures":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"},"font-variant-numeric":{"syntax":"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"},"font-variant-position":{"syntax":"normal | sub | super","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-position"},"font-weight":{"syntax":"<font-weight-absolute> | bolder | lighter","media":"visual","inherited":true,"animationType":"fontWeight","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"keywordOrNumericalValueBolderLighterTransformedToRealValue","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-weight"},"forced-color-adjust":{"syntax":"auto | none","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["CSS Color"],"initial":"auto","appliesto":"allElementsAndText","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"},"gap":{"syntax":"<\'row-gap\'> <\'column-gap\'>?","media":"visual","inherited":false,"animationType":["row-gap","column-gap"],"percentages":"no","groups":["CSS Box Alignment"],"initial":["row-gap","column-gap"],"appliesto":"multiColumnElementsFlexContainersGridContainers","computed":["row-gap","column-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},"grid":{"syntax":"<\'grid-template\'> | <\'grid-template-rows\'> / [ auto-flow && dense? ] <\'grid-auto-columns\'>? | [ auto-flow && dense? ] <\'grid-auto-rows\'>? / <\'grid-template-columns\'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-rows","grid-template-columns","grid-auto-rows","grid-auto-columns"],"groups":["CSS Grid Layout"],"initial":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"appliesto":"gridContainers","computed":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid"},"grid-area":{"syntax":"<grid-line> [ / <grid-line> ]{0,3}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-area"},"grid-auto-columns":{"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"},"grid-auto-flow":{"syntax":"[ row | column ] || dense","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"row","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"},"grid-auto-rows":{"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"},"grid-column":{"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-column-start","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-column-start","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column"},"grid-column-end":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-end"},"grid-column-gap":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},"grid-column-start":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-start"},"grid-gap":{"syntax":"<\'grid-row-gap\'> <\'grid-column-gap\'>?","media":"visual","inherited":false,"animationType":["grid-row-gap","grid-column-gap"],"percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-gap","grid-column-gap"],"appliesto":"gridContainers","computed":["grid-row-gap","grid-column-gap"],"order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},"grid-row":{"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-row-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-row-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row"},"grid-row-end":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-end"},"grid-row-gap":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},"grid-row-start":{"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-start"},"grid-template":{"syntax":"none | [ <\'grid-template-rows\'> / <\'grid-template-columns\'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-columns","grid-template-rows"],"groups":["CSS Grid Layout"],"initial":["grid-template-columns","grid-template-rows","grid-template-areas"],"appliesto":"gridContainers","computed":["grid-template-columns","grid-template-rows","grid-template-areas"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template"},"grid-template-areas":{"syntax":"none | <string>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"},"grid-template-columns":{"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"},"grid-template-rows":{"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"},"hanging-punctuation":{"syntax":"none | [ first || [ force-end | allow-end ] || last ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"},"height":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAutoOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/height"},"hyphenate-character":{"syntax":"auto | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"},"hyphens":{"syntax":"none | manual | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"manual","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hyphens"},"image-orientation":{"syntax":"from-image | <angle> | [ <angle>? flip ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"from-image","appliesto":"allElements","computed":"angleRoundedToNextQuarter","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-orientation"},"image-rendering":{"syntax":"auto | crisp-edges | pixelated","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-rendering"},"image-resolution":{"syntax":"[ from-image || <resolution> ] && snap?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"1dppx","appliesto":"allElements","computed":"asSpecifiedWithExceptionOfResolution","order":"uniqueOrder","status":"experimental"},"ime-mode":{"syntax":"auto | normal | active | inactive | disabled","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"textFields","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ime-mode"},"initial-letter":{"syntax":"normal | [ <number> <integer>? ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"normal","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter"},"initial-letter-align":{"syntax":"[ auto | alphabetic | hanging | ideographic ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"auto","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"},"inline-size":{"syntax":"<\'width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inline-size"},"input-security":{"syntax":"auto | none","media":"interactive","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"sensitiveTextInputs","computed":"asSpecified","order":"perGrammar","status":"standard"},"inset":{"syntax":"<\'top\'>{1,4}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOrWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":["top","bottom","left","right"],"appliesto":"positionedElements","computed":["top","bottom","left","right"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset"},"inset-block":{"syntax":"<\'top\'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":["inset-block-start","inset-block-end"],"appliesto":"positionedElements","computed":["inset-block-start","inset-block-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block"},"inset-block-end":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-end"},"inset-block-start":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-start"},"inset-inline":{"syntax":"<\'top\'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":["inset-inline-start","inset-inline-end"],"appliesto":"positionedElements","computed":["inset-inline-start","inset-inline-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline"},"inset-inline-end":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"},"inset-inline-start":{"syntax":"<\'top\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"},"isolation":{"syntax":"auto | isolate","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"auto","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/isolation"},"justify-content":{"syntax":"normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-content"},"justify-items":{"syntax":"normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"legacy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-items"},"justify-self":{"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-self"},"justify-tracks":{"syntax":"[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirInlineAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-tracks"},"left":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/left"},"letter-spacing":{"syntax":"normal | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumValueOfAbsoluteLengthOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/letter-spacing"},"line-break":{"syntax":"auto | loose | normal | strict | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-break"},"line-clamp":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"line-height":{"syntax":"normal | <number> | <length> | <percentage>","media":"visual","inherited":true,"animationType":"numberOrLength","percentages":"referToElementFontSize","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"absoluteLengthOrAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height"},"line-height-step":{"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"0","appliesto":"blockContainers","computed":"absoluteLength","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height-step"},"list-style":{"syntax":"<\'list-style-type\'> || <\'list-style-position\'> || <\'list-style-image\'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":["list-style-type","list-style-position","list-style-image"],"appliesto":"listItems","computed":["list-style-image","list-style-position","list-style-type"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style"},"list-style-image":{"syntax":"<image> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"none","appliesto":"listItems","computed":"theKeywordListStyleImageNoneOrComputedValue","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-image"},"list-style-position":{"syntax":"inside | outside","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"outside","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-position"},"list-style-type":{"syntax":"<counter-style> | <string> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"disc","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-type"},"margin":{"syntax":"[ <length> | <percentage> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["margin-bottom","margin-left","margin-right","margin-top"],"appliesto":"allElementsExceptTableDisplayTypes","computed":["margin-bottom","margin-left","margin-right","margin-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin"},"margin-block":{"syntax":"<\'margin-left\'>{1,2}","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":["margin-block-start","margin-block-end"],"appliesto":"sameAsMargin","computed":["margin-block-start","margin-block-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block"},"margin-block-end":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-end"},"margin-block-start":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-start"},"margin-bottom":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-bottom"},"margin-inline":{"syntax":"<\'margin-left\'>{1,2}","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":["margin-inline-start","margin-inline-end"],"appliesto":"sameAsMargin","computed":["margin-inline-start","margin-inline-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline"},"margin-inline-end":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"},"margin-inline-start":{"syntax":"<\'margin-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"},"margin-left":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-left"},"margin-right":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-right"},"margin-top":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-top"},"margin-trim":{"syntax":"none | in-flow | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"none","appliesto":"blockContainersAndMultiColumnContainers","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line"],"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-trim"},"mask":{"syntax":"<mask-layer>#","media":"visual","inherited":false,"animationType":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"percentages":["mask-position"],"groups":["CSS Masking"],"initial":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"appliesto":"allElementsSVGContainerElements","computed":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},"mask-border":{"syntax":"<\'mask-border-source\'> || <\'mask-border-slice\'> [ / <\'mask-border-width\'>? [ / <\'mask-border-outset\'> ]? ]? || <\'mask-border-repeat\'> || <\'mask-border-mode\'>","media":"visual","inherited":false,"animationType":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"percentages":["mask-border-slice","mask-border-width"],"groups":["CSS Masking"],"initial":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"appliesto":"allElementsSVGContainerElements","computed":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border"},"mask-border-mode":{"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"alpha","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"},"mask-border-outset":{"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"},"mask-border-repeat":{"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"stretch","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"},"mask-border-slice":{"syntax":"<number-percentage>{1,4} fill?","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfMaskBorderImage","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"},"mask-border-source":{"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-source"},"mask-border-width":{"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToMaskBorderImageArea","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-width"},"mask-clip":{"syntax":"[ <geometry-box> | no-clip ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},"mask-composite":{"syntax":"<compositing-operator>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"add","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-composite"},"mask-image":{"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},"mask-mode":{"syntax":"<masking-mode>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"match-source","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-mode"},"mask-origin":{"syntax":"<geometry-box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},"mask-position":{"syntax":"<position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfMaskPaintingArea","groups":["CSS Masking"],"initial":"center","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoKeywordsForOriginAndOffsets","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},"mask-repeat":{"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"repeat","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoDimensionKeywords","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},"mask-size":{"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},"mask-type":{"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"luminance","appliesto":"maskElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-type"},"masonry-auto-flow":{"syntax":"[ pack | next ] || [ definite-first | ordered ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"pack","appliesto":"gridContainersWithMasonryLayout","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"},"math-depth":{"syntax":"auto-add | add(<integer>) | <integer>","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["MathML"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/math-depth"},"math-shift":{"syntax":"normal | compact","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["MathML"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/math-shift"},"math-style":{"syntax":"normal | compact","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["MathML"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/math-style"},"max-block-size":{"syntax":"<\'max-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"none","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-block-size"},"max-height":{"syntax":"none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesNone","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-height"},"max-inline-size":{"syntax":"<\'max-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"none","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-inline-size"},"max-lines":{"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},"max-width":{"syntax":"none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-width"},"min-block-size":{"syntax":"<\'min-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-block-size"},"min-height":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentages0","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-height"},"min-inline-size":{"syntax":"<\'min-width\'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-inline-size"},"min-width":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-width"},"mix-blend-mode":{"syntax":"<blend-mode> | plus-lighter","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"},"object-fit":{"syntax":"fill | contain | cover | none | scale-down","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"fill","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-fit"},"object-position":{"syntax":"<position>","media":"visual","inherited":true,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToWidthAndHeightOfElement","groups":["CSS Images"],"initial":"50% 50%","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-position"},"offset":{"syntax":"[ <\'offset-position\'>? [ <\'offset-path\'> [ <\'offset-distance\'> || <\'offset-rotate\'> ]? ]? ]! [ / <\'offset-anchor\'> ]?","media":"visual","inherited":false,"animationType":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"percentages":["offset-position","offset-distance","offset-anchor"],"groups":["CSS Motion Path"],"initial":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"appliesto":"transformableElements","computed":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset"},"offset-anchor":{"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"relativeToWidthAndHeight","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard"},"offset-distance":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToTotalPathLength","groups":["CSS Motion Path"],"initial":"0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-distance"},"offset-path":{"syntax":"none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-path"},"offset-position":{"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"referToSizeOfContainingBlock","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"experimental"},"offset-rotate":{"syntax":"[ auto | reverse ] || <angle>","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-rotate"},"opacity":{"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"mapToRange0To1","groups":["CSS Color"],"initial":"1","appliesto":"allElements","computed":"specifiedValueNumberClipped0To1","order":"perGrammar","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/opacity"},"order":{"syntax":"<integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsGridItemsAbsolutelyPositionedContainerChildren","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/order"},"orphans":{"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/orphans"},"outline":{"syntax":"[ <\'outline-color\'> || <\'outline-style\'> || <\'outline-width\'> ]","media":["visual","interactive"],"inherited":false,"animationType":["outline-color","outline-width","outline-style"],"percentages":"no","groups":["CSS Basic User Interface"],"initial":["outline-color","outline-style","outline-width"],"appliesto":"allElements","computed":["outline-color","outline-width","outline-style"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline"},"outline-color":{"syntax":"<color> | invert","media":["visual","interactive"],"inherited":false,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"invertOrCurrentColor","appliesto":"allElements","computed":"invertForTranslucentColorRGBAOtherwiseRGB","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-color"},"outline-offset":{"syntax":"<length>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"0","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-offset"},"outline-style":{"syntax":"auto | <\'border-style\'>","media":["visual","interactive"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-style"},"outline-width":{"syntax":"<line-width>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"medium","appliesto":"allElements","computed":"absoluteLength0ForNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-width"},"overflow":{"syntax":"[ visible | hidden | clip | scroll | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":["overflow-x","overflow-y"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow"},"overflow-anchor":{"syntax":"auto | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Anchoring"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard"},"overflow-block":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},"overflow-clip-box":{"syntax":"padding-box | content-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"},"overflow-clip-margin":{"syntax":"<visual-box> || <length [0,∞]>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"0px","appliesto":"allElements","computed":"theComputedLength","order":"perGrammar","status":"standard"},"overflow-inline":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},"overflow-wrap":{"syntax":"normal | break-word | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},"overflow-x":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-x"},"overflow-y":{"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-y"},"overscroll-behavior":{"syntax":"[ contain | none | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["overscroll-behavior-x","overscroll-behavior-y"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"},"overscroll-behavior-block":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"},"overscroll-behavior-inline":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"},"overscroll-behavior-x":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"},"overscroll-behavior-y":{"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"},"padding":{"syntax":"[ <length> | <percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["padding-bottom","padding-left","padding-right","padding-top"],"appliesto":"allElementsExceptInternalTableDisplayTypes","computed":["padding-bottom","padding-left","padding-right","padding-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding"},"padding-block":{"syntax":"<\'padding-left\'>{1,2}","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":["padding-block-start","padding-block-end"],"appliesto":"allElementsExceptInternalTableDisplayTypes","computed":["padding-block-start","padding-block-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block"},"padding-block-end":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-end"},"padding-block-start":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-start"},"padding-bottom":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-bottom"},"padding-inline":{"syntax":"<\'padding-left\'>{1,2}","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":["padding-inline-start","padding-inline-end"],"appliesto":"allElementsExceptInternalTableDisplayTypes","computed":["padding-inline-start","padding-inline-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline"},"padding-inline-end":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"},"padding-inline-start":{"syntax":"<\'padding-left\'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"},"padding-left":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-left"},"padding-right":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-right"},"padding-top":{"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-top"},"page-break-after":{"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-after"},"page-break-before":{"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-before"},"page-break-inside":{"syntax":"auto | avoid","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-inside"},"paint-order":{"syntax":"normal | [ fill || stroke || markers ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/paint-order"},"perspective":{"syntax":"none | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"absoluteLengthOrNone","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective"},"perspective-origin":{"syntax":"<position>","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50%","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective-origin"},"place-content":{"syntax":"<\'align-content\'> <\'justify-content\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-content","justify-content"],"appliesto":"multilineFlexContainers","computed":["align-content","justify-content"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-content"},"place-items":{"syntax":"<\'align-items\'> <\'justify-items\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-items","justify-items"],"appliesto":"allElements","computed":["align-items","justify-items"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-items"},"place-self":{"syntax":"<\'align-self\'> <\'justify-self\'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-self","justify-self"],"appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":["align-self","justify-self"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-self"},"pointer-events":{"syntax":"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/pointer-events"},"position":{"syntax":"static | relative | absolute | sticky | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"static","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/position"},"quotes":{"syntax":"none | auto | [ <string> <string> ]+","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/quotes"},"resize":{"syntax":"none | both | horizontal | vertical | block | inline","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"elementsWithOverflowNotVisibleAndReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/resize"},"right":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/right"},"rotate":{"syntax":"none | <angle> | [ x | y | z | <number>{3} ] && <angle>","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/rotate"},"row-gap":{"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},"ruby-align":{"syntax":"start | center | space-between | space-around","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"space-around","appliesto":"rubyBasesAnnotationsBaseAnnotationContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-align"},"ruby-merge":{"syntax":"separate | collapse | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"separate","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"ruby-position":{"syntax":"[ alternate || [ over | under ] ] | inter-character","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"alternate","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-position"},"scale":{"syntax":"none | <number>{1,3}","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scale"},"scrollbar-color":{"syntax":"auto | <color>{2}","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"},"scrollbar-gutter":{"syntax":"auto | stable && both-edges?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"},"scrollbar-width":{"syntax":"auto | thin | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"},"scroll-behavior":{"syntax":"auto | smooth","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSSOM View"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"},"scroll-margin":{"syntax":"<length>{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":["scroll-margin-bottom","scroll-margin-left","scroll-margin-right","scroll-margin-top"],"appliesto":"allElements","computed":["scroll-margin-bottom","scroll-margin-left","scroll-margin-right","scroll-margin-top"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin"},"scroll-margin-block":{"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":["scroll-margin-block-start","scroll-margin-block-end"],"appliesto":"allElements","computed":["scroll-margin-block-start","scroll-margin-block-end"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"},"scroll-margin-block-start":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"},"scroll-margin-block-end":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"},"scroll-margin-bottom":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"},"scroll-margin-inline":{"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":["scroll-margin-inline-start","scroll-margin-inline-end"],"appliesto":"allElements","computed":["scroll-margin-inline-start","scroll-margin-inline-end"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"},"scroll-margin-inline-start":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"},"scroll-margin-inline-end":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"},"scroll-margin-left":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"},"scroll-margin-right":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"},"scroll-margin-top":{"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"},"scroll-padding":{"syntax":"[ auto | <length-percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":["scroll-padding-bottom","scroll-padding-left","scroll-padding-right","scroll-padding-top"],"appliesto":"scrollContainers","computed":["scroll-padding-bottom","scroll-padding-left","scroll-padding-right","scroll-padding-top"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding"},"scroll-padding-block":{"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":["scroll-padding-block-start","scroll-padding-block-end"],"appliesto":"scrollContainers","computed":["scroll-padding-block-start","scroll-padding-block-end"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"},"scroll-padding-block-start":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"},"scroll-padding-block-end":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"},"scroll-padding-bottom":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"},"scroll-padding-inline":{"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":["scroll-padding-inline-start","scroll-padding-inline-end"],"appliesto":"scrollContainers","computed":["scroll-padding-inline-start","scroll-padding-inline-end"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"},"scroll-padding-inline-start":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"},"scroll-padding-inline-end":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"},"scroll-padding-left":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"},"scroll-padding-right":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"},"scroll-padding-top":{"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"},"scroll-snap-align":{"syntax":"[ none | start | end | center ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"},"scroll-snap-coordinate":{"syntax":"none | <position>#","media":"interactive","inherited":false,"animationType":"position","percentages":"referToBorderBox","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"},"scroll-snap-destination":{"syntax":"<position>","media":"interactive","inherited":false,"animationType":"position","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"0px 0px","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"},"scroll-snap-points-x":{"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"},"scroll-snap-points-y":{"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"},"scroll-snap-stop":{"syntax":"normal | always","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"},"scroll-snap-type":{"syntax":"none | [ x | y | block | inline | both ] [ mandatory | proximity ]?","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"},"scroll-snap-type-x":{"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"},"scroll-snap-type-y":{"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"},"scroll-timeline":{"syntax":"<scroll-timeline-name> || <scroll-timeline-axis>","media":"visual","inherited":false,"animationType":["scroll-timeline-name","scroll-timeline-axis"],"percentages":"no","groups":["CSS Animations"],"initial":["scroll-timeline-name","scroll-timeline-axis"],"appliesto":"scrollContainers","computed":["scroll-timeline-name","scroll-timeline-axis"],"order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-timeline"},"scroll-timeline-axis":{"syntax":"block | inline | vertical | horizontal","media":"interactive","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"block","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis"},"scroll-timeline-name":{"syntax":"none | <custom-ident>","media":"interactive","inherited":false,"animationType":"notAnimatable","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name"},"shape-image-threshold":{"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Shapes"],"initial":"0.0","appliesto":"floats","computed":"specifiedValueNumberClipped0To1","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"},"shape-margin":{"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Shapes"],"initial":"0","appliesto":"floats","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-margin"},"shape-outside":{"syntax":"none | [ <shape-box> || <basic-shape> ] | <image>","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"no","groups":["CSS Shapes"],"initial":"none","appliesto":"floats","computed":"asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-outside"},"tab-size":{"syntax":"<integer> | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"8","appliesto":"blockContainers","computed":"specifiedIntegerOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/tab-size"},"table-layout":{"syntax":"auto | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"auto","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/table-layout"},"text-align":{"syntax":"start | end | left | right | center | justify | match-parent","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"startOrNamelessValueIfLTRRightIfRTL","appliesto":"blockContainers","computed":"asSpecifiedExceptMatchParent","order":"orderOfAppearance","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align"},"text-align-last":{"syntax":"auto | start | end | left | right | center | justify","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"blockContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align-last"},"text-combine-upright":{"syntax":"none | all | [ digits <integer>? ]","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["CSS Writing Modes"],"initial":"none","appliesto":"nonReplacedInlineElements","computed":"keywordPlusIntegerIfDigits","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"},"text-decoration":{"syntax":"<\'text-decoration-line\'> || <\'text-decoration-style\'> || <\'text-decoration-color\'> || <\'text-decoration-thickness\'>","media":"visual","inherited":false,"animationType":["text-decoration-color","text-decoration-style","text-decoration-line","text-decoration-thickness"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-decoration-color","text-decoration-style","text-decoration-line"],"appliesto":"allElements","computed":["text-decoration-line","text-decoration-style","text-decoration-color","text-decoration-thickness"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration"},"text-decoration-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"},"text-decoration-line":{"syntax":"none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"},"text-decoration-skip":{"syntax":"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"objects","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"},"text-decoration-skip-ink":{"syntax":"auto | all | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"},"text-decoration-style":{"syntax":"solid | double | dotted | dashed | wavy","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"solid","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"},"text-decoration-thickness":{"syntax":"auto | from-font | <length> | <percentage> ","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"},"text-emphasis":{"syntax":"<\'text-emphasis-style\'> || <\'text-emphasis-color\'>","media":"visual","inherited":false,"animationType":["text-emphasis-color","text-emphasis-style"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-emphasis-style","text-emphasis-color"],"appliesto":"allElements","computed":["text-emphasis-style","text-emphasis-color"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis"},"text-emphasis-color":{"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"},"text-emphasis-position":{"syntax":"[ over | under ] && [ right | left ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"over right","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"},"text-emphasis-style":{"syntax":"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"},"text-indent":{"syntax":"<length-percentage> && hanging? && each-line?","media":"visual","inherited":true,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Text"],"initial":"0","appliesto":"blockContainers","computed":"percentageOrAbsoluteLengthPlusKeywords","order":"lengthOrPercentageBeforeKeywords","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-indent"},"text-justify":{"syntax":"auto | inter-character | inter-word | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"inlineLevelAndTableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-justify"},"text-orientation":{"syntax":"mixed | upright | sideways","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"mixed","appliesto":"allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-orientation"},"text-overflow":{"syntax":"[ clip | ellipsis | <string> ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"clip","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-overflow"},"text-rendering":{"syntax":"auto | optimizeSpeed | optimizeLegibility | geometricPrecision","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Miscellaneous"],"initial":"auto","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-rendering"},"text-shadow":{"syntax":"none | <shadow-t>#","media":"visual","inherited":true,"animationType":"shadowList","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"colorPlusThreeAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-shadow"},"text-size-adjust":{"syntax":"none | auto | <percentage>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToSizeOfFont","groups":["CSS Text"],"initial":"autoForSmartphoneBrowsersSupportingInflation","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"},"text-transform":{"syntax":"none | capitalize | uppercase | lowercase | full-width | full-size-kana","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-transform"},"text-underline-offset":{"syntax":"auto | <length> | <percentage> ","media":"visual","inherited":true,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"},"text-underline-position":{"syntax":"auto | from-font | [ under || [ left | right ] ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-position"},"top":{"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/top"},"touch-action":{"syntax":"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Pointer Events"],"initial":"auto","appliesto":"allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/touch-action"},"transform":{"syntax":"none | <transform-list>","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform"},"transform-box":{"syntax":"content-box | border-box | fill-box | stroke-box | view-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"view-box","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-box"},"transform-origin":{"syntax":"[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50% 0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-origin"},"transform-style":{"syntax":"flat | preserve-3d","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"flat","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-style"},"transition":{"syntax":"<single-transition>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":["transition-delay","transition-duration","transition-property","transition-timing-function"],"appliesto":"allElementsAndPseudos","computed":["transition-delay","transition-duration","transition-property","transition-timing-function"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition"},"transition-delay":{"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-delay"},"transition-duration":{"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-duration"},"transition-property":{"syntax":"none | <single-transition-property>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"all","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-property"},"transition-timing-function":{"syntax":"<easing-function>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"},"translate":{"syntax":"none | <length-percentage> [ <length-percentage> <length>? ]?","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/translate"},"unicode-bidi":{"syntax":"normal | embed | isolate | bidi-override | isolate-override | plaintext","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"normal","appliesto":"allElementsSomeValuesNoEffectOnNonInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"},"user-select":{"syntax":"auto | text | none | contain | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/user-select"},"vertical-align":{"syntax":"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"referToLineHeight","groups":["CSS Table"],"initial":"baseline","appliesto":"inlineLevelAndTableCellElements","computed":"absoluteLengthOrKeyword","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/vertical-align"},"visibility":{"syntax":"visible | hidden | collapse","media":"visual","inherited":true,"animationType":"visibility","percentages":"no","groups":["CSS Box Model"],"initial":"visible","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/visibility"},"white-space":{"syntax":"normal | pre | nowrap | pre-wrap | pre-line | break-spaces","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/white-space"},"widows":{"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/widows"},"width":{"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAutoOrAbsoluteLength","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/width"},"will-change":{"syntax":"auto | <animateable-feature>#","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Will Change"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/will-change"},"word-break":{"syntax":"normal | break-all | keep-all | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-break"},"word-spacing":{"syntax":"normal | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"referToWidthOfAffectedGlyph","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"absoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-spacing"},"word-wrap":{"syntax":"normal | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},"writing-mode":{"syntax":"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"horizontal-tb","appliesto":"allElementsExceptTableRowColumnGroupsTableRowsColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/writing-mode"},"z-index":{"syntax":"auto | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/z-index"},"zoom":{"syntax":"normal | reset | <number> | <percentage>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["Microsoft Extensions"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/zoom"}}',
      );
    },
    1509: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"abs()":{"syntax":"abs( <calc-sum> )"},"absolute-size":{"syntax":"xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"},"acos()":{"syntax":"acos( <calc-sum> )"},"alpha-value":{"syntax":"<number> | <percentage>"},"angle-percentage":{"syntax":"<angle> | <percentage>"},"angular-color-hint":{"syntax":"<angle-percentage>"},"angular-color-stop":{"syntax":"<color> && <color-stop-angle>?"},"angular-color-stop-list":{"syntax":"[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"},"animateable-feature":{"syntax":"scroll-position | contents | <custom-ident>"},"asin()":{"syntax":"asin( <calc-sum> )"},"atan()":{"syntax":"atan( <calc-sum> )"},"atan2()":{"syntax":"atan2( <calc-sum>, <calc-sum> )"},"attachment":{"syntax":"scroll | fixed | local"},"attr()":{"syntax":"attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"},"attr-matcher":{"syntax":"[ \'~\' | \'|\' | \'^\' | \'$\' | \'*\' ]? \'=\'"},"attr-modifier":{"syntax":"i | s"},"attribute-selector":{"syntax":"\'[\' <wq-name> \']\' | \'[\' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? \']\'"},"auto-repeat":{"syntax":"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},"auto-track-list":{"syntax":"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"},"axis":{"syntax":"block | inline | vertical | horizontal"},"baseline-position":{"syntax":"[ first | last ]? baseline"},"basic-shape":{"syntax":"<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"},"bg-image":{"syntax":"none | <image>"},"bg-layer":{"syntax":"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},"bg-position":{"syntax":"[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"},"bg-size":{"syntax":"[ <length-percentage> | auto ]{1,2} | cover | contain"},"blur()":{"syntax":"blur( <length> )"},"blend-mode":{"syntax":"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"},"box":{"syntax":"border-box | padding-box | content-box"},"brightness()":{"syntax":"brightness( <number-percentage> )"},"calc()":{"syntax":"calc( <calc-sum> )"},"calc-sum":{"syntax":"<calc-product> [ [ \'+\' | \'-\' ] <calc-product> ]*"},"calc-product":{"syntax":"<calc-value> [ \'*\' <calc-value> | \'/\' <number> ]*"},"calc-value":{"syntax":"<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"},"calc-constant":{"syntax":"e | pi | infinity | -infinity | NaN"},"cf-final-image":{"syntax":"<image> | <color>"},"cf-mixing-image":{"syntax":"<percentage>? && <image>"},"circle()":{"syntax":"circle( [ <shape-radius> ]? [ at <position> ]? )"},"clamp()":{"syntax":"clamp( <calc-sum>#{3} )"},"class-selector":{"syntax":"\'.\' <ident-token>"},"clip-source":{"syntax":"<url>"},"color":{"syntax":"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"},"color-stop":{"syntax":"<color-stop-length> | <color-stop-angle>"},"color-stop-angle":{"syntax":"<angle-percentage>{1,2}"},"color-stop-length":{"syntax":"<length-percentage>{1,2}"},"color-stop-list":{"syntax":"[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"},"combinator":{"syntax":"\'>\' | \'+\' | \'~\' | [ \'||\' ]"},"common-lig-values":{"syntax":"[ common-ligatures | no-common-ligatures ]"},"compat-auto":{"syntax":"searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"},"composite-style":{"syntax":"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"},"compositing-operator":{"syntax":"add | subtract | intersect | exclude"},"compound-selector":{"syntax":"[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"},"compound-selector-list":{"syntax":"<compound-selector>#"},"complex-selector":{"syntax":"<compound-selector> [ <combinator>? <compound-selector> ]*"},"complex-selector-list":{"syntax":"<complex-selector>#"},"conic-gradient()":{"syntax":"conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"},"contextual-alt-values":{"syntax":"[ contextual | no-contextual ]"},"content-distribution":{"syntax":"space-between | space-around | space-evenly | stretch"},"content-list":{"syntax":"[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"},"content-position":{"syntax":"center | start | end | flex-start | flex-end"},"content-replacement":{"syntax":"<image>"},"contrast()":{"syntax":"contrast( [ <number-percentage> ] )"},"cos()":{"syntax":"cos( <calc-sum> )"},"counter":{"syntax":"<counter()> | <counters()>"},"counter()":{"syntax":"counter( <counter-name>, <counter-style>? )"},"counter-name":{"syntax":"<custom-ident>"},"counter-style":{"syntax":"<counter-style-name> | symbols()"},"counter-style-name":{"syntax":"<custom-ident>"},"counters()":{"syntax":"counters( <counter-name>, <string>, <counter-style>? )"},"cross-fade()":{"syntax":"cross-fade( <cf-mixing-image> , <cf-final-image>? )"},"cubic-bezier-timing-function":{"syntax":"ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"},"deprecated-system-color":{"syntax":"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"},"discretionary-lig-values":{"syntax":"[ discretionary-ligatures | no-discretionary-ligatures ]"},"display-box":{"syntax":"contents | none"},"display-inside":{"syntax":"flow | flow-root | table | flex | grid | ruby"},"display-internal":{"syntax":"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"},"display-legacy":{"syntax":"inline-block | inline-list-item | inline-table | inline-flex | inline-grid"},"display-listitem":{"syntax":"<display-outside>? && [ flow | flow-root ]? && list-item"},"display-outside":{"syntax":"block | inline | run-in"},"drop-shadow()":{"syntax":"drop-shadow( <length>{2,3} <color>? )"},"east-asian-variant-values":{"syntax":"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"},"east-asian-width-values":{"syntax":"[ full-width | proportional-width ]"},"element()":{"syntax":"element( <id-selector> )"},"ellipse()":{"syntax":"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"},"ending-shape":{"syntax":"circle | ellipse"},"env()":{"syntax":"env( <custom-ident> , <declaration-value>? )"},"exp()":{"syntax":"exp( <calc-sum> )"},"explicit-track-list":{"syntax":"[ <line-names>? <track-size> ]+ <line-names>?"},"family-name":{"syntax":"<string> | <custom-ident>+"},"feature-tag-value":{"syntax":"<string> [ <integer> | on | off ]?"},"feature-type":{"syntax":"@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"},"feature-value-block":{"syntax":"<feature-type> \'{\' <feature-value-declaration-list> \'}\'"},"feature-value-block-list":{"syntax":"<feature-value-block>+"},"feature-value-declaration":{"syntax":"<custom-ident>: <integer>+;"},"feature-value-declaration-list":{"syntax":"<feature-value-declaration>"},"feature-value-name":{"syntax":"<custom-ident>"},"fill-rule":{"syntax":"nonzero | evenodd"},"filter-function":{"syntax":"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"},"filter-function-list":{"syntax":"[ <filter-function> | <url> ]+"},"final-bg-layer":{"syntax":"<\'background-color\'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},"fixed-breadth":{"syntax":"<length-percentage>"},"fixed-repeat":{"syntax":"repeat( [ <integer [1,∞]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},"fixed-size":{"syntax":"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"},"font-stretch-absolute":{"syntax":"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"},"font-variant-css21":{"syntax":"[ normal | small-caps ]"},"font-weight-absolute":{"syntax":"normal | bold | <number [1,1000]>"},"frequency-percentage":{"syntax":"<frequency> | <percentage>"},"general-enclosed":{"syntax":"[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"},"generic-family":{"syntax":"serif | sans-serif | cursive | fantasy | monospace"},"generic-name":{"syntax":"serif | sans-serif | cursive | fantasy | monospace"},"geometry-box":{"syntax":"<shape-box> | fill-box | stroke-box | view-box"},"gradient":{"syntax":"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"},"grayscale()":{"syntax":"grayscale( <number-percentage> )"},"grid-line":{"syntax":"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"},"historical-lig-values":{"syntax":"[ historical-ligatures | no-historical-ligatures ]"},"hsl()":{"syntax":"hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"},"hsla()":{"syntax":"hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"},"hue":{"syntax":"<number> | <angle>"},"hue-rotate()":{"syntax":"hue-rotate( <angle> )"},"hwb()":{"syntax":"hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"},"hypot()":{"syntax":"hypot( <calc-sum># )"},"id-selector":{"syntax":"<hash-token>"},"image":{"syntax":"<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"},"image()":{"syntax":"image( <image-tags>? [ <image-src>? , <color>? ]! )"},"image-set()":{"syntax":"image-set( <image-set-option># )"},"image-set-option":{"syntax":"[ <image> | <string> ] [ <resolution> || type(<string>) ]"},"image-src":{"syntax":"<url> | <string>"},"image-tags":{"syntax":"ltr | rtl"},"inflexible-breadth":{"syntax":"<length-percentage> | min-content | max-content | auto"},"inset()":{"syntax":"inset( <length-percentage>{1,4} [ round <\'border-radius\'> ]? )"},"invert()":{"syntax":"invert( <number-percentage> )"},"keyframes-name":{"syntax":"<custom-ident> | <string>"},"keyframe-block":{"syntax":"<keyframe-selector># {\\n  <declaration-list>\\n}"},"keyframe-block-list":{"syntax":"<keyframe-block>+"},"keyframe-selector":{"syntax":"from | to | <percentage>"},"lab()":{"syntax":"lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"},"layer()":{"syntax":"layer( <layer-name> )"},"layer-name":{"syntax":"<ident> [ \'.\' <ident> ]*"},"lch()":{"syntax":"lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"},"leader()":{"syntax":"leader( <leader-type> )"},"leader-type":{"syntax":"dotted | solid | space | <string>"},"length-percentage":{"syntax":"<length> | <percentage>"},"line-names":{"syntax":"\'[\' <custom-ident>* \']\'"},"line-name-list":{"syntax":"[ <line-names> | <name-repeat> ]+"},"line-style":{"syntax":"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"},"line-width":{"syntax":"<length> | thin | medium | thick"},"linear-color-hint":{"syntax":"<length-percentage>"},"linear-color-stop":{"syntax":"<color> <color-stop-length>?"},"linear-gradient()":{"syntax":"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},"log()":{"syntax":"log( <calc-sum>, <calc-sum>? )"},"mask-layer":{"syntax":"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"},"mask-position":{"syntax":"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"},"mask-reference":{"syntax":"none | <image> | <mask-source>"},"mask-source":{"syntax":"<url>"},"masking-mode":{"syntax":"alpha | luminance | match-source"},"matrix()":{"syntax":"matrix( <number>#{6} )"},"matrix3d()":{"syntax":"matrix3d( <number>#{16} )"},"max()":{"syntax":"max( <calc-sum># )"},"media-and":{"syntax":"<media-in-parens> [ and <media-in-parens> ]+"},"media-condition":{"syntax":"<media-not> | <media-and> | <media-or> | <media-in-parens>"},"media-condition-without-or":{"syntax":"<media-not> | <media-and> | <media-in-parens>"},"media-feature":{"syntax":"( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"},"media-in-parens":{"syntax":"( <media-condition> ) | <media-feature> | <general-enclosed>"},"media-not":{"syntax":"not <media-in-parens>"},"media-or":{"syntax":"<media-in-parens> [ or <media-in-parens> ]+"},"media-query":{"syntax":"<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"},"media-query-list":{"syntax":"<media-query>#"},"media-type":{"syntax":"<ident>"},"mf-boolean":{"syntax":"<mf-name>"},"mf-name":{"syntax":"<ident>"},"mf-plain":{"syntax":"<mf-name> : <mf-value>"},"mf-range":{"syntax":"<mf-name> [ \'<\' | \'>\' ]? \'=\'? <mf-value>\\n| <mf-value> [ \'<\' | \'>\' ]? \'=\'? <mf-name>\\n| <mf-value> \'<\' \'=\'? <mf-name> \'<\' \'=\'? <mf-value>\\n| <mf-value> \'>\' \'=\'? <mf-name> \'>\' \'=\'? <mf-value>"},"mf-value":{"syntax":"<number> | <dimension> | <ident> | <ratio>"},"min()":{"syntax":"min( <calc-sum># )"},"minmax()":{"syntax":"minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"},"mod()":{"syntax":"mod( <calc-sum>, <calc-sum> )"},"name-repeat":{"syntax":"repeat( [ <integer [1,∞]> | auto-fill ], <line-names>+ )"},"named-color":{"syntax":"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"},"namespace-prefix":{"syntax":"<ident>"},"ns-prefix":{"syntax":"[ <ident-token> | \'*\' ]? \'|\'"},"number-percentage":{"syntax":"<number> | <percentage>"},"numeric-figure-values":{"syntax":"[ lining-nums | oldstyle-nums ]"},"numeric-fraction-values":{"syntax":"[ diagonal-fractions | stacked-fractions ]"},"numeric-spacing-values":{"syntax":"[ proportional-nums | tabular-nums ]"},"nth":{"syntax":"<an-plus-b> | even | odd"},"opacity()":{"syntax":"opacity( [ <number-percentage> ] )"},"overflow-position":{"syntax":"unsafe | safe"},"outline-radius":{"syntax":"<length> | <percentage>"},"page-body":{"syntax":"<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"},"page-margin-box":{"syntax":"<page-margin-box-type> \'{\' <declaration-list> \'}\'"},"page-margin-box-type":{"syntax":"@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"},"page-selector-list":{"syntax":"[ <page-selector># ]?"},"page-selector":{"syntax":"<pseudo-page>+ | <ident> <pseudo-page>*"},"page-size":{"syntax":"A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"},"path()":{"syntax":"path( [ <fill-rule>, ]? <string> )"},"paint()":{"syntax":"paint( <ident>, <declaration-value>? )"},"perspective()":{"syntax":"perspective( [ <length [0,∞]> | none ] )"},"polygon()":{"syntax":"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"},"position":{"syntax":"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"},"pow()":{"syntax":"pow( <calc-sum>, <calc-sum> )"},"pseudo-class-selector":{"syntax":"\':\' <ident-token> | \':\' <function-token> <any-value> \')\'"},"pseudo-element-selector":{"syntax":"\':\' <pseudo-class-selector>"},"pseudo-page":{"syntax":": [ left | right | first | blank ]"},"quote":{"syntax":"open-quote | close-quote | no-open-quote | no-close-quote"},"radial-gradient()":{"syntax":"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},"ratio":{"syntax":"<number [0,∞]> [ / <number [0,∞]> ]?"},"relative-selector":{"syntax":"<combinator>? <complex-selector>"},"relative-selector-list":{"syntax":"<relative-selector>#"},"relative-size":{"syntax":"larger | smaller"},"rem()":{"syntax":"rem( <calc-sum>, <calc-sum> )"},"repeat-style":{"syntax":"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"},"repeating-conic-gradient()":{"syntax":"repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"},"repeating-linear-gradient()":{"syntax":"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},"repeating-radial-gradient()":{"syntax":"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},"reversed-counter-name":{"syntax":"reversed( <counter-name> )"},"rgb()":{"syntax":"rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"},"rgba()":{"syntax":"rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"},"rotate()":{"syntax":"rotate( [ <angle> | <zero> ] )"},"rotate3d()":{"syntax":"rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"},"rotateX()":{"syntax":"rotateX( [ <angle> | <zero> ] )"},"rotateY()":{"syntax":"rotateY( [ <angle> | <zero> ] )"},"rotateZ()":{"syntax":"rotateZ( [ <angle> | <zero> ] )"},"round()":{"syntax":"round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"},"rounding-strategy":{"syntax":"nearest | up | down | to-zero"},"saturate()":{"syntax":"saturate( <number-percentage> )"},"scale()":{"syntax":"scale( [ <number> | <percentage> ]#{1,2} )"},"scale3d()":{"syntax":"scale3d( [ <number> | <percentage> ]#{3} )"},"scaleX()":{"syntax":"scaleX( [ <number> | <percentage> ] )"},"scaleY()":{"syntax":"scaleY( [ <number> | <percentage> ] )"},"scaleZ()":{"syntax":"scaleZ( [ <number> | <percentage> ] )"},"scroller":{"syntax":"root | nearest"},"self-position":{"syntax":"center | start | end | self-start | self-end | flex-start | flex-end"},"shape-radius":{"syntax":"<length-percentage> | closest-side | farthest-side"},"sign()":{"syntax":"sign( <calc-sum> )"},"skew()":{"syntax":"skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"},"skewX()":{"syntax":"skewX( [ <angle> | <zero> ] )"},"skewY()":{"syntax":"skewY( [ <angle> | <zero> ] )"},"sepia()":{"syntax":"sepia( <number-percentage> )"},"shadow":{"syntax":"inset? && <length>{2,4} && <color>?"},"shadow-t":{"syntax":"[ <length>{2,3} && <color>? ]"},"shape":{"syntax":"rect(<top>, <right>, <bottom>, <left>)"},"shape-box":{"syntax":"<box> | margin-box"},"side-or-corner":{"syntax":"[ left | right ] || [ top | bottom ]"},"sin()":{"syntax":"sin( <calc-sum> )"},"single-animation":{"syntax":"<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"},"single-animation-direction":{"syntax":"normal | reverse | alternate | alternate-reverse"},"single-animation-fill-mode":{"syntax":"none | forwards | backwards | both"},"single-animation-iteration-count":{"syntax":"infinite | <number>"},"single-animation-play-state":{"syntax":"running | paused"},"single-animation-timeline":{"syntax":"auto | none | <timeline-name> | scroll(<axis>? <scroller>?)"},"single-transition":{"syntax":"[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"},"single-transition-property":{"syntax":"all | <custom-ident>"},"size":{"syntax":"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"},"sqrt()":{"syntax":"sqrt( <calc-sum> )"},"step-position":{"syntax":"jump-start | jump-end | jump-none | jump-both | start | end"},"step-timing-function":{"syntax":"step-start | step-end | steps(<integer>[, <step-position>]?)"},"subclass-selector":{"syntax":"<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"},"supports-condition":{"syntax":"not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"},"supports-in-parens":{"syntax":"( <supports-condition> ) | <supports-feature> | <general-enclosed>"},"supports-feature":{"syntax":"<supports-decl> | <supports-selector-fn>"},"supports-decl":{"syntax":"( <declaration> )"},"supports-selector-fn":{"syntax":"selector( <complex-selector> )"},"symbol":{"syntax":"<string> | <image> | <custom-ident>"},"tan()":{"syntax":"tan( <calc-sum> )"},"target":{"syntax":"<target-counter()> | <target-counters()> | <target-text()>"},"target-counter()":{"syntax":"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"},"target-counters()":{"syntax":"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"},"target-text()":{"syntax":"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"},"time-percentage":{"syntax":"<time> | <percentage>"},"timeline-name":{"syntax":"<custom-ident> | <string>"},"easing-function":{"syntax":"linear | <cubic-bezier-timing-function> | <step-timing-function>"},"track-breadth":{"syntax":"<length-percentage> | <flex> | min-content | max-content | auto"},"track-list":{"syntax":"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"},"track-repeat":{"syntax":"repeat( [ <integer [1,∞]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"},"track-size":{"syntax":"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"},"transform-function":{"syntax":"<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"},"transform-list":{"syntax":"<transform-function>+"},"translate()":{"syntax":"translate( <length-percentage> , <length-percentage>? )"},"translate3d()":{"syntax":"translate3d( <length-percentage> , <length-percentage> , <length> )"},"translateX()":{"syntax":"translateX( <length-percentage> )"},"translateY()":{"syntax":"translateY( <length-percentage> )"},"translateZ()":{"syntax":"translateZ( <length> )"},"type-or-unit":{"syntax":"string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"},"type-selector":{"syntax":"<wq-name> | <ns-prefix>? \'*\'"},"var()":{"syntax":"var( <custom-property-name> , <declaration-value>? )"},"viewport-length":{"syntax":"auto | <length-percentage>"},"visual-box":{"syntax":"content-box | padding-box | border-box"},"wq-name":{"syntax":"<ns-prefix>? <ident-token>"}}',
      );
    },
  };
  var __webpack_module_cache__ = {};
  function __nccwpck_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (__webpack_module_cache__[moduleId] = { exports: {} });
    var threw = true;
    try {
      __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nccwpck_require__,
      );
      threw = false;
    } finally {
      if (threw) delete __webpack_module_cache__[moduleId];
    }
    return module.exports;
  }
  (() => {
    __nccwpck_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  var __webpack_exports__ = __nccwpck_require__(6945);
  module.exports = __webpack_exports__;
})();
