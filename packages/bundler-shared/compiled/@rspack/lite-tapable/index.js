(function(){"use strict";var e={257:function(e,t){Object.defineProperty(t,"__esModule",{value:true});t.MultiHook=t.QueriedHookMap=t.HookMap=t.AsyncSeriesWaterfallHook=t.AsyncSeriesBailHook=t.AsyncSeriesHook=t.AsyncParallelHook=t.SyncWaterfallHook=t.SyncBailHook=t.SyncHook=t.QueriedHook=t.safeStage=t.maxStage=t.minStage=t.HookBase=void 0;class HookBase{constructor(e=[],t){this.args=e;this.name=t;this.taps=[];this.interceptors=[]}intercept(e){this.interceptors.push(Object.assign({},e));if(e.register){for(let t=0;t<this.taps.length;t++){this.taps[t]=e.register(this.taps[t])}}}_runRegisterInterceptors(e){return this.interceptors.reduce(((e,t)=>t.register?.(e)??e),e)}_runCallInterceptors(...e){for(const t of this.interceptors){if(t.call){t.call(...e)}}}_runErrorInterceptors(e){for(const t of this.interceptors){if(t.error){t.error(e)}}}_runTapInterceptors(e){for(const t of this.interceptors){if(t.tap){t.tap(e)}}}_runDoneInterceptors(){for(const e of this.interceptors){if(e.done){e.done()}}}_runResultInterceptors(e){for(const t of this.interceptors){if(t.result){t.result(e)}}}withOptions(e){const mergeOptions=t=>Object.assign({},e,typeof t==="string"?{name:t}:t);return{name:this.name,tap:(e,t)=>this.tap(mergeOptions(e),t),tapAsync:(e,t)=>this.tapAsync(mergeOptions(e),t),tapPromise:(e,t)=>this.tapPromise(mergeOptions(e),t),intercept:e=>this.intercept(e),isUsed:()=>this.isUsed(),withOptions:e=>this.withOptions(mergeOptions(e)),queryStageRange:e=>this.queryStageRange(e)}}isUsed(){return this.taps.length>0||this.interceptors.length>0}queryStageRange(e){return new QueriedHook(e,this)}callAsyncStageRange(e,...t){throw new Error("Hook should implement there own _callAsyncStageRange")}callAsync(...e){return this.callAsyncStageRange(this.queryStageRange(n),...e)}promiseStageRange(e,...t){return new Promise(((n,s)=>{this.callAsyncStageRange(e,...t,((e,t)=>{if(e)return s(e);return n(t)}))}))}promise(...e){return this.promiseStageRange(this.queryStageRange(n),...e)}tap(e,t){this._tap("sync",e,t)}tapAsync(e,t){this._tap("async",e,t)}tapPromise(e,t){this._tap("promise",e,t)}_tap(e,t,n){let s=t;if(typeof t==="string"){s={name:t.trim()}}else if(typeof t!=="object"||t===null){throw new Error("Invalid tap options")}if(typeof s.name!=="string"||s.name===""){throw new Error("Missing name for tap")}this._insert(this._runRegisterInterceptors(Object.assign({type:e,fn:n},s)))}_insert(e){let t;if(typeof e.before==="string"){t=new Set([e.before])}else if(Array.isArray(e.before)){t=new Set(e.before)}let n=0;if(typeof e.stage==="number"){n=e.stage}let s=this.taps.length;while(s>0){s--;const e=this.taps[s];this.taps[s+1]=e;const r=e.stage||0;if(t){if(t.has(e.name)){t.delete(e.name);continue}if(t.size>0){continue}}if(r>n){continue}s++;break}this.taps[s]=e}_prepareArgs(e){const t=this.args.length;if(e.length<t){e.length=t;return e.fill(undefined,e.length,t)}if(e.length>t){e.length=t;return e}return e}}t.HookBase=HookBase;t.minStage=Number.NEGATIVE_INFINITY;t.maxStage=Number.POSITIVE_INFINITY;const n=[t.minStage,t.maxStage];const s=-(2**31);const r=2**31-1;const safeStage=e=>{if(e<s)return s;if(e>r)return r;return e};t.safeStage=safeStage;class QueriedHook{constructor(e,n){const s=[];const[r,o]=e;for(const e of n.taps){const n=e.stage??0;if(r<=n&&n<o){s.push(e)}else if(o===t.maxStage&&n===t.maxStage){s.push(e)}}this.stageRange=e;this.hook=n;this.tapsInRange=s}isUsed(){if(this.tapsInRange.length>0)return true;if(this.stageRange[0]===t.minStage&&this.hook.interceptors.some((e=>e.call)))return true;if(this.stageRange[1]===t.maxStage&&this.hook.interceptors.some((e=>e.done)))return true;return false}call(...e){if(typeof this.hook.callStageRange!=="function"){throw new Error("hook is not a SyncHook, call methods only exists on SyncHook")}return this.hook.callStageRange(this,...e)}callAsync(...e){return this.hook.callAsyncStageRange(this,...e)}promise(...e){return this.hook.promiseStageRange(this,...e)}}t.QueriedHook=QueriedHook;class SyncHook extends HookBase{callAsyncStageRange(e,...n){const{stageRange:[s,r],tapsInRange:o}=e;const a=n.slice(0,n.length-1);const i=n[n.length-1];const c=this._prepareArgs(a);if(s===t.minStage){this._runCallInterceptors(...c)}for(const e of o){this._runTapInterceptors(e);try{e.fn(...c)}catch(e){const t=e;this._runErrorInterceptors(t);return i(t)}}if(r===t.maxStage){this._runDoneInterceptors();i(null)}}call(...e){return this.callStageRange(this.queryStageRange(n),...e)}callStageRange(e,...t){let n;let s;this.callAsyncStageRange(e,...t,((e,t)=>{s=e;n=t}));if(s){throw s}return n}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}t.SyncHook=SyncHook;class SyncBailHook extends HookBase{callAsyncStageRange(e,...n){const{stageRange:[s,r],tapsInRange:o}=e;const a=n.slice(0,n.length-1);const i=n[n.length-1];const c=this._prepareArgs(a);if(s===t.minStage){this._runCallInterceptors(...c)}for(const e of o){this._runTapInterceptors(e);let t=undefined;try{t=e.fn(...c)}catch(e){const t=e;this._runErrorInterceptors(t);return i(t)}if(t!==undefined){this._runResultInterceptors(t);return i(null,t)}}if(r===t.maxStage){this._runDoneInterceptors();i(null)}}call(...e){return this.callStageRange(this.queryStageRange(n),...e)}callStageRange(e,...t){let n;let s;this.callAsyncStageRange(e,...t,((e,t)=>{s=e;n=t}));if(s){throw s}return n}tapAsync(){throw new Error("tapAsync is not supported on a SyncBailHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncBailHook")}}t.SyncBailHook=SyncBailHook;class SyncWaterfallHook extends HookBase{constructor(e=[],t){if(e.length<1)throw new Error("Waterfall hooks must have at least one argument");super(e,t)}callAsyncStageRange(e,...n){const{stageRange:[s,r],tapsInRange:o}=e;const a=n.slice(0,n.length-1);const i=n[n.length-1];const c=this._prepareArgs(a);if(s===t.minStage){this._runCallInterceptors(...c)}for(const e of o){this._runTapInterceptors(e);try{const t=e.fn(...c);if(t!==undefined){c[0]=t}}catch(e){const t=e;this._runErrorInterceptors(t);return i(t)}}if(r===t.maxStage){this._runDoneInterceptors();i(null,c[0])}}call(...e){return this.callStageRange(this.queryStageRange(n),...e)}callStageRange(e,...t){let n;let s;this.callAsyncStageRange(e,...t,((e,t)=>{s=e;n=t}));if(s){throw s}return n}tapAsync(){throw new Error("tapAsync is not supported on a SyncWaterfallHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncWaterfallHook")}}t.SyncWaterfallHook=SyncWaterfallHook;class AsyncParallelHook extends HookBase{callAsyncStageRange(e,...n){const{stageRange:[s],tapsInRange:r}=e;const o=n.slice(0,n.length-1);const a=n[n.length-1];const i=this._prepareArgs(o);if(s===t.minStage){this._runCallInterceptors(...i)}const done=()=>{this._runDoneInterceptors();a(null)};const error=e=>{this._runErrorInterceptors(e);a(e)};if(r.length===0)return done();let c=r.length;for(const e of r){this._runTapInterceptors(e);if(e.type==="promise"){const t=e.fn(...i);if(!t||!t.then){throw new Error(`Tap function (tapPromise) did not return promise (returned ${t})`)}t.then((()=>{c-=1;if(c===0){done()}}),(e=>{c=0;error(e)}))}else if(e.type==="async"){e.fn(...i,(e=>{if(e){c=0;error(e)}else{c-=1;if(c===0){done()}}}))}else{let t=false;try{e.fn(...i)}catch(e){t=true;c=0;error(e)}if(!t&&--c===0){done()}}if(c<=0)return}}}t.AsyncParallelHook=AsyncParallelHook;class AsyncSeriesHook extends HookBase{callAsyncStageRange(e,...n){const{stageRange:[s],tapsInRange:r}=e;const o=n.slice(0,n.length-1);const a=n[n.length-1];const i=this._prepareArgs(o);if(s===t.minStage){this._runCallInterceptors(...i)}const done=()=>{this._runDoneInterceptors();a(null)};const error=e=>{this._runErrorInterceptors(e);a(e)};if(r.length===0)return done();let c=0;const next=()=>{const e=r[c];this._runTapInterceptors(e);if(e.type==="promise"){const t=e.fn(...i);if(!t||!t.then){throw new Error(`Tap function (tapPromise) did not return promise (returned ${t})`)}t.then((()=>{c+=1;if(c===r.length){done()}else{next()}}),(e=>{c=r.length;error(e)}))}else if(e.type==="async"){e.fn(...i,(e=>{if(e){c=r.length;error(e)}else{c+=1;if(c===r.length){done()}else{next()}}}))}else{let t=false;try{e.fn(...i)}catch(e){t=true;c=r.length;error(e)}if(!t){c+=1;if(c===r.length){done()}else{next()}}}if(c===r.length)return};next()}}t.AsyncSeriesHook=AsyncSeriesHook;class AsyncSeriesBailHook extends HookBase{callAsyncStageRange(e,...n){const{stageRange:[s],tapsInRange:r}=e;const o=n.slice(0,n.length-1);const a=n[n.length-1];const i=this._prepareArgs(o);if(s===t.minStage){this._runCallInterceptors(...i)}const done=()=>{this._runDoneInterceptors();a(null)};const error=e=>{this._runErrorInterceptors(e);a(e)};const result=e=>{this._runResultInterceptors(e);a(null,e)};if(r.length===0)return done();let c=0;const next=()=>{const e=r[c];this._runTapInterceptors(e);if(e.type==="promise"){const t=e.fn(...i);if(!t||!t.then){throw new Error(`Tap function (tapPromise) did not return promise (returned ${t})`)}t.then((e=>{c+=1;if(e!==undefined){result(e)}else if(c===r.length){done()}else{next()}}),(e=>{c=r.length;error(e)}))}else if(e.type==="async"){e.fn(...i,((e,t)=>{if(e){c=r.length;error(e)}else{c+=1;if(t!==undefined){result(t)}else if(c===r.length){done()}else{next()}}}))}else{let t=false;let n=undefined;try{n=e.fn(...i)}catch(e){t=true;c=r.length;error(e)}if(!t){c+=1;if(n!==undefined){result(n)}else if(c===r.length){done()}else{next()}}}if(c===r.length)return};next()}}t.AsyncSeriesBailHook=AsyncSeriesBailHook;class AsyncSeriesWaterfallHook extends HookBase{constructor(e=[],t){if(e.length<1)throw new Error("Waterfall hooks must have at least one argument");super(e,t)}callAsyncStageRange(e,...n){const{stageRange:[s],tapsInRange:r}=e;const o=n.slice(0,n.length-1);const a=n[n.length-1];const i=this._prepareArgs(o);if(s===t.minStage){this._runCallInterceptors(...i)}const result=e=>{this._runResultInterceptors(e);a(null,e)};const error=e=>{this._runErrorInterceptors(e);a(e)};if(r.length===0)return result(i[0]);let c=0;const next=()=>{const e=r[c];this._runTapInterceptors(e);if(e.type==="promise"){const t=e.fn(...i);if(!t||!t.then){throw new Error(`Tap function (tapPromise) did not return promise (returned ${t})`)}t.then((e=>{c+=1;if(e!==undefined){i[0]=e}if(c===r.length){result(i[0])}else{next()}}),(e=>{c=r.length;error(e)}))}else if(e.type==="async"){e.fn(...i,((e,t)=>{if(e){c=r.length;error(e)}else{c+=1;if(t!==undefined){i[0]=t}if(c===r.length){result(i[0])}else{next()}}}))}else{let t=false;try{const t=e.fn(...i);if(t!==undefined){i[0]=t}}catch(e){t=true;c=r.length;error(e)}if(!t){c+=1;if(c===r.length){result(i[0])}else{next()}}}if(c===r.length)return};next()}}t.AsyncSeriesWaterfallHook=AsyncSeriesWaterfallHook;const defaultFactory=(e,t)=>t;class HookMap{constructor(e,t){this._map=new Map;this.name=t;this._factory=e;this._interceptors=[]}get(e){return this._map.get(e)}for(e){const t=this.get(e);if(t!==undefined){return t}let n=this._factory(e);const s=this._interceptors;for(let t=0;t<s.length;t++){const r=s[t].factory;if(r){n=r(e,n)}}this._map.set(e,n);return n}intercept(e){this._interceptors.push(Object.assign({factory:defaultFactory},e))}isUsed(){for(const e of this._map.keys()){const t=this.get(e);if(t?.isUsed()){return true}}return false}queryStageRange(e){return new QueriedHookMap(e,this)}}t.HookMap=HookMap;class QueriedHookMap{constructor(e,t){this.stageRange=e;this.hookMap=t}get(e){return this.hookMap.get(e)?.queryStageRange(this.stageRange)}for(e){return this.hookMap.for(e).queryStageRange(this.stageRange)}isUsed(){for(const e of this.hookMap._map.keys()){if(this.get(e)?.isUsed()){return true}}return false}}t.QueriedHookMap=QueriedHookMap;class MultiHook{constructor(e,t){this.hooks=e;this.name=t}tap(e,t){for(const n of this.hooks){n.tap(e,t)}}tapAsync(e,t){for(const n of this.hooks){n.tapAsync(e,t)}}tapPromise(e,t){for(const n of this.hooks){n.tapPromise(e,t)}}isUsed(){for(const e of this.hooks){if(e.isUsed())return true}return false}intercept(e){for(const t of this.hooks){t.intercept(e)}}withOptions(e){return new MultiHook(this.hooks.map((t=>t.withOptions(e))),this.name)}}t.MultiHook=MultiHook}};if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var t={};e[257](0,t);module.exports=t})();